{"query":{"pages":{"2135":{"pageid":2135,"ns":0,"title":"Add a variable to a class instance at runtime","revisions":[{"*":"<div class=\"infobox\" style=\"width: 2in\">[[File:Rcode-button-task-crushed.png|64px|left|alt=Task|link=Category:Solutions by Programming Task]]'''Add a variable to a class instance at runtime'''<br\/>\nYou are encouraged to [[Rosetta Code:Solve a Task|solve this task]] according to the task description, using any language you may know.[[Category:Programming Tasks]][[Category:Object oriented]]<\/div>\nDemonstrate how to dynamically add variables to an object (a class instance) at runtime.\n\nThis is useful when the methods\/variables of an instance are based on a data file that isn't available until runtime.  Hal Fulton gives an example of creating an OO CSV parser at [http:\/\/www.devsource.com\/article2\/0,1759,1928562,00.asp An Exercise in Metaprogramming with Ruby].  This is referred to as \"monkeypatching\" by Pythonistas and some others.\n\n==[[:Category:ActionScript|ActionScript]][[Category:ActionScript]]==\nIn ActionScript this can be done using an Object object\n<lang actionscript>var object:Object = new Object();\nobject.foo = \"bar\";<\/lang>\nOr by creating a dynamic class\n<lang actionscript>package\n{\n    public dynamic class Foo\n    {\n        \/\/ ...\n    }\n}<\/lang>\n<lang actionscript>var foo:Foo = new Foo();\nfoo.bar = \"zap\";<\/lang>\n[[Category:Modula-2\/Omit]]\n\n==[[:Category:Ada|Ada]][[Category:Ada]]==\nAda is not a dynamically typed language. Yet it supports mix-in inheritance, run-time inheritance and interfaces. These three allow us to achieve the desired effect, however questionably useful it could be. The example declares an interface of the class (Class). Then a concrete type is created (Base). The object E is an instance of Base. Later, at the run time, a new type Monkey_Patch is created such that it refers to E and implements the class interface per delegation to E. Monkey_Patch has a new integer member Foo and EE is an instance of Monkey_Path. For the user EE appears as E with Foo.\n<lang ada>with Ada.Text_IO;  use Ada.Text_IO;\n\nprocedure Dynamic is\n   package Abstract_Class is\n      type Class is limited interface;\n      function Boo (X : Class) return String is abstract;\n   end Abstract_Class;\n   use Abstract_Class;\n\n   package Base_Class is\n      type Base is new Class with null record;\n      overriding function Boo (X : Base) return String;\n   end Base_Class;\n   \n   package body Base_Class is\n      function Boo (X : Base) return String is\n      begin\n         return \"I am Class\";\n      end Boo;\n   end Base_Class;\n   use Base_Class;\n\n   E : aliased Base;  -- An instance of Base\n   \nbegin\n   -- Gone run-time\n   declare\n      type Monkey_Patch (Root : access Base) is new Class with record\n         Foo : Integer := 1;\n      end record;\n      overriding function Boo (X : Monkey_Patch) return String;\n      function Boo (X : Monkey_Patch) return String is\n      begin -- Delegation to the base\n         return X.Root.Boo;\n      end Boo;\n      EE : Monkey_Patch (E'Access); -- Extend E\n   begin\n      Put_Line (EE.Boo & \" with\" & Integer'Image (EE.Foo));\n   end;\nend Dynamic;<\/lang>\nSample output:\n<pre>\nI am Class with 1\n<\/pre>\n==[[:Category:AutoHotkey|AutoHotkey]][[Category:AutoHotkey]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[AutoHotkey_L]][[SMW::on]]<\/div>\n<lang AutoHotkey>e := {}\ne.foo := 1 <\/lang>\n\n==[[:Category:Bracmat|Bracmat]][[Category:Bracmat]]==\nThis solution saves the original members and methods in a variable, using pattern matching. Then, using macro expansion, a new object is created with an additional member variable and also an additional method. Because the new object is assigned to the same variable as the original object, the original object ceases to exist.\n<lang bracmat>( ( struktuur\n  = (aMember=) (aMethod=.!(its.aMember))\n  )\n& new$struktuur:?object\n& out$\"Object as originally created:\"\n& lst$object\n& A value:?(object..aMember)\n& !object:(=?originalMembersAndMethods)\n&     new\n    $ ( \n      ' ( (anotherMember=)\n          (anotherMethod=.!(its.anotherMember))\n          ()$originalMembersAndMethods\n        )\n      )\n  : ?object\n&   out\n  $ \"\nObject with additional member and method and with 'aMember' already set to some interesting value:\"\n& lst$object\n& some other value:?(object..anotherMember)\n& out$\"\nCall both methods and output their return values.\"\n& out$(\"aMember contains:\" (object..aMethod)$)\n& out$(\"anotherMember contains:\" (object..anotherMethod)$)\n&);<\/lang>\nOutput:\n<lang bracmat>Object as originally created:\n(object=\n=(aMember=) (aMethod=.!(its.aMember)));\n\nObject with additional member and method and with 'aMember' already set to some interesting value:\n(object=\n\n=   (anotherMember=)\n    (anotherMethod=.!(its.anotherMember))\n    (aMember=A value)\n    (aMethod=.!(its.aMember)));\n\nCall both methods and output their return values.\naMember contains: A value\nanotherMember contains: some other value<\/lang>\n\n==[[:Category:CoffeeScript|CoffeeScript]][[Category:CoffeeScript]]==\n<lang coffeescript># CoffeeScript is dynamic, just like the Javascript it compiles to.\n# You can dynamically add attributes to objects.\n\n# First create an object very simply.\ne = {}\ne.foo = \"bar\"\ne.yo = -> \"baz\"\nconsole.log e.foo, e.yo()\n\n# CS also has class syntax to instantiate objects, the details of which\n# aren't shown here.  The mechanism to add members is the same, though.\nclass Empty\n  # empty class\n  \ne = new Empty()\ne.foo = \"bar\"\ne.yo = -> \"baz\"\nconsole.log e.foo, e.yo()\n<\/lang>\n\n==[[:Category:Common Lisp|Common Lisp]][[Category:Common Lisp]]==\n\nThis version adds a new slot only to one instance, not to the whole class.\n\n<div class=\"examplemeta libheader\">'''Library:''' [[SMW::off]][[:Category:Closer to MOP|Closer to MOP]][[Category:Closer to MOP]][[SMW::on]]<\/div>\n\n<lang lisp>(defun augment-instance-with-slots (instance slots)\n  (change-class instance\n                (make-instance 'standard-class\n                  :direct-superclasses (list (class-of instance))\n                  :direct-slots slots)))<\/lang>\n\nExample:\n\n<lang lisp>CL-USER> (let* ((instance (make-instance 'foo :bar 42 :baz 69))\n                (new-slots '((:name xenu :initargs (:xenu)))))\n           (augment-instance-with-slots instance new-slots)\n           (reinitialize-instance instance :xenu 666)\n           (describe instance))\n#<#<STANDARD-CLASS NIL {1003AEE2C1}> {1003AEE271}>\n  [standard-object]\n\nSlots with :INSTANCE allocation:\n  BAR   = 42\n  BAZ   = 69\n  XENU  = 666<\/lang>\n\nThe following REPL transcript (from [[LispWorks]]) shows the definition of a class <code>some-class<\/code> with no slots, and the creation of an instance of the class.  The first attempt to access the slot named <code>slot1<\/code> signals an error as there is no such slot.  Then the class is redefined to have such a slot, and with a default value of 23.  Attempting to access the slot in the pre\u00ebxisting instance now gives the default value, since the slot has been added to the instance.  This behavior is specified in [http:\/\/www.lispworks.com\/documentation\/HyperSpec\/Body\/04_cf.htm \u00a74.3.6 Redefining Classes] of the [http:\/\/www.lispworks.com\/documentation\/HyperSpec\/Front\/index.htm HyperSpec].\n\n<pre>CL-USER 57 > (defclass some-class () ())\n#<STANDARD-CLASS SOME-CLASS 200BF63B>\n\nCL-USER 58 > (defparameter *an-instance*\n               (make-instance 'some-class))\n*AN-INSTANCE*\n\nCL-USER 59 > (slot-value *an-instance* 'slot1)\n\nError: The slot SLOT1 is missing from #<SOME-CLASS 21F59E37> (of class #<STANDARD-CLASS SOME-CLASS 200BF63B>), when reading the value.\n  1 (abort) Return to level 0.\n  2 Return to top loop level 0.\n\nType :b for backtrace, :c <option number> to proceed,  or :? for other options\n\nCL-USER 60 : 1 > :a\n\nCL-USER 61 > (defclass some-class ()\n               ((slot1 :initform 23)))\n#<STANDARD-CLASS SOME-CLASS 200BF63B>\n\nCL-USER 62 > (slot-value *an-instance* 'slot1)\n23<\/pre>\n\n==[[:Category:D|D]][[Category:D]]==\n<lang d>struct Dynamic(T) {\n    private T[string] vars;\n\n    @property T opDispatch(string key)() pure nothrow {\n        return vars[key];\n    }\n\n    @property void opDispatch(string key, U)(U value)\/*pure*\/ nothrow {\n        vars[key] = value;\n    }\n}\n\nvoid main() {\n    import std.variant, std.stdio;\n\n    \/\/ If the type of the attributes is known at compile-time:\n    auto d1 = Dynamic!double();\n    d1.first = 10.5;\n    d1.second = 20.2;\n    writeln(d1.first, \" \", d1.second);\n\n\n    \/\/ If the type of the attributes is mixed:\n    auto d2 = Dynamic!Variant();\n    d2.a = \"Hello\";\n    d2.b = 11;\n    d2.c = ['x':2, 'y':4];\n    d2.d = (int x) => x ^^ 3;\n    writeln(d2.a, \" \", d2.b, \" \", d2.c);\n    immutable int x = d2.b.get!int;\n}<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>10.5 20.2\nHello 11 ['x':2, 'y':4]<\/pre>\nIf you want Dynamic to be a class the code is similar. If the attribute names aren't known at compile-time, you have to use a more normal syntax:\n<lang d>import std.stdio, std.variant, std.conv;\n\nstruct Dyn {\n    Variant[string] data;\n    alias data this;\n}\n\nvoid main(string[] args) {\n    Dyn d;\n    const attribute_name = text(\"attribute_\", args.length);\n    d[attribute_name] = \"something\";\n    writeln(d[attribute_name]);\n}<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>something<\/pre>\n\n==[[:Category:Elena|Elena]][[Category:Elena]]==\nELENA does not support adding a variable at run-time but it can be simulated with the help of a group object\n<lang elena>#subject foo.\n\n#class FieldContainer\n{\n    #field theValue.\n    \n    #method foo'set : anObject\n    [\n        theValue := anObject.\n    ]\n    \n    #method foo'get = theValue.\n}\n\n#symbol Program =>\n[\n    #var anObject := 234.\n    \n    \/\/ adding a field\n    anObject := anObject~FieldContainer.\n    \n    anObject set &foo:\"bar\".\n    \n    'program'Output << anObject << \".foo=\" << anObject foo.\n].\n<\/lang>\n\n==[[:Category:Falcon|Falcon]][[Category:Falcon]]==\nClasses and singleton objects have a fixed structure which cannot be changed during runtime.  However falcon does have capability to add variables\/functions at runtime with Prototype based objects.  Below are two of the prototype objects that allow adding variables at runtime.  These are arrays and dictionaries (hashes for the perl type out there).\n\n'''Array:'''\nIn this example we add a function (which prints out the content of the array) and a new value.  While we are not technically adding a \"variable\", this example is presented to show similar type of functionality.\n<lang falcon>vect = [ 'alpha', 'beta', 'gamma' ]\nvect.dump = function ()\n  for n in [0: self.len()]\n    > @\"$(n): \", self[n]\n  end\nend\nvect += 'delta'\nvect.dump()<\/lang>\nOutput from the above:\n<lang falcon>0: alpha\n1: beta\n2: gamma\n3: delta<\/lang>\n'''Dictionary:'''\nIn this example we will add a variable through the use of an object from a bless'ed dictionary.  We create a new variable called 'newVar' at runtime and assign a string to it.  Additionally we assign an external, to the object, function (sub_func) to the variable 'sub'. \n<lang falcon>function sub_func( value )\n  self['prop'] -= value\n  return self.prop\nend\n\ndict = bless( [\n  'prop' => 0,\n  'add' => function ( value )\n    self.prop += value\n    return self.prop\n  end ,\n  'sub' => sub_func\n])\n\ndict[ 'newVar' ] = \"I'm Rich In Data\"<\/lang>\n\n==[[:Category:Groovy|Groovy]][[Category:Groovy]]==\n\nAny [[Groovy]] class that implements \"''Object get(String)''\" and \"''void set(String, Object)''\" will have the '''apparent''' capability to add new properties. However, this capability will only work as expected with an appropriate implementation, backed by a Map object or something very much like a Map.\n<lang groovy>class A {\n    final x = { it + 25 }\n    private map = new HashMap()\n    Object get(String key) { map[key] }\n    void set(String key, Object value) { map[key] = value }\n}<\/lang>\n\nTest:\n<lang groovy>def a = new A()\na.y = 55\na.z = { println (new Date()); Thread.sleep 5000 }\n\nprintln a.x(25)\nprintln a.y\n(0..2).each(a.z)\n\nprintln a.q<\/lang>\n\nOutput:\n<pre>50\n55\nWed Feb 23 21:33:40 CST 2011\nWed Feb 23 21:33:45 CST 2011\nWed Feb 23 21:33:50 CST 2011\nnull<\/pre>\n\n==[[:Category:Io|Io]][[Category:Io]]==\n\nAll \"instance variables\" (or slots in Io nomenclature) are created at runtime.\n\n<lang io>Empty := Object clone\n\ne := Empty clone\ne foo := 1<\/lang>\n\n==[[:Category:Icon|Icon]][[Category:Icon]] and [[:Category:Unicon|Unicon]][[Category:Unicon]]==\n[[Category:Icon\/Omit]]\nUnicon implements object environments with records and supporting procedures for creation, initialization, and methods. To modify an instance you must create a new record then copy, amend, and replace it.  Strictly speaking we can't guarantee the replace as there is no way to modify the existing object and we are creating a new instance with extensions.  The procedures ''constructor'' and ''fieldnames'' are needed.  This example doesn't do error checking. Here ''extend'' takes three arguments, the class instance, a list of new variable names as strings, and an optional list of new values to be assigned.  The new instance is returned and the object is replaced by assignment.  The caveat here is that if the object was assigned to anything else we will now have two objects floating around with possible side effects.  As written this isn't safe from name collisions - aside from local declarations the use of a fixed constructor name uses the global name space.  There is a final caveat that needs to be observed - if future implementations of objects change then this could easily stop working.  \n\n''Note:'' Unicon can be translated via a command line switch into icon which allows for classes to be shared with Icon code (assuming no other incompatibilities exist). \n<lang unicon>\nlink ximage\n\nprocedure main()\n   c1 := foo(1,2)                            # instance of foo\n   write(\"c1:\\n\",ximage(c1))\n   c1 := extend(c1,[\"c\",\"d\"],[8,9])          # 2 new fields\n   write(\"new c1:\\n\",ximage(c1))\n   c1 := extend(c1,[\"e\"],[7])                # 1 more\n   write(\"newest c1:\\n\",ximage(c1))   \nend\n\nclass foo(a,b)                               # dummy class\nend\n\nprocedure extend(instance,newvars,newvals)   #: extend a class instance \n   every put(f := [],fieldnames(instance))   # copy existing fieldnames\n   c := [\"tempconstructor\"] ||| f            # new constructor    \n   every put(c,!newvars)                     # append new vars\n   t := constructor!c                        # new constructor\n   x := t()                                  # new instance\n   every x[v := !f] := instance[v]           # same as old instance  \n   x.__s := x                                # new self \n   if \\newvals then \n      every i := 1 to min(*newvars,*newvals) do \n         x[newvars[i]] := newvals[i]         # add new vars = values   \n   return x\nend<\/lang>\n\n<div class=\"examplemeta libheader\">'''Library:''' [[SMW::off]][[:Category:Icon Programming Library|Icon Programming Library]][[Category:Icon Programming Library]][[SMW::on]]<\/div>  \n[http:\/\/www.cs.arizona.edu\/icon\/library\/src\/procs\/ximage.icn ximage.icn provides ximage to dump variable contents] \n\nOutput:<pre>c1:\nR_foo__state_1 := foo__state()\n   R_foo__state_1.a := 1\n   R_foo__state_1.b := 2\nnew c1:\nR_tempconstructor_1 := tempconstructor()\n   R_tempconstructor_1.__s := R_tempconstructor_1\n   R_tempconstructor_1.__m := R_foo__methods_1 := foo__methods()\n   R_tempconstructor_1.a := 1\n   R_tempconstructor_1.b := 2\n   R_tempconstructor_1.c := 8\n   R_tempconstructor_1.d := 9\nnewest c1:\nR_tempconstructor_1 := tempconstructor()\n   R_tempconstructor_1.__s := R_tempconstructor_1\n   R_tempconstructor_1.__m := R_foo__methods_1 := foo__methods()\n   R_tempconstructor_1.a := 1\n   R_tempconstructor_1.b := 2\n   R_tempconstructor_1.c := 8\n   R_tempconstructor_1.d := 9\n   R_tempconstructor_1.e := 7<\/pre>\n\n==[[:Category:J|J]][[Category:J]]==\nIf you assign a value to the name which references a property of a class instance, that name within that instance gets that value.\n\n<lang j>   C=:<'exampleclass'         NB. this will be our class name\n   V__C=: 0                   NB. ensure the class exists\n   OBJ1=:conew 'exampleclass' NB. create an instance of our class\n   OBJ2=:conew 'exampleclass' NB. create another instance\n   V__OBJ1,V__OBJ2            NB. both of our instances exist\n0\n   W__OBJ1                    NB. instance does not have a W\n|value error\n   W__OBJ1=: 0                NB. here, we add a W to this instance\n   W__OBJ1                    NB. this instance now has a W\n0\n   W__OBJ2                    NB. our other instance does not\n|value error<\/lang>\n\n==[[:Category:JavaScript|JavaScript]][[Category:JavaScript]]==\nThis kind of thing is fundamental to JavaScript, as it's a prototype-based language rather than a class-based one.\n<lang javascript>e = {}       \/\/ generic object\ne.foo = 1\ne[\"bar\"] = 2    \/\/ name specified at runtime<\/lang>\n\n==[[:Category:Lua|Lua]][[Category:Lua]]==\n<lang lua>empty = {}\nempty.foo = 1<\/lang>\n\n==[[:Category:Mathematica|Mathematica]][[Category:Mathematica]]==\nMathematica doesn't rally have classes, so it doesn't have class variables. However, many rules can be applied to a single tag, so it has some aspects similar to a class. With that definition, adding a class variable is similar to adding a rule:\n<lang Mathematica>\nf[a]=1;\nf[b]=2;\nf[a]=3;\n? f<\/lang>\nOutput:\n Global`f\n f[a]=3\n f[b]=2\n\nHere, the two 'variables' can be seen under the single heading 'f'. And of course all of this is done at runtime.\n\n==[[:Category:Objective-C|Objective-C]][[Category:Objective-C]]==\nObjective-C doesn't have the ability to add a variable to an instance at runtime. However, since Mac OS X 10.6 and iOS 3.1, it has something that can accomplish a very similar purpose, called \"associative references\" or \"associated objects\", which allow you to attach additional objects onto an object without changing its class.\n\nYou can put associative references on any object. You can put multiple ones on the same object. They are indexed by a pointer key (typically the address of some dummy variable). You use the functions <code>objc_getAssociatedObject()<\/code> and <code>objc_setAssociatedObject<\/code> to get and set them, respectively.\n\n<lang objc>#import <Foundation\/Foundation.h>\n#import <objc\/runtime.h>\n\nchar fooKey;\n\nint main (int argc, const char *argv[]) {\n    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];\n\n    id e = [[NSObject alloc] init];\n\n    \/\/ set\n    objc_setAssociatedObject(e, &fooKey, [NSNumber numberWithInt:1], OBJC_ASSOCIATION_RETAIN);\n\n    \/\/ get\n    NSNumber *associatedObject = objc_getAssociatedObject(e, &fooKey);\n    NSLog(@\"associatedObject: %@\", associatedObject);\n\n    [e release];\n    [pool drain];\n    return 0;\n}<\/lang>\n\n==[[:Category:Octave|Octave]][[Category:Octave]]==\nOctave is dynamically typed, and can have fields added in two methods:\n\n<lang octave>\n% Given struct \"test\"\ntest.b=1;\ntest = setfield (test, \"c\", 3);\n<\/lang>\n\n==[[:Category:Oz|Oz]][[Category:Oz]]==\nIt is not possible to add variables to instances in Oz. Every object has exactly one class and this association cannot be changed after object creation. Classes themselves are immutable.\n\nHowever, classes are also first-class values and are created at runtime. Many of the tasks that are solved with \"monkeypatching\" in other languages, can be solved by dynamically creating classes in Oz.\n\n<lang oz>declare\n  %% Creates a new class derived from BaseClass\n  %% with an added feature (==public immutable attribute)\n  fun {AddFeature BaseClass FeatureName FeatureValue}\n     class DerivedClass from BaseClass\n        feat\n\t   %% \"FeatureName\" is escaped, otherwise a new variable\n\t   %% refering to a private feature would be created\n           !FeatureName:FeatureValue\n     end\n  in\n     DerivedClass\n  end\n\n  class Base\n     feat\n        bar:1\n\n     meth init\n        skip\n     end\n  end\n\n  Derived = {AddFeature Base foo 2}\n\n  Instance = {New Derived init}\nin\n  {Show Instance.bar} %% inherited feature\n  {Show Instance.foo} %% feature of \"synthesized\" class<\/lang>\n\nTo add a variable number of features and attributes, you can use [http:\/\/www.mozart-oz.org\/documentation\/base\/class.html Class.new].\n \n==[[:Category:Perl|Perl]][[Category:Perl]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Perl]] version 5.x[[SMW::on]]<\/div>\n<lang perl>package Empty;\n\n# Constructor. Object is hash.\nsub new { return bless {}, shift; }\n\npackage main;\n\n# Object.\nmy $o = Empty->new;\n\n# Set runtime variable (key => value).\n$o->{'foo'} = 1;<\/lang>\n\n\n==[[:Category:Perl 6|Perl 6]][[Category:Perl 6]]==\nYou can add variables\/methods to a class at runtime by composing in a role. The role only affects that instance, though it is inheritable. An object created from an existing object will inherit any roles composed in with values set to those at the time the role was created. If you want to keep changed values in the new object, clone it instead.\n<lang perl6>class Bar { }             # an empty class\n\nmy $object = Bar.new;     # new instance\n\nrole a_role {             # role to add a variable: foo,\n   has $.foo is rw = 2;   # with an initial value of 2\n}\n\n$object does a_role;      # compose in the role\n\nsay $object.foo;          # prints: 2\n$object.foo = 5;          # change the variable\nsay $object.foo;          # prints: 5\n\nmy $ohno = Bar.new;       # new Bar object\n#say $ohno.foo;           # runtime error, base Bar class doesn't have the variable foo\n\nmy $this = $object.new;   # instantiate a new Bar derived from $object\nsay $this.foo;            # prints: 2 - original role value\n\nmy $that = $object.clone; # instantiate a new Bar derived from $object copying any variables\nsay $that.foo;            # 5 - value from the cloned object<\/lang>\nThat's what's going on underneath, but often people just mix in an anonymous role directly using the <tt>but<\/tt> operator.  Here we'll mix an attribute into a normal integer.\n<lang perl6>my $lue = 42 but role { has $.answer = \"Life, the Universe, and Everything\" }\n\nsay $lue;          # 42\nsay $lue.answer;   # Life, the Universe, and Everything<\/lang>\nOn the other hand, mixins are frowned upon when it is possible to compose roles directly into classes (as with Smalltalk traits), so that you get method collision detection at compile time.  If you want to change a class at run time, you can also use monkey patching:\n\n<lang perl6>use MONKEY_TYPING;\naugment class Int {\n    method answer { \"Life, the Universe, and Everything\" }\n}\nsay 42.answer;     # Life, the Universe, and Everything<\/lang>\nThis practice, though allowed, is considered to be Evil Action at a Distance.\n\n==[[:Category:PHP|PHP]][[Category:PHP]]==\n<lang php>class E {};\n\n$e=new E();\n\n$e->foo=1;\n\n$e->{\"foo\"} = 1; \/\/ using a runtime name\n$x = \"foo\";\n$e->$x = 1; \/\/ using a runtime name in a variable<\/lang>\n\n==[[:Category:PicoLisp|PicoLisp]][[Category:PicoLisp]]==\nIn general, all instance variables in PicoLisp are dynamically created at\nruntime.\n<lang PicoLisp>: (setq MyObject (new '(+MyClass)))       # Create some object\n-> $385605941\n: (put MyObject 'newvar '(some value))    # Set variable\n-> (some value)\n: (show MyObject)                         # Show the object\n$385605941 (+MyClass)\n   newvar (some value)\n-> $385605941<\/lang>\n\n==[[:Category:Pike|Pike]][[Category:Pike]]==\nPike does not allow adding variables to existing objects, but we can design a class that allows us to add variables.\n<lang Pike>class CSV\n{\n    mapping variables = ([]);\n\n    mixed `->(string name)\n    {\n        return variables[name];\n    }\n\n    void `->=(string name, mixed value)\n    {\n        variables[name] = value;\n    }\n\n    array _indices()\n    {\n        return indices(variables);\n    }\n}\n\nobject csv = CSV();\ncsv->greeting = \"hello world\";\ncsv->count = 1;\ncsv->lang = \"Pike\";\n\nindices(csv);\nResult: ({ \/* 3 elements *\/\n              \"lang\",\n              \"count\",\n              \"greeting\"\n         })\n<\/lang>\n\n==[[:Category:Pop11|Pop11]][[Category:Pop11]]==\n\nIn Pop11 instance variables (slots) are specified at class creation\ntime and there is no way to add new slot to an instance after its\nclass was created.  However, for most practical purposes one can\nobtain desired effect in different way.  Namely, except for a few\nlow-level routines slots in Pop11 are accessed via getter and\nsetter methods.  Getters and setters are like ordinary methods,\nbut are automatically defined and \"know\" low level details of\nslot access.  Pop11 allows dynamic definition of methods, and\none can add new methods which work as \"getter\" and \"setter\" but\ndo not store data directly in instance.  One possibility is\nto have one instance variable which contains a hastable (this\nis essentially what Perl solution is doing).  Another possibility\n(used below) is to create na external hashtable.  Adding new slots\ntypically make sense if slot name is only known at runtine, so\nwe create method definition (as a list) at runtime and compile\nit using the 'pop11_compile' procedure.\n\n<lang pop11>lib objectclass;\n\ndefine :class foo;\nenddefine;\n\ndefine define_named_method(method, class);\n    lvars method_str = method >< '';\n    lvars class_str = class >< '';\n    lvars method_hash_str = 'hash_' >< length(class_str) >< '_'\n                              >< class_str >< '_' >< length(method_str)\n                              >< '_' >< method_str;\n    lvars method_hash = consword(method_hash_str);\n    pop11_compile([\n        lvars ^method_hash = newassoc([]);\n        define :method ^method(self : ^class);\n            ^method_hash(self);\n        enddefine;\n        define :method updaterof ^method(val, self : ^class);\n            val -> ^method_hash(self);\n        enddefine;\n    ]);\nenddefine;\n\ndefine_named_method(\"met1\", \"foo\");\nlvars bar = consfoo();\nmet1(bar) =>  ;;; default value -- false\n\"baz\" -> met1(bar);\nmet1(bar) =>  ;;; new value<\/lang>\n\n==[[:Category:PowerShell|PowerShell]][[Category:PowerShell]]==\nPowerShell allows extending arbitrary object instances at runtime with the <code>Add-Member<\/code> cmdlet. The following example adds a property ''Title'' to an integer:\n<lang powershell>$x = 42 `\n     | Add-Member -PassThru `\n        NoteProperty `\n        Title `\n        \"The answer to the question about life, the universe and everything\"<\/lang>\nNow that property can be accessed:\n<pre>PS> $x.Title\nThe answer to the question about life, the universe and everything<\/pre>\nor reflected:\n<pre>PS> $x | Get-Member\n\n   TypeName: System.Int32\n\nName        MemberType   Definition\n----        ----------   ----------\nCompareTo   Method       int CompareTo(System.Object value), ...\nEquals      Method       bool Equals(System.Object obj), bool...\nGetHashCode Method       int GetHashCode()\nGetType     Method       type GetType()\nGetTypeCode Method       System.TypeCode GetTypeCode()\nToString    Method       string ToString(), string ToString(s...\nTitle       NoteProperty System.String Title=The answer to th...<\/pre>\nWhile trying to access the same property in another instance will fail:\n<pre>PS> $y = 42\nPS> $y.Title<\/pre>\n(which simply causes no output).\n\n==[[:Category:Python|Python]][[Category:Python]]==\n\n<lang python>class empty(object):\n    pass\ne = empty()<\/lang>\n\nIf the variable (attribute) name is known at \"compile\" time (hard-coded):\n\n<lang python>   e.foo = 1<\/lang>\n\nIf the variable name is determined at runtime:\n<lang python>   setattr(e, name, value)<\/lang>\n\n'''Note:''' Somewhat counter-intuitively one cannot simply use ''e = object(); e.foo = 1'' because the Python base ''object'' (the ultimate ancestor to all new-style classes) will raise attribute exceptions.  However, any normal derivatives of ''object'' can be \"monkey patched\" at will.\n\nBecause functions are first class objects in Python one can not only add variables to instances.  One can add or replace functionality to an instance.  Doing so is tricky if one wishes to refer back to other instance attributes since there's no \"magic\" binding back to \"self.\"  One trick is to dynamically define the function to be added, nested within the function that applies the patch like so:\n\n<lang python>class empty(object):\n    def __init__(this):\n        this.foo = \"whatever\"\n\ndef patch_empty(obj):\n    def fn(self=obj):\n        print self.foo\n    obj.print_output = fn\n\ne = empty()\npatch_empty(e)\ne.print_output()\n# >>> whatever<\/lang>\n:Note: The name ''self'' is not special; it's merely the pervasive Python convention.  In this example I've deliberately used ''this'' in the class definition to underscore this fact.  The nested definition could use any name for the \"self\" object.  Because it's nested the value of the object is evaluated at the time that the patch_empty() function is run and thus the function being patched in has a valid reference to the object into which it is being inserted.  Other arguments could be passed as necessary.  Such techniques are not recommended; however they are possible.\n\n==[[:Category:REBOL|REBOL]][[Category:REBOL]]==\n<lang rebol>\nREBOL [\n\tTitle: \"Add Variables to Class at Runtime\"\n\tAuthor: oofoe\n\tDate: 2009-12-04\n\tURL: http:\/\/rosettacode.org\/wiki\/Adding_variables_to_a_class_instance_at_runtime\n]\n\n; As I understand it, a REBOL object can only ever have whatever\n; properties it was born with. However, this is somewhat offset by the\n; fact that every instance can serve as a prototype for a new object\n; that also has the new parameter you want to add.\n\n; Here I create an empty instance of the base object (x), then add the\n; new instance variable while creating a new object prototyped from\n; x. I assign the new object to x, et voila', a dynamically added\n; variable.\n\nx: make object! [] ; Empty object.\n\nx: make x [\n\tnewvar: \"forty-two\" ; New property.\n]\n\nprint \"Empty object modifed with 'newvar' property:\"\nprobe x\n\n; A slightly more interesting example:\n\nstarfighter: make object! [\n\tmodel: \"unknown\"\n\tpilot: none\n]\nx-wing: make starfighter [\n\tmodel: \"Incom T-65 X-wing\"\n]\n\t\nsquadron: reduce [\n\tmake x-wing [pilot: \"Luke Skywalker\"]\n\tmake x-wing [pilot: \"Wedge Antilles\"]\n\tmake starfighter [\n\t\tmodel: \"Slayn & Korpil B-wing\"\n\t\tpilot: \"General Salm\"\n\t]\n]\n\n; Adding new property here.\nsquadron\/1: make squadron\/1 [deathstar-removal-expert: yes]\n\nprint [crlf \"Fighter squadron:\"]\nforeach pilot squadron [probe pilot]\n<\/lang>\n\n==[[:Category:Ruby|Ruby]][[Category:Ruby]]==\n<lang ruby>class Empty\nend\n\ne = Empty.new\nclass << e\n  attr_accessor :foo\nend\ne.foo = 1\nputs e.foo  # output: \"1\"\n\nf = Empty.new\nf.foo = 1   # raises NoMethodError\n<\/lang>\n\n\"class << e\" uses the ''singleton class'' of \"e\", which is an automatic subclass of Empty that has only this single instance. Therefore we added the \"foo\" accessor only to \"e\", not to other instances of Empty.\n\n==[[:Category:Scala|Scala]][[Category:Scala]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Scala]] version 2.10[[SMW::on]]<\/div>\nSince version 2.10 Scala supports dynamic types. Dynamic types have to implement trait ''Dynamic'' and implement methods ''selectDynamic'' and ''updateDynamic''.\n\n<lang scala>import language.dynamics\nimport scala.collection.mutable.HashMap\n\nclass A extends Dynamic {\n  private val map = new HashMap[String, Any]\n  def selectDynamic(name: String): Any = {\n    return map(name)\n  }\n  def updateDynamic(name:String)(value: Any) = {\n    map(name) = value\n  }\n}<\/lang>\n\nSample output in the REPL:\n\n<lang scala>scala> val a = new A\na: A = A@7b20f29d\n\nscala> a.foo = 42\na.foo: Any = 42\n\nscala> a.foo\nres10: Any = 42<\/lang>\n\n==[[:Category:Slate|Slate]][[Category:Slate]]==\nSlate objects are prototypes:\n<lang slate>define: #Empty -> Cloneable clone.\ndefine: #e -> Empty clone.\ne addSlotNamed: #foo valued: 1.<\/lang>\n\n==[[:Category:Smalltalk|Smalltalk]][[Category:Smalltalk]]==\n{| class=\"messagebox\" style=\"text-align: center; background-color: #ffc8c8; clear: both;\"\n| This example is '''incorrect'''.  It extends the class (adds a new instance var and new method that will exists even in brand new future instances of that class), not only the particular instance. -- The description of the problem must be reworded then, as it\nasks for adding variables to the class, not the instance.  Please fix the code and remove this message.\n|}[[Category:Smalltalk examples needing attention]][[Category:Examples needing attention]]\n\n<lang smalltalk>Object subclass: #Monkey\n  instanceVariableNames: 'aVar'\n  classVariableNames: ''\n  poolDictionaries: ''\n  category: nil !\n\n!Monkey class methodsFor: 'new instance'!\nnew\n  | o |\n  o := super new.\n  o init.\n  ^o\n!!\n\n!Monkey methodsFor: 'init instance'!\ninit\n  aVar := 0\n!\ninitWith: value\n  aVar := value\n!!\n\n!Monkey methodsFor: 'set\/get the inst var(s)'!\nsetVar: var\n  aVar := var\n!\ngetVar\n  ^aVar\n!!\n\n\n\"Create a new instance\"\nSmalltalk at: #aMonkey put: (Monkey new) !\n\n\"set the 'original' instance var to 12\"\naMonkey setVar: 12 .\n\n\"let's see what's inside\"\naMonkey inspect .\n\n\"add a new instance var\"\nMonkey addInstVarName: 'x'.\n\n\"let's see what's inside now\"\naMonkey inspect .\n\n\"let us create a new method for x\"\n!Monkey methodsFor: 'about x'!\nsetX: val\n   x := val\n!\nx\n  ^x\n!!\n\naMonkey setX: 10 .\naMonkey inspect .\n(aMonkey x) printNl .<\/lang>\n\nOutput is:\n<pre>An instance of Monkey\n  aVar: 12\nAn instance of Monkey\n  aVar: 12\n  x: nil\nAn instance of Monkey\n  aVar: 12\n  x: 10\n10<\/pre>\n\n==[[:Category:Tcl|Tcl]][[Category:Tcl]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Tcl]] version 8.6[[SMW::on]]<\/div> or <div class=\"examplemeta libheader\">'''Library:''' [[SMW::off]][[:Category:TclOO|TclOO]][[Category:TclOO]][[SMW::on]]<\/div>\n\nThe code below uses the fact that each object is implemented as a namespace, to add a ''time'' variable to an instance of ''summation'':\n<lang Tcl>% package require TclOO\n% oo::class create summation {\n   constructor {} {\n       variable v 0\n   }\n   method add x {\n       variable v\n       incr v $x\n   }\n   method value {{var v}} {\n       variable $var\n       return [set $var]\n   }\n   destructor {\n       variable v\n       puts \"Ended with value $v\"\n   }\n}\n::summation\n% set s [summation new]\n% # Do the monkey patch!\n% set [info object namespace $s]::time now\nnow\n% # Prove it's really part of the object...\n% $s value time\nnow\n%<\/lang>\nAn alternative approach is to expose the (normally hidden) <code>varname<\/code> method on the object so that you can get a handle for an arbitrary variable in the object.\n<lang tcl>% oo::class create summation {\n   constructor {} {\n       variable v 0\n   }\n   method add x {\n       variable v\n       incr v $x\n   }\n   method value {{var v}} {\n       variable $var\n       return [set $var]\n   }\n   destructor {\n       variable v\n       puts \"Ended with value $v\"\n   }\n}\n::summation\n% set s [summation new]\n% set s2 [summation new]\n% oo::objdefine $s export varname\n% # Do the monkey patch...\n% set [$s varname time] \"now\"\n% $s value time\nnow\n% # Show that it is only in one object...\n% $s2 value time\ncan't read \"time\": no such variable<\/lang>\n\n[[Category:Applesoft BASIC\/Omit]]\n[[Category:ALGOL 68\/Omit]]\n[[Category:AWK\/Omit]]\n[[Category:Brainf***\/Omit]]\n[[Category:C\/Omit]]\n[[Category:C++\/Omit]]\n[[Category:Fortran\/Omit]]\n[[Category:gnuplot\/Omit]]\n[[Category:Go\/Omit]]\n[[Category:GUISS\/Omit]]\n[[Category:Haskell\/Omit]]\n[[Category:Integer BASIC\/Omit]]\n[[Category:Java\/Omit]]\n[[Category:LaTeX\/Omit]]\n[[Category:M4\/Omit]]\n[[Category:ML\/I\/Omit]]\n[[Category:Make\/Omit]]\n[[Category:OCaml\/Omit]]\n[[Category:Octave\/Omit]]\n[[Category:PARI\/GP\/Omit]]\n[[Category:Pascal\/Omit]]\n[[Category:PlainTeX\/Omit]]\n[[Category:PureBasic\/Omit]]\n[[Category:R\/Omit]]\n[[Category:TI-83 BASIC\/Omit]] [[Category:TI-89 BASIC\/Omit]] \n[[Category:Retro\/Omit]]\n[[Category:UNIX Shell\/Omit]]\n[[Category:ZX Spectrum Basic\/Omit]] "}]}}},"query-continue":{"revisions":{"rvstartid":135723}}}