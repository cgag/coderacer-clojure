{"query":{"pages":{"4669":{"pageid":4669,"ns":0,"title":"Animate a pendulum","revisions":[{"*":"[[File:pendulum.gif|160px|thumb|right|Capture of the Oz version.]]\n\n<div class=\"infobox\" style=\"width: 2in\">[[File:Rcode-button-task-crushed.png|64px|left|alt=Task|link=Category:Solutions by Programming Task]]'''Animate a pendulum'''<br\/>\nYou are encouraged to [[Rosetta Code:Solve a Task|solve this task]] according to the task description, using any language you may know.[[Category:Programming Tasks]][[Category:Temporal media]]<\/div>\nOne good way of making an animation is by simulating a physical system and illustrating the variables in that system using a dynamically changing graphical display. The classic such physical system is a [[wp:Pendulum|simple gravity pendulum]].\n\nFor this task, create a simple physical model of a pendulum and animate it.\n\n==[[:Category:Ada|Ada]][[Category:Ada]]==\nThis does not use a GUI, it simply animates the pendulum and prints out the positions. If you want, you can replace the output method with graphical update methods.\n\nX and Y are relative positions of the pendulum to the anchor.\n\npendulums.ads:\n<lang Ada>generic\n   type Float_Type is digits <>;\n   Gravitation : Float_Type;\npackage Pendulums is\n   type Pendulum is private;\n   function New_Pendulum (Length : Float_Type;\n                          Theta0 : Float_Type) return Pendulum;\n   function Get_X (From : Pendulum) return Float_Type;\n   function Get_Y (From : Pendulum) return Float_Type;\n   procedure Update_Pendulum (Item : in out Pendulum; Time : in Duration);\nprivate\n   type Pendulum is record\n      Length   : Float_Type;\n      Theta    : Float_Type;\n      X        : Float_Type;\n      Y        : Float_Type;\n      Velocity : Float_Type;\n   end record;\nend Pendulums;<\/lang>\n\npendulums.adb:\n<lang Ada>with Ada.Numerics.Generic_Elementary_Functions;\npackage body Pendulums is\n   package Math is new Ada.Numerics.Generic_Elementary_Functions (Float_Type);\n\n   function New_Pendulum (Length : Float_Type;\n                          Theta0 : Float_Type) return Pendulum is\n      Result : Pendulum;\n   begin\n      Result.Length   := Length;\n      Result.Theta    := Theta0 \/ 180.0 * Ada.Numerics.Pi;\n      Result.X        := Math.Sin (Theta0) * Length;\n      Result.Y        := Math.Cos (Theta0) * Length;\n      Result.Velocity := 0.0;\n      return Result;\n   end New_Pendulum;\n\n   function Get_X (From : Pendulum) return Float_Type is\n   begin\n      return From.X;\n   end Get_X;\n\n   function Get_Y (From : Pendulum) return Float_Type is\n   begin\n      return From.Y;\n   end Get_Y;\n\n   procedure Update_Pendulum (Item : in out Pendulum; Time : in Duration) is\n      Acceleration : constant Float_Type := Gravitation \/ Item.Length *\n                                            Math.Sin (Item.Theta);\n   begin\n         Item.X        := Math.Sin (Item.Theta) * Item.Length;\n         Item.Y        := Math.Cos (Item.Theta) * Item.Length;\n         Item.Velocity := Item.Velocity +\n                          Acceleration  * Float_Type (Time);\n         Item.Theta    := Item.Theta +\n                          Item.Velocity * Float_Type (Time);\n   end Update_Pendulum;\nend Pendulums;<\/lang>\n\nexample main.adb:\n<lang Ada>with Ada.Text_IO;\nwith Ada.Calendar;\nwith Pendulums;\n\nprocedure Main is\n   package Float_Pendulum is new Pendulums (Float, -9.81);\n   use Float_Pendulum;\n   use type Ada.Calendar.Time;\n\n   My_Pendulum : Pendulum := New_Pendulum (10.0, 30.0);\n   Now, Before : Ada.Calendar.Time;\nbegin\n   Before := Ada.Calendar.Clock;\n   loop\n      Delay 0.1;\n      Now := Ada.Calendar.Clock;\n      Update_Pendulum (My_Pendulum, Now - Before);\n      Before := Now;\n      -- output positions relative to origin\n      -- replace with graphical output if wanted\n      Ada.Text_IO.Put_Line (\" X: \" & Float'Image (Get_X (My_Pendulum)) &\n                            \" Y: \" & Float'Image (Get_Y (My_Pendulum)));\n   end loop;\nend Main;<\/lang>\n\nOutput:\n<pre> X:  5.00000E+00 Y:  8.66025E+00\n X:  4.95729E+00 Y:  8.68477E+00\n X:  4.87194E+00 Y:  8.73294E+00\n X:  4.74396E+00 Y:  8.80312E+00\n X:  4.57352E+00 Y:  8.89286E+00\n X:  4.36058E+00 Y:  8.99919E+00\n X:  4.10657E+00 Y:  9.11790E+00\n X:  3.81188E+00 Y:  9.24498E+00\n X:  3.47819E+00 Y:  9.37562E+00\n X:  3.10714E+00 Y:  9.50504E+00\n X:  2.70211E+00 Y:  9.62801E+00\n X:  2.26635E+00 Y:  9.73980E+00\n X:  1.80411E+00 Y:  9.83591E+00\n X:  1.32020E+00 Y:  9.91247E+00\n X:  8.20224E-01 Y:  9.96630E+00\n X:  3.10107E-01 Y:  9.99519E+00\n X: -2.03865E-01 Y:  9.99792E+00\n X: -7.15348E-01 Y:  9.97438E+00\n X: -1.21816E+00 Y:  9.92553E+00\n X: -1.70581E+00 Y:  9.85344E+00\n X: -2.17295E+00 Y:  9.76106E+00\n X: -2.61452E+00 Y:  9.65216E+00\n X: -3.02618E+00 Y:  9.53112E+00\n X: -3.40427E+00 Y:  9.40271E+00\n X: -3.74591E+00 Y:  9.27190E+00\n X: -4.04873E+00 Y:  9.14373E+00\n X: -4.31141E+00 Y:  9.02285E+00\n X: -4.53271E+00 Y:  8.91373E+00\n X: -4.71186E+00 Y:  8.82034E+00\n X: -4.84868E+00 Y:  8.74587E+00\n X: -4.94297E+00 Y:  8.69293E+00\n X: -4.99459E+00 Y:  8.66337E+00\n X: -5.00352E+00 Y:  8.65822E+00\n...<\/pre>\n\n==[[:Category:BBC BASIC|BBC BASIC]][[Category:BBC BASIC]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[BBC BASIC for Windows]][[SMW::on]]<\/div>\n<lang bbcbasic>      MODE 8\n      *FLOAT 64\n      VDU 23,23,4;0;0;0; : REM Set line thickness\n      \n      theta = RAD(40) : REM initial displacement\n      g = 9.81 : REM acceleration due to gravity\n      l = 0.50 : REM length of pendulum in metres\n      \n      REPEAT\n        PROCpendulum(theta, l)\n        WAIT 1\n        PROCpendulum(theta, l)\n        accel = - g * SIN(theta) \/ l \/ 100\n        speed += accel \/ 100\n        theta += speed\n      UNTIL FALSE\n      END\n      \n      DEF PROCpendulum(a, l)\n      LOCAL pivotX, pivotY, bobX, bobY\n      pivotX = 640\n      pivotY = 800\n      bobX = pivotX + l * 1000 * SIN(a)\n      bobY = pivotY - l * 1000 * COS(a)\n      GCOL 3,6\n      LINE pivotX, pivotY, bobX, bobY\n      GCOL 3,11\n      CIRCLE FILL bobX + 24 * SIN(a), bobY - 24 * COS(a), 24\n      ENDPROC<\/lang>\n\n==[[:Category:C|C]][[Category:C]]==\n<div class=\"examplemeta libheader\">'''Library:''' [[SMW::off]][[:Category:GLUT|GLUT]][[Category:GLUT]][[SMW::on]]<\/div>\n<lang c>#include <stdlib.h>\n#include <math.h>\n#include <GL\/glut.h>\n#include <GL\/gl.h>\n#include <sys\/time.h>\n\n#define length 5\n#define g 9.8\ndouble alpha, accl, omega = 0, E;\nstruct timeval tv;\n\ndouble elappsed() {\n\tstruct timeval now;\n\tgettimeofday(&now, 0);\n\tint ret = (now.tv_sec - tv.tv_sec) * 1000000\n\t\t+ now.tv_usec - tv.tv_usec;\n\ttv = now;\n\treturn ret \/ 1.e6;\n}\n\nvoid resize(int w, int h)\n{\n\tglViewport(0, 0, w, h);\n\tglMatrixMode(GL_PROJECTION);\n\tglLoadIdentity();\n\n\tglMatrixMode(GL_MODELVIEW);\n\tglLoadIdentity();\n\tglOrtho(0, w, h, 0, -1, 1);\n}\n\nvoid render()\n{\n\tdouble x = 320 + 300 * sin(alpha), y = 300 * cos(alpha);\n\tresize(640, 320);\n \tglClear(GL_COLOR_BUFFER_BIT);\n\n\tglBegin(GL_LINES);\n\tglVertex2d(320, 0);\n\tglVertex2d(x, y);\n\tglEnd();\n\tglFlush();\n\n\tdouble us = elappsed();\n\talpha += (omega + us * accl \/ 2) * us;\n\tomega += accl * us;\n\n\t\/* don't let precision error go out of hand *\/\n\tif (length * g * (1 - cos(alpha)) >= E) {\n\t\talpha = (alpha < 0 ? -1 : 1) * acos(1 - E \/ length \/ g);\n\t\tomega = 0;\n\t}\n\taccl = -g \/ length * sin(alpha);\n}\n\nvoid init_gfx(int *c, char **v)\n{\n\tglutInit(c, v);\n\tglutInitDisplayMode(GLUT_RGB);\n\tglutInitWindowSize(640, 320);\n\tglutIdleFunc(render);\n\tglutCreateWindow(\"Pendulum\");\n}\n\nint main(int c, char **v)\n{\n\talpha = 4 * atan2(1, 1) \/ 2.1;\n\tE = length * g * (1 - cos(alpha));\n\n\taccl = -g \/ length * sin(alpha);\n\tomega = 0;\n\n\tgettimeofday(&tv, 0);\n\tinit_gfx(&c, v);\n\tglutMainLoop();\n\treturn 0;\n}<\/lang>\n\n==<span id=\"C sharp\">[[:Category:C sharp|C#]]<\/span>[[Category:C sharp]]==\n<div class=\"examplemeta libheader\">'''Library:''' [[SMW::off]][[:Category:Windows Forms|Windows Forms]][[Category:Windows Forms]][[SMW::on]]<\/div>\n\n<div class=\"examplemeta libheader\">'''Library:''' [[SMW::off]][[:Category:GDI (System.Drawing)|GDI (System.Drawing)]][[Category:GDI (System.Drawing)]][[SMW::on]]<\/div>\n\n<lang csharp>\nusing System;\nusing System.Drawing;\nusing System.Windows.Forms;\n\nclass CSharpPendulum\n{\n    Form _form;\n    Timer _timer;\n    \n    double _angle = Math.PI \/ 2, \n           _angleAccel, \n           _angleVelocity = 0, \n           _dt = 0.1;\n    \n    int _length = 50;\n\n    [STAThread]\n    static void Main()\n    {\n        var p = new CSharpPendulum();\n    }\n\n    public CSharpPendulum()\n    {\n        _form = new Form() { Text = \"Pendulum\", Width = 200, Height = 200 };\n        _timer = new Timer() { Interval = 30 };\n\n        _timer.Tick += delegate(object sender, EventArgs e)\n        {\n            int anchorX = (_form.Width \/ 2) - 12,\n                anchorY = _form.Height \/ 4,\n                ballX = anchorX + (int)(Math.Sin(_angle) * _length),\n                ballY = anchorY + (int)(Math.Cos(_angle) * _length);\n\n            _angleAccel = -9.81 \/ _length * Math.Sin(_angle);\n            _angleVelocity += _angleAccel * _dt;\n            _angle += _angleVelocity * _dt;\n          \n            Bitmap dblBuffer = new Bitmap(_form.Width, _form.Height);\n            Graphics g = Graphics.FromImage(dblBuffer);\n            Graphics f = Graphics.FromHwnd(_form.Handle);\n\n            g.DrawLine(Pens.Black, new Point(anchorX, anchorY), new Point(ballX, ballY));\n            g.FillEllipse(Brushes.Black, anchorX - 3, anchorY - 4, 7, 7);\n            g.FillEllipse(Brushes.DarkGoldenrod, ballX - 7, ballY - 7, 14, 14);\n            \n            f.Clear(Color.White);\n            f.DrawImage(dblBuffer, new Point(0, 0));    \n        };\n\n        _timer.Start();\n        Application.Run(_form);\n    }     \n}\n<\/lang>\n\n==[[:Category:Clojure|Clojure]][[Category:Clojure]]==\nClojure solution using an atom and a separate rendering thread\n\n<div class=\"examplemeta libheader\">'''Library:''' [[SMW::off]][[:Category:Swing|Swing]][[Category:Swing]][[SMW::on]]<\/div> <div class=\"examplemeta libheader\">'''Library:''' [[SMW::off]][[:Category:AWT|AWT]][[Category:AWT]][[SMW::on]]<\/div>\n<lang clojure>\n(ns pendulum\n  (:import\n    (javax.swing JFrame)\n    (java.awt Canvas Graphics Color)))\n \n(def length 200)\n(def width (* 2 (+ 50 length)))\n(def height (* 3 (\/ length 2)))\n(def dt 0.1)\n(def g 9.812)\n(def k (- (\/ g length)))\n(def anchor-x (\/ width 2))\n(def anchor-y (\/ height 8))\n(def angle (atom (\/ (Math\/PI) 2)))\n \n(defn draw [#^Canvas canvas angle]\n  (let [buffer  (.getBufferStrategy canvas)\n        g       (.getDrawGraphics buffer)\n        ball-x (+ anchor-x (* (Math\/sin angle) length))\n        ball-y (+ anchor-y (* (Math\/cos angle) length))]\n    (try      \n      (doto g\n        (.setColor Color\/BLACK)\n        (.fillRect 0 0 width height)\n        (.setColor Color\/RED)\n        (.drawLine anchor-x anchor-y ball-x ball-y)\n        (.setColor Color\/YELLOW)\n        (.fillOval (- anchor-x 3) (- anchor-y 4) 7 7)\n        (.fillOval (- ball-x 7) (- ball-y 7) 14 14))      \n      (finally (.dispose g)))\n    (if-not (.contentsLost buffer)\n      (.show buffer)) ))\n\n(defn start-renderer [canvas]\n  (->>\n    (fn [] (draw canvas @angle) (recur))\n    (new Thread)\n    (.start)))\n \n(defn -main [& args]\n  (let [frame  (JFrame. \"Pendulum\")\n        canvas (Canvas.)]\n \n    (doto frame\n      (.setSize width height)      \n      (.setDefaultCloseOperation JFrame\/EXIT_ON_CLOSE)\n      (.setResizable false)\n      (.add canvas)\n      (.setVisible true))\n \n    (doto canvas\n      (.createBufferStrategy 2)      \n      (.setVisible true)\n      (.requestFocus))\n \n    (start-renderer canvas)\n \n    (loop [v 0]      \n      (swap! angle #(+ % (* v dt)))\n      (Thread\/sleep 15)\n      (recur (+ v (* k (Math\/sin @angle) dt)))) ))\n \n(-main)\n<\/lang>\n\n==[[:Category:E|E]][[Category:E]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[E-on-Java]][[SMW::on]]<\/div> (Uses Java Swing for GUI. The animation logic is independent, however.)\n\nThe angle <math>\\theta<\/math> of a pendulum with length <math>L<\/math> and acceleration due to gravity <math>g<\/math> with all its mass at the end and no friction\/air resistance has an acceleration at any given moment of\n:<math>\\frac{d^2}{dt^2}\\theta = -\\frac{g}{L} \\sin \\theta<\/math>\nThis simulation uses this formula directly, updating the velocity from the acceleration and the position from the velocity; inaccuracy results from the finite timestep.\n\nThe event flow works like this: The ''clock'' object created by the simulation steps the simulation on the specified in the interval. The simulation writes its output to <code><var>angle<\/var><\/code>, which is a ''Lamport slot'' which can notify of updates. The ''whenever'' set up by <code>makeDisplayComponent<\/code> listens for updates and triggers redrawing as long as ''interest'' has been expressed, which is done whenever the component actually redraws, which happens only if the component's window is still on screen. When the window is closed, additionally, the simulation itself is stopped and the application allowed to exit. (This logic is more general than necessary; it is designed to be suitable for a larger application as well.)\n\n<lang e>#!\/usr\/bin\/env rune\npragma.syntax(\"0.9\")\n\ndef pi := (-1.0).acos()\ndef makeEPainter := <unsafe:com.zooko.tray.makeEPainter>\ndef makeLamportSlot := <import:org.erights.e.elib.slot.makeLamportSlot>\ndef whenever := <import:org.erights.e.elib.slot.whenever>\ndef colors := <import:java.awt.makeColor>\n\n# --------------------------------------------------------------\n# --- Definitions\n\ndef makePendulumSim(length_m :float64,\n                    gravity_mps2 :float64,\n                    initialAngle_rad :float64,\n                    timestep_ms :int) {\n  var velocity := 0\n  def &angle := makeLamportSlot(initialAngle_rad)\n  def k := -gravity_mps2\/length_m\n  def timestep_s := timestep_ms \/ 1000\n  def clock := timer.every(timestep_ms, fn _ {\n    def acceleration := k * angle.sin()\n    velocity += acceleration * timestep_s\n    angle    += velocity     * timestep_s\n  })\n  return [clock, &angle]\n}\n\ndef makeDisplayComponent(&angle) {\n  def c\n  def updater := whenever([&angle], fn { c.repaint() })\n  \n  bind c := makeEPainter(def paintCallback {\n    to paintComponent(g) {\n      try {\n        def originX := c.getWidth() \/\/ 2\n        def originY := c.getHeight() \/\/ 2\n        def pendRadius := (originX.min(originY) * 0.95).round()\n        def ballRadius := (originX.min(originY) * 0.04).round()\n        def ballX := (originX + angle.sin() * pendRadius).round()\n        def ballY := (originY + angle.cos() * pendRadius).round()\n\n        g.setColor(colors.getWhite())\n        g.fillRect(0, 0, c.getWidth(), c.getHeight())\n        g.setColor(colors.getBlack())\n        \n        g.fillOval(originX - 2, originY - 2, 4, 4)\n        g.drawLine(originX, originY, ballX, ballY)\n        g.fillOval(ballX - ballRadius, ballY - ballRadius, ballRadius * 2, ballRadius * 2)\n      \n        updater[] # provoke interest provided that we did get drawn (window not closed)\n      } catch p {\n        stderr.println(`In paint callback: $p${p.eStack()}`)\n      }\n    }\n  })\n  \n  c.setPreferredSize(<awt:makeDimension>(300, 300))\n  return c\n}\n\n# --------------------------------------------------------------\n# --- Application setup\n\ndef [clock, &angle] := makePendulumSim(1, 9.80665, pi*99\/100, 10)\n\n# Initialize AWT, move to AWT event thread\nwhen (currentVat.morphInto(\"awt\")) -> {\n\n  # Create the window\n  def frame := <unsafe:javax.swing.makeJFrame>(\"Pendulum\")\n  frame.setContentPane(def display := makeDisplayComponent(&angle))\n  frame.addWindowListener(def mainWindowListener {\n    to windowClosing(_) {\n      clock.stop()\n      interp.continueAtTop()\n    }\n    match _ {}\n  })\n  frame.setLocation(50, 50)\n  frame.pack()\n\n  # Start and become visible\n  frame.show()\n  clock.start()\n}\n\ninterp.blockAtTop()<\/lang>\n\n==[[:Category:Euphoria|Euphoria]][[Category:Euphoria]]==\n===DOS32 version===\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Euphoria]] version 3.1.1[[SMW::on]]<\/div>\n<lang euphoria>include graphics.e\ninclude misc.e\n\nconstant dt = 1E-3\nconstant g = 50\n\nsequence vc\nsequence suspension\natom len\n\nprocedure draw_pendulum(atom color, atom len, atom alfa)\n    sequence point\n    point = (len*{sin(alfa),cos(alfa)} + suspension)\n    draw_line(color, {suspension, point})\n    ellipse(color,0,point-{10,10},point+{10,10})\nend procedure\n\nfunction wait()\n    atom t0\n    t0 = time()\n    while time() = t0 do\n        if get_key() != -1 then\n            return 1\n        end if\n    end while\n    return 0\nend function\n\nprocedure animation()\n    atom alfa, omega, epsilon\n    \n    if graphics_mode(18) then\n    end if\n    \n    vc = video_config()\n    suspension = {vc[VC_XPIXELS]\/2,vc[VC_YPIXELS]\/2}\n    len = vc[VC_YPIXELS]\/2-20\n    \n    alfa = PI\/2\n    omega = 0\n\n    while 1 do\n        draw_pendulum(BRIGHT_WHITE,len,alfa)\n        if wait() then\n            exit\n        end if\n        draw_pendulum(BLACK,len,alfa)\n        epsilon = -len*sin(alfa)*g\n        omega += dt*epsilon\n        alfa += dt*omega\n    end while\n\n    if graphics_mode(-1) then\n    end if\nend procedure\n\nanimation()<\/lang>\n\n==[[:Category:Factor|Factor]][[Category:Factor]]==\nApproximation of the pendulum for small swings : theta = theta0 * cos(omega0 * t)\n<lang factor>USING: accessors alarms arrays calendar colors.constants kernel\nlocals math math.constants math.functions math.rectangles\nmath.vectors opengl sequences system ui ui.gadgets ui.render ;\nIN: pendulum\n\nCONSTANT: g 9.81\nCONSTANT: l 20\nCONSTANT: theta0 0.5\n\n: current-time ( -- time ) nano-count -9 10^ * ;\n\n: T0 ( -- T0 ) 2 pi l g \/ sqrt * * ;\n: omega0 ( -- omega0 ) 2 pi * T0 \/ ;\n: theta ( -- theta ) current-time omega0 * cos theta0 * ;\n\n: relative-xy ( theta l -- xy ) \n    [ [ sin ] [ cos ] bi ]\n    [ [ * ] curry ] bi* bi@ 2array ;\n: theta-to-xy ( origin theta l -- xy ) relative-xy v+ ;\n\nTUPLE: pendulum-gadget < gadget alarm ;\n\n: O ( gadget -- origin ) rect-bounds [ drop ] [ first 2 \/ ] bi* 0 2array ;\n: window-l ( gadget -- l ) rect-bounds [ drop ] [ second ] bi* ;\n: gadget-xy ( gadget -- xy ) [ O ] [ drop theta ] [ window-l ] tri theta-to-xy ;\n\nM: pendulum-gadget draw-gadget* \n    COLOR: black gl-color\n    [ O ] [ gadget-xy ] bi gl-line ;\n\nM:: pendulum-gadget graft* ( gadget -- )\n    [ gadget relayout-1 ]\n    20 milliseconds every gadget (>>alarm) ;\nM: pendulum-gadget ungraft* alarm>> cancel-alarm ;\n\n: <pendulum-gadget> ( -- gadget ) \n    pendulum-gadget new \n    { 500 500 } >>pref-dim ;\n: pendulum-main ( -- )\n    [ <pendulum-gadget> \"pendulum\" open-window ] with-ui ;\nMAIN: pendulum-main\n<\/lang>\n\n==<span id=\"F_Sharp\">[[:Category:F_Sharp|F#]]<\/span>[[Category:F_Sharp]]==\nA nice application of F#'s support for units of measure.\n<lang fsharp>open System\nopen System.Drawing\nopen System.Windows.Forms\n\n\/\/ define units of measurement\n[<Measure>] type m;  \/\/ metres\n[<Measure>] type s;  \/\/ seconds\n\n\/\/ a pendulum is represented as a record of physical quantities\ntype Pendulum =\n { length   : float<m>\n   gravity  : float<m\/s^2>\n   velocity : float<m\/s>\n   angle    : float\n }\n\n\/\/ calculate the next state of a pendulum\nlet next pendulum deltaT : Pendulum =\n  let k = -pendulum.gravity \/ pendulum.length\n  let acceleration = k * Math.Sin pendulum.angle * 1.0<m> \n  let newVelocity = pendulum.velocity + acceleration * deltaT\n  let newAngle = pendulum.angle + newVelocity * deltaT \/ 1.0<m>\n  { pendulum with velocity = newVelocity; angle = newAngle }\n\n\/\/ paint a pendulum (using hard-coded screen coordinates)\nlet paint pendulum (gr: System.Drawing.Graphics) =\n  let homeX = 160\n  let homeY = 50\n  let length = 140.0\n  \/\/ draw plate\n  gr.DrawLine( new Pen(Brushes.Gray, width=2.0f), 0, homeY, 320, homeY )\n  \/\/ draw pivot\n  gr.FillEllipse( Brushes.Gray,           homeX-5, homeY-5, 10, 10 )\n  gr.DrawEllipse( new Pen(Brushes.Black), homeX-5, homeY-5, 10, 10 )\n  \/\/ draw the pendulum itself\n  let x = homeX + int( length * Math.Sin pendulum.angle )\n  let y = homeY + int( length * Math.Cos pendulum.angle )\n  \/\/ draw rod\n  gr.DrawLine( new Pen(Brushes.Black, width=3.0f), homeX, homeY, x, y )\n  \/\/ draw bob\n  gr.FillEllipse( Brushes.Yellow,         x-15, y-15, 30, 30 )\n  gr.DrawEllipse( new Pen(Brushes.Black), x-15, y-15, 30, 30 )\n\n\/\/ defines an operator \"-?\" that calculates the time from t2 to t1  \n\/\/ where t2 is optional\nlet (-?) (t1: DateTime) (t2: DateTime option) : float<s> =\n  match t2 with\n  | None   -> 0.0<s> \/\/ only one timepoint given -> difference is 0\n  | Some t -> (t1 - t).TotalSeconds * 1.0<s>\n\n\/\/ our main window is double-buffered form that reacts to paint events\ntype PendulumForm() as self = \n  inherit Form(Width=325, Height=240, Text=\"Pendulum\")\n  let mutable pendulum = { length   = 1.0<m>;\n                           gravity  = 9.81<m\/s^2>\n                           velocity = 0.0<m\/s>\n                           angle    = Math.PI \/ 2.0\n                         }\n  let mutable lastPaintedAt = None\n  let updateFreq = 0.01<s>\n\n  do self.DoubleBuffered <- true\n     self.Paint.Add( fun args ->\n       let now = DateTime.Now\n       let deltaT = now -? lastPaintedAt |> min 0.01<s> \n       lastPaintedAt <- Some now\n\n       pendulum <- next pendulum deltaT\n\n       let gr = args.Graphics\n       gr.Clear( Color.LightGray )\n       paint pendulum gr\n\n       \/\/ initiate a new paint event after a while (non-blocking)\n       async { do! Async.Sleep( int( 1000.0 * updateFreq \/ 1.0<s> ) )\n               self.Invalidate()\n            }\n       |> Async.Start \n     )\n\n[<STAThread>]\nApplication.Run( new PendulumForm( Visible=true ) )<\/lang>\n\n==[[:Category:Haskell|Haskell]][[Category:Haskell]]==\nUsing <div class=\"examplemeta libheader\">'''Library:''' [[SMW::off]][[:Category:HGL|HGL]][[Category:HGL]][[SMW::on]]<\/div> from [http:\/\/hackage.haskell.org\/packages\/hackage.html HackageDB]\n<lang haskell>import Graphics.HGL.Draw.Monad (Graphic, )\nimport Graphics.HGL.Draw.Picture\nimport Graphics.HGL.Utils\nimport Graphics.HGL.Window\nimport Graphics.HGL.Run\n\nimport Control.Exception (bracket, )\nimport Control.Arrow\n\ntoInt = fromIntegral.round\n  \npendulum = runGraphics $\n  bracket\n    (openWindowEx \"Pendulum animation task\" Nothing (600,400) DoubleBuffered (Just 30))\n    closeWindow\n    (\\w -> mapM_ ((\\ g -> setGraphic w g >> getWindowTick w).\n\t\t    (\\ (x, y) -> overGraphic (line (300, 0) (x, y))\n\t\t\t\t  (ellipse (x - 12, y + 12) (x + 12, y - 12)) )) pts)\n where\n    dt = 1\/30\n    t = - pi\/4\n    l = 1\n    g = 9.812 \n    nextAVT (a,v,t) = (a', v', t + v' * dt) where\n\ta' = - (g \/ l) * sin t\n\tv' = v + a' * dt\n    pts = map (\\(_,t,_) -> (toInt.(300+).(300*).cos &&& toInt. (300*).sin) (pi\/2+0.6*t) )\n\t$ iterate nextAVT (- (g \/ l) * sin t, t, 0)<\/lang>\nUse (interpreter ghci):\n *Main> pendulum\n\n==[[:Category:HicEst|HicEst]][[Category:HicEst]]==\n[http:\/\/www.HicEst.com\/DIFFEQ.htm DIFFEQ] and the callback procedure pendulum numerically integrate the pendulum equation.\nThe display window can be resized during the run, but for window width not equal to 2*height the pendulum rod becomes a rubber band instead:\n<lang HicEst>REAL :: msec=10, Lrod=1, dBob=0.03, g=9.81, Theta(2), dTheta(2)\nBobMargins = ALIAS(ls, rs, ts, bs) ! box margins to draw the bob\n\n\nTheta = (1, 0)        ! initial angle and velocity\nstart_t = TIME()\n\nDO i = 1, 1E100       ! \"forever\"\n   end_t = TIME()     ! to integrate in real-time sections:\n   DIFFEQ(Callback=\"pendulum\", T=end_t, Y=Theta, DY=dTheta, T0=start_t)\n   xBob = (SIN(Theta(1)) + 1) \/ 2\n   yBob = COS(Theta(1)) - dBob\n\n   ! create or clear window and draw pendulum bob at (xBob, yBob):\n   WINDOW(WIN=wh, LeftSpace=0, RightSpace=0, TopSpace=0, BottomSpace=0, Up=999)\n   BobMargins = (xBob-dBob, 1-xBob-dBob, yBob-dBob, 1-yBob-dBob)\n   WINDOW(WIN=wh, LeftSpace=ls, RightSpace=rs, TopSpace=ts, BottomSpace=bs)\n   WRITE(WIN=wh, DeCoRation='EL=4, BC=4') ! flooded red ellipse as bob\n\n   ! draw the rod hanging from the center of the window:\n   WINDOW(WIN=wh, LeftSpace=0.5, TopSpace=0, RightSpace=rs+dBob)\n   WRITE(WIN=wh, DeCoRation='LI=0 0; 1 1, FC=4.02') ! red pendulum rod\n\n   SYSTEM(WAIT=msec)\n   start_t = end_t\nENDDO\n\nEND\n\nSUBROUTINE pendulum                 ! Theta\" = - (g\/Lrod) * SIN(Theta)\n  dTheta(1) = Theta(2)              ! Theta' = Theta(2)  substitution\n  dTheta(2) = -g\/Lrod*SIN(Theta(1)) ! Theta\" = Theta(2)' = -g\/Lrod*SIN(Theta(1))\nEND<\/lang>\n\n== Icon and [[:Category:Unicon|Unicon]][[Category:Unicon]] ==\n\nThe following code uses features exclusive to Unicon, specifically the object-oriented gui library.\n\n<div class=\"examplemeta translation\">'''Translation of''': [[Animate a pendulum#Scheme|Scheme]]<\/div>\n\n<lang Unicon>\nimport gui\n$include \"guih.icn\"\n\n# some constants to define the display and pendulum\n$define HEIGHT 400\n$define WIDTH 500\n$define STRING_LENGTH 200\n$define HOME_X 250\n$define HOME_Y 21\n$define SIZE 30\n$define START_ANGLE 80\n\nclass WindowApp : Dialog ()\n\n  # draw the pendulum on given context_window, at position (x,y)\n  method draw_pendulum (x, y)\n    # reference to current screen area to draw on\n    cw := Clone(self.cwin)\n\n    # clear screen\n    WAttrib (cw, \"bg=grey\")\n    EraseRectangle (cw, 0, 0, WIDTH, HEIGHT)\n\n    # draw the display\n    WAttrib (cw, \"fg=dark gray\")\n    DrawLine (cw, 10, 20, WIDTH-20, 20)\n    WAttrib (cw, \"fg=black\")\n    DrawLine (cw, HOME_X, HOME_Y, x, y)\n    FillCircle (cw, x, y, SIZE+2)\n    WAttrib (cw, \"fg=yellow\")\n    FillCircle (cw, x, y, SIZE)\n\n    # free reference to screen area\n    Uncouple (cw)\n  end\n\n  # find the average of given two arguments\n  method avg (a, b)\n    return (a + b) \/ 2\n  end\n\n  # this method gets called by the ticker\n  # it computes the next position of the pendulum and\n  # requests a redraw\n  method tick ()\n    static x, y\n    static theta := START_ANGLE\n    static d_theta := 0\n    # update x,y of pendulum\n    scaling := 3000.0 \/ (STRING_LENGTH * STRING_LENGTH)\n    # -- first estimate\n    first_dd_theta := -(sin (dtor (theta)) * scaling)\n    mid_d_theta := d_theta + first_dd_theta\n    mid_theta := theta + avg (d_theta, mid_d_theta)\n    # -- second estimate\n    mid_dd_theta := - (sin (dtor (mid_theta)) * scaling)\n    mid_d_theta_2 := d_theta + avg (first_dd_theta, mid_dd_theta)\n    mid_theta_2 := theta + avg (d_theta, mid_d_theta_2)\n    # -- again first\n    mid_dd_theta_2 := -(sin (dtor (mid_theta_2)) * scaling)\n    last_d_theta := mid_d_theta_2 + mid_dd_theta_2\n    last_theta := mid_theta_2 + avg (mid_d_theta_2, last_d_theta)\n    # -- again second\n    last_dd_theta := - (sin (dtor (last_theta)) * scaling)\n    last_d_theta_2 := mid_d_theta_2 + avg (mid_dd_theta_2, last_dd_theta)\n    last_theta_2 := mid_theta_2 + avg (mid_d_theta_2, last_d_theta_2)\n    # -- update stored angles\n    d_theta := last_d_theta_2\n    theta := last_theta_2\n    # -- update x, y\n    pendulum_angle := dtor (theta)\n    x := HOME_X + STRING_LENGTH * sin (pendulum_angle)\n    y := HOME_Y + STRING_LENGTH * cos (pendulum_angle)\n\n    # draw pendulum\n    draw_pendulum (x, y)\n  end\n\n  # set up the window\n  method component_setup ()\n    # some cosmetic settings for the window\n    attrib(\"size=\"||WIDTH||\",\"||HEIGHT, \"bg=light gray\", \"label=Pendulum\")\n    # make sure we respond to window close event\n    connect (self, \"dispose\", CLOSE_BUTTON_EVENT)\n    # start the ticker, to update the display periodically\n    self.set_ticker (20)\n  end\nend\n\nprocedure main ()\n  w := WindowApp ()\n  w.show_modal ()\nend\n<\/lang>\n\n==[[:Category:J|J]][[Category:J]]==\n<lang j>require 'gl2 trig'\ncoinsert 'jgl2'\n\nDT   =: %30      NB. seconds\nANGLE=: 0.25p1   NB. radians\nL    =: 1        NB. metres\nG    =: 9.80665  NB. ms_2\nVEL  =: 0        NB. ms_1\n\nPEND=: noun define\npc pend;pn \"Pendulum\";\nxywh 0 0 320 200;cc isi isigraph rightmove bottommove;\npas 0 0;pcenter;\nrem form end;\n)\n\npend_run      =: verb def ' wd PEND,'';pshow;timer '',\":DT * 1000 '\npend_close    =: verb def ' wd ''timer 0; pclose'' '\npend_isi_paint=: verb def ' drawPendulum ANGLE '\n\nsys_timer_z_=: verb define\n  recalcAngle ''\n  wd 'psel pend; setinvalid isi'\n)\n\nrecalcAngle=: verb define\n  accel=. - (G % L) * sin ANGLE\n  VEL  =: VEL + accel * DT\n  ANGLE=: ANGLE + VEL * DT\n)\n\ndrawPendulum=: verb define\n  width=. {. glqwh''\n  ps=. (-: width) , 40\n  pe=. ps + 280 <.@* (cos , sin) 0.5p1 + y    NB. adjust orientation\n  glrgb 91 91 91\n  glbrush''\n  gllines ps , pe\n  glellipse (,~ ps - -:) 40 15\n  glellipse (,~ pe - -:) 20 20\n  glrect 0 0 ,width, 40\n)\n\npend_run''                                    NB. run animation<\/lang>\n\n==[[:Category:Java|Java]][[Category:Java]]==\n<div class=\"examplemeta libheader\">'''Library:''' [[SMW::off]][[:Category:Swing|Swing]][[Category:Swing]][[SMW::on]]<\/div> <div class=\"examplemeta libheader\">'''Library:''' [[SMW::off]][[:Category:AWT|AWT]][[Category:AWT]][[SMW::on]]<\/div>\n<lang java>import java.awt.*;\nimport javax.swing.*;\n\npublic class Pendulum extends JPanel implements Runnable {\n\n    private double angle = Math.PI \/ 2;\n    private int length;\n\n    public Pendulum(int length) {\n        this.length = length;\n        setDoubleBuffered(true);\n    }\n\n    @Override\n    public void paint(Graphics g) {\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, getWidth(), getHeight());\n        g.setColor(Color.BLACK);\n        int anchorX = getWidth() \/ 2, anchorY = getHeight() \/ 4;\n        int ballX = anchorX + (int) (Math.sin(angle) * length);\n        int ballY = anchorY + (int) (Math.cos(angle) * length);\n        g.drawLine(anchorX, anchorY, ballX, ballY);\n        g.fillOval(anchorX - 3, anchorY - 4, 7, 7);\n        g.fillOval(ballX - 7, ballY - 7, 14, 14);\n    }\n\n    public void run() {\n        double angleAccel, angleVelocity = 0, dt = 0.1;\n        while (true) {\n            angleAccel = -9.81 \/ length * Math.sin(angle);\n            angleVelocity += angleAccel * dt;\n            angle += angleVelocity * dt;\n            repaint();\n            try { Thread.sleep(15); } catch (InterruptedException ex) {}\n        }\n    }\n\n    @Override\n    public Dimension getPreferredSize() {\n        return new Dimension(2 * length + 50, length \/ 2 * 3);\n    }\n\n    public static void main(String[] args) {\n        JFrame f = new JFrame(\"Pendulum\");\n        Pendulum p = new Pendulum(200);\n        f.add(p);\n        f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        f.pack();\n        f.setVisible(true);\n        new Thread(p).start();\n    }\n}<\/lang>\n\n==[[:Category:JavaScript|JavaScript]][[Category:JavaScript]] + &lt;canvas>==\n<div class=\"examplemeta translation\">'''Translation of''': [[Animate a pendulum#E|E]]<\/div> (plus gratuitous motion blur)\n\n<lang javascript><html><head>\n  <title>Pendulum<\/title>\n<\/head><body style=\"background: gray;\">\n\n<canvas id=\"canvas\" width=\"600\" height=\"600\">\n  <p>Sorry, your browser does not support the &lt;canvas&gt; used to display the pendulum animation.<\/p>\n<\/canvas>\n<script>\n  function PendulumSim(length_m, gravity_mps2, initialAngle_rad, timestep_ms, callback) {\n    var velocity = 0;\n    var angle = initialAngle_rad;\n    var k = -gravity_mps2\/length_m;\n    var timestep_s = timestep_ms \/ 1000;\n    return setInterval(function () {\n      var acceleration = k * Math.sin(angle);\n      velocity += acceleration * timestep_s;\n      angle    += velocity     * timestep_s;\n      callback(angle);\n    }, timestep_ms);\n  }\n  \n  var canvas = document.getElementById('canvas');\n  var context = canvas.getContext('2d');\n  var prev=0;\n  var sim = PendulumSim(1, 9.80665, Math.PI*99\/100, 10, function (angle) {\n    var rPend = Math.min(canvas.width, canvas.height) * 0.47;\n    var rBall = Math.min(canvas.width, canvas.height) * 0.02;\n    var rBar = Math.min(canvas.width, canvas.height) * 0.005;\n    var ballX = Math.sin(angle) * rPend;\n    var ballY = Math.cos(angle) * rPend;\n\n    context.fillStyle = \"rgba(255,255,255,0.51)\";\n    context.globalCompositeOperation = \"destination-out\";\n    context.fillRect(0, 0, canvas.width, canvas.height);\n    \n    context.fillStyle = \"yellow\";\n    context.strokeStyle = \"rgba(0,0,0,\"+Math.max(0,1-Math.abs(prev-angle)*10)+\")\";\n    context.globalCompositeOperation = \"source-over\";\n\n    context.save();\n      context.translate(canvas.width\/2, canvas.height\/2);\n      context.rotate(angle);\n      \n      context.beginPath();\n      context.rect(-rBar, -rBar, rBar*2, rPend+rBar*2);\n      context.fill();\n      context.stroke();\n      \n      context.beginPath();\n      context.arc(0, rPend, rBall, 0, Math.PI*2, false);\n      context.fill();\n      context.stroke();\n    context.restore();\n    prev=angle;\n  });\n<\/script>\n\n<\/body><\/html><\/lang>\n\n==[[:Category:Liberty BASIC|Liberty BASIC]][[Category:Liberty BASIC]]==\n<lang lb>nomainwin\n    WindowWidth = 400\n    WindowHeight = 300\n\n    open \"Pendulum\" for graphics_nsb_nf as #main\n    #main, \"down;fill white; flush\"\n    #main, \"color black\"\n    #main, \"trapclose [quit.main]\"\n\n    Angle = asn(1)\n    DeltaT = 0.1\n    PendLength = 150\n    FixX = int(WindowWidth \/ 2)\n    FixY = 40\n\n    timer 30, [swing]\n\n    wait\n\n[swing]\n\n    #main, \"cls\"\n    #main, \"discard\"\n\n    PlumbobX = FixX + int(sin(Angle) * PendLength)\n    PlumbobY = FixY + int(cos(Angle) * PendLength)\n    AngAccel = -9.81 \/ PendLength * sin(Angle)\n    AngVelocity = AngVelocity + AngAccel * DeltaT\n    Angle = Angle + AngVelocity * DeltaT\n\n    #main, \"backcolor black\"\n    #main, \"place \";FixX;\" \";FixY\n    #main, \"circlefilled 3\"\n    #main, \"line \";FixX;\" \";FixY;\" \";PlumbobX;\" \";PlumbobY\n    #main, \"backcolor red\"\n    #main, \"circlefilled 10\"\n\n    wait\n\n[quit.main]\n    close #main\n    end<\/lang>\n\n==[[:Category:Logo|Logo]][[Category:Logo]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[UCB Logo]][[SMW::on]]<\/div>\n<lang logo>make \"angle 45\nmake \"L 1\nmake \"bob 10\n\nto draw.pendulum\n  clearscreen\n  seth :angle+180\t\t; down on screen is 180\n  forward :L*100-:bob\n  penup\n  forward :bob\n  pendown\n  arc 360 :bob\nend\n\nmake \"G   9.80665\nmake \"dt  1\/30\nmake \"acc 0\nmake \"vel 0\n\nto step.pendulum\n  make \"acc  -:G \/ :L * sin :angle\n  make \"vel   :vel   + :acc * :dt\n  make \"angle :angle + :vel * :dt\n  wait :dt*60\n  draw.pendulum\nend\n\nhideturtle\nuntil [key?] [step.pendulum]<\/lang>\n\n==[[:Category:Mathematica|Mathematica]][[Category:Mathematica]]==\n<lang Mathematica>freq = 8; length = freq^(-1\/2);\nAnimate[Graphics[\n  List[{Line[{{0, 0}, length {Sin[T], -Cos[T]}} \/. {T -> (Pi\/6) Cos[2 Pi freq t]}], PointSize[Large], \n               Point[{length {Sin[T], -Cos[T]}} \/. {T -> (Pi\/6) Cos[2 Pi freq t]}]}], \n  PlotRange -> {{-0.3, 0.3}, {-0.5, 0}}], {t, 0, 1}, AnimationRate -> 0.07]<\/lang>\n[[File:mmapendulum.gif]]\n\n==[[:Category:MATLAB|MATLAB]][[Category:MATLAB]]==\npendulum.m\n<lang MATLAB>%This is a numerical simulation of a pendulum with a massless pivot arm.\n\n%% User Defined Parameters\n%Define external parameters\ng = -9.8;\ndeltaTime = 1\/50; %Decreasing this will increase simulation accuracy\nendTime = 16;\n\n%Define pendulum\nrodPivotPoint = [2 2]; %rectangular coordinates\nrodLength = 1;\nmass = 1; %of the bob\nradius = .2; %of the bob\ntheta = 45; %degrees, defines initial position of the bob\nvelocity = [0 0]; %cylindrical coordinates; first entry is radial velocity,\n                  %second entry is angular velocity\n\n%% Simulation\nassert(radius < rodLength,'Pendulum bob radius must be less than the length of the rod.');\n\nposition = rodPivotPoint - (rodLength*[-sind(theta) cosd(theta)]); %in rectangular coordinates\n\n%Generate graphics, render pendulum\nfigure;\naxesHandle = gca;\nxlim(axesHandle, [(rodPivotPoint(1) - rodLength - radius) (rodPivotPoint(1) + rodLength + radius)] );\nylim(axesHandle, [(rodPivotPoint(2) - rodLength - radius) (rodPivotPoint(2) + rodLength + radius)] );\n\nrectHandle = rectangle('Position',[(position - radius\/2) radius radius],...\n    'Curvature',[1,1],'FaceColor','g'); %Pendulum bob\nhold on\nplot(rodPivotPoint(1),rodPivotPoint(2),'^'); %pendulum pivot\nlineHandle = line([rodPivotPoint(1) position(1)],...\n    [rodPivotPoint(2) position(2)]); %pendulum rod\nhold off\n\n%Run simulation, all calculations are performed in cylindrical coordinates\nfor time = (deltaTime:deltaTime:endTime)\n        \n    drawnow; %Forces MATLAB to render the pendulum\n    \n    %Find total force\n    gravitationalForceCylindrical = [mass*g*cosd(theta) mass*g*sind(theta)];\n    \n    %This code is just incase you want to add more forces,e.g friction\n    totalForce = gravitationalForceCylindrical; \n    \n    %If the rod isn't massless or is a spring, etc., modify this line\n    %accordingly\n    rodForce = [-totalForce(1) 0]; %cylindrical coordinates\n    \n    totalForce = totalForce + rodForce;\n    \n    acceleration = totalForce \/ mass; %F = ma\n    velocity = velocity + acceleration * deltaTime;\n    rodLength = rodLength + velocity(1) * deltaTime;\n    theta = theta + velocity(2) * deltaTime;\n    \n    position = rodPivotPoint - (rodLength*[-sind(theta) cosd(theta)]);\n    \n    %Update figure with new position info\n    set(rectHandle,'Position',[(position - radius\/2) radius radius]);\n    set(lineHandle,'XData',[rodPivotPoint(1) position(1)],'YData',...\n        [rodPivotPoint(2) position(2)]);\n\nend<\/lang>\n\n==[[:Category:Oz|Oz]][[Category:Oz]]==\nInspired by the E and Ruby versions.\n\n<lang oz>declare\n  [QTk] = {Link ['x-oz:\/\/system\/wp\/QTk.ozf']}\n\n  Pi = 3.14159265\n\n  class PendulumModel\n     feat\n\tK\n     attr\n\tangle\n\tvelocity\n\n     meth init(length:L       <= 1.0    %% meters\n\t       gravity:G      <= 9.81   %% m\/s\u00b2\n\t       initialAngle:A <= Pi\/2.) %% radians\n\tself.K = ~G \/ L\n\tangle := A\n\tvelocity := 0.0\n     end\n\n     meth nextAngle(deltaT:DeltaTMS %% milliseconds\n\t\t    ?Angle)         %% radians\n        DeltaT = {Int.toFloat DeltaTMS} \/ 1000.0 %% seconds\n        Acceleration = self.K * {Sin @angle}\n     in\n        velocity := @velocity + Acceleration * DeltaT\n        angle := @angle + @velocity * DeltaT\n        Angle = @angle\n     end\n  end\n\n  %% Animates a pendulum on a given canvas.\n  class PendulumAnimation from Time.repeat\n     feat\n        Pend\n        Rod\n        Bob\n        home:pos(x:160 y:50)\n        length:140.0\n\tdelay\n      \n     meth init(Pendulum Canvas delay:Delay <= 25) %% milliseconds\n\tself.Pend = Pendulum\n\tself.delay = Delay\n\t%% plate and pivot\n        {Canvas create(line 0 self.home.y 320 self.home.y width:2 fill:grey50)}\n        {Canvas create(oval 155 self.home.y-5 165 self.home.y+5 fill:grey50 outline:black)}\n\t%% the pendulum itself\n\tself.Rod = {Canvas create(line 1 1 1 1 width:3 fill:black handle:$)}\n        self.Bob = {Canvas create(oval 1 1 2 2 fill:yellow outline:black handle:$)}\n        %%\n        {self setRepAll(action:Animate delay:Delay)}\n     end\n\n     meth Animate\n\tTheta = {self.Pend nextAngle(deltaT:self.delay $)}\n\t%% calculate x and y from angle\n\tX = self.home.x + {Float.toInt self.length * {Sin Theta}}\n\tY = self.home.y + {Float.toInt self.length * {Cos Theta}}\n     in\n\t%% update canvas\n\ttry\n\t   {self.Rod setCoords(self.home.x self.home.y X Y)}\n\t   {self.Bob setCoords(X-15 Y-15 X+15 Y+15)}\n\tcatch system(tk(alreadyClosed ...) ...) then skip end\n     end\n  end\n   \n  Pendulum = {New PendulumModel init}\n\n  Canvas\n  GUI = td(title:\"Pendulum\"\n           canvas(width:320 height:210 handle:?Canvas)\n           action:proc {$} {Animation stop} {Window close} end\n          )\n  Window = {QTk.build GUI}\n\n  Animation = {New PendulumAnimation init(Pendulum Canvas)}\nin\n  {Window show}\n  {Animation go}<\/lang>\n\n==[[:Category:PicoLisp|PicoLisp]][[Category:PicoLisp]]==\nA minimalist solution. The pendulum consists of the center point '+', and the swinging xterm cursor.\n<lang PicoLisp>(load \"@lib\/math.l\")\n\n(de pendulum (X Y Len)\n   (let (Angle pi\/2  V 0)\n      (call 'clear)\n      (call 'tput \"cup\" Y X)\n      (prin '+)\n      (call 'tput \"cup\" 1 (+ X Len))\n      (until (key 25)                        # 25 ms\n         (let A (*\/ (sin Angle) -9.81 1.0)\n            (inc 'V (*\/ A 40))               # DT = 25 ms = 1\/40 sec\n            (inc 'Angle (*\/ V 40)) )\n         (call 'tput \"cup\"\n            (+ Y (*\/ Len (cos Angle) 2.2))   # Compensate for aspect ratio\n            (+ X (*\/ Len (sin Angle) 1.0)) ) ) ) )<\/lang>\nTest (hit any key to stop):\n<lang PicoLisp>(pendulum 40 1 36)<\/lang>\n\n==[[:Category:Prolog|Prolog]][[Category:Prolog]]==\nSWI-Prolog has a graphic interface XPCE.\n<lang Prolog>:- use_module(library(pce)).\n\npendulum :-\n\tnew(D, window('Pendulum')),\n\tsend(D, size, size(560, 300)),\n\tnew(Line, line(80, 50, 480, 50)),\n\tsend(D, display, Line),\n\tnew(Circle, circle(20)),\n\tsend(Circle, fill_pattern,  colour(@default, 0, 0, 0)),\n\tnew(Boule, circle(60)),\n\tsend(Boule, fill_pattern,  colour(@default, 0, 0, 0)),\n\tsend(D, display, Circle, point(270,40)),\n\tsend(Circle, handle, handle(h\/2, w\/2, in)),\n\tsend(Boule, handle, handle(h\/2, w\/2, out)),\n\tsend(Circle, connect, Boule, link(in, out, line(0,0,0,0,none))),\n\tnew(Anim, animation(D, 0.0, Boule, 200.0)),\n\tsend(D, done_message, and(message(Anim, free),\n\t\t\t\t  message(Boule, free),\n\t\t\t\t  message(Circle, free),\n\t\t\t\t  message(@receiver,destroy))),\n\tsend(Anim?mytimer, start),\n\tsend(D, open).\n\n\n\n\n:- pce_begin_class(animation(window, angle, boule, len_pendulum), object).\nvariable(window, object,  both, \"Display window\").\nvariable(boule,  object, both,  \"bowl of the pendulum\").\nvariable(len_pendulum,    object, both,  \"len of the pendulum\").\nvariable(angle,  object, both,  \"angle with the horizontal\").\nvariable(delta,    object, both,  \"increment of the angle\").\nvariable(mytimer, timer, both, \"timer of the animation\").\n\ninitialise(P, W:object, A:object, B : object, L:object) :->\n        \"Creation of the object\"::\n        send(P, window, W),\n        send(P, angle, A),\n        send(P, boule, B),\n        send(P, len_pendulum, L),\n        send(P, delta, 0.01),\n\tsend(P, mytimer, new(_, timer(0.01,message(P, anim_message)))).\n\n% method called when the object is destroyed\n% first the timer is stopped\n% then all the resources are freed\nunlink(P) :->\n\tsend(P?mytimer, stop),\n\tsend(P, send_super, unlink).\n\n\n% message processed by the timer\nanim_message(P) :->\n\tget(P, angle, A),\n\tget(P, len_pendulum, L),\n\tcalc(A, L, X, Y),\n\tget(P, window, W),\n\tget(P, boule, B),\n\tsend(W, display, B, point(X,Y)),\n\t% computation of the next position\n\tget(P, delta, D),\n\tnext_Angle(A, D, NA, ND),\n\tsend(P, angle, NA),\n\tsend(P, delta, ND).\n\n:- pce_end_class.\n\n% computation of the position of the bowl.\ncalc(Ang, Len, X, Y) :-\n\tX is Len * cos(Ang)+ 250,\n\tY is Len * sin(Ang) + 20.\n\n\n% computation of the next angle\n% if we reach 0 or pi, delta change.\nnext_Angle(A, D, NA, ND) :-\n\tNA is D + A,\n\t(((D > 0,   abs(pi-NA) < 0.01); (D < 0, abs(NA) < 0.01))->\n\t  ND = - D;\n\t  ND = D).\n<\/lang>\n==[[:Category:PureBasic|PureBasic]][[Category:PureBasic]]==\nIf the code was part of a larger application it could be improved by specifying constants for the locations of image elements.\n<lang PureBasic>Procedure handleError(x, msg.s)\n  If Not x\n    MessageRequester(\"Error\", msg)\n    End\n  EndIf\nEndProcedure\n\n#ScreenW = 320\n#ScreenH = 210\nhandleError(OpenWindow(0, 0, 0, #ScreenW, #ScreenH, \"Animated Pendulum\", #PB_Window_SystemMenu), \"Can't open window.\")\nhandleError(InitSprite(), \"Can't setup sprite display.\")\nhandleError(OpenWindowedScreen(WindowID(0), 0, 0, #ScreenW, #ScreenH, 0, 0, 0), \"Can't open screen.\")\n\nEnumeration ;sprites\n  #bob_spr\n  #ceiling_spr\n  #pivot_spr\nEndEnumeration\n\nTransparentSpriteColor(#PB_Default, RGB(255, 0, 255))\nCreateSprite(#bob_spr, 32, 32)\nStartDrawing(SpriteOutput(#bob_spr))\n  Box(0, 0, 32, 32, RGB(255, 0, 255))\n  Circle(16, 16, 15, RGB(253, 252, 3))\n  DrawingMode(#PB_2DDrawing_Outlined)\n  Circle(16, 16, 15, RGB(0, 0, 0))\nStopDrawing()\n\nCreateSprite(#pivot_spr, 10, 10)\nStartDrawing(SpriteOutput(#pivot_spr))\n  Box(0, 0, 10, 10, RGB(255, 0, 255))\n  Circle(5, 5, 4, RGB(125, 125, 125))\n  DrawingMode(#PB_2DDrawing_Outlined)\n  Circle(5, 5, 4, RGB(0,0 , 0))\nStopDrawing()\n\nCreateSprite(#ceiling_spr,#ScreenW,2)\nStartDrawing(SpriteOutput(#ceiling_spr))\n  Box(0,0,SpriteWidth(#ceiling_spr), SpriteHeight(#ceiling_spr), RGB(126, 126, 126))\nStopDrawing()\n\nStructure pendulum\n  length.d   ; meters\n  constant.d ; -g\/l\n  gravity.d  ; m\/s\u00b2\n  angle.d    ; radians\n  velocity.d ; m\/s\nEndStructure\n\nProcedure initPendulum(*pendulum.pendulum, length.d = 1.0, gravity.d = 9.81, initialAngle.d = #PI \/ 2)\n  With *pendulum\n    \\length = length\n    \\gravity = gravity\n    \\angle = initialAngle\n    \\constant = -gravity \/ length\n    \\velocity = 0.0\n  EndWith\nEndProcedure\n  \n\nProcedure updatePendulum(*pendulum.pendulum, deltaTime.d) \n  deltaTime = deltaTime \/ 1000.0 ;ms\n  Protected acceleration.d = *pendulum\\constant * Sin(*pendulum\\angle)\n  *pendulum\\velocity + acceleration * deltaTime\n  *pendulum\\angle + *pendulum\\velocity * deltaTime\nEndProcedure\n\nProcedure drawBackground()\n  ClearScreen(RGB(190,190,190))\n  ;draw ceiling\n  DisplaySprite(#ceiling_spr, 0, 47)\n  ;draw pivot\n  DisplayTransparentSprite(#pivot_spr, 154,43) ;origin in upper-left\nEndProcedure\n\nProcedure drawPendulum(*pendulum.pendulum)\n  ;draw rod\n  Protected x = *pendulum\\length * 140 * Sin(*pendulum\\angle) ;scale = 1 m\/140 pixels\n  Protected y = *pendulum\\length * 140 * Cos(*pendulum\\angle)\n  StartDrawing(ScreenOutput())\n    LineXY(154 + 5,43 + 5, 154 + 5 + x, 43 + 5 + y) ;draw from pivot-center to bob-center, adjusting for origins\n  StopDrawing()\n  \n  ;draw bob\n  DisplayTransparentSprite(#bob_spr, 154 + 5 - 16 + x, 43 + 5 - 16 + y) ;adj for origin in upper-left\nEndProcedure \n\nDefine pendulum.pendulum, event\ninitPendulum(pendulum)\ndrawPendulum(pendulum)\n\nAddWindowTimer(0, 1, 50)\nRepeat\n  event = WindowEvent()\n  Select event\n    Case #pb_event_timer\n      drawBackground()\n      Select EventTimer()\n        Case 1\n          updatePendulum(pendulum, 50)\n          drawPendulum(pendulum)\n      EndSelect\n      FlipBuffers() \n    Case #PB_Event_CloseWindow\n      Break\n  EndSelect\nForEver<\/lang>\n\n==[[:Category:Python|Python]][[Category:Python]]==\n<div class=\"examplemeta libheader\">'''Library:''' [[SMW::off]][[:Category:pygame|pygame]][[Category:pygame]][[SMW::on]]<\/div>\n\n<div class=\"examplemeta translation\">'''Translation of''': [[Animate a pendulum#C|C]]<\/div>\n<lang python>import pygame, sys\nfrom pygame.locals import *\nfrom math import sin, cos, radians\n\npygame.init()\n\nWINDOWSIZE = 250\nTIMETICK = 100\nBOBSIZE = 15\n\nwindow = pygame.display.set_mode((WINDOWSIZE, WINDOWSIZE))\npygame.display.set_caption(\"Pendulum\")\n\nscreen = pygame.display.get_surface()\nscreen.fill((255,255,255))\n\nPIVOT = (WINDOWSIZE\/2, WINDOWSIZE\/10)\nSWINGLENGTH = PIVOT[1]*4\n\nclass BobMass(pygame.sprite.Sprite):\n    def __init__(self):\n        pygame.sprite.Sprite.__init__(self)\n        self.theta = 45\n        self.dtheta = 0\n        self.rect = pygame.Rect(PIVOT[0]-SWINGLENGTH*cos(radians(self.theta)),\n                                PIVOT[1]+SWINGLENGTH*sin(radians(self.theta)),\n                                1,1)\n        self.draw()\n\n    def recomputeAngle(self):\n        scaling = 3000.0\/(SWINGLENGTH**2)\n\n        firstDDtheta = -sin(radians(self.theta))*scaling\n        midDtheta = self.dtheta + firstDDtheta\n        midtheta = self.theta + (self.dtheta + midDtheta)\/2.0\n\n        midDDtheta = -sin(radians(midtheta))*scaling\n        midDtheta = self.dtheta + (firstDDtheta + midDDtheta)\/2\n        midtheta = self.theta + (self.dtheta + midDtheta)\/2\n\n        midDDtheta = -sin(radians(midtheta)) * scaling\n        lastDtheta = midDtheta + midDDtheta\n        lasttheta = midtheta + (midDtheta + lastDtheta)\/2.0\n        \n        lastDDtheta = -sin(radians(lasttheta)) * scaling\n        lastDtheta = midDtheta + (midDDtheta + lastDDtheta)\/2.0\n        lasttheta = midtheta + (midDtheta + lastDtheta)\/2.0\n\n        self.dtheta = lastDtheta\n        self.theta = lasttheta\n        self.rect = pygame.Rect(PIVOT[0]-\n                                SWINGLENGTH*sin(radians(self.theta)), \n                                PIVOT[1]+\n                                SWINGLENGTH*cos(radians(self.theta)),1,1)\n\n\n    def draw(self):\n        pygame.draw.circle(screen, (0,0,0), PIVOT, 5, 0)\n        pygame.draw.circle(screen, (0,0,0), self.rect.center, BOBSIZE, 0)\n        pygame.draw.aaline(screen, (0,0,0), PIVOT, self.rect.center)\n        pygame.draw.line(screen, (0,0,0), (0, PIVOT[1]), (WINDOWSIZE, PIVOT[1]))\n\n    def update(self):\n        self.recomputeAngle()\n        screen.fill((255,255,255))\n        self.draw()\n\nbob = BobMass()\n\nTICK = USEREVENT + 2\npygame.time.set_timer(TICK, TIMETICK)\n\ndef input(events):\n    for event in events:\n        if event.type == QUIT:\n            sys.exit(0)\n        elif event.type == TICK:\n            bob.update()\n\nwhile True:\n    input(pygame.event.get())\n    pygame.display.flip()<\/lang>\n\n==[[:Category:Racket|Racket]][[Category:Racket]]==\n<lang scheme>#lang racket\n\n(require 2htdp\/image\n         2htdp\/universe)\n\n(define (pendulum)\n  (define (accel \u03b8) (- (sin \u03b8)))\n  (define \u03b8 (\/ pi 2.5))\n  (define \u03b8\u2032 0)\n  (define \u03b8\u2032\u2032 (accel (\/ pi 2.5)))\n  (define (x \u03b8) (+ 200 (* 150 (sin \u03b8))))\n  (define (y \u03b8) (* 150 (cos \u03b8)))\n  (\u03bb (n)\n    (define p-image (underlay\/xy (add-line (empty-scene 400 200) 200 0 (x \u03b8) (y \u03b8) \"black\") \n                                 (- (x \u03b8) 5) (- (y \u03b8) 5) (circle 5 \"solid\" \"blue\")))\n    (set! \u03b8 (+ \u03b8 (* \u03b8\u2032 0.04)))\n    (set! \u03b8\u2032 (+ \u03b8\u2032 (* (accel \u03b8) 0.04)))\n    p-image))\n\n(animate (pendulum))<\/lang>\n\n==[[:Category:RLaB|RLaB]][[Category:RLaB]]==\nThe plane pendulum motion is an interesting and easy problem in which the facilities of RLaB for numerical computation and simulation\nare easily accessible.\nThe parameters of the problem are <math>L<\/math>, the length of the arm, and <math>g<\/math> the magnitude of the gravity.\n\nWe start with the mathematical transliteration of the problem. We solve it in plane (2-D) in terms of <math>\\theta<\/math> describing the angle between the <math>z<\/math>-axis and the arm of the pendulum, where the downwards direction is taken as positive.\nThe Newton equation of motian, which is a second-order non-linear ordinary differential equation (ODE) reads\n:<math>\\ddot\\theta = -\\frac{g}{L} \\sin \\theta<\/math>\nIn our example, we will solve the problem as, so called, initial value problem (IVP). That is, we will specify that at the\ntime ''t=0'' the pendulum was at rest <math>\\dot\\theta(0)=0<\/math>, extended at an angle <math>\\theta(0)=0.523598776<\/math>\nradians (equivalent to 30 degrees).\n\nRLaB has the facilities to solve ODE IVP which are accessible through ''odeiv'' solver. This solver requires that the ODE\nbe written as the first order differential equation,\n:<math>\\dot u = f(u) <\/math>\nHere, we introduced  a vector <math>u = [\\theta, \\dot\\theta] = [u_1, u_2]<\/math>, for which the original ODE reads\n:<math>\\dot\\theta = \\dot u_1 = u_2 = f_1(u)<\/math>\n:<math>\\ddot\\theta = \\dot u_2 = -\\frac{g}{L} \\sin \\theta = -\\frac{g}{L} \\sin u_1 =f_2(u)<\/math>.\nThe RLaB script that solves the problem is\n\n<lang RLaB>\n\/\/\n\/\/ example: solve ODE for pendulum\n\/\/\n\n\/\/ we first define the first derivative function for the solver\ndudt = function(t, u, p)\n{\n  \/\/ t-> time\n  \/\/ u->[theta, dtheta\/dt ]\n  \/\/ p-> g\/L, parameter\n  rval = zeros(2,1);\n  rval[1] =  u[2];\n  rval[2] = -p[1] * sin(u[1]);\n  return rval;\n};\n\n\/\/ now we solve the problem\n\/\/ physical parameters\nL  = 5;  \/\/ (m), the length of the arm of the pendulum\np  = mks.g \/ L;  \/\/ RLaB has a built-in list 'mks' which contains large number of physical constants and conversion factors\nT0 = 2*const.pi*sqrt(L\/mks.g); \/\/ approximate period of the pendulum\n\n\/\/ initial conditions\ntheta0 = 30;  \/\/ degrees, initial angle of deflection of pendulum\nu0 = [theta0*const.pi\/180, 0];  \/\/ RLaB has a built-in list 'const' of mathematical constants.\n\n\/\/ times at which we want solution\nt = [0:4:1\/64] * T0;  \/\/ solve for 4 approximate periods with at time points spaced at T0\/64\n\n\/\/ prepare ODEIV solver\noptsode = <<>>;\noptsode.eabs   = 1e-6;      \/\/ relative error for step size\noptsode.erel   = 1e-6;      \/\/ absolute error for step size\noptsode.delta_t = 1e-6;     \/\/ maximum dt that code is allowed\noptsode.stdout = stderr();  \/\/ open the text console and in it print the results of each step of calculation\noptsode.imethod = 5;        \/\/ use method No. 5 from the odeiv toolkit, Runge-Kutta 8th order Prince-Dormand method\n\/\/optsode.phase_space = 0;    \/\/ the solver returns [t, u1(t), u2(t)] which is default behavior\noptsode.phase_space = 1;    \/\/ the solver returns [t, u1(t), u2(t), d(u1)\/dt(t), d(u2)\/dt]\n\n\/\/ solver do my bidding\ny = odeiv(dudt, p, t, u0, optsode);\n\n\/\/ Make an animation. We choose to use 'pgplot' rather then 'gnuplot' interface because the former is\n\/\/ faster and thus less cache-demanding, while the latter can be very cache-demanding (it may slow your\n\/\/ linux system quite down if one sends lots of plots for gnuplot to plot).\nplwins (1); \/\/ we will use one pgplot-window\n\nplwin(1);  \/\/ plot to pgplot-window No. 1; necessary if using more than one pgplot window\nplimits (-L,L, -1.25*L, 0.25*L);\nxlabel (\"x-coordinate\");\nylabel (\"z-coordinate\");\nplegend (\"Arm\");\nfor (i in 1:y.nr)\n{\n  \/\/ plot a line between the pivot point at (0,0) and the current position of the pendulum\n  arm_line = [0,0; L*sin(y[i;2]), -L*cos(y[i;2])]; \/\/ this is because theta is between the arm and the z-coordinate\n  plot  (arm_line); \n  sleep (0.1); \/\/ sleep 0.1 seconds between plots\n}\n\n<\/lang>\n\n==[[:Category:Ruby|Ruby]][[Category:Ruby]]==\n<div class=\"examplemeta libheader\">'''Library:''' [[SMW::off]][[:Category:Ruby\/Tk|Ruby\/Tk]][[Category:Ruby\/Tk]][[SMW::on]]<\/div>\n\n<div class=\"examplemeta translation\">'''Translation of''': [[Animate a pendulum#Tcl|Tcl]]<\/div>\n\nThis does not have the window resizing handling that Tcl does -- I did not spend enough time in the docs to figure out how to get the new window size out of the configuration event.  Of interest when running this pendulum side-by-side with the Tcl one: the Tcl pendulum swings noticibly faster.\n\n<lang ruby>require 'tk'\n\n$root = TkRoot.new(\"title\" => \"Pendulum Animation\")\n$canvas = TkCanvas.new($root) do\n  width 320\n  height 200\n  create TkcLine, 0,25,320,25,   'tags' => 'plate', 'width' => 2, 'fill' => 'grey50'\n  create TkcOval, 155,20,165,30, 'tags' => 'pivot', 'outline' => \"\", 'fill' => 'grey50'\n  create TkcLine, 1,1,1,1, 'tags' => 'rod', 'width' => 3, 'fill' => 'black'\n  create TkcOval, 1,1,2,2, 'tags' => 'bob', 'outline' => 'black', 'fill' => 'yellow'\nend\n$canvas.raise('pivot')\n$canvas.pack('fill' => 'both', 'expand' => true)\n\n$Theta = 45.0\n$dTheta = 0.0\n$length = 150\n$homeX = 160\n$homeY = 25\n\ndef show_pendulum\n  angle = $Theta * Math::PI \/ 180\n  x = $homeX + $length * Math.sin(angle)\n  y = $homeY + $length * Math.cos(angle)\n  $canvas.coords('rod', $homeX, $homeY, x, y)\n  $canvas.coords('bob', x-15, y-15, x+15, y+15)\nend\n\ndef recompute_angle\n  scaling = 3000.0 \/ ($length ** 2)\n  # first estimate\n  firstDDTheta = -Math.sin($Theta * Math::PI \/ 180) * scaling\n  midDTheta = $dTheta + firstDDTheta\n  midTheta = $Theta + ($dTheta + midDTheta)\/2\n  # second estimate\n  midDDTheta = -Math.sin(midTheta * Math::PI \/ 180) * scaling\n  midDTheta = $dTheta + (firstDDTheta + midDDTheta)\/2\n  midTheta = $Theta + ($dTheta + midDTheta)\/2\n  # again, first\n  midDDTheta = -Math.sin(midTheta * Math::PI \/ 180) * scaling\n  lastDTheta = midDTheta + midDDTheta\n  lastTheta = midTheta + (midDTheta + lastDTheta)\/2\n  # again, second\n  lastDDTheta = -Math.sin(lastTheta * Math::PI\/180) * scaling\n  lastDTheta = midDTheta + (midDDTheta + lastDDTheta)\/2\n  lastTheta = midTheta + (midDTheta + lastDTheta)\/2\n  # Now put the values back in our globals\n  $dTheta  = lastDTheta\n  $Theta = lastTheta\nend\n\ndef animate\n  recompute_angle\n  show_pendulum\n  $after_id = $root.after(15) {animate}\nend\n\nshow_pendulum\n$after_id = $root.after(500) {animate}\n\n$canvas.bind('<Destroy>') {$root.after_cancel($after_id)}\n\nTk.mainloop<\/lang>\n\n<div class=\"examplemeta libheader\">'''Library:''' [[SMW::off]][[:Category:Shoes|Shoes]][[Category:Shoes]][[SMW::on]]<\/div>\n<lang ruby>Shoes.app(:width => 320, :height => 200) do\n  @centerX = 160\n  @centerY = 25\n  @length = 150\n  @diameter = 15\n\n  @Theta = 45.0\n  @dTheta = 0.0\n\n  stroke gray\n  strokewidth 3\n  line 0,25,320,25\n  oval 155,20,10\n\n  stroke black\n  @rod = line(@centerX, @centerY, @centerX, @centerY + @length)\n  @bob = oval(@centerX - @diameter, @centerY + @length - @diameter, 2*@diameter)\n\n  animate(24) do |i|\n    recompute_angle\n    show_pendulum\n  end\n\n  def show_pendulum\n    angle = (90 + @Theta) * Math::PI \/ 180\n    x = @centerX + (Math.cos(angle) * @length).to_i\n    y = @centerY + (Math.sin(angle) * @length).to_i\n\n    @rod.remove\n    strokewidth 3\n    @rod = line(@centerX, @centerY, x, y)\n    @bob.move(x-@diameter, y-@diameter)\n  end\n\n  def recompute_angle\n    scaling = 3000.0 \/ (@length **2)\n    # first estimate\n    firstDDTheta = -Math.sin(@Theta * Math::PI \/ 180) * scaling\n    midDTheta = @dTheta + firstDDTheta\n    midTheta = @Theta + (@dTheta + midDTheta)\/2\n    # second estimate\n    midDDTheta = -Math.sin(midTheta * Math::PI \/ 180) * scaling\n    midDTheta = @dTheta + (firstDDTheta + midDDTheta)\/2\n    midTheta = @Theta + (@dTheta + midDTheta)\/2\n    # again, first\n    midDDTheta = -Math.sin(midTheta * Math::PI \/ 180) * scaling\n    lastDTheta = midDTheta + midDDTheta\n    lastTheta = midTheta + (midDTheta + lastDTheta)\/2\n    # again, second\n    lastDDTheta = -Math.sin(lastTheta * Math::PI\/180) * scaling\n    lastDTheta = midDTheta + (midDDTheta + lastDDTheta)\/2\n    lastTheta = midTheta + (midDTheta + lastDTheta)\/2\n    # Now put the values back in our globals\n    @dTheta  = lastDTheta\n    @Theta = lastTheta\n  end\nend<\/lang>\n\n==[[:Category:Scala|Scala]][[Category:Scala]]==\nInspired by Java\n<lang Scala>import scala.swing._\nimport scala.swing.Swing._\nimport scala.actors._\nimport scala.actors.Actor._\n\nimport java.awt.{Color, Graphics}\n\nobject Pendulum extends SimpleSwingApplication {\n\n  val length    = 100\n  \n  val prefSizeX = 2*length+50\n  val prefSizeY = length\/2*3\n  \n  lazy val ui = new Panel {\n    import math._\n    background = Color.white\n    preferredSize = (prefSizeX, prefSizeY)\n    peer.setDoubleBuffered(true)\n    \n    var angle: Double = Pi\/2;\n  \n    def pendular = new Actor {\n      var angleAccel, angleVelocity = 0.0; \n      var dt = 0.1\n      \n      def act() {\n        while (true) {\n          angleAccel = -9.81 \/ length * sin(angle)\n          angleVelocity += angleAccel * dt\n          angle += angleVelocity * dt\n          repaint()\n          Thread.sleep(15)\n        }\n      }\n    }\n\n    override def paintComponent(g: Graphics2D) = {\n      super.paintComponent(g)\n      \n      g.setColor(Color.white);\n      g.fillRect(0, 0, size.width, size.height);\n      val anchorX = size.width \/ 2\n      val anchorY = size.height \/ 4\n      val ballX = anchorX + (sin(angle) * length).toInt\n      val ballY = anchorY + (cos(angle) * length).toInt\n      g.setColor(Color.lightGray)\n      g.drawLine(anchorX-2*length, anchorY, anchorX+2*length, anchorY)\n      g.setColor(Color.black)\n      g.drawLine(anchorX, anchorY, ballX, ballY)\n      g.fillOval(anchorX - 3, anchorY - 4, 7, 7)\n      g.drawOval(ballX - 7, ballY - 7, 14, 14)\n      g.setColor(Color.yellow)\n      g.fillOval(ballX - 7, ballY - 7, 14, 14)\n    }    \n  }\n\n  def top = new MainFrame {\n    title = \"Rosetta Code >>> Task: Animate a pendulum | Language: Scala\"\n    contents = ui\n    ui.pendular.start\n  }\n\n}<\/lang>\n\n==[[:Category:Scheme|Scheme]][[Category:Scheme]]==\n<div class=\"examplemeta libheader\">'''Library:''' [[SMW::off]][[:Category:Scheme\/PsTk|Scheme\/PsTk]][[Category:Scheme\/PsTk]][[SMW::on]]<\/div>\n\n<div class=\"examplemeta translation\">'''Translation of''': [[Animate a pendulum#Ruby|Ruby]]<\/div>\n\nThis is a direct translation of the Ruby\/Tk example into Scheme + PS\/Tk.\n\n<lang scheme>#!r6rs\n\n;;; R6RS implementation of Pendulum Animation\n\n(import (rnrs)\n        (lib pstk main) ; change this for your pstk installation\n        )\n\n(define PI 3.14159)\n(define *conv-radians* (\/ PI 180))\n(define *theta* 45.0)\n(define *d-theta* 0.0)\n(define *length* 150)\n(define *home-x* 160)\n(define *home-y* 25)\n\n;;; estimates new angle of pendulum\n(define (recompute-angle)\n  (define (avg a b) (\/ (+ a b) 2))\n  (let* ((scaling (\/ 3000.0 (* *length* *length*)))\n         ; first estimate\n         (first-dd-theta (- (* (sin (* *theta* *conv-radians*)) scaling)))\n         (mid-d-theta (+ *d-theta* first-dd-theta))\n         (mid-theta (+ *theta* (avg *d-theta* mid-d-theta)))\n         ; second estimate\n         (mid-dd-theta (- (* (sin (* mid-theta *conv-radians*)) scaling)))\n         (mid-d-theta-2 (+ *d-theta* (avg first-dd-theta mid-dd-theta)))\n         (mid-theta-2 (+ *theta* (avg *d-theta* mid-d-theta-2)))\n         ; again first\n         (mid-dd-theta-2 (- (* (sin (* mid-theta-2 *conv-radians*)) scaling)))\n         (last-d-theta (+ mid-d-theta-2 mid-dd-theta-2))\n         (last-theta (+ mid-theta-2 (avg mid-d-theta-2 last-d-theta)))\n         ; again second\n         (last-dd-theta (- (* (sin (* last-theta *conv-radians*)) scaling)))\n         (last-d-theta-2 (+ mid-d-theta-2 (avg mid-dd-theta-2 last-dd-theta)))\n         (last-theta-2 (+ mid-theta-2 (avg mid-d-theta-2 last-d-theta-2))))\n    ; put values back in globals\n    (set! *d-theta* last-d-theta-2)\n    (set! *theta* last-theta-2)))\n\n;;; The main event loop and graphics context\n(let ((tk (tk-start)))\n  (tk\/wm 'title tk \"Pendulum Animation\")\n  (let ((canvas (tk 'create-widget 'canvas)))\n\n    ;;; redraw the pendulum on canvas\n    ;;; - uses angle and length to compute new (x,y) position of bob\n    (define (show-pendulum canvas)\n      (let* ((pendulum-angle (* *conv-radians* *theta*))\n             (x (+ *home-x* (* *length* (sin pendulum-angle))))\n             (y (+ *home-y* (* *length* (cos pendulum-angle)))))\n        (canvas 'coords 'rod *home-x* *home-y* x y)\n        (canvas 'coords 'bob (- x 15) (- y 15) (+ x 15) (+ y 15))))\n\n    ;;; move the pendulum and repeat after 20ms\n    (define (animate)\n      (recompute-angle)\n      (show-pendulum canvas)\n      (tk\/after 20 animate))\n\n    ;; layout the canvas\n    (tk\/grid canvas 'column: 0 'row: 0)\n    (canvas 'create 'line 0 25 320 25 'tags: 'plate 'width: 2 'fill: 'grey50)\n    (canvas 'create 'oval 155 20 165 30 'tags: 'pivot 'outline: \"\" 'fill: 'grey50)\n    (canvas 'create 'line 1 1 1 1 'tags: 'rod 'width: 3 'fill: 'black)\n    (canvas 'create 'oval 1 1 2 2 'tags: 'bob 'outline: 'black 'fill: 'yellow)\n\n    ;; get everything started\n    (show-pendulum canvas)\n    (tk\/after 500 animate)\n    (tk-event-loop tk)))\n<\/lang>\n\n==[[:Category:Tcl|Tcl]][[Category:Tcl]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Tcl]] version 8.5[[SMW::on]]<\/div><div class=\"examplemeta libheader\">'''Library:''' [[SMW::off]][[:Category:Tk|Tk]][[Category:Tk]][[SMW::on]]<\/div>\n<lang tcl>package require Tcl 8.5\npackage require Tk\n\n# Make the graphical entities\npack [canvas .c -width 320 -height 200] -fill both -expand 1\n.c create line 0 25 320 25 -width 2 -fill grey50 -tags plate\n.c create line 1 1 1 1 -tags rod -width 3 -fill black\n.c create oval 1 1 2 2 -tags bob -fill yellow -outline black\n.c create oval 155 20 165 30 -fill grey50 -outline {} -tags pivot\n\n# Set some vars\nset points {}\nset Theta   45.0\nset dTheta   0.0\nset pi       3.1415926535897933\nset length 150\nset homeX  160\n\n# How to respond to a changing in size of the window\nproc resized {width} {\n    global homeX\n    .c coords plate 0 25 $width 25\n    set homeX [expr {$width \/ 2}]\n    .c coords pivot [expr {$homeX-5}] 20 [expr {$homeX+5}] 30\n    showPendulum\n}\n\n# How to actually arrange the pendulum, mapping the model to the display\nproc showPendulum {} {\n    global Theta dTheta pi length homeX\n    set angle [expr {$Theta * $pi\/180}]\n    set x [expr {$homeX + $length*sin($angle)}]\n    set y [expr {25 + $length*cos($angle)}]\n    .c coords rod $homeX 25 $x $y\n    .c coords bob [expr {$x-15}] [expr {$y-15}] [expr {$x+15}] [expr {$y+15}]\n}\n\n# The dynamic part of the display\nproc recomputeAngle {} {\n    global Theta dTheta pi length\n    set scaling [expr {3000.0\/$length**2}]\n\n    # first estimate\n    set firstDDTheta [expr {-sin($Theta * $pi\/180)*$scaling}]\n    set midDTheta [expr {$dTheta + $firstDDTheta}]\n    set midTheta [expr {$Theta + ($dTheta + $midDTheta)\/2}]\n    # second estimate\n    set midDDTheta [expr {-sin($midTheta * $pi\/180)*$scaling}]\n    set midDTheta [expr {$dTheta + ($firstDDTheta + $midDDTheta)\/2}]\n    set midTheta [expr {$Theta + ($dTheta + $midDTheta)\/2}]\n    # Now we do a double-estimate approach for getting the final value\n    # first estimate\n    set midDDTheta [expr {-sin($midTheta * $pi\/180)*$scaling}]\n    set lastDTheta [expr {$midDTheta + $midDDTheta}]\n    set lastTheta [expr {$midTheta + ($midDTheta + $lastDTheta)\/2}]\n    # second estimate\n    set lastDDTheta [expr {-sin($lastTheta * $pi\/180)*$scaling}]\n    set lastDTheta [expr {$midDTheta + ($midDDTheta + $lastDDTheta)\/2}]\n    set lastTheta [expr {$midTheta + ($midDTheta + $lastDTheta)\/2}]\n    # Now put the values back in our globals\n    set dTheta $lastDTheta\n    set Theta $lastTheta\n}\n\n# Run the animation by updating the physical model then the display\nproc animate {} {\n    global animation\n\n    recomputeAngle\n    showPendulum\n\n    # Reschedule\n    set animation [after 15 animate]\n}\nset animation [after 500 animate]; # Extra initial delay is visually pleasing\n\n# Callback to handle resizing of the canvas\nbind .c <Configure> {resized %w}\n# Callback to stop the animation cleanly when the GUI goes away\nbind .c <Destroy> {after cancel $animation}<\/lang>\n\n==[[:Category:XPL0|XPL0]][[Category:XPL0]]==\n<lang XPL0>include c:\\cxpl\\codes;          \\intrinsic 'code' declarations\n\nproc    Ball(X0, Y0, R, C);     \\Draw a filled circle\nint     X0, Y0, R, C;           \\center coordinates, radius, color\nint     X, Y;\nfor Y:= -R to R do\n    for X:= -R to R do\n        if X*X + Y*Y <= R*R then Point(X+X0, Y+Y0, C);\n\n\ndef     L  = 2.0,               \\pendulum arm length (meters)\n        G  = 9.81,              \\acceleration due to gravity (meters\/second^2)\n        Pi = 3.14,\n        DT = 1.0\/72.0;          \\delta time = screen refresh rate (seconds)\ndef     X0=640\/2, Y0=480\/2;     \\anchor point = center coordinate\nreal    S, V, A, T;             \\arc length, velocity, acceleration, theta angle\nint     X, Y;                   \\ball coordinates\n\n[SetVid($101);                  \\set 640x480x8 graphic display mode\nT:= Pi*0.75;  V:= 0.0;          \\starting angle and velocity\nS:= T*L;\nrepeat  A:= -G*Sin(T);\n        V:= V + A*DT;\n        S:= S + V*DT;\n        T:= S\/L;\n        X:= X0 + fix(L*100.0*Sin(T));   \\100 scales to fit screen\n        Y:= Y0 + fix(L*100.0*Cos(T));\n        Move(X0, Y0); Line(X, Y, 7);    \\draw pendulum\n        Ball(X, Y, 10, $E\\yellow\\);\n        while port($3DA) & $08 do [];   \\wait for vertical retrace to go away\n        repeat until port($3DA) & $08;  \\wait for vertical retrace signal\n        Move(X0, Y0); Line(X, Y, 0);    \\erase pendulum\n        Ball(X, Y, 10, 0\\black\\);\nuntil   KeyHit;                         \\keystroke terminates program\nSetVid(3);                              \\restore normal text screen\n]<\/lang>\n\n[[Category:PARI\/GP\/Omit]]\n[[Category:PHP\/Omit]]\n\n[[Category:Animation]]"}]}}},"query-continue":{"revisions":{"rvstartid":135773}}}