{"query":{"pages":{"2774":{"pageid":2774,"ns":0,"title":"Amb","revisions":[{"*":"<div class=\"infobox\" style=\"width: 2in\">'' '''Amb''' '' is a '''draft''' programming task. It is not yet considered ready to be promoted as a complete task, for reasons that should be found in its [[Talk:Amb|talk page]].[[Category:Draft Programming Tasks]]<\/div>\nDefine and give an example of the Amb operator.\n\nThe Amb operator takes some number of expressions (or values if that's simpler in the language) and nondeterministically yields the one or fails if given no parameter, amb returns the value that doesn't lead to failure.\n\nThe example is using amb to choose four words from the following strings:\n\nset 1: \"the\" \"that\" \"a\"\n\nset 2: \"frog\" \"elephant\" \"thing\"\n\nset 3: \"walked\" \"treaded\" \"grows\"\n\nset 4: \"slowly\" \"quickly\"\n\nIt is a failure if the last character of word 1 is not equal to the first character of word 2, and similarly with word 2 and word 3, as well as word 3 and word 4. (the only successful sentence is \"that thing grows slowly\").\n\n==[[:Category:Ada|Ada]][[Category:Ada]]==\n<lang ada>with Ada.Strings.Unbounded;  use Ada.Strings.Unbounded;\nwith Ada.Text_IO;            use Ada.Text_IO;\n\nprocedure Test_Amb is\n   type Alternatives is array (Positive range <>) of Unbounded_String;\n\n   type Amb (Count : Positive) is record\n      This : Positive := 1;\n      Left : access Amb; \n      List : Alternatives (1..Count);\n   end record;\n   \n   function Image (L : Amb) return String is\n   begin\n      return To_String (L.List (L.This));\n   end Image;\n\n   function \"\/\" (L, R : String) return Amb is\n      Result : Amb (2);\n   begin\n      Append (Result.List (1), L);\n      Append (Result.List (2), R);\n      return Result;\n   end \"\/\";\n   \n   function \"\/\" (L : Amb; R : String) return Amb is\n      Result : Amb (L.Count + 1);\n   begin\n      Result.List (1..L.Count) := L.List ;\n      Append (Result.List (Result.Count), R);\n      return Result;\n   end \"\/\";\n\n   function \"=\" (L, R : Amb) return Boolean is\n      Left : Unbounded_String renames L.List (L.This);\n   begin\n      return Element (Left, Length (Left)) = Element (R.List (R.This), 1);\n   end \"=\";\n   \n   procedure Failure (L : in out Amb) is\n   begin\n      loop\n         if L.This < L.Count then\n            L.This := L.This + 1;\n         else\n            L.This := 1;\n            Failure (L.Left.all);\n         end if;\n         exit when L.Left = null or else L.Left.all = L;\n      end loop;\n   end Failure;\n\n   procedure Join (L : access Amb; R : in out Amb) is\n   begin\n      R.Left := L;\n      while L.all \/= R loop\n         Failure (R);\n      end loop;\n   end Join;\n\n   W_1 : aliased Amb := \"the\" \/ \"that\" \/ \"a\";\n   W_2 : aliased Amb := \"frog\" \/ \"elephant\" \/ \"thing\";\n   W_3 : aliased Amb := \"walked\" \/ \"treaded\" \/ \"grows\";\n   W_4 : aliased Amb := \"slowly\" \/ \"quickly\";\nbegin\n   Join (W_1'Access, W_2);\n   Join (W_2'Access, W_3);\n   Join (W_3'Access, W_4);\n   Put_Line (Image (W_1) & ' ' & Image (W_2) & ' ' & Image (W_3) & ' ' & Image (W_4));\nend Test_Amb;<\/lang>\nThe type Amb is implemented with the operations \"\/\" to construct it from strings. Each instance keeps its state. The operation Failure performs back tracing. Join connects two elements into a chain. The implementation propagates Constraint_Error when matching fails. Sample output:\n<pre>\nthat thing grows slowly\n<\/pre>\n\n==[[:Category:ALGOL 68|ALGOL 68]][[Category:ALGOL 68]]==\n\n\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[ELLA ALGOL 68]] version Any (with appropriate job cards) - tested with release [http:\/\/sourceforge.net\/projects\/algol68\/files\/algol68toc\/algol68toc-1.8.8d\/algol68toc-1.8-8d.fc9.i386.rpm\/download 1.8-8d][[SMW::on]]<\/div>\nNote: This program violates ALGOL 68's scoping rules when a locally scoped procedure is returned to a more global scope.  [[ELLA ALGOL 68RS]] misses this violation, but [[ALGOL 68 Genie]] spots it at run time and then produces an assert.  However [[ELLA ALGOL 68RS]] does produce the desired result, but may potentially suffer from \"mysterious\" stack problems.\n<lang algol68>MODE PAGE = FLEX[0]STRING;\nMODE YIELDPAGE = PROC(PAGE)VOID;\nMODE ITERPAGE = PROC(YIELDPAGE)VOID;\n\nOP INITITERPAGE = (PAGE self)ITERPAGE: \n  (YIELDPAGE yield)VOID: # scope violation #\n    FOR i TO UPB self DO\n      yield(self[i])\n    OD;\n      \nOP + = (ITERPAGE for strings, PAGE b)ITERPAGE:\n  (YIELDPAGE yield)VOID: # scope violation #\n    for strings((PAGE amb)VOID:(\n      [UPB amb + 1]STRING joined; \n      joined[:UPB amb] := amb;\n      STRING last string := amb[UPB amb];\n      CHAR last char := last string[UPB last string];\n      FOR i TO UPB b DO\n        IF last char = b[i][1] THEN\n          joined[UPB joined] := b[i];\n          yield(joined)\n        FI\n      OD\n    ));\n\nOP + = (PAGE a, PAGE b)ITERPAGE: INITITERPAGE a + b;\n\nITERPAGE gen amb := \n   PAGE(\"the\", \"that\", \"a\") +\n   PAGE(\"frog\", \"elephant\", \"thing\") +\n   PAGE(\"walked\", \"treaded\", \"grows\") +\n   PAGE(\"slowly\", \"quickly\");\n\nPAGE sep;\n#FOR PAGE amb IN # gen amb( # ) DO #\n##  (PAGE amb)VOID:\n    print((amb[1]+\" \"+amb[2]+\" \"+amb[3]+\" \"+amb[4], new line))\n#OD# )<\/lang>\nOutput:\n<pre>\nthat thing grows slowly\n<\/pre>\n\n==[[:Category:AutoHotkey|AutoHotkey]][[Category:AutoHotkey]]==\n''Search autohotkey.com'': [http:\/\/www.google.com\/search?q=site:www.autohotkey.com+Amb]<br>\n<br>\nSource: [http:\/\/www.autohotkey.com\/forum\/topic45454.html AMB - Ambiguous selector] by infogulch\n<lang autohotkey>set1 := \"the that a\" \nset2 := \"frog elephant thing\" \nset3 := \"walked treaded grows\" \nset4 := \"slowly quickly\" \n\nMsgBox % amb( \"\", set1, set2, set3, set4 ) \n; this takes a total of 17 iterations to complete \n\namb( char = \"\", set1 = \"\", set2 = \"\", set3 = \"\", set4 = \"\" ) \n{ ; original call to amb must leave char param blank \n  Loop, Parse, set1, %A_Space% \n    If (char = (idxchar := SubStr(A_LoopField, 1, 1)) && set2 = \"\" \n    || (char = idxchar || char = \"\") && ((retval:= amb(SubStr(A_LoopField, 0, 1), set2, set3, set4)) != \"\")) \n      Return A_LoopField \" \" retval \n  Return \"\" \n}<\/lang>\n\n==[[:Category:Bracmat|Bracmat]][[Category:Bracmat]]==\n<lang bracmat>( ( Amb\n  =   first last list words word solution\n    .   !arg:(?first.?list)\n      & ( !list:\n        |   !list:(.?words) ?list\n          &   !words\n            :   ?\n                %( @(?word:!first ? @?last)\n                 & Amb$(!last.!list):?solution\n                 & !word !solution:?solution\n                 )\n                ?\n          & !solution\n        )\n  )\n&   Amb\n  $ (\n    .   (.the that a)\n        (.frog elephant thing)\n        (.walked treaded grows)\n        (.slowly quickly)\n    )\n)<\/lang>\n\n<pre>that thing grows slowly<\/pre>\n\n==[[:Category:C|C]][[Category:C]]==\nNote: This uses the continuations code from http:\/\/homepage.mac.com\/sigfpe\/Computing\/continuations.html\n<lang c>typedef const char * amb_t;\n\namb_t amb(size_t argc, ...)\n{\n  amb_t *choices;\n  va_list ap;\n  int i;\n  \n  if(argc) {\n    choices = malloc(argc*sizeof(amb_t));\n    va_start(ap, argc);\n    i = 0;\n    do { choices[i] = va_arg(ap, amb_t); } while(++i < argc);\n    va_end(ap);\n    \n    i = 0;\n    do { TRY(choices[i]); } while(++i < argc);\n    free(choices);\n  }\n  \n  FAIL;\n}\n\nint joins(const char *left, const char *right) { return left[strlen(left)-1] == right[0]; }\n\nint _main() {\n  const char *w1,*w2,*w3,*w4;\n  \n  w1 = amb(3, \"the\", \"that\", \"a\");\n  w2 = amb(3, \"frog\", \"elephant\", \"thing\");\n  w3 = amb(3, \"walked\", \"treaded\", \"grows\");\n  w4 = amb(2, \"slowly\", \"quickly\");\n  \n  if(!joins(w1, w2)) amb(0);\n  if(!joins(w2, w3)) amb(0);\n  if(!joins(w3, w4)) amb(0);\n  \n  printf(\"%s %s %s %s\\n\", w1, w2, w3, w4);\n  \n  return EXIT_SUCCESS;\n}<\/lang>\n\n==<span id=\"C sharp\">[[:Category:C sharp|C#]]<\/span>[[Category:C sharp]]==\nThe implementation of the Amb class\n<lang csharp>using System;\nusing System.Collections.Generic;\n\npublic class Amb : IDisposable\n{\n    List<IValueSet> streams = new List<IValueSet>();\n    List<IAssertOrAction> assertsOrActions = new List<IAssertOrAction>();\n    volatile bool stopped = false;\n\n    public IAmbValue<T> DefineValues<T>(params T[] values)\n    {\n        return DefineValueSet(values);\n    }\n\n    public IAmbValue<T> DefineValueSet<T>(IEnumerable<T> values)\n    {\n        ValueSet<T> stream = new ValueSet<T>();\n        stream.Enumerable = values;\n        streams.Add(stream);\n        return stream;\n    }\n\n    public Amb Assert(Func<bool> function)\n    {\n        assertsOrActions.Add(new AmbAssert()\n        {\n            Level = streams.Count,\n            IsValidFunction = function\n        });\n        return this;\n    }\n\n    public Amb Perform(Action action)\n    {\n        assertsOrActions.Add(new AmbAction()\n        {\n            Level = streams.Count,\n            Action = action\n        });\n        return this;\n    }\n\n    public void Stop()\n    {\n        stopped = true;\n    }\n\n    public void Dispose()\n    {\n        RunLevel(0, 0);\n        if (!stopped)\n        {\n            throw new AmbException();\n        }\n    }\n\n    void RunLevel(int level, int actionIndex)\n    {\n        while (actionIndex < assertsOrActions.Count && assertsOrActions[actionIndex].Level <= level)\n        {\n            if (!assertsOrActions[actionIndex].Invoke() || stopped)\n                return;\n            actionIndex++;\n        }\n        if (level < streams.Count)\n        {\n            using (IValueSetIterator iterator = streams[level].CreateIterator())\n            {\n                while (iterator.MoveNext())\n                {\n                    RunLevel(level + 1, actionIndex);\n                }\n            }\n        }\n    }\n\n    interface IValueSet\n    {\n        IValueSetIterator CreateIterator();\n    }\n\n    interface IValueSetIterator : IDisposable\n    {\n        bool MoveNext();\n    }\n\n    interface IAssertOrAction\n    {\n        int Level { get; }\n        bool Invoke();\n    }\n\n    class AmbAssert : IAssertOrAction\n    {\n        internal int Level;\n        internal Func<bool> IsValidFunction;\n\n        int IAssertOrAction.Level { get { return Level; } }\n\n        bool IAssertOrAction.Invoke()\n        {\n            return IsValidFunction();\n        }\n    }\n\n    class AmbAction : IAssertOrAction\n    {\n        internal int Level;\n        internal Action Action;\n\n        int IAssertOrAction.Level { get { return Level; } }\n\n        bool IAssertOrAction.Invoke()\n        {\n            Action(); return true;\n        }\n    }\n\n    class ValueSet<T> : IValueSet, IAmbValue<T>, IValueSetIterator\n    {\n        internal IEnumerable<T> Enumerable;\n        private IEnumerator<T> enumerator;\n\n        public T Value { get { return enumerator.Current; } }\n\n        public IValueSetIterator CreateIterator()\n        {\n            enumerator = Enumerable.GetEnumerator();\n            return this;\n        }\n\n        public bool MoveNext()\n        {\n            return enumerator.MoveNext();\n        }\n\n        public void Dispose()\n        {\n            enumerator.Dispose();\n        }\n    }\n}\n\npublic interface IAmbValue<T>\n{\n    T Value { get; }\n}\n\npublic class AmbException : Exception\n{\n    public AmbException() : base(\"AMB is angry\") { }\n}<\/lang>\n\nUsage:\n<lang csharp>    \/\/ original problem\n    using (Amb amb = new Amb())\n    {\n        var set1 = amb.DefineValues(\"the\", \"that\", \"a\");\n        var set2 = amb.DefineValues(\"frog\", \"elephant\", \"thing\");\n        var set3 = amb.DefineValues(\"walked\", \"treaded\", \"grows\");\n        var set4 = amb.DefineValues(\"slowly\", \"quickly\");\n\n        amb.Assert(() => IsJoinable(set1.Value, set2.Value));\n        amb.Assert(() => IsJoinable(set2.Value, set3.Value));\n        amb.Assert(() => IsJoinable(set3.Value, set4.Value));\n\n        amb.Perform(() =>\n            {\n                System.Console.WriteLine(\"{0} {1} {2} {3}\", set1.Value, set2.Value, set3.Value, set4.Value);\n                amb.Stop();\n            });\n    }\n    \/\/ problem from http:\/\/www.randomhacks.net\/articles\/2005\/10\/11\/amb-operator\n    using (Amb amb = new Amb())\n    {\n        IAmbValue<int> x = amb.DefineValues(1, 2, 3);\n        IAmbValue<int> y = amb.DefineValues(4, 5, 6);\n        amb.Assert(() => x.Value * y.Value == 8);\n        amb.Perform(() =>\n            {\n                System.Console.WriteLine(\"{0} {1}\", x.Value, y.Value);\n                amb.Stop();\n            });\n    }<\/lang>\n\n==[[:Category:Clojure|Clojure]][[Category:Clojure]]==\n<lang clojure>(ns amb\n  (:use clojure.contrib.monads))\n\n(defn amb [wss]\n  (let [valid-word (fn [w1 w2]\n                     (if (and w1 (= (last w1) (first w2)))\n                       (str w1 \" \" w2)))]\n    (filter #(reduce valid-word %)\n            (with-monad sequence-m (m-seq wss)))))\n\namb> (amb '((\"the\" \"that\" \"a\") (\"frog\" \"elephant\" \"thing\") (\"walked\" \"treaded\" \"grows\") (\"slowly\" \"quickly\")))\n((\"that\" \"thing\" \"grows\" \"slowly\"))\n<\/lang>\n\n==[[:Category:Common Lisp|Common Lisp]][[Category:Common Lisp]]==\nCommon Lisp lacks the <code>call\/cc<\/code> present in Scheme, and so the straightforward implementation using continuations would require a full-blown code walker (and could still have some issues with dynamically bound variables).  A workable compromise uses the condition system and some convenience macros to define <code>amblet<\/code> a binding construct like <code>let<\/code> except that if a variable's init-form is of the form <code>(amb {form}*)<\/code> the <code>amblet<\/code>'s body will be evaluated with the variable bound to successive values produced by each <code>form<\/code> until some evaluation does not signal an <code>amb-error<\/code>.\n\n<lang lisp>(define-condition amb-failure () ()\n  (:report \"No amb alternative succeeded.\"))\n\n(defun invoke-ambiguously (function thunks)\n  \"Call function with successive values produced by successive\nfunctions in thunks until some invocation of function does not signal\nan amb-failure.\"\n  (do ((thunks thunks (rest thunks)))\n      ((endp thunks) (error 'amb-failure))\n    (let ((argument (funcall (first thunks))))\n      (handler-case (return (funcall function argument))\n        (amb-failure ())))))\n\n(defmacro amblet1 ((var form) &body body)\n  \"If form is of the form (amb {form}*) then amblet1 is a convenient\nsyntax for invoke-ambiguously, by which body is evaluated with var\nbound the results of each form until some evaluation of body does not\nsignal an amb-failure. For any other form, amblet binds var the result\nof form, and evaluates body.\"\n  (if (and (listp form) (eq (first form) 'amb))\n    `(invoke-ambiguously\n      #'(lambda (,var) ,@body)\n      (list ,@(loop for amb-form in (rest form)\n                    collecting `#'(lambda () ,amb-form))))\n    `(let ((,var ,form))\n       ,@body)))\n\n(defmacro amblet (bindings &body body)\n  \"Like let, except that if an init-form is of the form (amb {form}*),\nthen the corresponding var is bound with amblet1.\"\n  (if (endp bindings)\n    `(progn ,@body)\n    `(amblet1 ,(first bindings)\n       (amblet ,(rest bindings)\n         ,@body))))<\/lang>\n\nExample:\n\n<pre>> (flet ((string-adjacent (s1 s2)\n           (char= (char s1 (1- (length s1)))\n                  (char s2 0))))\n    (amblet ((w1 (amb \"the\" \"that\" \"a\"))\n             (w2 (amb \"frog\" \"elephant\" \"thing\"))\n             (w3 (amb \"walked\" \"treaded\" \"grows\"))\n             (w4 (amb \"slowly\" \"quickly\")))\n      (if (and (string-adjacent w1 w2)\n               (string-adjacent w2 w3)\n               (string-adjacent w3 w4))\n        (list w1 w2 w3 w4)\n        (signal 'amb-failure))))\n(\"that\" \"thing\" \"grows\" \"slowly\")<\/pre>\n===Macro with dynamic variables===\n<lang lisp>(defparameter *amb-ops* nil)\n(defparameter *amb-hist* nil)\n\n(setf *random-state* (make-random-state t))\n(defun shuffle (items)\n  (loop for i from 0 with r = items with l = (length r) while (< i l) do\n\t(rotatef (elt r i) (elt r (+ i (random (- l i)))))\n\tfinally (return r)))\n\n;;; (assert '(mess in, mess out))\n(defmacro amb (a &rest rest)\n  (let ((f (first rest))\n\t(rest (rest rest)))\n    (if (not f)\n      `(let ((items (shuffle ,a)))\n\t   (let ((y (car (last *amb-hist*)))\n\t\t (o (car (last *amb-ops*))))\n\t     (loop for x in items do\n\t\t   (if (or (not *amb-ops*)\n\t\t\t   (funcall o y x))\n\t\t\t   (return (append *amb-hist* (list x))))\n\t   (elt items (random (length items))))))\n\n      `(let ((items (shuffle ,a)))\n\t   (let ((y (car (last *amb-hist*)))\n\t\t (o (car (last *amb-ops*))))\n\t     (loop for x in items do\n\t\t   (if (or (not *amb-ops*)\n\t\t\t   (funcall o y x))\n\t\t     (let ((*amb-hist* (append *amb-hist* (list x)))\n\t\t\t   (*amb-ops*  (append *amb-ops* (list ,f))))\n\t\t       (let ((r ,@rest))\n\t\t\t (if r (return r)))))))))))\n\n;; test cases\n(defun joins (a b)\n  (char= (char a (1- (length a))) (char b 0)))\n\n(defun w34()\n  (amb '(\"walked\" \"treaded\" \"grows\") #'joins\n       (amb '(\"slowly\" \"quickly\"))))\n\n(print\n  (amb '(\"the\" \"that\" \"a\") #'joins\n       (amb '(\"frog\" \"elephant\" \"thing\") #'joins\n\t    (w34))))\n\n(print (amb '(1 2 5) #'<\n\t    (amb '(2 3 4) #'=\n\t\t (amb '(3 4 5))))) ; 1 4 4, 2 3 3, etc<\/lang>\n\n==[[:Category:D|D]][[Category:D]]==\nThis example may not display the original intent of this exercise, since the implementer was not fully aware of what the amb operator is used for.\n<lang d>import std.stdio;\nimport std.string;\nchar[][]set1 = [\"the\",\"that\",\"a\"];\nchar[][]set2 = [\"frog\",\"elephant\",\"thing\"];\nchar[][]set3 = [\"walked\",\"treaded\",\"grows\"];\nchar[][]set4 = [\"slowly\",\"quickly\"];\n\n\/\/ this amb function takes a function pointer to a comparison function and the possibilities that need to be checked\nchar[][]amb(bool function(char[],char[])comp,char[][][]options,char[]prev = \"\") {\n        char[][]res;\n        char[][]set = options[0];\n        options = options[1..$];\n        foreach(opt;set) {\n                \/\/ if this is the base call, prev is \"\" and we need to continue (unfortunately, this is array specific,\n                \/\/ but could be reworked with pointers)\n                if (!prev.length || comp(prev,opt)) {\n                        \/\/ take care of the case where we have no options left\n                        if (!options.length) return [opt];\n                        \/\/ traverse into the tree\n                        res = amb(comp,options,opt);\n                        \/\/ if it was a failure, try the next one\n                        if (res is null) continue;\n                        \/\/ we have a match!\n                        else return opt~res;\n                }\n        }\n        \/\/ no matches\n        return null;\n}\n\nbool comparator(char[]left,char[]right) {\n        return left[$-1] == right[0];\n}\n\nint main() {\n        \/\/ pass in the comparator and the available sets\n        char[][]ret = amb(&comparator,[set1,set2,set3,set4]);\n        if (ret is null) writefln(\"No matches found!\");\n        else writefln(\"%s\",ret.join(\" \"));\n        return 0;\n}<\/lang>\n\n==[[:Category:E|E]][[Category:E]]==\n{| class=\"messagebox\" style=\"text-align: center; background-color: #ffc8c8; clear: both;\"\n| Some lines in this example are '''too long''' (more than 80 characters).  Please fix the code if it's possible and remove this message.\n|}[[Category:E examples needing attention]][[Category:Examples needing attention]]\nE does not currently have any kind of backtracking control flow (though there is a proposal in the works to backtrack upon exceptions, for the sake of consistency). However, since (Almost) Everything Is Message Passing, we can create an object which represents a set of possible values.\n\nThis is complicated, however, by the fact that any given amb must appear to produce only one result; that is, <code>def x := amb([\"a\", \"b\"]); x + x<\/code> produces aa or bb, not aa,bb,ab,ba as <code>amb([\"a\", \"b\"]) + amb([\"a\", \"b\"])<\/code> would. Therefore, each choice is associated with the ''decisions'' which produced it: a map from ''amb'' objects to which member of them was chosen; any combination of two ambs discards any combination of choices which have inconsistent decisions.\n\nNote that the choices are not evaluated lazily; this is a breadth-first rather than depth-first search through possibilities. Also, every amb remembers all of the ambs which produced it. As such, this is probably not a practical system for large problems.\n\n<lang e>pragma.enable(\"accumulator\")\n\ndef [amb, unamb] := { # block hides internals\n\n  def Choice := Tuple[any, Map]\n\n  def [ambS, ambU] := <elib:sealing.makeBrand>(\"amb\")\n  var counter := 0 # Used just for printing ambs\n\n  \/** Check whether two sets of decisions are consistent *\/\n  def consistent(decA, decB) {\n    def overlap := decA.domain() & decB.domain()\n    for ambObj in overlap {\n      if (decA[ambObj] != decB[ambObj]) { return false }\n    }\n    return true\n  }\n\n  \/** From an amb object, extract the possible choices *\/\n  def getChoices(obj, decisions) :List[Choice] {\n    if (decisions.maps(obj)) {\n      return [[decisions[obj], decisions]]\n    } else if (ambU.amplify(obj) =~ [[choices, _]]) {\n      return accum [] for [chosen, dec] ? (consistent(decisions, dec)) in choices { _ + getChoices(chosen, (decisions | dec).with(obj, chosen)) }\n    } else {\n      return [[obj, decisions]]\n    }\n  }\n  \n  \/** Construct an amb object with remembered decisions *\/\n  def ambDec(choices :List[Choice]) {\n    def serial := (counter += 1)\n    def ambObj {\n      to __printOn(out) {\n        out.print(\"<amb(\", serial, \")\")\n        for [chosen, decisions] in choices {\n          out.print(\" \", chosen)\n          for k => v in decisions {\n            out.print(\";\", ambU.amplify(k)[0][1], \"=\", v)\n          }\n        }\n        out.print(\">\")\n      }\n      to __optSealedDispatch(brand) {\n        if (brand == ambS.getBrand()) {\n          return ambS.seal([choices, serial])\n        }\n      }\n      match [verb, args] {\n        var results := []\n        for [rec, rdec] in getChoices(ambObj, [].asMap()) {\n          def expandArgs(dec, prefix, choosing) {\n            switch (choosing) {\n               match [] { results with= [E.call(rec, verb, prefix), dec] }\n               match [argAmb] + moreArgs {\n                 for [arg, adec] in getChoices(argAmb, dec) {\n                   expandArgs(adec, prefix.with(arg), moreArgs)\n                 }\n               }\n            }\n          }\n          expandArgs(rdec, [], args)\n        }\n        ambDec(results)\n      }\n    }\n    return ambObj\n  }\n  \n  \/** Construct an amb object with no remembered decisions. (public interface) *\/\n  def amb(choices) {\n    return ambDec(accum [] for c in choices { _.with([c, [].asMap()]) })\n  }\n\n  \/** Get the possible results from an amb object, discarding decision info. (public interface) *\/\n  def unamb(ambObj) {\n    return accum [] for [c,_] in getChoices(ambObj, [].asMap()) { _.with(c) }\n  }\n  \n  [amb, unamb]\n}<\/lang>\n\n<lang e>def join(a, b) {\n  # This must not use the builtin if, since it coerces to boolean rather than passing messages.\n  # false.pick(x, y) returns y and true.pick(x, y) returns x; we protect the amb([]) from causing\n  # unconditional failure by putting both options in functions.\n  # <=> is the comparison operator that happens to be message-based.\n  return (a.last() <=> b[0]).pick(fn { \n    a + \" \" + b\n  }, fn {\n    amb([])\n  })()\n}\n\ndef w1 := amb([\"the\", \"that\", \"a\"           ])\ndef w2 := amb([\"frog\", \"elephant\", \"thing\"  ])\ndef w3 := amb([\"walked\", \"treaded\", \"grows\" ])\ndef w4 := amb([\"slowly\", \"quickly\"          ])\n\nunamb(join(join(join(w1, w2), w3), w4))<\/lang>\n\n===Comparison with Haskell===\nThis can be compared with the Haskell use of lists as a monad to represent choice.\n* Haskell uses lazy evaluation; E does not. This implementation does not simulate lazy evaluation with thunks; it is eager (computes every intermediate choice before continuing) and therefore inefficient if you only need one successful result.\n* Haskell does not need to track decisions. This is because when using a monad in Haskell, the points of choice are explicitly written, either by monadic operators or combinators. The analogues to the two \"ab\" operations given above are: <code>do x <- [\"a\",\"b\"]; return (x ++ x)<\/code> and <code>do x <- [\"a\",\"b\"]; y <- [\"a\",\"b\"]; return (x ++ y)<\/code> \u2014 the relevant difference being the number of <code>&lt;-<\/code> operators. In this implementation, we instead absorb the choice into normal method calls; the Haskell analogue would be something like <code>instance Monoid a => Monoid (Amb a) where Amb ... `mconcat` Amb ... = ...<\/code>, which would have a similar need to track decisions.\n\n==[[:Category:Ela|Ela]][[Category:Ela]]==\n<lang ela>open Core\n\nlet amb [] _ _ = None\n    amb (x::xs) next w | eq' w x, next x is Some x' = Some (x ++ \" \" ++ x')\n                       | else = amb xs next w\n                       where eq' w x | w == \"\" = true\n                                     | else = last w == head x<\/lang>\n\nUsage:\n\n<lang ela>let (Some x) = f \"\"\n    where f = \n        amb [\"the\",\"that\",\"a\"] \n        <| amb [\"frog\",\"elephant\",\"thing\"] \n        <| amb [\"walked\",\"treaded\",\"grows\"]\n        <| amb [\"slowly\",\"quickly\"] (\\_ -> Some \"\")\n    in x<\/lang>\n\n==[[:Category:Elena|Elena]][[Category:Elena]]==\nThe implementation\n<lang elena>#define std'dictionary'*.\n#define std'basic'*.\n#define std'patterns'*.\n#define ext'routines'*.\n\n#subject joinable, with.\n\n#class(sign:(joinable, with)) JoinArg\n{\n    #field(arg:joinable) theFirst.\n    #field(arg:with)     theSecond.\n    \n    #method is\n    [\n        Control if:(theFirst@(theFirst length - 1) == theSecond@0).\n    ]\n}\n\n#class AmbEnumerator\n{\n    #field theValues.\n    \n    #role BOF\n    {\n        #method proceed\n        [\n            theValues $reset.\n            \n            #shift.\n            \n            ^ true.\n        ]\n    }\n    \n    #method new : Values\n    [\n        theValues := Values.\n        \n        #shift BOF.\n    ]\n     \n    #method proceed\n    [\n        ^ theValues $next.\n    ]\n    \n    #method clear\n    [\n        #shift BOF.\n    ]\n    \n    #method get = theValues.\n}\n\n#class AmbValue\n{\n    #field theValues.\n    #field theCurrent.\n    \n    #method enumerator = AmbEnumerator::$self.\n\n    #method $reset\n    [\n        theCurrent := theValues@0.\n    ]\n    \n    #method $next\n    [\n        theCurrent append &index:1.\n                \n        ^ theCurrent eof'isnot back:true | back:false.\n    ]\n    \n    #method new : Values\n    [\n        theValues := Values.\n        theCurrent := nil.\n    ]\n    \n    #outer theCurrent content.\n}\n\n#role AmbOperator\n{\n    #method seek : anExpression\n    [\n        (MultiEnumerator::self)~foreach seek: anExpression.\n    ]\n}\n\n#symbol Program =>\n[\n    #var A := AmbValue::(\"the\",\"that\",\"a\").\n    #var B := AmbValue::(\"frog\", \"elephant\", \"thing\").\n    #var C := AmbValue::(\"walked\", \"treaded\", \"grows\").\n    #var D := AmbValue::(\"slowly\", \"quickly\").\n    \n    (A, B, C, D)~AmbOperator seek:\n        => (Boolean::{ &joinable:A &with:B } and &joinable:B &with:C and &joinable:C &with:D).\n    \n    'program'Output << A << \" \" << B << \" \" << C << \" \" << D.\n].\n<\/lang>\n\n==[[:Category:Factor|Factor]][[Category:Factor]]==\n<lang factor>USING: backtrack continuations kernel prettyprint sequences ;\nIN: amb\n\nCONSTANT: words {\n    { \"the\" \"that\" \"a\" }\n    { \"frog\" \"elephant\" \"thing\" }\n    { \"walked\" \"treaded\" \"grows\" }\n    { \"slowly\" \"quickly\"  }\n}\n\n: letters-match? ( str1 str2 -- ? ) [ last ] [ first ] bi* = ;\n\n: sentence-match? ( seq -- ? ) dup rest [ letters-match? ] 2all? ;\n\n: select ( seq -- seq' ) [ amb-lazy ] map ;\n\n: search ( -- )\n    words select dup sentence-match? [ \" \" join ] [ fail ] if . ;\n\nMAIN: search<\/lang>\n\nRunning it from the listener :\n\n ( scratchpad ) \"amb\" run\n \"that thing grows slowly\"\n\n==<span id=\"F_Sharp\">[[:Category:F_Sharp|F#]]<\/span>[[Category:F_Sharp]]==\n<div class=\"examplemeta translation\">'''Translation of''': [[Amb#Haskell|Haskell]]<\/div>\nImportant differences to the Haskell solution:\n* The list monad is not predefined in F#. (But it is easy to define it.)\n* F# is not lazy, so this will check all combinations even if we just want one solution.\nBoth problems could be addressed by using sequence expressions instead.\n\n<lang fsharp>\/\/ define the List \"workflow\" (monad)\ntype ListBuilder() =\n   member o.Bind( lst, f ) = List.concat( List.map (fun x -> f x) lst )\n   member o.Return( x ) = [x]\n   member o.Zero() = []\n\nlet list = ListBuilder()\n\nlet amb = id\n\n\/\/ last element of a sequence\nlet last s = Seq.nth ((Seq.length s) - 1) s\n\n\/\/ is the last element of left the same as the first element of right?\nlet joins left right = last left = Seq.head right\n\nlet example = list { let! w1 = amb [\"the\"; \"that\"; \"a\"]\n                     let! w2 = amb [\"frog\"; \"elephant\"; \"thing\"]\n                     let! w3 = amb [\"walked\"; \"treaded\"; \"grows\"]\n                     let! w4 = amb [\"slowly\"; \"quickly\"]\n                     if joins w1 w2 &&\n                        joins w2 w3 &&\n                        joins w3 w4\n                     then\n                        return String.concat \" \" [w1; w2; w3; w4]\n                   }\n\nprintfn \"%s\" (List.head example)<\/lang>\n\n==[[:Category:Go|Go]][[Category:Go]]==\nSolution with goroutines. See description on talk page.\n<lang go>package main\n\nimport (\n    \"fmt\"\n    \"sync\"\n)\n\nfunc ambStrings(ss []string) chan []string {\n    c := make(chan []string)\n    go func() {\n        for _, s := range ss {\n            c <- []string{s}\n        }\n        close(c)\n    }()\n    return c\n}\n\nfunc ambChain(ss []string, cIn chan []string) chan []string {\n    cOut := make(chan []string)\n    go func() {\n        var w sync.WaitGroup\n        for chain := range cIn {\n            w.Add(1)\n            go func(chain []string) {\n                for s1 := range ambStrings(ss) {\n                    if s1[0][len(s1[0])-1] == chain[0][0] {\n                        cOut <- append(s1, chain...)\n                    }\n                }\n                w.Done()\n            }(chain)\n        }\n        w.Wait()\n        close(cOut)\n    }()\n    return cOut\n}\n\nfunc main() {\n    s1 := []string{\"the\", \"that\", \"a\"}\n    s2 := []string{\"frog\", \"elephant\", \"thing\"}\n    s3 := []string{\"walked\", \"treaded\", \"grows\"}\n    s4 := []string{\"slowly\", \"quickly\"}\n    c := ambChain(s1, ambChain(s2, ambChain(s3, ambStrings(s4)))) {\n    for s := range c {\n        fmt.Println(s)\n    }\n}<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>\n[that thing grows slowly]\n<\/pre>\nAlternative solution:\n<lang go>package main\nimport \"fmt\"\n\nfunc amb(wordsets [][]string, res []string) bool {\n\tif len(wordsets) == 0 {\n\t\treturn true\n\t}\n\n\tvar s string\n\n\tl := len(res)\n\tif l > 0 { s = res[l - 1] }\n\n\tres = res[0:len(res) + 1]\n\n\tfor _, res[l] = range(wordsets[0]) {\n\t\tif l > 0 && s[len(s) - 1] != res[l][0] { continue }\n\n\t\tif amb(wordsets[1:len(wordsets)], res) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\nfunc main() {\n\twordset := [][]string { { \"the\", \"that\", \"a\" },\n\t\t\t\t{ \"frog\", \"elephant\", \"thing\" },\n\t\t\t\t{ \"walked\", \"treaded\", \"grows\" },\n\t\t\t\t{ \"slowly\", \"quickly\" } }\n\tres := make([]string, len(wordset))\n\n\tif amb(wordset, res[0:0]) {\n\t\tfmt.Println(res)\n\t} else {\n\t\tfmt.Println(\"No amb found\")\n\t}\n}<\/lang>\n\n==[[:Category:Haskell|Haskell]][[Category:Haskell]]==\nHaskell's List monad returns all the possible choices. Use the \"head\" function on the result if you just want one.\n<lang haskell>import Control.Monad\n\namb = id\n\njoins left right = last left == head right\n\nexample = do\n  w1 <- amb [\"the\", \"that\", \"a\"]\n  w2 <- amb [\"frog\", \"elephant\", \"thing\"]\n  w3 <- amb [\"walked\", \"treaded\", \"grows\"]\n  w4 <- amb [\"slowly\", \"quickly\"]\n  unless (joins w1 w2) (amb [])\n  unless (joins w2 w3) (amb [])\n  unless (joins w3 w4) (amb [])\n  return (unwords [w1, w2, w3, w4])<\/lang>\n\nNote that \"amb\" is defined as a no-op and is written only to help show the analogy with other implementations; ordinary style is to write e.g. <code>w1 <- [\"the\", \"that\", \"a\"]<\/code>.\n\n==[[:Category:haXe|haXe]][[Category:haXe]]==\n{| class=\"messagebox\" style=\"text-align: center; background-color: #ffc8c8; clear: both;\"\n| Some lines in this example are '''too long''' (more than 80 characters).  Please fix the code if it's possible and remove this message.\n|}[[Category:haXe examples needing attention]][[Category:Examples needing attention]]\n<lang haXe>class RosettaDemo\n{\n    static var SetA : Array<String> = ['the', 'that', 'a'];\n    static var SetB : Array<String> = ['frog', 'elephant', 'thing'];\n    static var SetC : Array<String> = ['walked', 'treaded', 'grows'];\n    static var SetD : Array<String> = ['slowly', 'quickly'];\n\n    static public function main()\n    {\n        neko.Lib.print(AmbParse([ SetA, SetB, SetC, SetD ]).toString());\n    }\n\n    static function AmbParse(Sets : Array<Array<String>>)\n    {\n        var AmbData : Dynamic = Amb(Sets);\n\n        for (data in 0...AmbData.length)\n        {\n            var tmpData : String = parseIt(AmbData[data]);\n            var tmpArray : Array<String> = tmpData.split(' ');\n            tmpArray.pop();\n            if (tmpArray.length == Sets.length)\n            {\n                return tmpData;\n            }\n        }\n\n        return '';\n    }\n\n    static function Amb(?StartingWith : String = '', Sets : Array<Array<String>>)\n    {\n        if (Sets.length == 0 || Sets[0].length == 0) { return; }\n\n        var match : Dynamic = [];\n        for (Reference in 0...Sets[0].length)\n        {\n            if (StartingWith == '' || StartingWith == Sets[0][Reference].charAt(0))\n            {\n                if (Std.is(Amb(Sets[0][Reference].charAt(Sets[0][Reference].length-1), Sets.slice(1)), Array))\n                {\n                    match.push([ Sets[0][Reference], Amb(Sets[0][Reference].charAt(Sets[0][Reference].length-1), Sets.slice(1))]);\n                }\n                else\n                {\n                    match.push([ Sets[0][Reference] ]);\n                }\n            }\n        }\n        return match;\n    }\n\n    static function parseIt(data : Dynamic)\n    {\n        var retData : String = '';\n        if (Std.is(data, Array))\n        {\n            for (elements in 0...data.length)\n            {\n                if (Std.is(data[elements], Array))\n                {\n                    retData = retData + parseIt(data[elements]);\n                }\n                else\n                {\n                    retData = retData + data[elements] + ' ';\n                }\n            }\n        }\n        return retData;\n    }\n}<\/lang>\n\n==[[:Category:Icon|Icon]][[Category:Icon]] and [[:Category:Unicon|Unicon]][[Category:Unicon]]==\n<lang icon>procedure main()\n    s1 := [\"the\",\"that\",\"a\"]\n    s2 := [\"frog\",\"elephant\",\"thing\"]\n    s3 := [\"walked\",\"treaded\",\"grows\"]\n    s4 := [\"slowly\",\"quickly\"]\n\n    write(amb(!s1,!s2,!s3,!s4))\nend\n\nprocedure amb(exprs[])\n    s := \"\"\n    every e := !exprs do {\n        if \\c ~== e[1] then fail\n        c := e[-1]\n        s ||:= e || \" \"\n        }\n    return s\nend<\/lang>\n\n==[[:Category:J|J]][[Category:J]]==\n<lang j>   amb=. ([ , ' ' , ])&>\/&.>@:((({:@:[ = {.@:])&>\/&> # ])@:,@:({@(,&<)))\n   >@(amb&.>\/) ('the';'that';'a');('frog';'elephant';'thing');('walked';'treaded';'grows');(<'slowly';'quickly')\n+-----------------------+\n|that thing grows slowly|\n+-----------------------+<\/lang>\namb is a dyadic verb:\n<lang j>   ('the';'that';'a') amb ('frog';'elephant';'thing') amb ('walked';'treaded';'grows') amb ('slowly';'quickly')\n+-----------------------+\n|that thing grows slowly|\n+-----------------------+<\/lang>\nA structured derivation of amb follows:\n<lang j>   NB. Dynamic programming method...\n   \n   o=. @:                NB. Composing verbs\n   success=. {:o[ = {.o] NB. Is the last letter of the left word equal to the first of the right?\n   join=. [ , ' ' , ]    NB. Joining the left and right words\n   cp=. {@(,&<)          NB. Cartesian product\n   \n   amb=. join&>\/&.> o ((success&>\/ &> # ]) o , o cp)f.\n   amb NB. Showing the point-free code...\n([ , ' ' , ])&>\/&.>@:((({:@:[ = {.@:])&>\/&> # ])@:,@:({@(,&<)))<\/lang>\n\n==[[:Category:JavaScript|JavaScript]][[Category:JavaScript]]==\n<lang javascript>function ambRun(func) {\n    var choices = [];\n    var index;\n\n    function amb(values) {\n        if (values.length == 0) {\n            fail();\n        }\n        if (index == choices.length) {\n            choices.push({i: 0,\n                          count: values.length});\n        }\n        var choice = choices[index++];\n        return values[choice.i];\n    }\n\n    function fail() { throw fail; }\n\n    while (true) {\n        try {\n            index = 0;\n            return func(amb, fail);\n        } catch (e) {\n            if (e != fail) {\n                throw e;\n            }\n            var choice;\n            while ((choice = choices.pop()) && ++choice.i == choice.count) {}\n            if (choice == undefined) {\n                return undefined;\n            }\n            choices.push(choice);\n        }\n    }\n}\n\nambRun(function(amb, fail) {\n    function linked(s1, s2) {\n        return s1.slice(-1) == s2.slice(0, 1);\n    }\n\n    var w1 = amb([\"the\", \"that\", \"a\"]);\n    var w2 = amb([\"frog\", \"elephant\", \"thing\"]);\n    if (!linked(w1, w2)) fail();\n\n    var w3 = amb([\"walked\", \"treaded\", \"grows\"]);\n    if (!linked(w2, w3)) fail();\n\n    var w4 = amb([\"slowly\", \"quickly\"]);\n    if (!linked(w3, w4)) fail();\n\n    return [w1, w2, w3, w4].join(' ');\n});  \/\/ \"that thing grows slowly\"<\/lang>\n\n==[[:Category:Lua|Lua]][[Category:Lua]]==\n<lang lua>function amb (set)\n    local workset = {}\n    if (#set == 0) or (type(set) ~= 'table') then return end\n    if #set == 1 then return set end\n    if #set > 2 then\n        local first = table.remove(set,1)\n        set = amb(set)\n        for i,v in next,first do\n            for j,u in next,set do\n                if v:byte(#v) == u[1]:byte(1) then table.insert(workset, {v,unpack(u)}) end\n            end\n        end\n        return workset\n    end\n    for i,v in next,set[1] do\n        for j,u in next,set[2] do\n            if v:byte(#v) == u:byte(1) then table.insert(workset,{v,u}) end\n        end\n    end\n    return workset\nend<\/lang>\nUsage example:\n<lang lua>result = amb({{'the','that','a'},{'frog','elephant','thing'},{'walked','treaded','grows'},{'slowly','quickly'}})\nfor i,v in next,result do\n    io.write (i,':\\t')\n    for j,u in next,v do\n        io.write (u,' ')\n    end\n    io.write ('\\n')\nend<\/lang>\n\n==[[:Category:Mathematica|Mathematica]][[Category:Mathematica]]==\nMake all the tuples of all the lists, then filter out the good ones:\n<lang Mathematica> CheckValid[i_List]:=If[Length[i]<=1,True,And@@(StringTake[#[[1]],-1]==StringTake[#[[2]],1]&\/@Partition[i,2,1])]\n sets={{\"the\",\"that\",\"a\"},{\"frog\",\"elephant\",\"thing\"},{\"walked\",\"treaded\",\"grows\"},{\"slowly\",\"quickly\"}};\n Select[Tuples[sets],CheckValid]<\/lang>\ngives back:\n<lang Mathematica>{{\"that\", \"thing\", \"grows\", \"slowly\"}}<\/lang>\nNote that it will return multiple values if multiple sentences match the requirement, that is why the returned value is a list of list (1 element, 4 elements).\n\nAlternative algorithm (slightly faster on most data sets):\n<lang Mathematica>CheckValid2[i_List] := StringFreeQ[StringJoin[Riffle[i, \",\"]], a_ ~~ \",\" ~~ b_ \/; a =!= b]<\/lang>\n\n==[[:Category:Mercury|Mercury]][[Category:Mercury]]==\nLike Prolog, Mercury has built-in nondeterminacy; however, Mercury is explicit about it, and statically checks it.\n\n<lang Mercury>:- module amb.\n:- interface.\n:- import_module io.\n:- pred main(io::di, io::uo) is cc_multi.\n:- implementation.\n:- import_module list, string, char, int.\n\nmain(!IO) :-\n        ( solution(S) -> io.write_string(S, !IO), io.nl(!IO)\n        ; io.write_string(\"No solutions found :-(\\n\", !IO) ).\n\n:- pred solution(string::out) is nondet.\nsolution(S) :-\n        member(A, [\"the\", \"that\", \"a\"]),\n        member(N, [\"frog\", \"elephant\", \"thing\"]),\n        member(V, [\"walked\", \"treaded\", \"grows\"]),\n        member(E, [\"slowly\", \"quickly\"]),\n        S = join_list(\" \", [A, N, V, E]),\n        rule1(A, N), rule1(N, V), rule1(V, E).\n\n:- pred rule1(string::in, string::in) is semidet.\nrule1(A, B) :- last_char(A) = C, first_char(B, C, _).\n\n:- func last_char(string::in) = (char::out) is semidet.\nlast_char(S) = C :- index(S, length(S) - 1, C).<\/lang>\n\nThe Amb defined in the Prolog solution is similar to the use of list.member\/2 above.  Predicates could be used instead:\n\n<lang Mercury>\n:- pred noun(string).\n:- mode noun(out) is multi.    % provide any one noun.\n:- mode noun(in) is semidet.   % fail if given string isn't a known noun.\nnoun(\"frog\").\nnoun(\"elephant\").\nnoun(\"thing\").<\/lang>\n\n==[[:Category:OCaml|OCaml]][[Category:OCaml]]==\nThere is no Amb operator in OCaml. So below are two solutions to solve the same task. The first one is the more idiomatic for OCaml (and is similar to the Haskell solution), it builds all possible combinations and then take the good result in it.\n\nThe second solution tries to be closer to the way of solving the problem of Amb. It does not build and accumulate the combinations, it iterates over these with a higher order function and it stops when it finds a solution that matches the predicate.\n\n=== Filtering possible combinations ===\n<lang ocaml>let set_1 = [\"the\"; \"that\"; \"a\"]\nlet set_2 = [\"frog\"; \"elephant\"; \"thing\"]\nlet set_3 = [\"walked\"; \"treaded\"; \"grows\"]\nlet set_4 = [\"slowly\"; \"quickly\"]\n\nlet combs ll =\n  let rec aux acc = function\n  | [] -> (List.map List.rev acc)\n  | hd::tl ->\n      let acc =\n        List.fold_left\n          (fun _ac l ->\n            List.fold_left (fun _ac v -> (v::l)::_ac) _ac hd\n          ) [] acc\n      in\n      aux acc tl\n  in\n  aux [[]] ll\n\nlet last s = s.[pred(String.length s)]\nlet joined a b = (last a = b.[0])\n\nlet rec test = function\n  | a::b::tl -> (joined a b) && (test (b::tl))\n  | _ -> true\n\nlet print_set set =\n  List.iter (Printf.printf \" %s\") set;\n  print_newline();\n;;\n\nlet () =\n  let sets = combs [set_1; set_2; set_3; set_4] in\n  let sets = List.filter test sets in\n  List.iter print_set sets;\n;;<\/lang>\n\nWe can take all the good results with List.filter or just take the first one with List.find.\n\n=== Higher order function ===\nHere the function comb_search replaces the function combs and uses arrays instead of lists. This function takes successively all the possible results by their indicies (with the array nx). When a result satisfies the predicate p, it is returned\n\n<lang ocaml>let set_1 = [| \"the\"; \"that\"; \"a\" |]\nlet set_2 = [| \"frog\"; \"elephant\"; \"thing\" |]\nlet set_3 = [| \"walked\"; \"treaded\"; \"grows\" |]\nlet set_4 = [| \"slowly\"; \"quickly\" |]\n\nlet comb_search p aa =\n  let nx = Array.make (Array.length aa) 0 in\n  let lx = Array.map Array.length aa in\n  let la = Array.length aa in\n  let rec loop() =\n    let res = Array.mapi (fun i j -> aa.(i).(j)) nx in\n    if p res then (res)\n    else    \n    ( nx.(0) <- nx.(0) + 1;\n      if nx.(0) < lx.(0)\n      then loop()\n      else\n      ( nx.(0) <- 0;\n        let rec roll n =\n          if n >= la then raise Not_found\n          else \n          ( nx.(n) <- nx.(n) + 1;\n            if nx.(n) >= lx.(n)\n            then ( nx.(n) <- 0; roll (n+1) )\n            else loop()\n          )\n        in\n        roll 1\n      )\n    )\n  in\n  loop()\n  \nlet last s = s.[pred(String.length s)]\nlet joined a b = (last a = b.[0])\n\nlet rec test = function\n  | a::b::tl -> (joined a b) && (test (b::tl))\n  | _ -> true\n\nlet test r = test(Array.to_list r)\n\nlet print_set set =\n  Array.iter (Printf.printf \" %s\") set;\n  print_newline();\n;;\n\nlet () =\n  let result = comb_search test [| set_1; set_2; set_3; set_4 |] in\n  print_set result;\n;;<\/lang>\n\n==[[:Category:OpenEdge\/Progress|OpenEdge\/Progress]][[Category:OpenEdge\/Progress]]==\n<lang progress>DEF VAR cset AS CHAR EXTENT 4 INIT [   \n   \"the,that,a\",\n   \"frog,elephant,thing\", \n   \"walked,treaded,grows\",\n   \"slowly,quickly\"\n].\n\nFUNCTION getAmb RETURNS CHARACTER ( \n   i_cwords AS CHAR,\n   i_iset   AS INT\n):\n\n   DEF VAR cresult   AS CHAR.\n   DEF VAR ii        AS INT.\n   DEF VAR cword     AS CHAR.\n\n   DO ii = 1 TO NUM-ENTRIES( cset [ i_iset ] ) WHILE NUM-ENTRIES( cresult, \" \" ) < EXTENT( cset ):\n\n      cword = ENTRY( ii, cset[ i_iset ] ).\n      IF i_cwords = \"\" OR \n         SUBSTRING( i_cwords, LENGTH( i_cwords ), 1 ) = SUBSTRING( cword, 1, 1 )\n      THEN DO:\n         IF i_iset = EXTENT ( cset ) THEN\n            cresult = i_cwords + \" \" + cword.\n         ELSE\n            cresult = getAmb( i_cwords + \" \" + cword, i_iset + 1 ).\n      END.\n\n   END.\n\n   RETURN cresult.\n\nEND FUNCTION. \/* getAmb *\/\n\n\nMESSAGE getAmb( \"\", 1 ) VIEW-AS ALERT-BOX.<\/lang>\n\nOutput:\n<pre>\n---------------------------\nMessage\n---------------------------\n that thing grows slowly\n---------------------------\nOK   \n---------------------------\n<\/pre>\n\n==[[:Category:Oz|Oz]][[Category:Oz]]==\nOz is, among other things, a logic programming language and has a choice operator. Using recursion we can easily build an Amb operator with it.\n<lang oz>declare\n\n  fun {Amb Xs}\n     case Xs of nil then fail\n     [] [X] then X\n     [] X|Xr then\n        choice X\n        [] {Amb Xr}\n        end\n     end\n  end\n\n  fun {Example}\n     W1 = {Amb [\"the\" \"that\" \"a\"]}\n     W2 = {Amb [\"frog\" \"elephant\" \"thing\"]}\n     W3 = {Amb [\"walked\" \"treaded\" \"grows\"]}\n     W4 = {Amb [\"slowly\" \"quickly\"]}\n  in\n     {List.last W1 W2.1}\n     {List.last W2 W3.1}\n     {List.last W3 W4.1}\n     W1#\" \"#W2#\" \"#W3#\" \"#W4\n  end\n\nin\n\n  {ForAll {SearchAll Example} System.showInfo}<\/lang>\n\nIn Oz, the programmer explicitly controls how a logic program is executed (search strategy, number of required solutions, laziness, which physical machines are used for the search process...). In this case we use the predefined function SearchAll to eagerly calculate all possible solution. All work is done within the current process.\n\n==[[:Category:PARI\/GP|PARI\/GP]][[Category:PARI\/GP]]==\n<lang parigp>Amb(V)={\n\tamb(vector(#V,i,vector(#V[i],j,Vec(V[i][j]))),[])\n};\namb(V,s)={\n\tif (#V == 0, return(concat(s)));\n\tmy(v=V[1],U=vecextract(V,2^#V-2),t,final=if(#s,s[#s]));\n\tif(#s, s = concat(s,[\" \"]));\n\tfor(i=1,#v,\n\t\tif ((#s == 0 | final == v[i][1]),\n\t\t\tt = amb(U, concat(s, v[i]));\n\t\t\tif (t, return(t))\n\t\t)\n\t);\n\t0\n};\nAmb([[\"the\",\"that\",\"a\"],[\"frog\",\"elephant\",\"thing\"],[\"walked\",\"treaded\",\"grows\"],[\"slowly\",\"quickly\"]])<\/lang>\n\n==[[:Category:Prolog|Prolog]][[Category:Prolog]]==\n<lang prolog>amb(E, [E|_]).\namb(E, [_|ES]) :- amb(E, ES).\n\njoins(Left, Right) :-\n  append(_, [T], Left),\n  append([R], _, Right),\n  ( T \\= R -> amb(_, [])  % (explicitly using amb fail as required)\n  ; true ).\n\namb_example([Word1, Word2, Word3, Word4]) :-\n  amb(Word1, [\"the\",\"that\",\"a\"]),\n  amb(Word2, [\"frog\",\"elephant\",\"thing\"]),\n  amb(Word3, [\"walked\",\"treaded\",\"grows\"]),\n  amb(Word4, [\"slowly\",\"quickly\"]),\n  joins(Word1, Word2),\n  joins(Word2, Word3),\n  joins(Word3, Word4).<\/lang>\n\n==[[:Category:Perl|Perl]][[Category:Perl]]==\nGenerates permutation of the sets with the [http:\/\/perldoc.perl.org\/functions\/glob.html glob] function.\nThen, validate the combination with a regular expression.\n<lang perl>$s1 = \"the|,that|,a|\";\n$s2 = \"frog|,elephant|,thing|\";\n$s3 = \"walked|,treaded|,grows|\";\n$s4 = \"slowly|,quickly|\";\n\n$sets = \"{$s1}{$s2}{$s3}{$s4}\";\nprint \"$sets\\n\";\n\nfor( glob($sets) )\n{\n        tr\/|\/ \/;\n        print \"$_\\n\" if(m\/\\w+?(\\w) \\1\\w+?(\\w) \\2\\w+?(\\w) \\3\\w+\/);\n}<\/lang>\n==[[:Category:Perl 6|Perl 6]][[Category:Perl 6]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[niecza]] version 2012-02-29[[SMW::on]]<\/div>\n<lang perl6>sub infix:<lf> ($a,$b) {\n    next unless try $a.substr(*-1,1) eq $b.substr(0,1);\n    \"$a $b\";\n}\n\nmulti dethunk(Callable $x) { try take $x() }\nmulti dethunk(     Any $x) {     take $x   }\n\nsub amb (*@c) { gather @c\u00bb.&dethunk }\n\nsay first *, do\n    amb(<the that a>, { die 'oops'}) Xlf\n    amb('frog',{'elephant'},'thing') Xlf\n    amb(<walked treaded grows>)      Xlf\n    amb { die 'poison dart' },\n        {'slowly'},\n        {'quickly'},\n        { die 'fire' };<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>that thing grows slowly<\/pre>\nThis uses lazy lists, created by the <tt>X<\/tt> metaoperator applied to a user-defined function, <tt>lf<\/tt>, that asserts the last-first condition,\nand short-circuits the match so that it does not need to generate parts of the search tree that cannot match. We use the <tt>first<\/tt> function to pull one element from the lazy list; a subscript of <tt>[0]<\/tt> would have worked just as well.\n\nThe <tt>amb<\/tt> operator itself uses a hyper to run the <tt>dethunk<\/tt> calls in parallel.  Results are returned asyncronously via <tt>gather<\/tt>\/<tt>take<\/tt>.  The <tt>dethunk<\/tt> call traps failures after the failure has bypassed the <tt>take<\/tt>.\n\nIf you consider lazy lists to be cheating on the idea of continuations, here's\nsome admittedly grungy code that uses the continuation engine of regexes to solve it.  At some point we'll wrap this up in nice syntax to let people write in a sublanguage of Perl\u00a06 that looks more like a logic language.\n<lang perl6>sub amb($var,*@a) {\n    \"[{\n        @a.pick(*).map: {\"||\\{ $var = '$_' }\"}\n     }]\";\n}\n\n'' ~~ m\/\n    :my ($a,$b,$c,$d);\n    <{ amb '$a', <the that a> }>\n    <{ amb '$b', <frog elephant thing> }>\n    <?{ substr($a,*-1,1) eq substr($b,0,1) }>\n    <{ amb '$c', <walked treaded grows> }>\n    <?{ substr($b,*-1,1) eq substr($c,0,1) }>\n    <{ amb '$d', <slowly quickly> }>\n    <?{ substr($c,*-1,1) eq substr($d,0,1) }>\n    { say \"$a $b $c $d\" }\n    <!>\n\/;<\/lang>\n\n==[[:Category:PicoLisp|PicoLisp]][[Category:PicoLisp]]==\nFor backtracking, Pilog (PicoLisp Prolog) is the natural choice.\n<div class=\"examplemeta translation\">'''Translation of''': [[Amb#Prolog|Prolog]]<\/div>\n<lang PicoLisp>(be amb (@E @Lst)\n   (lst @E @Lst) )\n\n(be joins (@Left @Right)\n   (@T last (chop (-> @Left)))\n   (@R car (chop (-> @Right)))\n   (or\n      ((equal @T @R))\n      ((amb @ NIL)) ) )  # Explicitly using amb fail as required\n\n(be ambExample ((@Word1 @Word2 @Word3 @Word4))\n  (amb @Word1 (\"the\" \"that\" \"a\"))\n  (amb @Word2 (\"frog\" \"elephant\" \"thing\"))\n  (amb @Word3 (\"walked\" \"treaded\" \"grows\"))\n  (amb @Word4 (\"slowly\" \"quickly\"))\n  (joins @Word1 @Word2)\n  (joins @Word2 @Word3)\n  (joins @Word3 @Word4) )<\/lang>\nOutput:\n<pre>: (? (ambExample @Result))\n @Result=(\"that\" \"thing\" \"grows\" \"slowly\")\n-> NIL<\/pre>\n\n==[[:Category:PureBasic|PureBasic]][[Category:PureBasic]]==\n<lang PureBasic>Procedure Words_Ok(String1.s, String2.s)\n  If Mid(String1,Len(String1),1)=Mid(String2,1,1)\n    ProcedureReturn #True\n  EndIf\n  ProcedureReturn #False\nEndProcedure\n\nProcedure.s Amb(Array A.s(1), Array B.s(1), Array C.s(1), Array D.s(1))\n  Protected a, b, c, d\n  For a=0 To ArraySize(A())\n    For b=0 To ArraySize(B())\n      For c=0 To ArraySize(C())\n        For d=0 To ArraySize(D())\n          If Words_Ok(A(a),B(b)) And Words_Ok(B(b),C(c)) And Words_Ok(C(c),D(d))\n            ProcedureReturn A(a)+\" \"+B(b)+\" \"+C(c)+\" \"+D(d)\n          EndIf\n        Next\n      Next\n    Next\n  Next\n  ProcedureReturn \"\"   ; Empty string, e.g. fail\nEndProcedure\n\nIf OpenConsole()\n  Define Text.s\n  Dim Set1.s(2)\n  Dim Set2.s(2)\n  Dim Set3.s(2)\n  Dim Set4.s(1)\n  \n  Set1(0)=\"the\":    set1(1)=\"that\":     set1(2)=\"a\"\n  Set2(0)=\"frog\":   set2(1)=\"elephant\": set2(2)=\"thing\" \n  Set3(0)=\"walked\": set3(1)=\"treaded\":  set3(2)=\"grows\" \n  Set4(0)=\"slowly\": set4(1)=\"quickly\"\n  \n  text=Amb(set1(),set2(),Set3(),set4())\n  If Text<>\"\"\n    PrintN(\"Correct sentence would be,\"+#CRLF$+Text)\n  Else\n    PrintN(\"Failed to fine a correct sentence.\")\n  EndIf\n  PrintN(#CRLF$+#CRLF$+\"Press ENTER to exit.\"): Input()\n  CloseConsole()\nEndIf<\/lang>\n\n==[[:Category:Python|Python]][[Category:Python]]==\n<small>(Note: The code is also imported and used as a module in the solution to [[Dinesman's_multiple-dwelling_problem#By_using_the_Amb_operator|this task]]).<\/small>\n\nPython does not have the amb function, but the declarative style of programming and the use of the one \"function\" to do all three tasks of:\n* Setting ranges\n* Setting the constraint\n* Iterating over all solutions\ncan be done in what appears to be a [[wp:Declarative programming|declarative]] manner with the following class Amb:\n<lang python>import itertools as _itertools\n\nclass Amb(object):\n    def __init__(self):\n        self._names2values   = {}       # set of values for each global name\n        self._func           = None     # Boolean constraint function\n        self._valueiterator  = None     # itertools.product of names values\n        self._funcargnames   = None     # Constraint parameter names\n\n    def __call__(self, arg=None):\n        if hasattr(arg, 'func_globals'):\n            ##\n            ## Called with a constraint function. \n            ##\n            globls = arg.func_globals\n            # Names used in constraint\n            argv = arg.__code__.co_varnames[:arg.__code__.co_argcount]\n            for name in argv:\n                if name not in self._names2values:\n                    assert name in globls, \\\n                           \"Global name %s not found in function globals\" % name\n                    self._names2values[name] = globls[name]\n            # Gather the range of values of all names used in the constraint\n            valuesets = [self._names2values[name] for name in argv]\n            self._valueiterator = _itertools.product(*valuesets)\n            self._func = arg\n            self._funcargnames = argv\n            return self\n        elif arg is not None:\n            ##\n            ## Assume called with an iterable set of values\n            ##\n            arg = frozenset(arg)\n            return arg\n        else:\n            ##\n            ## blank call tries to return next solution\n            ##\n            return self._nextinsearch()\n\n    def _nextinsearch(self):\n        arg = self._func\n        globls = arg.func_globals\n        argv = self._funcargnames\n        found = False\n        for values in self._valueiterator:\n            if arg(*values):\n                # Set globals.\n                found = True\n                for n, v in zip(argv, values):\n                    globls[n] = v\n                break\n        if not found: raise StopIteration\n        return values\n\n    def __iter__(self):\n        return self\n    \n    def next(self):\n        return self()\n\nif __name__ == '__main__':\n    if True:\n        amb = Amb()\n        \n        print(\"\\nSmall Pythagorean triples problem:\")\n        x = amb(range(1,11))\n        y = amb(range(1,11))\n        z = amb(range(1,11))\n\n        for _dummy in amb( lambda x, y, z: x*x + y*y == z*z ):\n            print x, y, z\n\n\n    if True:\n        amb = Amb()\n        \n        print(\"\\nRosetta Code Amb problem:\")\n        w1 = amb([\"the\", \"that\", \"a\"])\n        w2 = amb([\"frog\", \"elephant\", \"thing\"])\n        w3 = amb([\"walked\", \"treaded\", \"grows\"])\n        w4 = amb([\"slowly\", \"quickly\"])\n\n        for _dummy in amb( lambda w1, w2, w3, w4: \\\n                             w1[-1] == w2[0] and \\\n                             w2[-1] == w3[0] and \\\n                             w3[-1] == w4[0] ):\n            print w1, w2, w3, w4\n\n    if True:\n        amb = Amb()\n        \n        print(\"\\nAmb problem from \"\n            \"http:\/\/www.randomhacks.net\/articles\/2005\/10\/11\/amb-operator:\")\n        x = amb([1, 2, 3])\n        y = amb([4, 5, 6])\n\n        for _dummy in amb( lambda x, y: x * y != 8 ):\n            print x, y<\/lang>\n\nSample output:\n<pre>\nSmall Pythagorean triples problem:\n3 4 5\n4 3 5\n6 8 10\n8 6 10\n\nRosetta Code Amb problem:\nthat thing grows slowly\n\nAmb problem from http:\/\/www.randomhacks.net\/articles\/2005\/10\/11\/amb-operator:\n1 4\n1 5\n1 6\n2 5\n2 6\n3 4\n3 5\n3 6<\/pre>\n\n==[[:Category:R|R]][[Category:R]]==\nA brute force approach that depends on the expand.grid() function, which generates all possible paths through a list of vectors:\n<lang r>checkSentence <- function(sentence){\n# Input: character vector\n# Output: whether the sentence formed by the elements of the vector is valid\n  for (index in 1:(length(sentence)-1)){\n    first.word  <- sentence[index]\n    second.word <- sentence[index+1]\n    \n    last.letter  <- substr(first.word, nchar(first.word), nchar(first.word))\n    first.letter <- substr(second.word, 1, 1)\n    \n    if (last.letter != first.letter){ return(FALSE) } \n  }\n  return(TRUE)\n}\n\namb <- function(sets){\n# Input: list of character vectors containing all sets to consider\n# Output: list of character vectors that are valid\n  all.paths      <- apply(expand.grid(sets), 2, as.character)\n  all.paths.list <- split(all.paths, 1:nrow(all.paths))\n  winners        <- all.paths.list[sapply(all.paths.list, checkSentence)]\n  return(winners)\n}<\/lang>\n\nSome sample output:\n<lang r>sentence1 <- c(\"that\", \"thing\", \"grows\", \"slowly\")\nsentence2 <- c(\"rosetta\", \"code\", \"is\", \"cool\")\nsentence  <- list(sentence1, sentence2)\nsapply(sentence, checkSentence)\n[1]  TRUE FALSE\n\nset1 <- c(\"the\", \"that\", \"a\")\nset2 <- c(\"frog\", \"elephant\", \"thing\")\nset3 <- c(\"walked\", \"treaded\", \"grows\")\nset4 <- c(\"slowly\", \"quickly\")\nsets <- list(set1, set2, set3, set4)\namb(sets)\n$`26`\n[1] \"that\"   \"thing\"  \"grows\"  \"slowly\"<\/lang>\n\n==[[:Category:REXX|REXX]][[Category:REXX]]==\nThe example didn't say so, but an assumption made (for this program) that lowercase and uppercase letters are considered to be considered a match.\n<lang rexx>\/*REXX program demonstrates Amd operator (choosing 4 words from 4 sets).*\/\n\n@.=''                                  \/*default value for any # of sets*\/\n@.1=\"the that a\"\n@.2=\"frog elephant thing\"\n@.3=\"walked treaded grows\"\n@.4=\"slowly quickly\"\n\n  do j=1 until @.j==''; end;  @.0=j-1  \/*find how many sets there are.  *\/\n                                       \/*@.0   contains number of sets. *\/\ncall Amb 1                             \/*find combo of words that works.*\/\nexit\n\n\/*\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500AMB procedure\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500*\/\nAmb: procedure expose @.; parse arg # _; arg . u; if #=='' then return\nif #>@.0 then do; if u=='' then return\n              w=word(u,1)              \/*(Below) use upper case version.*\/\n                   do n=2 to words(_)\n                   c=word(u,n); if left(c,1)\\==right(w,1) then return; w=c\n                   end\n              say strip(_)             \/*_ has an extra leading blank.  *\/\n              end\n  do j=1 for words(@.#)\n  call amb #+1 _ word(@.#,j)           \/*generate the next combination. *\/\n  end\nreturn<\/lang>\nOutput \n<pre>\nthat thing grows slowly\n<\/pre>\n\n==[[:Category:Ruby|Ruby]][[Category:Ruby]]==\n<lang ruby>class Amb\n  class ExhaustedError < RuntimeError; end\n\n  def initialize\n    @fail = proc { fail ExhaustedError, \"amb tree exhausted\" }\n  end\n\n  def choose(*choices)\n    prev_fail = @fail\n    callcc { |sk|\n      choices.each { |choice|\n\tcallcc { |fk|\n\t  @fail = proc {\n\t    @fail = prev_fail\n\t    fk.call(:fail)\n\t  }\n\t  if choice.respond_to? :call\n\t    sk.call(choice.call)\n\t  else\n\t    sk.call(choice)\n\t  end\n\t}\n      }\n      @fail.call\n    }\n  end\n\n  def failure\n    choose\n  end\n\n  def assert(cond)\n    failure unless cond\n  end\nend\n\nA = Amb.new\nw1 = A.choose(\"the\", \"that\", \"a\")\nw2 = A.choose(\"frog\", \"elephant\", \"thing\")\nw3 = A.choose(\"walked\", \"treaded\", \"grows\")\nw4 = A.choose(\"slowly\", \"quickly\")\n\nA.choose() unless w1[-1] == w2[0]\nA.choose() unless w2[-1] == w3[0]\nA.choose() unless w3[-1] == w4[0]\n\nputs w1, w2, w3, w4<\/lang>\n\n==[[:Category:Scala|Scala]][[Category:Scala]]==\n<lang Scala>object Amb {\n\n  def amb(wss: List[List[String]]): Option[String] = {\n    def _amb(ws: List[String], wss: List[List[String]]): Option[String] = wss match {\n      case Nil => ((Some(ws.head): Option[String]) \/: ws.tail)((a, w) => a match {\n        case Some(x) => if (x.last == w.head) Some(x + \" \" + w) else None\n        case None => None\n      })\n      case ws1 :: wss1 => ws1.flatMap(w => _amb(w :: ws, wss1)).headOption\n    }\n    _amb(Nil, wss.reverse)\n  }\n\n  def main(args: Array[String]) {\n    println(amb(List(List(\"the\", \"that\", \"a\"),\n                     List(\"frog\", \"elephant\", \"thing\"),\n                     List(\"walked\", \"treaded\", \"grows\"),\n                     List(\"slowly\", \"quickly\"))))\n  }\n}<\/lang>\n\n==[[:Category:Scheme|Scheme]][[Category:Scheme]]==\n<lang scheme>(define fail \n  (lambda () \n    (error \"Amb tree exhausted\"))) \n\n(define-syntax amb \n  (syntax-rules () \n    ((AMB) (FAIL))                      ; Two shortcuts. \n    ((AMB expression) expression) \n \n    ((AMB expression ...) \n     (LET ((FAIL-SAVE FAIL)) \n       ((CALL-WITH-CURRENT-CONTINUATION ; Capture a continuation to \n          (LAMBDA (K-SUCCESS)           ;   which we return possibles. \n            (CALL-WITH-CURRENT-CONTINUATION \n              (LAMBDA (K-FAILURE)       ; K-FAILURE will try the next \n                (SET! FAIL K-FAILURE)   ;   possible expression. \n                (K-SUCCESS              ; Note that the expression is \n                 (LAMBDA ()             ;   evaluated in tail position \n                   expression))))       ;   with respect to AMB. \n            ... \n            (SET! FAIL FAIL-SAVE)      ; Finally, if this is reached, \n            FAIL-SAVE)))))))            ;   we restore the saved FAIL. \n\n\n(let ((w-1 (amb \"the\" \"that\" \"a\"))\n      (w-2 (amb \"frog\" \"elephant\" \"thing\"))\n      (w-3 (amb \"walked\" \"treaded\" \"grows\"))\n      (w-4 (amb \"slowly\" \"quickly\")))\n  (define (joins? left right)\n    (equal? (string-ref left (- (string-length left) 1)) (string-ref right 0)))\n  (if (joins? w-1 w-2) '() (amb))\n  (if (joins? w-2 w-3) '() (amb))\n  (if (joins? w-3 w-4) '() (amb))\n  (list w-1 w-2 w-3 w-4))<\/lang>\n\n==[[:Category:Seed7|Seed7]][[Category:Seed7]]==\n<lang seed7>$ include \"seed7_05.s7i\";\n\nconst type: setListType is array array string;\n\nconst func array string: amb (in string: word1, in setListType: listOfSets) is func\n  result\n    var array string: result is 0 times \"\";\n  local\n    var string: word2 is \"\";\n  begin\n    for word2 range listOfSets[1] do\n      if length(result) = 0 and word1[length(word1) len 1] = word2[1 len 1] then\n        if length(listOfSets) = 1 then\n          result := [] (word1) & [] (word2);\n        else\n          result := amb(word2, listOfSets[2 ..]);\n          if length(result) <> 0 then\n            result := [] (word1) & result;\n          end if;\n        end if;\n      end if;\n    end for;\n  end func;\n\nconst func array string: amb (in setListType: listOfSets) is func\n  result\n    var array string: result is 0 times \"\";\n  local\n    var string: word1 is \"\";\n  begin\n    for word1 range listOfSets[1] do\n      if length(result) = 0 then\n        result := amb(word1, listOfSets[2 ..]);\n      end if;\n    end for;\n  end func;\n\nconst proc: main is func\n  local\n    var array string: ambResult is 0 times \"\";\n    var string: word is \"\";\n  begin\n    ambResult := amb([] ([] (\"the\", \"that\", \"a\"),\n                         [] (\"frog\", \"elephant\", \"thing\"),\n                         [] (\"walked\", \"treaded\", \"grows\"),\n                         [] (\"slowly\", \"quickly\")));\n    for word range ambResult do\n      write(word <& \" \");\n    end for;\n    writeln;\n  end func;<\/lang>\nOutput:\n<pre>\nthat thing grows slowly \n<\/pre>\n\n==[[:Category:SETL|SETL]][[Category:SETL]]==\n<lang SETL>program amb;\n\nsets := unstr('[{the that a} {frog elephant thing} {walked treaded grows} {slowly quickly}]');\n\nwords := [amb(words): words in sets];\nif exists lWord = words(i), rWord in {words(i+1)} |\n          lWord(#lWord) \/= rWord(1) then\n  fail;\nend if;\n\nproc amb(words);\n  return arb {word in words | ok};\nend proc;\n\nend program;<\/lang>\nSadly ''ok'' and ''fail'' were only ever implemented in CIMS SETL, and are not in any compiler or interpreter that is available today, so this is not very useful as it stands.\n\n===Alternate version (avoids [http:\/\/www.setl-lang.org\/wiki\/index.php\/Backtracking backtracking])===\n<lang SETL>program amb;\n\nsets := unstr('[{the that a} {frog elephant thing} {walked treaded grows} {slowly quickly}]');\n\nprint(amb(sets));\n\nproc amb(sets);\n  return amb1([], {}, sets);\nend proc;\n\nproc amb1(prev, mbLast, sets);\n  if sets = [] then\n    return prev;\n  else\n    words fromb sets;\n    if exists word in words |\n              (forall last in mbLast |\n                      last(#last) = word(1)) and\n              (exists sentence in {amb1(prev with word, {word}, sets)} |\n                      true) then\n      return sentence;\n    end if;\n  end if;\nend proc;\n\nend program;<\/lang>\nWe cheat a bit here - this version of ''amb'' must be given the whole list of word sets, and that list is consumed recursively.  It can't pick a word from an individual list.\n\n==[[:Category:Tcl|Tcl]][[Category:Tcl]]==\n===Brute Force===\nBrute force, with quick kill of failing attempts:\n<lang Tcl>set amb {\n    {the    that     a}\n    {frog   elephant thing}\n    {walked treaded  grows}\n    {slowly quickly}\n}\n\nproc joins {a b} {\n    expr {[string index $a end] eq [string index $b 0]}\n}\n\nforeach i [lindex $amb 0] {\n    foreach j [lindex $amb 1] {\n        if ![joins $i $j] continue\n        foreach k [lindex $amb 2] {\n            if ![joins $j $k] continue\n            foreach l [lindex $amb 3] {\n                if [joins $k $l] {\n                    puts [list $i $j $k $l]\n                }\n            }\n        }\n    }\n}<\/lang>\n===With Coroutines===\nA more sophisticated using Tcl 8.6's coroutine facility that avoids the assumption of what the problem is in the code structure:\n<lang Tcl>package require Tcl 8.6\nproc cp {args} {\n    coroutine cp.[incr ::cps] apply {{list args} {\n\tyield [info coroutine]\n\tforeach item $list {\n\t    if {[llength $args]} {\n\t\tset c [cp {*}$args]\n\t\twhile 1 { yield [list $item {*}[$c]] }\n\t    } else { yield $item }\n\t}\n\treturn -code break\n    }} {*}$args\n}\nproc amb {name filter args} {\n    coroutine $name apply {{filter args} {\n\tset c [cp {*}$args]\n\tyield [info coroutine]\n\twhile 1 {\n\t    set value [$c]\n\t    if {[{*}$filter $value]} { yield $value }\n\t}\n\treturn -code break\n    }} $filter {*}$args\n}\n\nproc joins {a b} {\n    expr {[string index $a end] eq [string index $b 0]}\n}\nproc joins* list {\n    foreach a [lrange $list 0 end-1] b [lrange $list 1 end] {\n\tif {![joins $a $b]} {return 0}\n    }\n    return 1\n}\n\namb words joins* \\\n    {the    that     a} \\\n    {frog   elephant thing} \\\n    {walked treaded  grows} \\\n    {slowly quickly}\nwhile 1 { puts [words] }<\/lang>\n\n==[[:Category:TUSCRIPT|TUSCRIPT]][[Category:TUSCRIPT]]==\n<lang tuscript>$$ MODE TUSCRIPT\nset1=\"the'that'a\"\nset2=\"frog'elephant'thing\"\nset3=\"walked'treaded'grows\"\nset4=\"slowly'quickly\"\nLOOP w1=set1\n lastw1=EXTRACT (w1,-1,0)\n LOOP w2=set2\n IF (w2.sw.$lastw1) THEN\n  lastw2=EXTRACT (w2,-1,0)\n  LOOP w3=set3\n  IF (w3.sw.$lastw2) THEN\n   lastw3=EXTRACT (w3,-1,0)\n   LOOP w4=set4\n   IF (w4.sw.$lastw3) sentence=JOIN (w1,\" \",w2,w3,w4)\n   ENDLOOP\n  ENDIF\n  ENDLOOP\n ENDIF\n ENDLOOP\nENDLOOP\nPRINT sentence<\/lang>\nOutput:\n<pre>\nthat thing grows slowly\n<\/pre>\n\n==[[:Category:TXR|TXR]][[Category:TXR]]==\n\nThis is not exactly the implementation of an operator, but a solution worth presenting. The language has the built in pattern matching and backtracking behavior suited for this type of text mining task.\n\nFor convenience, we prepare the data in four files:\n\n<pre>$ cat amb\/set1\nthe\nthat\na\n$ cat amb\/set2\nfrog\nelephant\nthing\n$ cat amb\/set3\nwalked\ntreaded\ngrows\n$ cat amb\/set4\nslowly\nquickly<\/pre>\n\nCode:\n\n<lang txr>@(define first_last (first last whole))\n@  (all)\n@(skip :greedy)@{last 1}\n@  (and)\n@{first 1}@(skip)\n@  (and)\n@whole\n@  (end)\n@(end)\n@(next \"amb\/set1\")\n@(skip)\n@(first_last fi1 la1 w1)\n@(next \"amb\/set2\")\n@(skip)\n@(first_last la1 la2 w2)\n@(next \"amb\/set3\")\n@(skip)\n@(first_last la2 la3 w3)\n@(next \"amb\/set4\")\n@(skip)\n@(first_last la3 la4 w4)\n@(output)\n@w1 @w2 @w3 @w4\n@(end)<\/lang>\n\nRun:\n\n<pre>$ .\/txr amb.txr \nthat thing grows slowly<\/pre>\n\nAs you can see, this has the \"nondeterministic flavor\" of Amb. The <code>@(skip)<\/code> directives\"magically\" skip over the lines of input that do not succeed.\n\nThis example naturally handles empty strings, since the <code>first_last<\/code> function simply does not match such inputs.\n\nHere is how to embed the task's specific data in the code:\n\n<lang txr>@(define first_last (first last whole))\n@  (all)\n@(skip :greedy)@{last 1}\n@  (and)\n@{first 1}@(skip)\n@  (and)\n@whole\n@  (end)\n@(end)\n@(next :list (\"the\" \"that\" \"a\"))\n@(skip)\n@(first_last fi1 la1 w1)\n@(next :list (\"frog\" \"elephant\" \"thing\"))\n@(skip)\n@(first_last la1 la2 w2)\n@(next :list (\"walked\" \"treaded\" \"grows\"))\n@(skip)\n@(first_last la2 la3 w3)\n@(next :list (\"slowly\" \"quickly\"))\n@(skip)\n@(first_last la3 la4 w4)\n@(output)\n@w1 @w2 @w3 @w4\n@(end)<\/lang>\n\n==[[:Category:VBScript|VBScript]][[Category:VBScript]]==\n=====Implementation=====\n<lang vb>class ambiguous\n\tdim sRule\n\n\tpublic property let rule( x )\n\t\tsRule = x\n\tend property\n\t\n\tpublic default function amb(p1, p2)\n\t\tamb = eval(sRule)\n\tend function\nend class<\/lang>\n\n=====Invocation=====\n<lang vb>dim amb\nset amb = new ambiguous\n\namb.rule = \"right(p1,1)=left(p2,1)\"\n\ndim w1, w2, w3, w4\nfor each w1 in split(\"the that a\", \" \")\n\tfor each w2 in split(\"frog elephant thing\", \" \")\n\t\tfor each w3 in split(\"walked treaded grows\", \" \")\n\t\t\tfor each w4 in split(\"slowly quickly\", \" \")\n\t\t\t\tif amb(w1, w2) and amb(w2, w3) and amb(w3, w4) then\n\t\t\t\t\twscript.echo w1, w2, w3, w4\n\t\t\t\tend if\n\t\t\tnext\n\t\tnext\n\tnext\nnext<\/lang>\n\n=====Output=====\n<pre>\nthat thing grows slowly\n<\/pre>\n\n[[Category:GUISS\/Omit]]\n[[Category:gnuplot\/Omit]]\n[[Category:LaTeX\/Omit]]\n[[Category:Make\/Omit]]\n[[Category:PlainTeX\/Omit]]\n[[Category:TI-83 BASIC\/Omit]] [[Category:TI-89 BASIC\/Omit]]"}]}}},"query-continue":{"revisions":{"rvstartid":132983}}}