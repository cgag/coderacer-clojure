{"query-continue":{"search":{"gsroffset":1},"revisions":{"rvstartid":137827}},"query":{"pages":{"2663":{"pageid":2663,"ns":0,"title":"99 Bottles of Beer","revisions":[{"*":"<div class=\"infobox\" style=\"width: 2in\">[[File:Rcode-button-task-crushed.png|64px|left|alt=Task|link=Category:Solutions by Programming Task]]'''99 Bottles of Beer'''<br\/>\nYou are encouraged to [[Rosetta Code:Solve a Task|solve this task]] according to the task description, using any language you may know.[[Category:Programming Tasks]][[Category:Solutions by Programming Task]]<\/div>In this puzzle, write code to print out the entire \"99 bottles of beer on the wall\" song. For those who do not know the song, the lyrics follow this form:\n X bottles of beer on the wall\n X bottles of beer\n Take one down, pass it around\n X-1 bottles of beer on the wall\n \n X-1 bottles of beer on the wall\n ...\n Take one down, pass it around\n 0 bottles of beer on the wall\nWhere X and X-1 are replaced by numbers of course. Grammatical support for \"1 bottle of beer\" is optional. As with any puzzle, try to do it in as creative\/concise\/comical a way as possible (simple, obvious solutions allowed, too).\n\nSee also: http:\/\/99-bottles-of-beer.net\/\n\n==[[:Category:ABAP|ABAP]][[Category:ABAP]]==\n<lang ABAP>REPORT z99bottles.\n\nDATA lv_no_bottles(2) TYPE n VALUE 99.\n\nDO lv_no_bottles TIMES.\n  WRITE lv_no_bottles NO-ZERO.\n  WRITE ' bottles of beer on the wall'.\n  NEW-LINE.\n  WRITE lv_no_bottles NO-ZERO.\n  WRITE ' bottles of beer'.\n  NEW-LINE.\n  WRITE 'Take one down, pass it around'.\n  NEW-LINE.\n  SUBTRACT 1 FROM lv_no_bottles.\n  WRITE lv_no_bottles NO-ZERO.\n  WRITE ' bottles of beer on the wall'.\n  WRITE \/.\nENDDO.<\/lang>\n\n==[[:Category:ACL2|ACL2]][[Category:ACL2]]==\n\n<lang Lisp>(defun bottles-of-beer (n)\n   (if (zp n)\n       nil\n       (prog2$ (cw (concatenate 'string\n                   \"~%\"\n                   \"~N0 bottle~#1~[~\/s~] of beer on the wall,~%\"\n                   \"~n0 bottle~#1~[~\/s~] of beer.~%\"\n                   \"Take one down, pass it around,~%\"\n                   \"~n2 bottle~#3~[~\/s~] of beer on the wall.~%\")\n                   n\n                   (if (= n 1) 0 1)\n                   (1- n)\n                   (if (= n 2) 0 1))\n               (bottles-of-beer (- n 1)))))<\/lang>\n\n==[[:Category:ActionScript|ActionScript]][[Category:ActionScript]]==\n<lang ActionScript>for(var numBottles:uint = 99; numBottles > 0; numBottles--)\n{\n\ttrace(numBottles, \" bottles of beer on the wall\");\n\ttrace(numBottles, \" bottles of beer\");\n\ttrace(\"Take one down, pass it around\");\n\ttrace(numBottles - 1, \" bottles of beer on the wall\\n\");\t\t  \n}<\/lang>\n\n==[[:Category:Ada|Ada]][[Category:Ada]]==\n===Simple version===\n<lang ada>with Ada.Text_Io; use Ada.Text_Io;\n \n procedure Bottles is\n begin\n    for X in reverse 1..99 loop\n       Put_Line(Integer'Image(X) & \" bottles of beer on the wall\");\n       Put_Line(Integer'Image(X) & \" bottles of beer\");\n       Put_Line(\"Take one down, pass it around\");\n       Put_Line(Integer'Image(X - 1) & \" bottles of beer on the wall\");\n       New_Line;\n    end loop;\n end Bottles;<\/lang>\n===Concurrent version===\nwith 1 task to print out the information and 99 tasks to specify the number of bottles\n<lang Ada>with Ada.Text_Io; use Ada.Text_Io;\n\nprocedure Tasking_99_Bottles is\n   subtype Num_Bottles is Natural range 1..99;\n   task Print is\n      entry Set (Num_Bottles);\n   end Print;\n   task body Print is\n      Num : Natural;\n   begin\n      for I in reverse Num_Bottles'range loop\n         select\n         accept \n            Set(I) do -- Rendezvous with Counter task I\n               Num := I;\n            end Set;\n            Put_Line(Integer'Image(Num) & \" bottles of beer on the wall\");\n            Put_Line(Integer'Image(Num) & \" bottles of beer\");\n            Put_Line(\"Take one down, pass it around\");\n            Put_Line(Integer'Image(Num - 1) & \" bottles of beer on the wall\");\n            New_Line;\n         or terminate; -- end when all Counter tasks have completed\n         end select;\n      end loop;\n   end Print;\n   task type Counter(I : Num_Bottles);\n   task body Counter is\n   begin\n      Print.Set(I);\n   end Counter;\n   type Task_Access is access Counter;\n   \n   Task_List : array(Num_Bottles) of Task_Access;\n \nbegin\n   for I in Task_List'range loop -- Create 99 Counter tasks\n      Task_List(I) := new Counter(I);\n   end loop;\nend Tasking_99_Bottles;<\/lang>\n\n==[[:Category:Aime|Aime]][[Category:Aime]]==\n<lang aime>integer\nmain(void)\n{\n    cardinal bottles;\n\n    bottles = 99;\n\n    do {\n\to_cardinal(bottles);\n        o_text(\" bottles of beer on the wall\\n\");\n\to_cardinal(bottles);\n        o_text(\" bottles of beer\\n\");\n        o_text(\"Take one down, pass it around\\n\");\n        bottles -= 1;\n\to_cardinal(bottles);\n        o_text(\" bottles of beer on the wall\\n\\n\");\n    } while (bottles);\n\n    return 0;\n}<\/lang>\n\n==[[:Category:ALGOL 68|ALGOL 68]][[Category:ALGOL 68]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[ALGOL 68]] version Standard - no extensions to language used[[SMW::on]]<\/div>\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[ALGOL 68G]] version Any - tested with release mk15-0.8b.fc9.i386[[SMW::on]]<\/div>\n<lang algol68>main:(\n   FOR bottles FROM 99 TO 1 BY -1 DO\n     printf(($z-d\" bottles of beer on the wall\"l$, bottles));\n     printf(($z-d\" bottles of beer\"l$, bottles));\n     printf(($\"Take one down, pass it around\"l$));\n     printf(($z-d\" bottles of beer on the wall\"ll$, bottles-1))\n   OD\n)<\/lang>\n\n==[[:Category:AmigaE|AmigaE]][[Category:AmigaE]]==\n<lang amigae>PROC main()\n  DEF t: PTR TO CHAR,\n      s: PTR TO CHAR,\n      u: PTR TO CHAR, i, x\n  t := 'Take one down, pass it around\\n'\n  s := '\\d bottle\\s of beer\\s\\n'\n  u := ' on the wall'\n  FOR i := 99 TO 0 STEP -1\n    ForAll({x}, [u, NIL], `WriteF(s, i, IF i <> 1 THEN 's' ELSE NIL,\n                           x))\n    IF i > 0 THEN WriteF(t)\n  ENDFOR\nENDPROC<\/lang>\n\n==[[:Category:Ant|Ant]][[Category:Ant]]==\nImplementation in Apache Ant, due to the limitations of Ant, this requires ant-contrib for arithmetic operations and a dummy target to keep Ant from detecting the loop.\n<lang xml><?xml version=\"1.0\"?>\n<project name=\"n bottles\" default=\"99_bottles\">\n\n  <!-- ant-contrib.sourceforge.net for arithmetic and if -->\n  <taskdef resource=\"net\/sf\/antcontrib\/antcontrib.properties\"\/>\n\n  <!-- start count of bottles, you can set this with\n    e.g. ant -f 99.xml -Dcount=10 -->\n  <property name=\"count\" value=\"99\"\/>\n\n  <target name=\"99_bottles\">\n    <antcall target=\"bottle\">\n      \t<param name=\"number\" value=\"${count}\"\/>\n    <\/antcall>\n  <\/target>\n\n  <target name=\"bottle\">\n    <echo message=\"${number} bottles of beer on the wall\"\/>\n    <echo message=\"${number} bottles of beer\"\/>\n    <echo message=\"Take one down, pass it around\"\/>\n\n    <math result=\"result\" operand1=\"${number}\" operation=\"-\" operand2=\"1\" datatype=\"int\"\/>\n\n    <echo message=\"${result} bottles of beer on the wall\"\/>\n\n    <if>\n      <not><equals arg1=\"${result}\" arg2=\"0\" \/><\/not>\n      <then>\n        <antcall target=\"bottleiterate\">\n          <param name=\"number\" value=\"${result}\"\/>\n        <\/antcall>\n      <\/then>\n    <\/if>\n  <\/target>\n\n  <target name=\"bottleiterate\">\n    <antcall target=\"bottle\">\n      \t<param name=\"number\" value=\"${number}\"\/>\n    <\/antcall>\n  <\/target>\n\n<\/project><\/lang>\n\n==[[:Category:APL|APL]][[Category:APL]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Dyalog APL]][[SMW::on]]<\/div>\n\n<div class=\"examplemeta translation\">'''Translation of''': [[99 Bottles of Beer#J|J]]<\/div>\n      bob  \u2190  { (\u2355\u2375), ' bottle', (1=\u2375)\u2193's of beer'}\n      bobw \u2190  {(bob \u2375) , ' on the wall'}\n      beer \u2190  { (bobw \u2375) , ', ', (bob \u2375) , '; take one down and pass it around, ', bobw \u2375-1}\n      \u2191beer\u00a8 \u233d(1-\u2395IO)+\u237399\n==[[:Category:Arbre|Arbre]][[Category:Arbre]]==\n<lang Arbre>\nbottle(x):\n  template: '\n  $x bottles of beer on the wall.\n  $x bottles of beer.\n  Take one down and pass it around,\n  $y bottles of beer on the wall.\n  '\n\n  if x==0\n    template~{x: 'No more', y: 'No more'}\n  else\n    if x==1\n      template~{x: x, y: 'No more'}\n    else\n      template~{x: x, y: x-1}\n\nbottles(n):\n  for x in [n..0]\n    bottle(x)\n\n99bottles():\n  bottles(99) -> io\n\n<\/lang>\n\n==[[:Category:Argile|Argile]][[Category:Argile]]==\n<lang Argile>use std\n\nlet X be an int\nfor each X from 99 down to 1\n  prints X bottles of beer on the wall\n  prints X bottles of beer\n  prints \"Take one down, pass it\" around\n  if X == 1\n    echo No more \"beer.\" Call da \"amber lamps\"\n    break\n  X--\n  prints X bottles of beer on the wall \"\\n\"\n  X++\n  .:around :. -> text {X>59 ? \"around\", \"to me\"}\n  .:bottles:. -> text {X> 5 ? \"bottles\", (X>1 ? \"buttles\", \"wall\")}\n  .:of beer:. -> text {X>11 ? \"of beer\", \"ov beeer\"}\n  .:on the wall:. -> text {\n    X>17 ? \"on the wall\", (X>1 ? \"on the bwall\", \"in the buttle\")\n  }<\/lang>\n\n==[[:Category:ATS|ATS]][[Category:ATS]]==\n<lang ATS>\/* .<n>. is a termination metric to prove that the function terminates. It can be omitted. *\/\nfun bottles {n:nat} .<n>. (n: int n): void =\n    if n = 0 then\n        ()\n    else begin\n        printf (\"%d bottles of beer on the wall\\n\", @(n));\n        printf (\"%d bottles of beer\\n\", @(n));\n        printf (\"Take one down, pass it around\\n\", @());\n        printf (\"%d bottles of beer on the wall\\n\", @(n-1));\n        bottles (n - 1)\n    end\n\nimplement main () = bottles (99)<\/lang>\n\n==[[:Category:AutoHotkey|AutoHotkey]][[Category:AutoHotkey]]==\n<lang AutoHotkey>; RC: 99 bottles of beer\n   b = 99\n   Loop, %b% {\n      s .= b . \" bottles of beer on the wall,`n\"\n        . b . \" bottles of beer.`nTake one down, pass it around,`n\"\n        . b-1 . \" bottles of beer on the wall.`n`n\"\n      b--\n   }\n   Gui, Add, Edit, w200 h200, %s%\n   Gui, Show, , 99 bottles of beer\nReturn ; end of auto-execute section\n\nGuiClose:\n   ExitApp\nReturn<\/lang>\n\nDelayed Sing along\n<lang AutoHotkey>n=99\nGui, Font, s20 cMaroon, Comic Sans MS\nGui, Add, Text, w500 vLyrics, %n% bottles of beer on the wall...\nGui, Show\nLoop {\n Sleep, 2000\n GuiControl,,Lyrics,% n!=1 ? n \" bottles of beer.\":n \" bottle of beer.\"\n Sleep, 2000\n GuiControl,,Lyrics,% n ? \"Take one down, pass it around...\":\"Go to the store, buy some more...\"\n Sleep, 2000\n n := n ? --n:99\n GuiControl,,Lyrics,% n!=1 ? n \" bottles of beer on the wall.\":n \" bottle of beer on the wall.\"\n Sleep, 2000\n GuiControl,,Lyrics,% n!=1 ? n \" bottles of beer on the wall...\":n \" bottle of beer on the wall...\"\n}\nGuiClose:\nExitApp<\/lang>\n\nFast and Short\n<lang AutoHotkey>b=99\nLoop, %b% {\ns := b \" bottles of beer on the wall, \" b \" bottles of beer, Take one down, pass it around \" b-1 \" bottles of beer on the wall\"\nb--\nTrayTip,,%s%\nsleep, 40\n}<\/lang>\n\nWith a GUI and slight grammatical variation:\n<lang AutoHotkey>N=o more\nZ=99\nL:=Z M:=(B:=\" bottle\")\"s\"\nLoop 99\nV.=L (W:=(O:=\" of beer\")\" on the wall\")\",`n\"L O \",`nTake one down and pass it around,`n\"(L:=(--Z ? Z:\"N\"N)(Z=1 ? B:M))W \".`n`n\"\nGui,Add,Edit,w600 h250,% V L W \", n\"N M O \".`nGo to the store and buy some more, 99\"M W \".\"\nGui,Show\nReturn\nGuiClose:\nExitApp<\/lang>\n\n==[[:Category:AutoIt|AutoIt]][[Category:AutoIt]]==\n<lang AutoIt>\n\n\nlocal $bottleNo=99\nlocal $lyrics=\" \"\n\nWhile $bottleNo<>0\n\tIf $bottleNo=1 Then\n\t\t$lyrics&=$bottleNo & \" bottles of beer on the wall\" & @CRLF\n\t\t$lyrics&=$bottleNo & \" bottles of beer\" & @CRLF\n\t\t$lyrics&=\"Take one down, pass it around\" & @CRLF\n\tElse\n\t\t$lyrics&=$bottleNo & \" bottles of beer on the wall\" & @CRLF\n\t\t$lyrics&=$bottleNo & \" bottles of beer\" & @CRLF\n\t\t$lyrics&=\"Take one down, pass it around\" & @CRLF\n\tEndIf\n\tIf $bottleNo=1 Then\n\t\t$lyrics&=$bottleNo-1 & \" bottle of beer\" & @CRLF\n\tElse\n\t\t$lyrics&=$bottleNo-1 & \" bottles of beer\" & @CRLF\n\tEndIf\n\t$bottleNo-=1\nWEnd\nMsgBox(1,\"99\",$lyrics)\n<\/lang>\n\n==[[:Category:AWK|AWK]][[Category:AWK]]==\n<lang awk>{ i = 99\nwhile (i > 0)\n\t{print i, \" bottles of beer on the wall,\"\n\tprint i, \" bottles of beer.\" \n\tprint \"Take one down, pass it around,\"\n\ti--\n\tprint i, \" bottles of beer on the wall\\n\"}}<\/lang>\n\n==[[:Category:Babel|Babel]][[Category:Babel]]==\n<lang babel>main: { 99 bottles }\n\nbottles!:\n    { x set\n        { bw\n        bx cr <<\n        \"Take one down, pass it around\\n\" << \n        1 x -= \n        bw \"\\n\" << }\n    x times }\n\nb  : \" bottles of beer\"\nbx!: { x %d << b )}\nw  : \" on the wall\"\nbw!: { bx w . cr << }\n\nx: [0]<\/lang>\n\n==[[:Category:BASIC|BASIC]][[Category:BASIC]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[QuickBASIC]] version 4.5[[SMW::on]]<\/div>\n===Sound===\nThis version plays the tune 100 times while printing out the lyrics (not synchronized).\n<lang qbasic>PLAY \"<\"\nFOR x = 99 TO 0 STEP -1\n  PRINT x; \"bottles of beer on the wall\"\n  PRINT x; \"bottles of beer\"\n  PRINT \"Take one down, pass it around\"\n  PRINT x-1; \"bottles of beer on the wall\"\n  PRINT\n  PLAY \"e-8e-8e-8<b-8b-8b-8>e-8e-8e-8e-4\"'X bottles of beer on the wall\n  PLAY \"f8f8f8c8c8c8f4\"'X bottles of beer\n  PLAY \"d4d8d8 N0 d8d8d8d4\"'take one down, pass it around\n  PLAY \"<a+8a+8a+8>c8c8d8d+8d+8d+8d+4\"'X-1 bottles of beer on the wall\nNEXT x<\/lang>\n\n===Text===\n<lang qbasic>FOR x = 99 TO 1 STEP -1\n  PRINT x; \"bottles of beer on the wall\"\n  PRINT x; \"bottles of beer\"\n  PRINT \"Take one down, pass it around\"\n  PRINT x-1; \"bottles of beer on the wall\"\n  PRINT\nNEXT x<\/lang>\n\n==[[:Category:Batch File|Batch File]][[Category:Batch File]]==\n<lang dos>@echo off\nsetlocal \n:main\nfor \/L %%i in (99,-1,1) do (\n\tcall :verse %%i\n)\necho no bottles of beer on the wall\necho no bottles of beer\necho go to the store and buy some more\necho 99 bottles of beer on the wall\necho.\nset \/p q=\"Keep drinking? \"\nif %q% == y goto main\nif %q% == Y goto main\ngoto :eof\n\n:verse\ncall :plural %1 res\necho %res% of beer on the wall \necho %res% of beer\ncall :oneit %1 res\necho take %res% down and pass it round\nset \/a c=%1-1\ncall :plural %c% res\necho %res% of beer on the wall\necho.\ngoto :eof\n\n:plural\nif %1 gtr 1 goto :gtr\nif %1 equ 1 goto :equ\nset %2=no bottles\ngoto :eof\n:gtr\nset %2=%1 bottles\ngoto :eof\n:equ\nset %2=1 bottle\ngoto :eof\n\n:oneit\nif %1 equ 1 (\n\tset %2=it\n) else (\n\tset %2=one\n)\ngoto :eof<\/lang>\n\n==[[:Category:BBC BASIC|BBC BASIC]][[Category:BBC BASIC]]==\n\n<lang bbcbasic>\n      N_Bottles = 99\n      \n      beer$ = \" of beer\"\n      wall$ = \" on the wall\"\n      unit$ = \"99 bottles\"\n      \n      WHILE N_Bottles >= 0\n        \n        IF N_Bottles=0 THEN\n          PRINT '\"No more bottles\" beer$ wall$ \", \" unit$ beer$ \".\"\n          PRINT \"Go to the store and buy some more, \";\n        ELSE\n          PRINT 'unit$ beer$ wall$ \", \" unit$ beer$ \".\"\n          PRINT \"Take one down and pass it around, \";\n        ENDIF\n        \n        N_Bottles -= 1\n        \n        CASE N_Bottles OF\n          WHEN 0:\n            unit$ = \"no more bottles\"\n          WHEN 1:\n            unit$ = \"1 bottle\"\n          OTHERWISE:\n            unit$ = STR$((N_Bottles + 100) MOD 100) + \" bottles\"\n        ENDCASE\n        \n        PRINT unit$ beer$ wall$ \".\"\n        \n      ENDWHILE\n      \n      END\n<\/lang>\n\n==[[:Category:Befunge|Befunge]][[Category:Befunge]]==\n\nThis outputs a single CR (ASCII code 13) between verses; this needs changing for systems other than [[DOS]], [[Windows]], and [[Mac OS]].\n\n<lang befunge><v  <.g10\" bottles of beer on the wall\"+*4310     <\nc>:,|\n    <v  <.g10\" bottles of beer\"+*4310\n     >:,|\n        <v  <\"take one down, pass it around\"+*4310\n         >:,|\n            >01g1-:01p                      v\nv  <.g10\" bottles of beer on the wall\"+*4310<\n>:,|\n   >134*+0`                                       |\n                                                  @<\/lang>\n==[[:Category:Bracmat|Bracmat]][[Category:Bracmat]]==\n\nCopy the code to a file called BottlesOfBeer.bra. Start Bracmat and after the <code>{?}<\/code> prompt write <code>get$\"BottlesOfBeer.bra\"<\/code> &lt;Enter&gt;. Then, after the next prompt, write\n<code>!r<\/code> &lt;Enter&gt;. Notice that the lyrics has two more lines at the end:\n\n<pre>No more bottles of beer on the wall, no more bottles of beer.\nGo to the store and buy some more, 99 bottles of beer on the wall.<\/pre>\n\nCode to save to BottlesOfBeer.bra:\n<lang bracmat>{BottlesOfBeer.bra\n\nSee http:\/\/99-bottles-of-beer.net\/}\n\nX=\n  new\n=   n upper nbottles lyrics\n  .   99:?n\n    & ( upper\n      = .@(!arg:%@?a ?z)&str$(upp$!a !z)\n      )\n    & ( nbottles\n      =   \n        .   str\n          $ ( (   !arg:>0\n                &   !arg\n                    \" bottle\"\n                    (!arg:1&|s)\n              | \"no more bottles\"\n              )\n              \" of beer\"\n            )\n      )\n    & ( lyrics\n      =   (upper$(nbottles$!n:?x) \" on the wall, \" !x \".\\n\")\n          (   !n+-1:?n:~<0\n            &   \"Take one down and pass it around, \"\n                nbottles$!n\n                \" on the wall.\n\n\"\n                !lyrics\n          |   \"Go to the store and buy some more, \"\n              nbottles$99\n              \" on the wall.\n\"\n          )\n      )\n    & put$(str$!lyrics);\n\nr=\n  get'\"BottlesOfBeer.bra\"\n& rmv$(str$(BottlesOfBeer \".bak\"))\n& ren$(\"BottlesOfBeer.bra\".str$(BottlesOfBeer \".bak\"))\n&   put\n  $ ( \"{BottlesOfBeer.bra\n\nSee http:\/\/99-bottles-of-beer.net\/}\n\n\"\n    , \"BottlesOfBeer.bra\"\n    , NEW\n    )\n& lst'(X,\"BottlesOfBeer.bra\",APP)\n& put'(\\n,\"BottlesOfBeer.bra\",APP)\n& lst'(r,\"BottlesOfBeer.bra\",APP)\n& put$(str$(\"\\nnew'\" X \";\\n\"),\"BottlesOfBeer.bra\",APP);\n\nnew'X;\n<\/lang>\n\n==[[:Category:Brainf***|Brainf***]][[Category:Brainf***]]==\n<lang bf>>+++++++++[<+++++++++++>-]<[>[-]>[-]<<[>+>+<<-]>>[<<+>>-]>>>\n[-]<<<+++++++++<[>>>+<<[>+>[-]<<-]>[<+>-]>[<<++++++++++>>>+<\n-]<<-<-]+++++++++>[<->-]>>+>[<[-]<<+>>>-]>[-]+<<[>+>-<<-]<<<\n[>>+>+<<<-]>>>[<<<+>>>-]>[<+>-]<<-[>[-]<[-]]>>+<[>[-]<-]<+++\n+++++[<++++++<++++++>>-]>>>[>+>+<<-]>>[<<+>>-]<[<<<<<.>>>>>-\n]<<<<<<.>>[-]>[-]++++[<++++++++>-]<.>++++[<++++++++>-]<++.>+\n++++[<+++++++++>-]<.><+++++..--------.-------.>>[>>+>+<<<-]>\n>>[<<<+>>>-]<[<<<<++++++++++++++.>>>>-]<<<<[-]>++++[<+++++++\n+>-]<.>+++++++++[<+++++++++>-]<--.---------.>+++++++[<------\n---->-]<.>++++++[<+++++++++++>-]<.+++..+++++++++++++.>++++++\n++[<---------->-]<--.>+++++++++[<+++++++++>-]<--.-.>++++++++\n[<---------->-]<++.>++++++++[<++++++++++>-]<++++.-----------\n-.---.>+++++++[<---------->-]<+.>++++++++[<+++++++++++>-]<-.\n>++[<----------->-]<.+++++++++++..>+++++++++[<---------->-]<\n-----.---.>>>[>+>+<<-]>>[<<+>>-]<[<<<<<.>>>>>-]<<<<<<.>>>+++\n+[<++++++>-]<--.>++++[<++++++++>-]<++.>+++++[<+++++++++>-]<.\n><+++++..--------.-------.>>[>>+>+<<<-]>>>[<<<+>>>-]<[<<<<++\n++++++++++++.>>>>-]<<<<[-]>++++[<++++++++>-]<.>+++++++++[<++\n+++++++>-]<--.---------.>+++++++[<---------->-]<.>++++++[<++\n+++++++++>-]<.+++..+++++++++++++.>++++++++++[<---------->-]<\n-.---.>+++++++[<++++++++++>-]<++++.+++++++++++++.++++++++++.\n------.>+++++++[<---------->-]<+.>++++++++[<++++++++++>-]<-.\n-.---------.>+++++++[<---------->-]<+.>+++++++[<++++++++++>-\n]<--.+++++++++++.++++++++.---------.>++++++++[<---------->-]\n<++.>+++++[<+++++++++++++>-]<.+++++++++++++.----------.>++++\n+++[<---------->-]<++.>++++++++[<++++++++++>-]<.>+++[<----->\n-]<.>+++[<++++++>-]<..>+++++++++[<--------->-]<--.>+++++++[<\n++++++++++>-]<+++.+++++++++++.>++++++++[<----------->-]<++++\n.>+++++[<+++++++++++++>-]<.>+++[<++++++>-]<-.---.++++++.----\n---.----------.>++++++++[<----------->-]<+.---.[-]<<<->[-]>[\n-]<<[>+>+<<-]>>[<<+>>-]>>>[-]<<<+++++++++<[>>>+<<[>+>[-]<<-]\n>[<+>-]>[<<++++++++++>>>+<-]<<-<-]+++++++++>[<->-]>>+>[<[-]<\n<+>>>-]>[-]+<<[>+>-<<-]<<<[>>+>+<<<-]>>>[<<<+>>>-]<>>[<+>-]<\n<-[>[-]<[-]]>>+<[>[-]<-]<++++++++[<++++++<++++++>>-]>>>[>+>+\n<<-]>>[<<+>>-]<[<<<<<.>>>>>-]<<<<<<.>>[-]>[-]++++[<++++++++>\n-]<.>++++[<++++++++>-]<++.>+++++[<+++++++++>-]<.><+++++..---\n-----.-------.>>[>>+>+<<<-]>>>[<<<+>>>-]<[<<<<++++++++++++++\n.>>>>-]<<<<[-]>++++[<++++++++>-]<.>+++++++++[<+++++++++>-]<-\n-.---------.>+++++++[<---------->-]<.>++++++[<+++++++++++>-]\n<.+++..+++++++++++++.>++++++++[<---------->-]<--.>+++++++++[\n<+++++++++>-]<--.-.>++++++++[<---------->-]<++.>++++++++[<++\n++++++++>-]<++++.------------.---.>+++++++[<---------->-]<+.\n>++++++++[<+++++++++++>-]<-.>++[<----------->-]<.+++++++++++\n..>+++++++++[<---------->-]<-----.---.+++.---.[-]<<<]<\/lang>\n\n==[[:Category:Brat|Brat]][[Category:Brat]]==\n<lang brat>99.to 2 { n |\n  p \"#{n} bottles of beer on the wall, #{n} bottles of beer!\"\n  p \"Take one down, pass it around, #{n - 1} bottle#{true? n > 2 's' ''} of beer on the wall.\"\n}\n\np \"One bottle of beer on the wall, one bottle of beer!\"\np \"Take one down, pass it around, no more bottles of beer on the wall.\"<\/lang>\n\n==[[:Category:C|C]][[Category:C]]==\n<div class=\"examplemeta translation\">'''Translation of''': [[99 Bottles of Beer#C++|C++]]<\/div>\n=== The simple solution ===\n<lang c>#include <stdlib.h>\n#include <stdio.h>\n\nint main(void)\n{\n  unsigned int bottles = 99;\n  do\n  {\n    printf(\"%u bottles of beer on the wall\\n\", bottles);\n    printf(\"%u bottles of beer\\n\", bottles);\n    printf(\"Take one down, pass it around\\n\");\n    printf(\"%u bottles of beer on the wall\\n\\n\", --bottles);\n  } while(bottles > 0);\n  return EXIT_SUCCESS;\n}<\/lang>\n\n=== Code golf ===\n<lang c>#include <stdio.h>\nmain(){_=100;while(--_)printf(\"%i bottle%s of beer in the wall,\\n%i bottle%\"\n\"s of beer.\\nTake one down, pass it round,\\n%s%s\\n\\n\",_,_-1?\"s\":\"\",_,_-1?\"s\"\n:\"\",_-1?(char[]){(_-1)\/10?(_-1)\/10+48:(_-1)%10+48,(_-1)\/10?(_-1)%10+48:2+30,\n(_-1)\/10?32:0,0}:\"\",_-1?\"bottles of beer in the wall\":\"No more beers\");}<\/lang>\n\n=== A preprocessor solution ===\nOf course, with the template metaprogramming solution, the program has still do the conversion of numbers to strings at runtime, and those function calls also cost unnecessary time. Couldn't we just compose the complete text at compile time, and just output it at run time? Well, with the preprocessor, that's indeed possible:\n\n<lang c>#include <stdlib.h>\n#include <stdio.h>\n\n#define BOTTLE(nstr) nstr \" bottles of beer\"\n\n#define WALL(nstr) BOTTLE(nstr) \" on the wall\"\n\n#define PART1(nstr) WALL(nstr) \"\\n\" BOTTLE(nstr) \\\n                    \"\\nTake one down, pass it around\\n\"\n\n#define PART2(nstr) WALL(nstr) \"\\n\\n\"\n\n#define MIDDLE(nstr) PART2(nstr) PART1(nstr)\n\n#define SONG PART1(\"100\") CD2 PART2(\"0\")\n\n#define CD2 CD3(\"9\") CD3(\"8\") CD3(\"7\") CD3(\"6\") CD3(\"5\") \\\n        CD3(\"4\") CD3(\"3\") CD3(\"2\") CD3(\"1\") CD4(\"\")\n\n#define CD3(pre) CD4(pre) MIDDLE(pre \"0\")\n\n#define CD4(pre) MIDDLE(pre \"9\") MIDDLE(pre \"8\") MIDDLE(pre \"7\") \\\n MIDDLE(pre \"6\") MIDDLE(pre \"5\") MIDDLE(pre \"4\") MIDDLE(pre \"3\") \\\n MIDDLE(pre \"2\") MIDDLE(pre \"1\")\n\nint main(void)\n{\n  (void) printf(SONG);\n  return EXIT_SUCCESS;\n}<\/lang>\n\nAn inspection of the generated executable proves that it indeed contains the complete text of the song in one block.\n\n===The bottled version===\nWYSIWYG (with correct plurals and can buy some more):<lang c>      int b =99,u =1;\n     #include<stdio.h>\n      char *d[16],y[]\n      = \"#:ottle\/ of\"\n      \":eer_ a_Go<o5\"\n      \"st>y\\x20some6\"\n      \"_Take8;down4p\"\n      \"a=1rou7_17 _<\"\n      \"h;_ m?_nd_ on\"\n      \"_085wal\" \"l_ \"\n      \"b_e _ t_ss it\"\n      \"_?4bu_ore_9, \"\n      \"\\060.\"\"@, 9$\";\n     # define x  c  ^=\n    #include <string.h>\n   #define or(t,z) else\\\n  if(c==t && !(c = 0) &&\\\n (c =! z)); int p(char *t)\n{ char *s = t; int c; for (\nd[c = 0] = y; !t && (d[c +1\n]= strchr(s = d[c], '_'));*\n(d[++c]++) = 0); for(t = s?\ns:t;(c= *s++); c && putchar\n(c)) { if (!((( x 48)& ~0xf\n) && ( x 48)) ) p(d[c]), c=\n0 ; or('$', p(b - 99?\".\\n\":\n\".\" ) && p(b - 99? t : \"\"))\nor ('\\x40', c && p( d[!!b--\n+ 2])) or('\/', c && p( b^1?\n\"s\": \"\")) or ('\\043', b++ ?\np(\"So6\" + --b):!printf(\"%d\"\n, b ? --b : (b += 99))) or(\n'S',!(++u % 3) * 32+ 78) or\n('.', puts(\".\"))}return c;}\n int main() {return p(0);}<\/lang>\n\n==[[:Category:C++|C++]][[Category:C++]]==\n=== The simple solution ===\n<lang cpp>#include <iostream>\nusing namespace std;\n\nint main() \n{\n int bottles = 99;\n   do {\n     cout << bottles << \" bottles of beer on the wall\" << endl;\n     cout << bottles << \" bottles of beer\" << endl;\n     cout << \"Take one down, pass it around\" << endl;\n     cout << --bottles << \" bottles of beer on the wall\\n\" << endl;\n   } while (bottles > 0);\n}<\/lang>\n\n=== An object-oriented solution ===\nSee: [[99 Bottles of Beer\/C++\/Object Oriented]]\n\n=== A template metaprogramming solution ===\nOf course, the output of the program always looks the same. One may therefore question why the program has to do all that tedious subtracting during runtime. Couldn't the compiler just generate the code to output the text, with ready-calculated constants? Indeed, it can, and the technique is called template metaprogramming. The following short code gives the text without containing a single variable, let alone a loop:\n\n<lang cpp>#include <iostream>\n\ntemplate<int max, int min> struct bottle_countdown\n{\n  static const int middle = (min + max)\/2;\n  static void print()\n  {\n    bottle_countdown<max, middle+1>::print();\n    bottle_countdown<middle, min>::print();\n  }\n};\n\ntemplate<int value> struct bottle_countdown<value, value>\n{\n  static void print()\n  {\n    std::cout << value << \" bottles of beer on the wall\\n\"\n              << value << \" bottles of beer\\n\"\n              << \"Take one down, pass it around\\n\"\n              << value-1 << \" bottles of beer\\n\\n\";\n  }\n};\n\nint main()\n{\n  bottle_countdown<100, 1>::print();\n  return 0;\n}<\/lang>\n=== A Recursive solution ===\n<lang cpp>#include <iostream>\nusing namespace std;\nvoid rec(int bottles)\n{\nif ( bottles!=0)    \n {    \n     cout << bottles << \" bottles of beer on the wall\" << endl; \n        cout << bottles << \" bottles of beer\" << endl;\n        cout << \"Take one down, pass it around\" << endl; \n        cout << --bottles << \" bottles of beer on the wall\\n\" << endl;    \n    rec(bottles);\n }  \n}\n\nint main() \n {   \nrec(99);\nsystem(\"pause\");\nreturn 0;\n}\n<\/lang>\n\n=== A preprocessor solution ===\nOf course, with the template metaprogramming solution, the program has still do the conversion of numbers to strings at runtime, and those function calls also cost unnecessary time. Couldn't we just compose the complete text at compile time, and just output it at run time? Well, with the preprocessor, that's indeed possible:\n\n<lang cpp>#include <iostream>\n#include <ostream>\n\n#define BOTTLE(nstr) nstr \" bottles of beer\"\n\n#define WALL(nstr) BOTTLE(nstr) \" on the wall\"\n\n#define PART1(nstr) WALL(nstr) \"\\n\" BOTTLE(nstr) \\\n                    \"\\nTake one down, pass it around\\n\"\n\n#define PART2(nstr) WALL(nstr) \"\\n\\n\"\n\n#define MIDDLE(nstr) PART2(nstr) PART1(nstr)\n\n#define SONG PART1(\"100\") CD2 PART2(\"0\")\n\n#define CD2 CD3(\"9\") CD3(\"8\") CD3(\"7\") CD3(\"6\") CD3(\"5\") \\\n        CD3(\"4\") CD3(\"3\") CD3(\"2\") CD3(\"1\") CD4(\"\")\n\n#define CD3(pre) CD4(pre) MIDDLE(pre \"0\")\n\n#define CD4(pre) MIDDLE(pre \"9\") MIDDLE(pre \"8\") MIDDLE(pre \"7\") \\\n MIDDLE(pre \"6\") MIDDLE(pre \"5\") MIDDLE(pre \"4\") MIDDLE(pre \"3\") \\\n MIDDLE(pre \"2\") MIDDLE(pre \"1\")\n\nint main()\n{\n  std::cout << SONG;\n  return 0;\n}<\/lang>\n\n==<span id=\"C sharp\">[[:Category:C sharp|C#]]<\/span>[[Category:C sharp]]==\n<lang csharp>using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        for (int i = 99; i > -1; i--)\n        {\n            if (i == 0)\n            {\n                Console.WriteLine(\"No more bottles of beer on the wall, no more bottles of beer.\");\n                Console.WriteLine(\"Go to the store and buy some more, 99 bottles of beer on the wall.\");\n                break;\n            }\n            if (i == 1)\n            {\n                Console.WriteLine(\"1 bottle of beer on the wall, 1 bottle of beer.\");\n                Console.WriteLine(\"Take one down and pass it around, no more bottles of beer on the wall.\");\n                Console.WriteLine();\n            }\n            else\n            {\n                Console.WriteLine(\"{0} bottles of beer on the wall, {0} bottles of beer.\", i);\n                Console.WriteLine(\"Take one down and pass it around, {0} bottles of beer on the wall.\", i - 1);\n                Console.WriteLine();\n            }\n        }\n    }\n}<\/lang>\n\n=== Another Implementation using Linq ===\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[C sharp|C#]] version 3+[[SMW::on]]<\/div>\n\n<lang csharp>using System;\nusing System.Linq;\n\nclass Program\n{\n    static void Main()\n    {\n        var query = from total in Enumerable.Range(0,100).Reverse()\n                    select (total > 0)\n                        ? string.Format(\"{0} bottles of beer on the wall\\n{0} bottles of beer\\nTake one down, pass it around\", total)\n                        : string.Format(\"{0} bottles left\", total);\n            \n        foreach (var item in query)\n        {\n            Console.WriteLine(item);\n        }\n    }\n}<\/lang>\n\n=== Using iterator blocks ===\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[C sharp|C#]] version 3+[[SMW::on]]<\/div>\n\n<lang csharp>using System;\nusing System.Linq;\n\nclass Program\n{\n    static void Main()\n    {\n        BeerBottles().Take(99).ToList().ForEach(Console.WriteLine);\t\n    }\n\n    static IEnumerable<String> BeerBottles()\n    {\n        int i = 100;\n        String f = \"{0}, {1}. Take one down, pass it around, {2}\";\n        Func<int, bool, String> booze = (c , b) => \n            String.Format(\"{0} bottle{1} of beer{2}\", c > 0 ? c.ToString() : \"no more\", (c == 1 ? \"\" : \"s\"), b ? \" on the wall\" : \"\");\n\t\n        while (--i >= 1) \n            yield return String.Format(f, booze(i, true), booze(i, false), booze(i - 1, true));\n    }\n}<\/lang>\n\n==[[:Category:Clay|Clay]][[Category:Clay]]==\n\n<lang Clay>\/* A few options here: I could give n type Int; or specify that n is of any\n   numeric type; but here I just let it go -- that way it'll work with anything\n   that compares with 1 and that printTo knows how to convert to a string. And\n   all checked at compile time, remember. *\/\ngetRound(n) {\n    var s      = String();\n    var bottle = if (n == 1) \" bottle \" else \" bottles \";\n    \n    printTo(s, \n            n, bottle, \"of beer on the wall\\n\",\n            n, bottle, \"of beer\\n\",\n            \"take one down, pass it around\\n\",\n            n, bottle, \"of beer on the wall!\\n\");\n    \n    return s;\n}\n\nmain() {\n    println(join(\"\\n\", mapped(getRound, reversed(range(100)))));\n}\n<\/lang>\n\n==[[:Category:Chapel|Chapel]][[Category:Chapel]]==\ncopied from http:\/\/99-bottles-of-beer.net\/language-chapel-1215.html\n<lang Chapel>\n\/***********************************************************************\n * Chapel implementation of \"99 bottles of beer\"\n *\n * by Brad Chamberlain and Steve Deitz\n * 07\/13\/2006 in Knoxville airport while waiting for flight home from\n *            HPLS workshop\n * compiles and runs with chpl compiler version 0.3.3211\n * for more information, contact: chapel_info@cray.com\n * \n *\n * Notes: \n * o as in all good parallel computations, boundary conditions\n *   constitute the vast bulk of complexity in this code (invite Brad to\n *   tell you about his zany boundary condition simplification scheme)\n * o uses type inference for variables, arguments\n * o relies on integer->string coercions\n * o uses named argument passing (for documentation purposes only)\n ***********************************************************************\/\n\n\/\/ allow executable command-line specification of number of bottles \n\/\/ (e.g., .\/a.out -snumBottles=999999)\nconfig const numBottles = 99;\nconst numVerses = numBottles+1;\n\n\/\/ a domain to describe the space of lyrics\nvar LyricsSpace: domain(1) = [1..numVerses];\n\n\/\/ array of lyrics\nvar Lyrics: [LyricsSpace] string;\n\n\/\/ parallel computation of lyrics array\n[verse in LyricsSpace] Lyrics(verse) = computeLyric(verse);\n\n\/\/ as in any good parallel language, I\/O to stdout is serialized.\n\/\/ (Note that I\/O to a file could be parallelized using a parallel\n\/\/ prefix computation on the verse strings' lengths with file seeking)\nwriteln(Lyrics);\n\n\n\/\/ HELPER FUNCTIONS:\n\nfun computeLyric(verseNum) {\n  var bottleNum = numBottles - (verseNum - 1);\n  var nextBottle = (bottleNum + numVerses - 1)%numVerses;\n  return \"\\n\" \/\/ disguise space used to separate elements in array I\/O\n       + describeBottles(bottleNum, startOfVerse=true) + \" on the wall, \"\n       + describeBottles(bottleNum) + \".\\n\"\n       + computeAction(bottleNum)\n       + describeBottles(nextBottle) + \" on the wall.\\n\";\n}\n\n\nfun describeBottles(bottleNum, startOfVerse:bool = false) {\n\/\/ NOTE: bool should not be necessary here (^^^^); working around bug\n  var bottleDescription = if (bottleNum) then bottleNum:string \n                                         else (if startOfVerse then \"N\" \n                                                               else \"n\") \n                                              + \"o more\";\n  return bottleDescription \n       + \" bottle\" + (if (bottleNum == 1) then \"\" else \"s\") \n       + \" of beer\";\n}\n\n\nfun computeAction(bottleNum) {\n  return if (bottleNum == 0) then \"Go to the store and buy some more, \"\n                             else \"Take one down and pass it around, \";\n}\n<\/lang>\n\n==[[:Category:Chef|Chef]][[Category:Chef]]==\n<lang chef>99 Bottles Of Beer.\n\nIngredients.\n99 bottles\n\nMethod.\nLoop the bottles.\n\tPut bottles into 1st mixing bowl.\n\tServe with bottles of beer on the wall.\t\n\tClean 1st mixing bowl.\n\tPut bottles into 1st mixing bowl.\n\tServe with bottles of beer.\n\tClean 1st mixing bowl.\n\tServe with Take one down and pass it around.\n\tClean 1st mixing bowl.\t\t\t\nLoop the bottles until looped.\nServe with No more bottles of beer.\nClean 1st mixing bowl.\nPour contents of the 3rd mixing bowl into the 1st baking dish.\n\nServes 1.\n\nbottles of beer on the wall.\n\nPrints out \"n\" bottles of beer on the wall.\n\nIngredients.\n108 g lime\n97 cups asparagus\n119 pinches watercress\n32 tablespoons pickles\n101 pinches eggplant\n104 g huckleberry\n116 teaspoons turnip\n110 tablespoons nannyberry\n111 tablespoons onion\n114 tablespoons raspberry\n98 g broccoli\n102 g feijoa\n115 teaspoons squach\n10 ml new line\n\nMethod.\nPut new line into 1st mixing bowl.\nPut lime into 2nd mixing bowl.\nPut lime into 2nd mixing bowl.\nPut asparagus into 2nd mixing bowl.\nPut watercress into 2nd mixing bowl.\nPut pickles into 2nd mixing bowl.\nPut eggplant into 2nd mixing bowl.\nPut huckleberry into 2nd mixing bowl.\nPut turnip into 2nd mixing bowl.\nPut pickles into 2nd mixing bowl.\nPut nannyberry into 2nd mixing bowl.\nPut onion into 2nd mixing bowl.\nPut pickles into 2nd mixing bowl.\nPut raspberry into 2nd mixing bowl.\nPut eggplant into 2nd mixing bowl.\nPut eggplant into 2nd mixing bowl.\nPut broccoli into 2nd mixing bowl.\nPut pickles into 2nd mixing bowl.\nPut feijoa into 2nd mixing bowl.\nPut onion into 2nd mixing bowl.\nPut pickles into 2nd mixing bowl.\nPut squach into 2nd mixing bowl.\nPut eggplant into 2nd mixing bowl.\nPut lime into 2nd mixing bowl.\nPut turnip into 2nd mixing bowl.\nPut turnip into 2nd mixing bowl.\nPut onion into 2nd mixing bowl.\nPut broccoli into 2nd mixing bowl.\nPut pickles into 2nd mixing bowl.\nLiquify contents of the 2nd mixing bowl.\nPour contents of the 2nd mixing bowl into the baking dish.\nPour contents of the mixing bowl into the baking dish.\nRefrigerate for 1 hour.\n\nbottles of beer.\n\nPrints out \"n\" bottles of beer.\n\nIngredients.\n114 tablespoons raspberry\n101 pinches eggplant\n98 teaspoons broccoli\n32 pinches pickles\n102 tablespoons feijoa\n111 teaspoons onion\n115 cups squach\n108 cups lime\n116 teaspoons turnip\n10 ml new line\n\nMethod.\nPut new line into 1st mixing bowl.\nPut raspberry into 2nd mixing bowl.\nPut eggplant into 2nd mixing bowl.\nPut eggplant into 2nd mixing bowl.\nPut broccoli into 2nd mixing bowl.\nPut pickles into 2nd mixing bowl.\nPut feijoa into 2nd mixing bowl.\nPut onion into 2nd mixing bowl.\nPut pickles into 2nd mixing bowl.\nPut squach into 2nd mixing bowl.\nPut eggplant into 2nd mixing bowl.\nPut lime into 2nd mixing bowl.\nPut turnip into 2nd mixing bowl.\nPut turnip into 2nd mixing bowl.\nPut onion into 2nd mixing bowl.\nPut broccoli into 2nd mixing bowl.\nPut pickles into 2nd mixing bowl.\nLiquify contents of the 2nd mixing bowl.\nPour contents of the 2nd mixing bowl into the baking dish.\nPour contents of the mixing bowl into the baking dish.\nRefrigerate for 1 hour.\n\nTake one down and pass it around.\n\nPrints out \"Take one down and pass it around\".\n\nIngredients.\n100 cups dandelion\n110 g nannyberry\n117 pinches cucumber\n111 pinches onion\n114 pinches raspberry\n97 g asparagus\n32 tablespoons pickles\n116 pinches turnip\n105 g chestnut\n115 g squach\n112 g pumpkin\n119 cups watercress\n101 g eggplant\n107 g kale\n84 cups tomatoe\n10 ml new line\n\nMethod.\nPut new line into 3rd mixing bowl.\nPut dandelion into 2nd mixing bowl.\nPut nannyberry into 2nd mixing bowl.\nPut cucumber into 2nd mixing bowl.\nPut onion into 2nd mixing bowl.\nPut raspberry into 2nd mixing bowl.\nPut asparagus into 2nd mixing bowl.\nPut pickles into 2nd mixing bowl.\nPut turnip into 2nd mixing bowl.\nPut chestnut into 2nd mixing bowl.\nPut pickles into 2nd mixing bowl.\nPut squach into 2nd mixing bowl.\nPut squach into 2nd mixing bowl.\nPut asparagus into 2nd mixing bowl.\nPut pumpkin into 2nd mixing bowl.\nPut pickles into 2nd mixing bowl.\nPut dandelion into 2nd mixing bowl.\nPut nannyberry into 2nd mixing bowl.\nPut asparagus into 2nd mixing bowl.\nPut pickles into 2nd mixing bowl.\nPut nannyberry into 2nd mixing bowl.\nPut watercress into 2nd mixing bowl.\nPut onion into 2nd mixing bowl.\nPut dandelion into 2nd mixing bowl.\nPut pickles into 2nd mixing bowl.\nPut eggplant into 2nd mixing bowl.\nPut nannyberry into 2nd mixing bowl.\nPut onion into 2nd mixing bowl.\nPut pickles into 2nd mixing bowl.\nPut eggplant into 2nd mixing bowl.\nPut kale into 2nd mixing bowl.\nPut asparagus into 2nd mixing bowl.\nPut tomatoe into 2nd mixing bowl.\nLiquify contents of the 2nd mixing bowl.\nPour contents of the 2nd mixing bowl into the baking dish.\nPour contents of the 3rd mixing bowl into the baking dish.\nRefrigerate for 1 hour.\n\nNo more bottles of beer.\n\nPrints out \"No more bottles of beer\".\n\nIngredients.\n114 pinches raspberry\n101 teaspoons eggplant\n98 cups broccoli\n32 tablespoons pickles\n102 pinches feijoa\n111 cups onion\n115 tablespoons squach\n108 tablespoons lime\n116 pinches turnip\n109 cups mushrooms\n78 g nectarine\n10 ml new line\n\nMethod.\nPut new line into 3rd mixing bowl.\nPut new line into 2nd mixing bowl.\nPut raspberry into 2nd mixing bowl.\nPut eggplant into 2nd mixing bowl.\nPut eggplant into 2nd mixing bowl.\nPut broccoli into 2nd mixing bowl.\nPut pickles into 2nd mixing bowl.\nPut feijoa into 2nd mixing bowl.\nPut onion into 2nd mixing bowl.\nPut pickles into 2nd mixing bowl.\nPut squach into 2nd mixing bowl.\nPut eggplant into 2nd mixing bowl.\nPut lime into 2nd mixing bowl.\nPut turnip into 2nd mixing bowl.\nPut turnip into 2nd mixing bowl.\nPut onion into 2nd mixing bowl.\nPut broccoli into 2nd mixing bowl.\nPut pickles into 2nd mixing bowl.\nPut eggplant into 2nd mixing bowl.\nPut raspberry into 2nd mixing bowl.\nPut onion into 2nd mixing bowl.\nPut mushrooms into 2nd mixing bowl.\nPut pickles into 2nd mixing bowl.\nPut onion into 2nd mixing bowl.\nPut nectarine into 2nd mixing bowl.\nLiquify contents of the 2nd mixing bowl.\nPour contents of the 2nd mixing bowl into the baking dish.\nPour contents of the 3rd mixing bowl into the baking dish.\nRefrigerate for 1 hour.<\/lang>\n\n==[[:Category:CLIPS|CLIPS]][[Category:CLIPS]]==\n\n<lang clips>(deffacts beer-bottles\n  (bottles 99))\n\n(deffunction bottle-count\n  (?count)\n  (switch ?count\n    (case 0 then \"No more bottles of beer\")\n    (case 1 then \"1 more bottle of beer\")\n    (default (str-cat ?count \" bottles of beer\"))))\n\n(defrule stanza\n  ?bottles <- (bottles ?count)\n  =>\n  (retract ?bottles)\n  (printout t (bottle-count ?count) \" on the wall,\" crlf)\n  (printout t (bottle-count ?count) \".\" crlf)\n  (printout t \"Take one down, pass it around,\" crlf)\n  (printout t (bottle-count (- ?count 1)) \" on the wall.\" crlf crlf)\n  (if (> ?count 1) then (assert (bottles (- ?count 1)))))<\/lang>\n\n==[[:Category:Clojure|Clojure]][[Category:Clojure]]==\n<lang lisp>(defn verse [n]\n  (printf\n\"%d bottles of beer on the wall\n%d bottles of beer\nTake one down, pass it around\n%d bottles of beer on the wall\\n\\n\" n n (dec n)))\n\n(defn sing [start]\n  (dorun (map verse (range start 0 -1))))<\/lang>\n\n==[[:Category:COBOL|COBOL]][[Category:COBOL]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[OpenCOBOL 1.1]][[SMW::on]]<\/div>\nAnother free-form version, with no DISPLAY NO ADVANCING.\n<lang cobol>identification division.\nprogram-id. ninety-nine.\nenvironment division.\ndata division.\nworking-storage section.\n01\tcounter\tpic 99.\n\t88 no-bottles-left value 0.\n\t88 one-bottle-left value 1.\n \n01\tparts-of-counter redefines counter.\n\t05\ttens\t\tpic 9.\n\t05\tdigits\t\tpic 9.\n \n01\tafter-ten-words.\n\t05\tfiller\tpic x(7) value spaces.\n\t05\tfiller\tpic x(7) value \"Twenty\".\n\t05\tfiller\tpic x(7) value \"Thirty\".\n\t05\tfiller\tpic x(7) value \"Forty\".\n\t05\tfiller\tpic x(7) value \"Fifty\".\n\t05\tfiller\tpic x(7) value \"Sixty\".\n\t05\tfiller\tpic x(7) value \"Seventy\".\n\t05\tfiller\tpic x(7) value \"Eighty\".\n\t05\tfiller\tpic x(7) value \"Ninety\".\n\t05\tfiller\tpic x(7) value spaces.\n \n01\tafter-ten-array redefines after-ten-words.\n\t05\tatens occurs 10 times pic x(7).\n \n01\tdigit-words.\n\t05\tfiller\tpic x(9) value \"One\".\n\t05\tfiller\tpic x(9) value \"Two\".\n\t05\tfiller\tpic x(9) value \"Three\".\n\t05\tfiller\tpic x(9) value \"Four\".\n\t05\tfiller\tpic x(9) value \"Five\".\n\t05\tfiller\tpic x(9) value \"Six\".\n\t05\tfiller\tpic x(9) value \"Seven\".\n\t05\tfiller\tpic x(9) value \"Eight\".\n\t05\tfiller\tpic x(9) value \"Nine\".\n\t05\tfiller\tpic x(9) value \"Ten\".\n\t05\tfiller\tpic x(9) value \"Eleven\".\n\t05\tfiller\tpic x(9) value \"Twelve\".\n\t05\tfiller\tpic x(9) value \"Thirteen\".\n\t05\tfiller\tpic x(9) value \"Fourteen\".\n\t05\tfiller\tpic x(9) value \"Fifteen\".\n\t05\tfiller\tpic x(9) value \"Sixteen\".\n\t05\tfiller\tpic x(9) value \"Seventeen\".\n\t05\tfiller\tpic x(9) value \"Eighteen\".\n\t05\tfiller\tpic x(9) value \"Nineteen\".\n\t05\tfiller\tpic x(9) value spaces.\n \n01\tdigit-array redefines digit-words.\n\t05\tadigits occurs 20 times \tpic x(9).\n \n01\tnumber-name pic x(15).\n\n01\tstringified pic x(30).\n01\toutline\t\tpic x(50).\n01  other-numbers.\n\t03\tn\tpic 999.\n\t03\tr\tpic 999.\n\t\nprocedure division.\n100-main section.\n100-setup.\n\tperform varying counter from 99 by -1 until no-bottles-left\n\t\tmove spaces to outline\n\t\tperform 100-show-number\n\t\tstring stringified delimited by \"|\", space, \"of beer on the wall\" into outline end-string\n\t\tdisplay outline end-display\n\t\tmove spaces to outline\n\t\tstring stringified delimited by \"|\", space, \"of beer\" into outline end-string\n\t\tdisplay outline end-display\n\t\tmove spaces to outline\n\t\tmove \"Take\" to outline\n\t\tif one-bottle-left\n\t\t\tstring outline delimited by space, space, \"it\" delimited by size, space, \"|\" into outline end-string\n\t\telse\n\t\t\tstring outline delimited by space, space, \"one\" delimited by size, space, \"|\" into outline end-string\n\t\tend-if\n\t\tstring outline delimited by \"|\", \"down and pass it round\" delimited by size into outline end-string\n\t\tdisplay outline end-display\n\t\tmove spaces to outline\n\t\tsubtract 1 from counter giving counter end-subtract\n\t\tperform 100-show-number\n\t\tstring stringified delimited by \"|\", space, \"of beer on the wall\" into outline end-string\n\t\tdisplay outline end-display\n\t\tadd 1 to counter giving counter end-add\n\t\tdisplay space end-display\n\tend-perform.\n\tdisplay \"No more bottles of beer on the wall\"\n\tdisplay \"No more bottles of beer\"\n\tdisplay \"Go to the store and buy some more\"\n\tdisplay \"Ninety-Nine bottles of beer on the wall\"\n\tstop run.\n \n100-show-number.\n\tif no-bottles-left \n\t\tmove \"No more|\" to stringified\n\telse \n\t\tif counter < 20\n\t\t\tstring function trim( adigits( counter ) ), \"|\" into stringified\n\t\telse \n\t\t\tif counter < 100\n\t\t\t\tmove spaces to number-name\n\t\t\t\tstring atens( tens ) delimited by space, space delimited by size, adigits( digits ) delimited by space into number-name end-string\n\t\t\t\tmove function trim( number-name) to stringified\n\t\t\t\tdivide counter by 10 giving n remainder r end-divide\n\t\t\t\tif r not = zero\n\t\t\t\t\tinspect stringified replacing first space by \"-\" \n\t\t\t\tend-if\n\t\t\t\tinspect stringified replacing first space by \"|\" \n\t\t\tend-if\n\t\tend-if\n\tend-if.\n\tif one-bottle-left\n\t\tstring stringified delimited by \"|\", space, \"bottle|\" delimited by size into stringified end-string\n\telse\n\t\tstring stringified delimited by \"|\", space, \"bottles|\" delimited by size into stringified end-string\n\tend-if.\n \n100-end.\nend-program.<\/lang>\n\nFree form version.\n<lang cobol>identification division.\nprogram-id. ninety-nine.\nenvironment division.\ndata division.\nworking-storage section.\n01\tcounter\tpic 99.\n\t88 no-bottles-left value 0.\n\t88 one-bottle-left value 1.\n\n01\tparts-of-counter redefines counter.\n\t05\ttens\t\tpic 9.\n\t05\tdigits\t\tpic 9.\n\n01\tafter-ten-words.\n\t05\tfiller\tpic x(7) value spaces.\n\t05\tfiller\tpic x(7) value \"Twenty\".\n\t05\tfiller\tpic x(7) value \"Thirty\".\n\t05\tfiller\tpic x(7) value \"Forty\".\n\t05\tfiller\tpic x(7) value \"Fifty\".\n\t05\tfiller\tpic x(7) value \"Sixty\".\n\t05\tfiller\tpic x(7) value \"Seventy\".\n\t05\tfiller\tpic x(7) value \"Eighty\".\n\t05\tfiller\tpic x(7) value \"Ninety\".\n\t05\tfiller\tpic x(7) value spaces.\n\n01\tafter-ten-array redefines after-ten-words.\n\t05\tatens occurs 10 times pic x(7).\n\n01\tdigit-words.\n\t05\tfiller\tpic x(9) value \"One\".\n\t05\tfiller\tpic x(9) value \"Two\".\n\t05\tfiller\tpic x(9) value \"Three\".\n\t05\tfiller\tpic x(9) value \"Four\".\n\t05\tfiller\tpic x(9) value \"Five\".\n\t05\tfiller\tpic x(9) value \"Six\".\n\t05\tfiller\tpic x(9) value \"Seven\".\n\t05\tfiller\tpic x(9) value \"Eight\".\n\t05\tfiller\tpic x(9) value \"Nine\".\n\t05\tfiller\tpic x(9) value \"Ten\".\n\t05\tfiller\tpic x(9) value \"Eleven\".\n\t05\tfiller\tpic x(9) value \"Twelve\".\n\t05\tfiller\tpic x(9) value \"Thirteen\".\n\t05\tfiller\tpic x(9) value \"Fourteen\".\n\t05\tfiller\tpic x(9) value \"Fifteen\".\n\t05\tfiller\tpic x(9) value \"Sixteen\".\n\t05\tfiller\tpic x(9) value \"Seventeen\".\n\t05\tfiller\tpic x(9) value \"Eighteen\".\n\t05\tfiller\tpic x(9) value \"Nineteen\".\n\t05\tfiller\tpic x(9) value spaces.\n\t\n01\tdigit-array redefines digit-words.\n\t05\tadigits occurs 20 times \tpic x(9).\n\t\n01\tnumber-name pic x(15).\n\nprocedure division.\n100-main section.\n100-setup.\n\tperform varying counter from 99 by -1 until no-bottles-left\n\t\tperform 100-show-number\n\t\tdisplay \" of beer on the wall\"\n\t\tperform 100-show-number\n\t\tdisplay \" of beer\"\n\t\tdisplay \"Take \" with no advancing\n\t\tif one-bottle-left \n\t\t\tdisplay \"it \" with no advancing\n\t\telse\n\t\t\tdisplay \"one \" with no advancing\n\t\tend-if\n\t\tdisplay \"down and pass it round\"\n\t\tsubtract 1 from counter giving counter\n\t\tperform 100-show-number\n\t\tdisplay \" of beer on the wall\"\n\t\tadd 1 to counter giving counter\n\t\tdisplay space\n\tend-perform.\n\tdisplay \"No more bottles of beer on the wall\"\n\tdisplay \"No more bottles of beer\"\n\tdisplay \"Go to the store and buy some more\"\n\tdisplay \"Ninety Nine bottles of beer on the wall\"\n\tstop run.\n\t\n100-show-number.\n\tif no-bottles-left \n\t\tdisplay \"No more\" with no advancing\n\telse \n\t\tif counter < 20\n\t\t\tdisplay function trim( adigits( counter ) ) with no advancing\n\t\telse \n\t\t\tif counter < 100\n\t\t\t\tmove spaces to number-name\n\t\t\t\tstring atens( tens ) delimited by space, space delimited by size, adigits( digits ) delimited by space into number-name\n\t\t\t\tdisplay function trim( number-name) with no advancing\n\t\t\tend-if\n\t\tend-if\n\tend-if.\n\tif one-bottle-left\n\t\tdisplay \" bottle\" with no advancing\n\telse\n\t\tdisplay \" bottles\" with no advancing\n\tend-if.\n\n100-end.\nend-program.<\/lang>\n\n==[[:Category:CoffeeScript|CoffeeScript]][[Category:CoffeeScript]]==\n<lang coffeescript>n = 99\nbottles = () -> if n isnt 1 then \"#{n} bottles\" else \"1 bottle\"\n\nwhile n\n    console.log \"\"\"\n    #{bottles()} of beer on the wall\n    #{bottles()} of beer\n    Take one down, pass it around\n    #{n-- and bottles()} of beer on the wall\n    \\r\"\"\"<\/lang>\n\nWith completely different approach...\n\n<lang coffeescript>for j in [99..1]\n    x=''\n    x += [j,j-1,'\\nTake one down, pass it around\\n',\" bottles of beer\",' on the wall\\n'][i] for i in [0,3,4,0,3,2,1,3,4]\n    console.log x.replace \/(1.+)s\/g, '$1'\n<\/lang>\n\nor as a one liner...\n\n<lang coffeescript>console.log( if (j+2)%4 then (x=Math.round j\/4)+\" bottle#{if x-1 then 's' else ''} of beer#{if (j+1)%4 then ' on the wall' else ''}\" else \"Take one down, pass it around\" ) for j in [396..1]<\/lang>\n\nor another completely different one liner\n\n<lang coffeescript>((console.log if i is 2 then \"Take one down, pass it around\" else \"#{b-!(i-1%4)} bottle#{if 4*b+i<10 and b-i then '' else 's'} of beer#{if i%3 then ' on the wall' else ''}\") for i in [4..1]) for b in [99..1]<\/lang>\n\n==[[:Category:ColdFusion|ColdFusion]][[Category:ColdFusion]]==\n=== Classic tag based ===\n<lang Coldfusion><cfoutput>\n  <cfloop index=\"x\" from=\"99\" to=\"0\" step=\"-1\">\n    <cfset plur = iif(x is 1,\"\",DE(\"s\"))>\n    #x# bottle#plur# of beer on the wall<br>\n    #x# bottle#plur# of beer<br>\n    Take one down, pass it around<br>\n    #iif(x is 1,DE(\"No more\"),\"x-1\")# bottle#iif(x is 2,\"\",DE(\"s\"))# of beer on the wall<br><br>\n  <\/cfloop>\n<\/cfoutput><\/lang>\nor if you prefer:  (identical output, grammatically correct to the last stanza)\n=== CFScript ===\n<lang CFScript><cfscript>\n  for (x=99; x gte 1; x--) {\n    plur = iif(x==1,'',DE('s'));\n    WriteOutput(\"#x# bottle#plur# of beer on the wall<br>#x# bottle#plur# of beer<br>Take one down, pass it around<br>#iif(x is 1,DE('No more'),'x-1')# bottle#iif(x is 2,'',DE('s'))# of beer on the wall<br><br>\");\n  }\n<\/cfscript><\/lang>\n\n==[[:Category:Common Lisp|Common Lisp]][[Category:Common Lisp]]==\n<lang lisp>(defun bottles (x)\n  (loop for bottles from x downto 1\n        do (format t \"~a bottle~:p of beer on the wall\n~:*~a bottle~:p of beer\nTake one down, pass it around\n~a bottle~:p of beer on the wall~2%\" bottles (1- bottles))))<\/lang>\nand then just call\n<lang lisp>(bottles 99)<\/lang>\n\n==[[:Category:D|D]][[Category:D]]==\n\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[D]] version 2[[SMW::on]]<\/div>\n\nBased on Steward Gordon's code at: [http:\/\/99-bottles-of-beer.net\/language-d-721.html 99-bottles-of-beer.net].\n<lang d>import std.stdio;\n\nvoid main() {\n    int bottles = 99;\n\n    while (bottles > 1) {\n        writeln(bottles, \" bottles of beer on the wall,\");\n        writeln(bottles, \" bottles of beer.\");\n        writeln(\"Take one down, pass it around,\");\n        if (--bottles > 1) {\n            writeln(bottles, \" bottles of beer on the wall.\\n\");\n        }        \n    }\n    writeln(\"1 bottle of beer on the wall.\\n\");\n\n    writeln(\"No more bottles of beer on the wall,\");\n    writeln(\"no more bottles of beer.\");\n    writeln(\"Go to the store and buy some more,\");\n    writeln(\"99 bottles of beer on the wall.\"); \n}<\/lang>\n\n==[[:Category:Dart|Dart]][[Category:Dart]]==\n<lang dart>main() {\n  for(int x=99;x>0;x--) {\n    print(\"$x bottles of beer on the wall\");\n    print(\"$x bottles of beer\");\n    print(\"Take one down, pass it around\");\n    print(\"${x-1} bottles of beer on the wall\");\n    print(\"\");\n  }\n}<\/lang>\n\n==[[:Category:Delphi|Delphi]][[Category:Delphi]]==\n:''See [[#Pascal|Pascal]]''\n\n:''Or\n\n<lang Delphi>program Hundred_Bottles; \n\n{$APPTYPE CONSOLE} \n\nuses SysUtils; \n\nconst C_1_Down = 'Take one down, pass it around' ; \n\nVar i : Integer ; \n\n\/\/ As requested, some fun : examples of Delphi basic techniques. Just to make it a bit complex \n\nprocedure WriteABottle( BottleNr : Integer ) ; \nbegin \n  Writeln(BottleNr, ' bottles of beer on the wall' ) ; \nend ; \n\nbegin \n  for i := 99 Downto 1 do begin \n  WriteABottle(i); \n  Writeln( Format('%d bottles of beer' , [i] ) ) ; \n  Writeln( C_1_Down ) ; \n  WriteABottle(i-1); \n  Writeln ; \nEnd ; \n\nend.<\/lang>\n\n==[[:Category:Dylan|Dylan]][[Category:Dylan]]==\n<lang dylan>Module: bottles\ndefine method bottles (n :: <integer>)\n  for (n from 99 to 1 by -1)\n    format-out(\"%d bottles of beer on the wall,\\n\"\n               \"%d bottles of beer\\n\"\n               \"Take one down, pass it around\\n\"\n               \"%d bottles of beer on the wall\\n\",\n               n, n, n - 1);\n  end\nend method<\/lang>\n\n==[[:Category:E|E]][[Category:E]]==\n<lang e>def bottles(n) {\n  return switch (n) {\n    match ==0 { \"No bottles\" }\n    match ==1 { \"1 bottle\" }\n    match _   { `$n bottles` }\n  }\n}\nfor n in (1..99).descending() {\n  println(`${bottles(n)} of beer on the wall,\n${bottles(n)} of beer.\nTake one down, pass it around,\n${bottles(n.previous())} of beer on the wall.\n`)\n}<\/lang>\n\n\n==[[:Category:Ela|Ela]][[Category:Ela]]==\n\n<lang Ela>open Core\n\nlet beer 1 = \"1 bottle of beer on the wall\\n1 bottle of beer\\nTake one down, pass it around\"\n    beer 0 = \"better go to the store and buy some more.\"\n    beer v = show v ++ \" bottles of beer on the wall\\n\"                 \n             ++ show v                 \n             ++\" bottles of beer\\nTake one down, pass it around\\n\"\n\nmap beer [99,98..0]<\/lang>\n\n\n==[[:Category:Erlang|Erlang]][[Category:Erlang]]==\n<lang erlang>-module(beersong).\n-export([sing\/0]).\n-define(TEMPLATE_0, \"~s of beer on the wall, ~s of beer.~nGo to the store and buy some more, 99\nbottles of beer on the wall.~n\").\n-define(TEMPLATE_N, \"~s of beer on the wall, ~s of beer.~nTake one down and pass it around, ~s of\nbeer on the wall.~n~n\").\n\ncreate_verse(0)      -> {0, io_lib:format(?TEMPLATE_0, phrase(0))};\ncreate_verse(Bottle) -> {Bottle, io_lib:format(?TEMPLATE_N, phrase(Bottle))}.\n\nphrase(0)      -> [\"No more bottles\", \"no more bottles\"];\nphrase(1)      -> [\"1 bottle\", \"1 bottle\", \"no more bottles\"];\nphrase(2)      -> [\"2 bottles\", \"2 bottles\", \"1 bottle\"];\nphrase(Bottle) -> lists:duplicate(2, integer_to_list(Bottle) ++ \" bottles\") ++\n[integer_to_list(Bottle-1) ++ \" bottles\"].\n\nbottles() -> lists:reverse(lists:seq(0,99)).\n\nsing() ->\n    lists:foreach(fun spawn_singer\/1, bottles()),\n    sing_verse(99).\n\nspawn_singer(Bottle) ->\n    Pid = self(), \n    spawn(fun() -> Pid ! create_verse(Bottle) end).\n\nsing_verse(Bottle) ->\n    receive\n        {_, Verse} when Bottle == 0 ->\n            io:format(Verse);\n        {N, Verse} when Bottle == N ->\n            io:format(Verse),\n            sing_verse(Bottle-1)\n    after \n        3000 ->\n            io:format(\"Verse not received - re-starting singer~n\"),\n            spawn_singer(Bottle),\n            sing_verse(Bottle)\n    end.<\/lang>\n\n==[[:Category:Euphoria|Euphoria]][[Category:Euphoria]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Euphoria]] version 4.0.0[[SMW::on]]<\/div>\nThis is based on the [[Batch File]] example.\n<lang Euphoria>\ninclude std\/console.e\ninclude std\/search.e\n\nfunction one_or_it( atom n )\n\tif n = 1 then\n\t\treturn \"it\"\n\telse\n\t\treturn \"one\"\n\tend if\nend function\n\nfunction numberable( atom n )\n\tif n = 0 then\n\t\treturn \"no\"\n\telse\n\t\treturn sprintf( \"%d\", n )\n\tend if\nend function\n\nfunction plural( atom n )\n\tif n != 1 then\n\t\treturn \"s\"\n\telse\n\t\treturn \"\"\n\tend if\nend function\n\natom stillDrinking = 1\n\nsequence yn\nsequence plurality\nsequence numerality\n\nwhile stillDrinking do\n\tfor bottle = 99 to 1 by -1 do\n\t\tplurality = plural( bottle )\n\t\tnumerality = numberable( bottle )\n\t\tprintf( 1, \"%s bottle%s of beer on the wall\\n%s bottle%s of beer\\n\", \n\t\t\t\t{ numerality, plurality, numerality, plurality } )\n\t\tprintf( 1, \"Take %s down and pass it round\\n\", { one_or_it( bottle ) } )\n\t\tprintf( 1, \"%s bottle%s of beer on the wall\\n\\n\", \n\t\t\t\t{ numberable( bottle - 1 ), plural( bottle - 1 ) } )\n\tend for\n\tputs( 1, \"No more bottles of beer on the wall\\nNo more bottles of beer\\n\" )\n\tputs( 1, \"Go to the store and buy some more\\n99 bottles of beer on the wall\\n\" )\n\tputs( 1, \"\\nKeep drinking? \" )\n\tyn = gets(0)\n\tstillDrinking = find_any( \"yY\", yn )\n\tputs( 1, \"\\n\" )\nend while<\/lang>\n\n==[[:Category:Extended BrainF***|Extended BrainF***]][[Category:Extended BrainF***]]==\n[http:\/\/sylwester.no\/ebf\/ more info about EBF]\n<lang ebf>\n;; Macroes\n; create 100\n{init\n  :tmp\n  $tmp 10+(-^where 10+)\n  !tmp\n}\n\n; macro that prints 99-2\n{print_num\n  :what:div:1s:10s\n  %where(-$what+$div+)\n  $div(-^where+)\n  %div 10+\n  $what &divmod\n  $div(-)\n  $10s(|\"0\"(-))\n  $1s|\"0\"(-)\n  $what(-)\n  !10s!1s!div!what\n}\n\n; macro that prints the text between the numbers\n{do_iteration\n    :iter:zero:tmp\n    (-$iter+$zero+)\n    $zero(-^+)+\n    switch $iter-\n    (\n      $tmp|\" of beer on the wall\"(-)\n      $iter-\n      (-$zero-|\".\"(-)10+..(-))\n      $zero(-|\", \"(-))\n    )\n    $zero(-\n            |\" of beer.\"(-)10+.(-)\n            $zero+\n            $not_first((-)$zero-\n                |\"Go to the store and buy some more, 99 bottles of beer on the wall.\"(-)10+.(-))\n            $zero(-|\"Take one down and pass it around, \"(-))\n    )\n  !tmp!zero!iter\n}\n\n; divmod performs divide and modulus at the same time\n{divmod[->-[>+>>]>[+[-<+>]>+>>]<<<<<]*-3}\n\n;; global variables\n:not_first\n:round\n:number\n:copy\n:flag\n\n;; main program starts here\n$number &init\nwhile $number\n(\n  $round++\n  $not_first(-$round+)\n  while $round\n  (\n    $number(-$copy+$flag+)\n    $flag(-$number+)+\n    switch $copy\n    -(-\n      (+\n        $copy &print_num\n        $flag-\n        $copy(-)\n        |\" bottles\"(-)\n      ) $flag (-\n          |\"1 bottle\"(-)\n    )) $flag (-\n          |\"No more bottles\"(-)\n          $not_first+\n    )\n\n    $round &do_iteration\n    $round-\n  )\n  $not_first+\n  $number-\n)\n\n<\/lang>\n\n==<span id=\"F_Sharp\">[[:Category:F_Sharp|F#]]<\/span>[[Category:F_Sharp]]==\n<lang fsharp>#light\nlet rec bottles n =\n    let (before, after) = match n with\n                          | 1 -> (\"bottle\", \"bottles\")\n                          | 2 -> (\"bottles\", \"bottle\")\n                          | n -> (\"bottles\", \"bottles\")\n    printfn \"%d %s of beer on the wall\" n before\n    printfn \"%d %s of beer\" n before\n    printfn \"Take one down, pass it around\"\n    printfn \"%d %s of beer on the wall\\n\" (n - 1) after\n    if n > 1 then\n        bottles (n - 1)<\/lang>\n\n==[[:Category:Factor|Factor]][[Category:Factor]]==\n<lang factor>USING: io kernel make math math.parser math.ranges sequences ;\n\n: bottle ( -- quot )\n    [\n        [\n            [\n                [ # \" bottles of beer on the wall,\\n\" % ]\n                [ # \" bottles of beer.\\n\" % ] bi\n            ] keep\n            \"Take one down, pass it around,\\n\" %\n            1 - # \" bottles of beer on the wall\\n\" %\n        ] \" \" make print\n    ] ; inline\n\n: last-verse ( -- )\n    \"Go to the store and buy some more,\" \n    \"no more bottles of beer on the wall!\" [ print ] bi@ ;\n\n: bottles ( n -- )\n    1 [a,b] bottle each last-verse ;\n\n! Usage: 99 bottles<\/lang>\n\n==[[:Category:Falcon|Falcon]][[Category:Falcon]]==\n<lang falcon>for i in [99:1]\n > i, \" bottles of beer on the wall\"\n > i, \" bottles of beer\"\n > \"Take one down, pass it around\"\n > i-1, \" bottles of beer on the wall\\n\"\nend<\/lang>\n\nA more robust version to handle plural\/not plural conditions\n<lang falcon>for i in [99:1]\n plural = (i != 1) ? 's' : \"\"\n > @ \"$i bottle$plural of beer on the wall\"\n > @ \"$i bottle$plural of beer\"\n > \"Take one down, pass it around\"\n > i-1, @ \" bottle$plural of beer on the wall\\n\"\nend<\/lang>\n\n==[[:Category:FALSE|FALSE]][[Category:FALSE]]==\n<lang false>[$.\" bottle\"$1-[\"s\"]?\" of beer\"]b:\n99\n[$][b;!\" on the wall\n\"b;!\"\nTake one down and pass it around\n\"1-b;!\" on the wall\n\"]#%<\/lang>\n\n==[[:Category:ferite|ferite]][[Category:ferite]]==\ncopied from [http:\/\/99-bottles-of-beer.net\/language-ferite-1281.html?PHPSESSID=b563ec9a2791f6c3cc917c22b17dc542 99-bottles-of-beer.net].\n\n<lang ferite>uses \"console\";\n\nnumber bottles = 99;\nboolean looping = true;\nobject counter = closure {\n\tif (--bottles > 0) {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n};\n\nwhile (looping) {\n\tConsole.println(\"${bottles} bottles of beer on the wall,\");\n\tConsole.println(\"${bottles} bottles of beer,\");\n\tConsole.println(\"Take one down, pass it around,\");\n\t\n\tlooping = counter.invoke();\n\t\n\tConsole.println(\"${bottles} bottles of beer on the wall.\");<\/lang>\n\n==[[:Category:Fexl|Fexl]][[Category:Fexl]]==\n<lang fexl>\n\\bottles_of_beer =\n    (\\n\n    print (< n 1 \"No more\" n);\n    print \" bottle\"; print (== n 1 \"\" \"s\");\n    print \" of beer\";\n    )\n\n\\bottles_of_beer_on_the_wall =\n    (\\n\n    bottles_of_beer n; print \" on the wall\";\n    )\n\n\\sing_bottles_of_beer =\n    (\\max\n    do (range max 0) \\qty\n    bottles_of_beer_on_the_wall qty; nl;\n    bottles_of_beer qty; nl;\n\n    \\qty =\n        (\n        > qty 0\n            (\n            print \"Take one down, pass it around\";nl;\n            - qty 1\n            )\n            (\n            print \"Go to the store and buy some more\";nl;\n            max\n            )\n        )\n\n    bottles_of_beer_on_the_wall qty; nl; \n    nl;\n    )\n\nsing_bottles_of_beer 99;\n<\/lang>\nThe output of singing with 3 bottles is:\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>\n3 bottles of beer on the wall\n3 bottles of beer\nTake one down, pass it around\n2 bottles of beer on the wall\n\n2 bottles of beer on the wall\n2 bottles of beer\nTake one down, pass it around\n1 bottle of beer on the wall\n\n1 bottle of beer on the wall\n1 bottle of beer\nTake one down, pass it around\nNo more bottles of beer on the wall\n\nNo more bottles of beer on the wall\nNo more bottles of beer\nGo to the store and buy some more\n3 bottles of beer on the wall\n<\/pre>\n\n==[[:Category:Forth|Forth]][[Category:Forth]]==\n<lang forth>:noname   dup . .\" bottles\" ;\n:noname       .\" 1 bottle\"  ;\n:noname .\" no more bottles\" ;\ncreate bottles , , ,\n\n: .bottles  dup 2 min cells bottles + @ execute ;\n: .beer     .bottles .\"  of beer\" ;\n: .wall     .beer .\"  on the wall\" ;\n: .take     .\" Take one down, pass it around\" ;\n: .verse    .wall cr .beer cr\n         1- .take cr .wall cr ;\n: verses    begin cr .verse ?dup 0= until ;\n\n99 verses<\/lang>\n\n==[[:Category:Fortran|Fortran]][[Category:Fortran]]==\n<lang fortran>program bottlestest\n\n  implicit none\n\n  integer :: i\n  \n  character(len=*), parameter   :: bwall = \" on the wall\", &\n                                   bottles = \"bottles of beer\", &\n                                   bottle  = \"bottle of beer\", &\n                                   take = \"Take one down, pass it around\", &\n                                   form = \"(I0, ' ', A)\"\n\n  do i = 99,0,-1\n     if ( i \/= 1 ) then\n        write (*,form)  i, bottles \/\/ bwall\n        if ( i > 0 ) write (*,form)  i, bottles\n     else\n        write (*,form)  i, bottle \/\/ bwall\n        write (*,form)  i, bottle\n     end if\n     if ( i > 0 ) write (*,*) take\n  end do\n\nend program bottlestest<\/lang>\n\n==[[:Category:Frink|Frink]][[Category:Frink]]==\nFrink tracks units of measure through all calculations.  It has a large library of built-in units of measure, including volume.  The following program prints out the remaining volume of beer (assuming we start with 99 bottles of beer, each containing 12 fluid ounces) in different random units of volume, never repeating a unit.\n<lang frink>\nunits = array[units[volume]]\nshowApproximations[false]\n\nfor n = 99 to 0 step -1\n{\n   unit = units.removeRandom[]\n   str = getBottleString[n, unit]\n   \n   println[\"$str of beer on the wall, $str.\"]\n\n   if (n == 0)\n      println[\"Go to the store and buy some more, 99 bottles of beer on the wall.\"]\n   else\n      println[\"Take one down and pass it around, \" + getBottleString[n-1, unit] + \" on the wall.\\n\"]\n}\n\ngetBottleString[n, unit] := format[n*12 floz, unit, 6] + \"s\"\n<\/lang>\n\nSample randomized output:\n<pre>\n0.019386 facecords of beer on the wall, 0.019386 facecords.\nTake one down and pass it around, 0.019190 facecords on the wall.\n\n36.750000 quarts of beer on the wall, 36.750000 quarts.\nTake one down and pass it around, 36.375000 quarts on the wall.\n\n581539.650545 brminims of beer on the wall, 581539.650545 brminims.\nTake one down and pass it around, 575544.396416 brminims on the wall.\n\n10.377148 scotsoatlippys of beer on the wall, 10.377148 scotsoatlippys.\nTake one down and pass it around, 10.269053 scotsoatlippys on the wall.\n\n7.416004 cangallons of beer on the wall, 7.416004 cangallons.\nTake one down and pass it around, 7.337941 cangallons on the wall.\n\n3335.894135 dessertspoons of beer on the wall, 3335.894135 dessertspoons.\nTake one down and pass it around, 3300.405899 dessertspoons on the wall.\n\n0.233105 barrelbulks of beer on the wall, 0.233105 barrelbulks.\nTake one down and pass it around, 0.230599 barrelbulks on the wall.\n\n21.766118 magnums of beer on the wall, 21.766118 magnums.\nTake one down and pass it around, 21.529530 magnums on the wall.\n\n1092.000000 fluidounces of beer on the wall, 1092.000000 fluidounces.\nTake one down and pass it around, 1080.000000 fluidounces on the wall.\n...\n12.000000 ponys of beer on the wall, 12.000000 ponys.\nTake one down and pass it around, 0.000000 ponys on the wall.\n\n0.000000 brfluidounces of beer on the wall, 0.000000 brfluidounces.\nGo to the store and buy some more, 99 bottles of beer on the wall.\n<\/pre>\n\n==[[:Category:GAP|GAP]][[Category:GAP]]==\n<lang gap>Bottles := function(n)\n\tlocal line, i, j, u;\n\tline := function(n)\n\t\ts := String(n);\n\t\tif n < 2 then\n\t\t\treturn Concatenation(String(n), \" bottle of beer\");\n\t\telse\n\t\t\treturn Concatenation(String(n), \" bottles of beer\");\n\t\tfi;\n\tend;\n\tfor i in [1 .. n] do\n\t\tj := n - i + 1;\n\t\tu := line(j);\n\t\tDisplay(Concatenation(u, \" on the wall\"));\n\t\tDisplay(u);\n\t\tDisplay(\"Take one down, pass it around\");\n\t\tDisplay(Concatenation(line(j - 1), \" on the wall\"));\n\t\tif i <> n then\n\t\t\tDisplay(\"\");\n\t\tfi;\n\tod;\nend;<\/lang>\n\n==[[:Category:gnuplot|gnuplot]][[Category:gnuplot]]==\n<lang gnuplot>if (!exists(\"bottles\")) bottles = 99\nprint sprintf(\"%i bottles of beer on the wall\", bottles)\nprint sprintf(\"%i bottles of beer\", bottles)\nprint \"Take one down, pass it around\"\nbottles = bottles - 1\nprint sprintf(\"%i bottles of beer on the wall\", bottles)\nprint \"\"\nif (bottles > 0) reread<\/lang>\n\n==[[:Category:Go|Go]][[Category:Go]]==\n<lang go>package main\n \nimport \"fmt\"\n \nfunc main() {\n\tcardinality := func (i int) string {\n\t\tif i!=1 {\n\t\t\treturn \"s\"\n\t\t}\n\t\treturn \"\"\n\t}\n\tfor i := 99; i > 0; i-- {\n\t\tfmt.Printf(\"%d bottle%s of beer on the wall\\n\", i, cardinality(i))\n\t\tfmt.Printf(\"%d bottle%s of beer\\n\", i, cardinality(i))\n\t\tfmt.Printf(\"Take one down, pass it around\\n\")\n\t\tfmt.Printf(\"%d bottle%s of beer on the wall\\n\", i-1, cardinality(i-1))\n\t}\n}<\/lang>\n\n==[[:Category:Go!|Go!]][[Category:Go!]]==\nCopied from [http:\/\/99-bottles-of-beer.net\/language-go!-289.html The 99 Bottles of Beer web site] with a minor bug fix.\n<lang go!>-- \n-- 99 Bottles of Beer in Go!\n-- John Knottenbelt\n-- \n-- Go! is a multi-paradigm programming language that is oriented\n-- to the needs of programming secure, production quality, agent\n-- based applications.\n-- \n--    http:\/\/www.doc.ic.ac.uk\/~klc\/dalt03.html \n-- \n\nmain .. {\n  include \"sys:go\/io.gof\".\n  include \"sys:go\/stdlib.gof\".\n\n  main() ->\n      drink(99);\n      stdout.outLine(\"Time to buy some more beer...\").\n\n  drink(0) -> {}.\n  drink(i) -> stdout.outLine(\n       bottles(i) <> \" on the wall,\\n\" <>\n       bottles(i) <> \".\\n\" <>\n       \"take one down, pass it around,\\n\" <>\n       bottles(i-1) <> \" on the wall.\\n\");\n      drink(i-1).\n\n  bottles(0) => \"no bottles of beer\".\n  bottles(1) => \"1 bottle of beer\".\n  bottles(i) => i^0 <> \" bottles of beer\".\n}<\/lang>\n\n==[[:Category:Gosu|Gosu]][[Category:Gosu]]==\n<lang gosu>\nfor (i in 99..0) {\n\n    print(\"${i} bottles of beer on the wall\")\n\n    if (i > 0) {\n        print(\"${i} bottles of beer\")\n        print(\"Take one down, pass it around\")\n    }\n    print(\"\");\n\n}\n<\/lang>\n\n==[[:Category:Golfscript|Golfscript]][[Category:Golfscript]]==\n<lang golfscript>[296,{3\/)}%-1%[\"No more\"]+[\" bottles\":b]294*[b-1<]2*+[b]+[\" of beer on the wall\\n\".8<\"\\nTake one down, pass it around\\n\"+1$n+]99*]zip<\/lang>\n\n==[[:Category:Groovy|Groovy]][[Category:Groovy]]==\n===Basic Solution===\nWith a closure to handle special cardinalities of bottles.\n<lang groovy>def bottles = { \"${it==0 ? 'No more' : it} bottle${it==1 ? '' : 's' }\" }\n\n99.downto(1) { i ->\n    print \"\"\"\n${bottles(i)} of beer on the wall\n${bottles(i)} of beer\nTake one down, pass it around\n${bottles(i-1)} of beer on the wall\n\"\"\"\n}<\/lang>\n\n=== Single Print Version ===\nUses a single print algorithm for all four lines. Handles cardinality on bottles, uses 'No more' instead of 0.\n<lang groovy>298.downto(2) {\n    def (m,d) = [it%3,(int)it\/3]\n    print \"${m==1?'\\n':''}${d?:'No more'} bottle${d!=1?'s':''} of beer\" +\n          \"${m?' on the wall':'\\nTake one down, pass it around'}\\n\"\n}<\/lang>\n\n===Bottomless Beer Solution===\nUsing more closures to create a richer lyrical experience.\n<lang groovy>def bottles = { \"${it==0 ? 'No more' : it} bottle${it==1 ? '' : 's' }\" }\n\ndef initialState = {\n  \"\"\"${result(it)}\n${resultShort(it)}\"\"\"\n}\n\ndef act = {\n  it > 0 ?\n      \"Take ${it==1 ? 'it' : 'one'} down, pass it around\" :\n      \"Go to the store, buy some more\"\n}\n\ndef delta = { it > 0 ? -1 : 99 }\n\ndef resultShort = { \"${bottles(it)} of beer\" }\n\ndef result = { \"${resultShort(it)} on the wall\" }\n\n\/\/ \/\/\/\/ uncomment commented lines to create endless drunken binge \/\/\/\/ \/\/\n\/\/ while (true) {\n99.downto(0) { i ->\n  print \"\"\"\n${initialState(i)}\n${act(i)}\n${result(i+delta(i))}\n\"\"\"\n}\n\/\/ Thread.sleep(1000)\n\/\/ }<\/lang>\n\n==[[:Category:GUISS|GUISS]][[Category:GUISS]]==\n\nWe will just use the calculator and keep taking one off. We do not get the full text here, but the number of the calculator shows how many bottles we still have left to drink:\n\n<lang guiss>Start,Programs,Accessories,Calculator,Button:9,Button:9,\nButton:[hyphen],Button:1,Button:[equals],Button:[hyphen],Button:1,Button:[equals],\nButton:[hyphen],Button:1,Button:[equals],Button:[hyphen],Button:1,Button:[equals],\nButton:[hyphen],Button:1,Button:[equals],Button:[hyphen],Button:1,Button:[equals],\nButton:[hyphen],Button:1,Button:[equals],Button:[hyphen],Button:1,Button:[equals]\n<\/lang>\nWe haven't drank all of the bottles at this point, but we can keep going, if we want.\n\n==[[:Category:Haskell|Haskell]][[Category:Haskell]]==\nA relatively concise solution:\n\n<lang haskell>main = mapM_ (putStrLn . beer) [99, 98 .. 0]\nbeer 1 = \"1 bottle of beer on the wall\\n1 bottle of beer\\nTake one down, pass it around\"\nbeer 0 = \"better go to the store and buy some more.\"\nbeer v = show v ++ \" bottles of beer on the wall\\n\" \n                ++ show v \n                ++\" bottles of beer\\nTake one down, pass it around\\n\" \n                ++ head (lines $ beer $ v-1) ++ \"\\n\"<\/lang>\n\nAs a list comprehension:\n\n<lang haskell>import qualified Char\n\nmain = putStr $ concat\n   [up (bob n) ++ wall ++ \", \" ++ bob n ++ \".\\n\" ++\n    pass n ++ bob (n - 1) ++ wall ++ \".\\n\\n\" |\n    n <- [99, 98 .. 0]]\n   where bob n = (num n) ++ \" bottle\" ++ (s n) ++ \" of beer\"\n         wall = \" on the wall\"\n         pass 0 = \"Go to the store and buy some more, \"\n         pass _ = \"Take one down and pass it around, \"\n         up (x : xs) = Char.toUpper x : xs\n         num (-1) = \"99\"\n         num 0    = \"no more\"\n         num n    = show n\n         s 1 = \"\"\n         s _ = \"s\"<\/lang>\n\nAnother version, which uses a Writer monad to collect each part of the song. It also uses Template Haskell to generate the song at compile time.\n\n<lang haskell>{-# LANGUAGE TemplateHaskell #-}\n-- build with \"ghc --make beer.hs\"\nmodule Main where\nimport Language.Haskell.TH\nimport Control.Monad.Writer\n\n-- This is calculated at compile time, and is equivalent to\n-- songString = \"99 bottles of beer on the wall\\n99 bottles...\"\nsongString = \n    $(let\n         sing = tell -- we can't sing very well...\n\n         someBottles 1 = \"1 bottle of beer \"\n         someBottles n = show n ++ \" bottles of beer \"\n\n         bottlesOfBeer n = (someBottles n ++) \n\n         verse n = do\n           sing $ n `bottlesOfBeer` \"on the wall\\n\"\n           sing $ n `bottlesOfBeer` \"\\n\"\n           sing $ \"Take one down, pass it around\\n\"\n           sing $ (n - 1) `bottlesOfBeer` \"on the wall\\n\\n\"\n\n         song = execWriter $ mapM_ verse [99,98..1]\n\n      in return $ LitE $ StringL $ song)\n\nmain = putStr songString<\/lang>\n\n==[[:Category:haXe|haXe]][[Category:haXe]]==\n<lang haXe>class RosettaDemo\n{\n    static public function main()\n    {\n        singBottlesOfBeer(100);\n    }\n\n    static function singBottlesOfBeer(bottles : Int)\n    {\n        var plural : String = 's';\n\n        while (bottles >= 1)\n        {\n            neko.Lib.print(bottles + \" bottle\" + plural + \" of beer on the wall,\\n\");\n            neko.Lib.print(bottles + \" bottle\" + plural + \" of beer!\\n\");\n            neko.Lib.print(\"Take one down, pass it around,\\n\");\n            if (bottles - 1 == 1)\n            {\n                plural = '';\n            }\n\n            if (bottles > 1)\n            {\n                neko.Lib.print(bottles-1 + \" bottle\" + plural + \" of beer on the wall!\\n\\n\");\n            }\n            else\n            {\n                neko.Lib.print(\"No more bottles of beer on the wall!\\n\");\n            }\n            bottles--;\n        }\n    }\n}<\/lang>\n\n==[[:Category:HicEst|HicEst]][[Category:HicEst]]==\n<lang hicest>DO x = 99, 1, -1\n  WRITE()   x       , \"bottles of beer on the wall\"\n  BEEP(\"T16 be be be   bH bH   bH be   be be  2be \")\n\n  WRITE()   x       , \"bottles of beer\"\n  BEEP(\"2p  f f f      c  c    c  2f  \")\n\n  WRITE()  \"take one down,  pass it around\"\n  BEEP(\"2p  2d   d   d   2p d    d  d 2d  \")\n\n  WRITE()   x     , \"bottles of beer on the wall\"\n  BEEP(\"2p  #A #A #A c  c    d  #d   #d #d  2#d 2p\")\nENDDO<\/lang>\n\n==[[:Category:HQ9+|HQ9+]][[Category:HQ9+]]==\n<lang hq9plus>9<\/lang>\n\n==[[:Category:Icon|Icon]][[Category:Icon]] and [[:Category:Unicon|Unicon]][[Category:Unicon]]==\nThe default is 99 bottles, but you can change this on the command line for\nreally long trips...\n<lang icon>procedure main(args)\n   numBeers := integer(args[1]) | 99\n   drinkUp(numBeers)\nend\n\nprocedure drinkUp(beerMax)\n    static beerMap\n    initial {\n        beerMap := table(\" bottles\")\n        beerMap[1] := \" bottle\"\n        }\n\n    every beerCount := beerMax to 1 by -1 do {\n       writes( beerCount,beerMap[beerCount],\" of beer on the wall, \")\n       write(  beerCount,beerMap[beerCount],\" of beer.\")\n\n       writes(\"Take one down and pass it around, \")\n       write(case x := beerCount-1 of {\n             0       : \"no more bottles\"\n             default : x||beerMap[x]\n             },\" of beer on the wall.\\n\")\n       }\n\n    write(\"No more bottles of beer on the wall, no more bottles of beer.\")\n    write(\"Go to the store and buy some more, \",\n          beerMax,\" bottles of beer on the wall.\")\nend<\/lang>\n\n==[[:Category:IDL|IDL]][[Category:IDL]]==\n<lang IDL>Pro bottles\n\nfor i=1,99 do begin\n print, 100-i, \" bottles of beer on the wall.\", 100-i, $\n \" bottles of beer.\", \" Take one down, pass it around,\" , $\n 99-i, \" bottles of beer on the wall.\"\nendfor\nEnd\n\n}<\/lang>\n\nSince in IDL \"FOR\"-loops are the embodiment of pure evil (see http:\/\/www.idlcoyote.com\/tips\/forloops.html and http:\/\/www.idlcoyote.com\/tips\/forloops2.html) there is also a loop free IDL way:\n\n<lang IDL>Pro bottles_noloop\n    b=(reverse(shift(sindgen(100),-1)))[1:99]\n    b2=reverse(sindgen(99))\n    wallT=replicate(' bottles of beer on the wall.', 100)\n    wallT2=replicate(' bottles of beer.', 100)\n    takeT=replicate('Take one down, pass it around,', 100)\n    print, b+wallT+string(10B)+b+wallT2+string(10B)+takeT+string(10B)+b2+wallT+string(10B)\nEnd<\/lang>\n\n==[[:Category:Inform 6|Inform 6]][[Category:Inform 6]]==\n<lang inform6>[ Bottles i;\n  if(i == 1) return \"bottle\";\n\n  return \"bottles\";\n];\n\n[ Beer i;\n  print i, \" \", (string) Bottles(i), \" of beer on the wall^\";\n  print i, \" \", (string) Bottles(i), \" of beer^\";\n  print \"Take one down, pass it around^\";\n  i--;\n  print i, \" \", (string) Bottles(i), \" of beer on the wall^^\";\n\n  if(i ~= 0) Beer(i);\n];\n\n[ Main;\n  Beer(99);\n];\n<\/lang>\n\n==[[:Category:Inform 7|Inform 7]][[Category:Inform 7]]==\n=== Programmatic solution ===\n<lang inform7>Beer Hall is a room.\n\nWhen play begins:\n\trepeat with iteration running from 1 to 99:\n\t\tlet N be 100 - iteration;\n\t\tsay \"[N] bottle[s] of beer on the wall[line break]\";\n\t\tsay \"[N] bottle[s] of beer[line break]\";\n\t\tsay \"Take one down, pass it around[line break]\";\n\t\tsay \"[N - 1] bottle[s] of beer on the wall[paragraph break]\";\n\tend the story.<\/lang>\n\n=== World model solution ===\nThis solution uses in-game objects to represent the wall and the bottles.\n\n<lang inform7>Beer Hall is a room.\n\nThe plural of bottle of beer is bottles of beer. A bottle of beer is a kind of thing.\n\nThe wall is a scenery supporter in Beer Hall. 99 bottles of beer are on the wall.\n\nWhen play begins:\n\twhile something is on the wall:\n\t\tsay \"[what's on the wall] on the wall[line break]\";\n\t\tsay \"[what's on the wall][line break]\";\n\t\tsay \"Take one down, pass it around[line break]\";\n\t\tremove a random thing on the wall from play;\n\t\tsay \"[what's on the wall] on the wall[paragraph break]\";\n\tend the story.\n\nTo say what's on the wall:\n\tif more than one thing is on the wall, say list of things on the wall;\n\totherwise say \"[number of things on the wall in words] bottle[s] of beer\".<\/lang>\n\n==[[:Category:Intercal|Intercal]][[Category:Intercal]]==\nSee [[99 Bottles of Beer\/Intercal]]\n\n==[[:Category:Io|Io]][[Category:Io]]==\n<lang io>bottles := method(i,\n    if(i==0, return \"no more bottles of beer\")\n    if(i==1, return \"1 bottle of beer\")\n    \"\" .. i .. \" bottles of beer\"\n)\nfor(i, 99, 1, -1,\n    write(\n        bottles(i), \" on the wall, \", \n        bottles(i), \",\\n\",\n        \"take one down, pass it around,\\n\",\n        bottles(i - 1), \" on the wall.\\n\\n\"\n    )\n)<\/lang>\n\n==[[:Category:Ioke|Ioke]][[Category:Ioke]]==\n<lang ioke>bottle = method(i,\n  case(i,\n    0, \"no more bottles of beer\",\n    1, \"1 bottle of beer\",\n    \"#{i} bottles of beer\"))\n\n(99..1) each(i,\n  \"#{bottle(i)} on the wall, \" println\n  \"take one down, pass it around,\" println\n  \"#{bottle(i - 1)} on the wall.\\n\" println\n)<\/lang>\n\n==[[:Category:J|J]][[Category:J]]==\nAs posted at the [http:\/\/www.jsoftware.com\/jwiki\/Essays\/99_Bottles_of_Beer J wiki]\n<lang j>bob =: \": , ' bottle' , (1 = ]) }. 's of beer'\"_\nbobw=: bob , ' on the wall'\"_\nbeer=: bobw , ', ' , bob , '; take one down and pass it around, ' , bobw@<:\nbeer\"0 >:i.-99<\/lang>\n\nOutput:\n<lang j>99 bottles of beer on the wall, 99 bottles of beer; take one down and pass it around, 98 bottles of beer on the wall\n98 bottles of beer on the wall, 98 bottles of beer; take one down and pass it around, 97 bottles of beer on the wall\n...\n3 bottles of beer on the wall, 3 bottles of beer; take one down and pass it around, 2 bottles of beer on the wall   \n2 bottles of beer on the wall, 2 bottles of beer; take one down and pass it around, 1 bottle of beer on the wall    \n1 bottle of beer on the wall, 1 bottle of beer; take one down and pass it around, 0 bottles of beer on the wall <\/lang>\n\n==[[:Category:Java|Java]][[Category:Java]]==\n===Console===\nMessageFormat's choice operator is used to properly format plurals.\n<lang java>import java.text.MessageFormat;\npublic class Beer\n{\n static String bottles(final int n)\n {\n  return MessageFormat.format(\"{0,choice,0#No more bottles|1#One bottle|2#{0} bottles} of beer\", n);\n }\n public static void main(final String[] args)\n {\n  String byob = bottles(99);\n  for (int x = 99; x > 0;)\n  {\n   System.out.println(byob + \" on the wall\");\n   System.out.println(byob);\n   System.out.println(\"Take one down, pass it around\");\n   byob = bottles(--x);\n   System.out.println(byob + \" on the wall\\n\");\n  }\n }\n}<\/lang>\n\n'''Optimized'''\n<lang java>public class Beer\n{\n public static void main(final String[] args)\n {\n  int beer = 99;\n  StringBuilder sb = new StringBuilder();\n  String data[] = new String[] { \" bottles of beer on the wall\\n\",\n                                 \" bottles of beer.\\nTake one down, pass it around,\\n\",\n                                 \"Better go to the store and buy some more.\" };\n\n  while (beer > 0)\n   sb.append(beer).append(data[0]).append(beer).append(data[1]).append(--beer).append(data[0]).append(\"\\n\");\n\n  System.out.println(sb.append(data[2]).toString());\n }\n}<\/lang>\n\n=== An object-oriented solution ===\n<div class=\"examplemeta translation\">'''Translation of''': [[99 Bottles of Beer#C++|C++]]<\/div>\n\nSee: [[99 Bottles of Beer\/Java\/Object Oriented]]\n\n===GUI===\n<div class=\"examplemeta libheader\">'''Library:''' [[SMW::off]][[:Category:Swing|Swing]][[Category:Swing]][[SMW::on]]<\/div>\n<div class=\"examplemeta libheader\">'''Library:''' [[SMW::off]][[:Category:AWT|AWT]][[Category:AWT]][[SMW::on]]<\/div>\nThis version requires user interaction. The first two lines are shown in a text area on a window. The third line is shown on a button which you need to click to see the fourth line in a message box. The numbers update and the process repeats until \"0 bottles of beer on the wall\" is shown in a message box, when the program ends.\n<lang java>import java.awt.BorderLayout;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport javax.swing.JButton;\nimport javax.swing.JFrame;\nimport javax.swing.JOptionPane;\nimport javax.swing.JTextArea;\npublic class Beer extends JFrame implements ActionListener{\n        private int x;\n        private JButton take;\n        private JTextArea text;\n        public static void main(String[] args){\n                new Beer();\/\/build and show the GUI\n        }\n\n        public Beer(){\n                x= 99;\n                take= new JButton(\"Take one down, pass it around\");\n                text= new JTextArea(4,30);\/\/size the area to 4 lines, 30 chars each\n                text.setText(x + \" bottles of beer on the wall\\n\" + x + \" bottles of beer\");\n                text.setEditable(false);\/\/so they can't change the text after it's displayed\n                take.addActionListener(this);\/\/listen to the button\n                setLayout(new BorderLayout());\/\/handle placement of components\n                add(text, BorderLayout.CENTER);\/\/put the text area in the largest section\n                add(take, BorderLayout.SOUTH);\/\/put the button underneath it\n                pack();\/\/auto-size the window\n                setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\/\/exit on \"X\" (I hate System.exit...)\n                setVisible(true);\/\/show it\n        }\n\n        public void actionPerformed(ActionEvent arg0){\n                if(arg0.getSource() == take){\/\/if they clicked the button\n                        JOptionPane.showMessageDialog(null, --x + \" bottles of beer on the wall\");\/\/show a popup message\n                        text.setText(x + \" bottles of beer on the wall\\n\" + x + \" bottles of beer\");\/\/change the text\n                }\n                if(x == 0){\/\/if it's the end\n                        dispose();\/\/end\n                }\n        }\n}<\/lang>\n\n==[[:Category:JavaScript|JavaScript]][[Category:JavaScript]]==\n=== The simple solution ===\n<lang javascript>\/\/ Line breaks are in HTML\nvar beer = 99;\nwhile (beer > 0)\n{\n document.write( beer + \" bottles of beer on the wall<br>\" );\n document.write( beer + \" bottles of beer<br>\" );\n document.write( \"Take one down, pass it around<br>\" );\n document.write( (beer - 1) + \" bottles of beer on the wall<br>\" );\n beer--;\n}<\/lang>\n\n=== More skilled solution \"one-liner\" with grammar check ===\n<lang javascript>\/\/ Line breaks are in HTML\nvar beer; while ((beer = typeof beer === \"undefined\" ? 99 : beer) > 0) document.write( beer + \" bottle\" + (beer != 1 ? \"s\" : \"\") + \" of beer on the wall<br>\" + beer + \" bottle\" + (beer != 1 ? \"s\" : \"\") + \" of beer<br>Take one down, pass it around<br>\" + (--beer) + \" bottle\" + (beer != 1 ? \"s\" : \"\") + \" of beer on the wall<br>\" );<\/lang>\n\n=== Object Oriented with DOM ===\n<lang javascript>\/\/ Line breaks are in HTML\nfunction Bottles(count){\n    this.count = (!!count)?count:99;\n    this.knock = function(){\n        var c = document.createElement('div');\n        c.id=\"bottle-\"+this.count;\n        c.innerHTML = \"<p>\"+this.count+\" bottles of beer on the wall<\/p>\"\n            +\"<p>\"+this.count+\" bottles of beer!<\/p>\"\n            +\"<p>Take one down,<br>Pass it around<\/p>\"\n            +\"<p>\"+(--this.count)+\" bottles of beer on the wall<\/p><p><br><\/p>\";\n        document.body.appendChild(c);\n    }\n    this.sing = function(){\n        while (this.count>0) { this.knock(); }\n    }\n}\n        \n(function(){\n    var bar = new Bottles(99);\n    bar.sing();\n})();<\/lang>\n\nAn alternative version:\n\n<lang javascript>function bottleSong(n) {\n  if (!isFinite(Number(n)) || n == 0) n = 100;\n  var a  = '%% bottles of beer',\n      b  = ' on the wall',\n      c  = 'Take one down, pass it around',\n      r  = '<br>'\n      p  = document.createElement('p'),\n      s  = [],\n      re = \/%%\/g;\n  \n  while(n) {\n    s.push((a+b+r+a+r+c+r).replace(re, n) + (a+b).replace(re, --n));\n  }\n  p.innerHTML = s.join(r+r);\n  document.body.appendChild(p);\n}\n\nwindow.onload = bottleSong;<\/lang>\n\n==[[:Category:Joy|Joy]][[Category:Joy]]==\n<lang joy>LIBRA\n\n\t_beerlib == true ;\n\nHIDE\n\tbeer == \"of beer \" putchars ;\n\twall == \"on the wall\" putchars ;\n\ttake1 == \"Take one down and pass it around, \" putchars ;\n\tdup3 == dup dup dup ;\n\tcomma == \", \" putchars ;\n\tperiod == '. putch ;\n\tbottles == [dup small] \n\t\t[ [null] [pop \"no more bottles \" putchars] [put \"bottle \" putchars] ifte] \n\t\t[put \"bottles \" putchars] ifte ;\n\tsing-verse == dup3 bottles beer wall comma \n\t\tbottles beer \".\\n\" putchars\n\t\ttake1 1 - bottles beer wall period newline newline ;\n\tsing-verse-0 == \"No more bottles of beer on the wall, no more bottles of beer\\n\" putchars\n\t\t\t\"Go to the store and buy some more, \" putchars \n\t\t\t99 bottles pop beer wall period newline ;\n\nIN\n\t(* n -- *)\n\tsing-verses == [null]\n\t\t\t[sing-verse-0]\n\t\t\t[sing-verse 1 -] tailrec .<\/lang>\n\n==[[:Category:K|K]][[Category:K]]==\n<lang k>`0:\\:{x[z],y,a,x[z],a,\"Take one down, pass it around\",a,x[z-1],y,a,a:\"\\n\"}[{($x),\" bottle\",:[x=1;\"\";\"s\"],\" of beer\"};\" on the wall\"]'|1_!100<\/lang>\n\n==[[:Category:Kotlin|Kotlin]][[Category:Kotlin]]==\n<lang kotlin>fun main(args : Array<String>) {\n  var i = 99\n  while (i > 0) {\n    \n    System.out?.println(\"${i} bottles of beer on the wall\")\n    System.out?.println(\"${i} bottles of beer\")\n    System.out?.println(\"Take one down, pass it around\")\n    i--;\n  }\n  System.out?.println(\"0 bottles of beer on the wall\")\n}\n<\/lang>\n\n==[[:Category:LabVIEW|LabVIEW]][[Category:LabVIEW]]==\nThis image is a [http:\/\/zone.ni.com\/devzone\/cda\/tut\/p\/id\/9330 VI Snippet], an executable image of [[LabVIEW]] code. The LabVIEW version is shown on the top-right hand corner. You can download it, then drag-and-drop it onto the LabVIEW block diagram from a file browser, and it will appear as runnable, editable code.<br\/>[[File:LabVIEW_99_Bottles_of_Beer.png]]\n==[[:Category:LaTeX|LaTeX]][[Category:LaTeX]]==\n===Recursive===\n<lang LaTeX>\\documentclass{article}\n\n\\newcounter{beer}\n\n\\newcommand{\\verses}[1]{\n  \\setcounter{beer}{#1}\n  \\par\\noindent\n  \\arabic{beer} bottles of beer on the wall,\\\\\n  \\arabic{beer} bottles of beer!\\\\\n  Take one down, pass it around---\\\\\n  \\addtocounter{beer}{-1}\n  \\arabic{beer} bottles of beer on the wall!\\\\\n  \\ifnum#1>0 \n    \\verses{\\value{beer}}\n  \\fi\n}\n\n\\begin{document}\n\\verses{99}\n\\end{document}<\/lang>\n\n===Iterative===\nThe \\loop macro is tail-recursive (Knuth 1984, page 219).\nJust for fun, this version uses Roman numerals.\n\n<lang LaTeX>\\documentclass{article}\n\n\\newcounter{beer}\n\\newcounter{showC}\n\n\\newcommand{\\verses}[1]{\n  \\setcounter{beer}{#1}\n  \\loop\n    \\par\\noindent\n    \\Roman{beer} bottles of beer on the wall,\\\\\n    \\Roman{beer} bottles of beer!\\\\\n    Take one down, pass it around---\\\\\n    \\addtocounter{beer}{-1}\n% Romans didn't know how to write zero ;-)\n    \\ifnum\\value{beer}=0 ZERO \\else\\Roman{beer} \\fi\n      bottles of beer on the wall!\\\\\n    \\ifnum\\value{beer}>0 \n  \\repeat\n}\n\n\\begin{document}\n\\verses{99}\n\\end{document}<\/lang>\n\n===References===\n\n*Knuth, Donald E. (1984). ''The TeXbook'', Addison Wesley.\n\n==[[:Category:Liberty BASIC|Liberty BASIC]][[Category:Liberty BASIC]]==\n<lang lb>For bottles = 99 To 1 Step -1\n    song$ = song$ + str$(bottles) + \" bottle\"\n    If (bottles > 1) Then song$ = song$ + \"s\"\n    song$ = song$ + \" of beer on the wall, \" + str$(bottles) + \" bottle\"\n    If (bottles > 1) Then song$ = song$ + \"s\"\n    song$ = song$ + \" of beer,\"  + chr$(13) + chr$(10) + \"Take one down, pass it around, \" + str$(bottles - 1) + \" bottle\"\n    If (bottles > 2) Or (bottles = 1) Then song$ = song$ + \"s\"\n    song$ = song$ + \" of beer on the wall.\" + chr$(13) + chr$(10)\nNext bottles\nsong$ = song$ + \"No more bottles of beer on the wall, no more bottles of beer.\" _\n        + chr$(13) + chr$(10) + \"Go to the store and buy some more, 99 bottles of beer on the wall.\"\n\nPrint song$<\/lang>\n\n==[[:Category:Logo|Logo]][[Category:Logo]]==\n<lang logo>to bottles :n\n  if :n = 0 [output [No more bottles]]\n  if :n = 1 [output [1 bottle]]\n  output sentence :n \"bottles\nend\nto verse :n\n  print sentence bottles :n [of beer on the wall]\n  print sentence bottles :n [of beer]\n  print [Take one down, pass it around]\n  print sentence bottles :n-1 [of beer on the wall]\nend\nfor [n 99 1] [verse :n  (print)]<\/lang>\n\n==[[:Category:Logtalk|Logtalk]][[Category:Logtalk]]==\n<lang logtalk>:- object(bottles).\n\n    :- initialization(sing(99)).\n\n    sing(0) :-\n        write('No more bottles of beer on the wall, no more bottles of beer.'), nl,\n        write('Go to the store and buy some more, 99 bottles of beer on the wall.'), nl, nl.\n    sing(N) :-\n        N > 0,\n        N2 is N -1,\n        beers(N), write(' of beer on the wall, '), beers(N), write(' of beer.'), nl,\n        write('Take one down and pass it around, '), beers(N2), write(' of beer on the wall.'), nl, nl,\n        sing(N2).\n\n    beers(0) :-\n        write('no more bottles').\n    beers(1) :-\n        write('1 bottle').\n    beers(N) :-\n        N > 1,\n        write(N), write(' bottles').\n\n:- end_object.<\/lang>\n\n==[[:Category:Lua|Lua]][[Category:Lua]]==\n<lang lua>local bottles = 99\n\nlocal function plural (bottles) if bottles == 1 then return '' end return 's' end\nwhile bottles > 0 do\n    print (bottles..' bottle'..plural(bottles)..' of beer on the wall')\n    print (bottles..' bottle'..plural(bottles)..' of beer')\n    print ('Take one down, pass it around')\n    bottles = bottles - 1\n    print (bottles..' bottle'..plural(bottles)..' of beer on the wall')\n    print ()\nend<\/lang>\n\n==[[:Category:Lucid|Lucid]][[Category:Lucid]]==\n<lang lucid>\/\/ Run luval with -s inside the lucid shell script\n\/\/ The print out is a list of lines. So the output is not separated by new lines, rather\n\/\/ by '[' and ']' -- I cant figure out how to do string concatenation with numbers in lucid.\n\/\/ beer(N) ^ bottle(N) ^ wall ^ beer(N) ^ bottle(N) ^ pass ^ beer(N-1) ^ bottle(N-1) ^ wall\n\/\/ should have worked but doesn't\n[%beer(N),bottle(N),wall,beer(N),bottle(N),pass,beer(N-1),bottle(N-1),wall%]\n   where\n       N = 100 fby N - 1;\n       wall = if N > 0 then ` On the wall ' else eod fi;\n       pass = `Take one down and pass it around.';\n       beer(A) = if A > 0 then A else `No more' fi;\n       bottle(A) = if A eq 1 then `bottle of beer' else `bottles of beer' fi;\n   end<\/lang>\n\n==[[:Category:M4|M4]][[Category:M4]]==\n\n<lang m4>define(`BOTTLES', `bottles of beer')dnl\ndefine(`BOTTLE', `bottle of beer')dnl\ndefine(`WALL', `on the wall')dnl\ndefine(`TAKE', `take one down, pass it around')dnl\ndefine(`NINETEEN', `$1 ifelse(`$1',`1',BOTTLE,BOTTLES) WALL\n$1 ifelse(`$1',`1',BOTTLE,BOTTLES)\nifelse(`$1',`0',,`TAKE')\nifelse(`$1',`0',,`NINETEEN(eval($1-1))')')dnl\nNINETEEN(99)<\/lang>\n\n==[[:Category:make|make]][[Category:make]]==\n=== BSD make ===\n<div class=\"examplemeta libheader\">'''Library:''' [[SMW::off]][[:Category:jot|jot]][[Category:jot]][[SMW::on]]<\/div>\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[BSD make]][[SMW::on]]<\/div>\n<lang make>START = 99\nUP != jot - 2 `expr $(START) - 1` 1\n\n0-bottles-of-beer: 1-bottle-of-beer\n\t@echo No more bottles of beer on the wall!\n\n1-bottle-of-beer: 2-bottles-of-beer\n\t@echo One last bottle of beer on the wall!\n\t@echo\n\t@echo One last bottle of beer on the wall,\n\t@echo One last bottle of beer,\n\t@echo Take it down, pass it around.\n\n.for COUNT in $(UP)\nONE_MORE != expr 1 + $(COUNT)\n$(COUNT)-bottles-of-beer: $(ONE_MORE)-bottles-of-beer\n\t@echo $(COUNT) bottles of beer on the wall!\n\t@echo\n\t@echo $(COUNT) bottles of beer on the wall,\n\t@echo $(COUNT) bottles of beer,\n\t@echo Take one down, pass it around.\n.endfor\n\n$(START)-bottles-of-beer:\n\t@echo $(START) bottles of beer on the wall,\n\t@echo $(START) bottles of beer.\n\t@echo Take one down, pass it around.<\/lang>\n\nUsage: <tt>make<\/tt> or <tt>make START=99<\/tt>\n\n=== GNU make ===\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[GNU make]] version 3.81[[SMW::on]]<\/div>\n<lang make>PRED=`expr $* - 1`\n\n1-bottles: 1-beer pass\n\t@echo \"No more bottles of beer on the wall\"\n\n%-bottles: %-beer pass\n\t@echo \"$(PRED) bottles of beer on the wall\\n\"\n\t@-$(MAKE) $(PRED)-bottles\n\n1-beer:\n\t@echo \"One bottle of beer on the wall, One bottle of beer\"\n\n%-beer:\n\t@echo \"$* bottles of beer on the wall, $* bottles of beer\"\n\npass:\n\t@echo \"Take one down and pass it around,\"<\/lang>\n\nUsage: <tt>make 99-bottles<\/tt>\n\nThis will fork 99 make processes. You might need to raise your process limit (<tt>ulimit -p<\/tt>).\n\n==[[:Category:Mathematica|Mathematica]][[Category:Mathematica]]==\n<lang Mathematica>Print[# <> \" bottles of beer on the wall\\n\" <> # <> \" bottles of beer\\nTake one down and pass it around\\n\"] & \/@ ToString \/@ Range[99, 1, -1]; \nPrint[ \"0 bottle of beer on the wall\\n\"]<\/lang>\n\n==[[:Category:MATLAB|MATLAB]][[Category:MATLAB]]==\n<lang MATLAB>function ninetyNineBottlesOfBeer()\n\n    disp( [ sprintf(['%d bottles of beer on the wall, %d bottles of beer.\\n'...\n        'Take one down, pass it around...\\n'],[(99:-1:2);(99:-1:2)])...\n        sprintf(['1 bottle of beer on the wall, 1 bottle of beer.\\nTake'...\n        'one down, pass it around;\\nNo more bottles of beer on the wall.']) ] );\n    \n    %The end of this song makes me sad. The shelf should always have more\n    %beer...like college.\n    \nend<\/lang>\n\n==[[:Category:MAXScript|MAXScript]][[Category:MAXScript]]==\n<lang maxscript>escapeEnable  = true \nresetMaxFile #noPrompt\nviewport.setType #view_top\nmax tool maximize\nviewport.SetRenderLevel #smoothhighlights\ndelay = 1.6\na = text size:30\na.wirecolor = white\ntheMod = extrude()\naddModifier a theMod\n\nfor i in 99 to 1 by -1 do -- this will iterate through 99 times use the escape key to terminate.\n(\n    a.text = (i as string + \" bottles of beer on the wall\")\n    redrawViews()\n    sleep delay \n    a.text = (i as string + \" bottles of beer\")\n    redrawViews()\n    sleep delay \n    a.text = \"Take one down, pass it around\"\n    redrawViews()\n    sleep delay \n    a.text = ((i-1) as string + \" bottles of beer on the wall\")\n    redrawViews()\n    sleep delay \n)<\/lang>\n\n=== A one-line version ===\nSince MAXscript is an expression based language (everything returns a value), it is relatively easy to write long expressions that are only one line long. the following single-line snippet (broken for clarity on the webpage) produces a grammatically correct printout of the song.\n\n<lang maxscript>for i = 99 to 1 by -1 do (print (i as string + (if i == 1 then \" bottle\" else \" bottles\") + \" of beer on the wall\\n\" + i as string +\\ \n(if i == 1 then \" bottle\" else \" bottles\") + \" of beer\\nTake one down, pass it around\\n\" + (i - 1) as string + (if i - 1 == 1 then \"\\ \nbottle\" else \" bottles\") + \" of beer on the wall\\n\" + (if i - 1 == 0 then \"\\nno more beer\" else \"\")))<\/lang>\n\n==[[:Category:Mirah|Mirah]][[Category:Mirah]]==\n<lang Mirah>plural = 's'\n99.downto(1) do |i|\n  puts \"#{i} bottle#{plural} of beer on the wall,\"\n  puts \"#{i} bottle#{plural} of beer\"\n  puts \"Take one down, pass it around!\"\n  plural = '' if i - 1 == 1\n  if i > 1\n    puts \"#{i-1} bottle#{plural} of beer on the wall!\"\n    puts\n  else\n    puts \"No more bottles of beer on the wall!\"\n  end\nend\n<\/lang>\n\n\n==[[:Category:ML\/I|ML\/I]][[Category:ML\/I]]==\n=== Simple iterative version ===\n<lang ML\/I>MCSKIP \"WITH\" NL\n\"\" 99 bottles - simple iterative version\nMCSKIP MT,<>\nMCINS %.\n\"\" Macro to generate singular or plural bottle(s)\nMCDEF BOT WITHS () AS <bottle<>MCGO L0 IF %A1. EN 1\ns>\n\"\" Main macro - argument is initial number of bottles\nMCDEF BOTTLES NL AS <MCSET T1=%A1.\n%L1.%T1. BOT(%T1.) of beer on the wall\n%T1. BOT(%T1.) of beer\nTake one down, pass it around\nMCSET T1=T1-1\n%T1. BOT(%T1.) of beer on the wall\nMCGO L0 IF T1 EN 0\n\nMCGO L1\n>\n\"\" Do it\nBOTTLES 99<\/lang>\n\n=== Recursive version ===\n<lang ML\/I>MCSKIP \"WITH\" NL\n\"\" 99 bottles - recursive version\nMCSKIP MT,<>\nMCINS %.\n\"\" Macro to generate singular or plural bottle(s)\nMCDEF BOT WITHS () AS <bottle<>MCGO L0 IF %A1. EN 1\ns>\n\"\" Main macro - recurses for each verse - argument is initial number of bottles\nMCDEF BOTTLES NL AS <MCSET T1=%A1.\n%T1. BOT(%T1.) of beer on the wall\n%T1. BOT(%T1.) of beer\nTake one down, pass it around\nMCSET T1=T1-1\n%T1. BOT(%T1.) of beer on the wall\nMCGO L0 IF T1 EN 0\n\nBOTTLES %T1.\n>\n\"\" Do it\nBOTTLES 99<\/lang>\n\n\n=== Macro Processing generalized version in 99 lines ===\n\nThis version demonstrates the macro text replacement capabilities central to ML\/I. \n\nThe code defines a macro \n\n'''Sing''' ''n'' ''containers'' '''of''' ''contents'' ''somewhere'' ''':''' ''deed'' '''!''' ''replenish'' '''.'''\n\nwhere the text (macro call) \n\n'''Sing''' ''99'' ''bottles'' '''of''' ''beer'' '''on''' ''the wall''''':''' ''Take one down, pass it around'' '''!''' ''Go to the store and buy some more'' '''.'''\n\nis macro substituted with the specified 99 bottles of beer song. The text\n\n'''Sing''' ''7'' ''bottles'' '''of''' ''Armagnac'' '''on''' ''the table''''':''' ''Take a swig, throw it down'' '''!''' ''Emilie vists, she brings some more'' '''.'''\n\nwould be substituted with a shorter, more expensive, less social and sexier lyric.\n\nInternal macros define English word replacements for decimal numbers from 0 to 99.\n\n<lang ML\/I>\nMCSKIP - WITH - NL\n-- The line above defines the comment syntax: -- through to newline is completely deleted.\n-- 99 Bottles of beer in 99 lines of ML\/I by Parzival Herzog.\n-- ML\/I is P.J. Brown's famous general purpose macro processor designed in 1967.\n--\n-- Define nestable quotes {...}, replaced by the unevaluated text within:\nMCSKIP MT, {}\n-- Define non-nestable quotes \"...\", replaced by the unevaluated text within:\nMCSKIP T, \"\"\n-- Define the argument insertion and expression evaluation syntax:\n-- ?e. is replaced by the value of macro expression e:\nMCINS ?.\n--\n-- Top level macro: Sing N CONTAINERS of CONTENTS SOMEWHERE : DO THE DEED! REPLENISH.\nMCDEF \"Sing WITH SPACE  SPACE  of WITH SPACE  SPACE  :  !  .\" AS --\n{MCDEF \"CONTAINERS\" AS \"{\"?A2.\"}\"\nMCDEF \"CONTAINER\" AS \"{\"MCSUB(CONTAINERS,1,-1)\"}\"\nMCDEF \"CONTENTS\" AS \"{\"?A3.\"}\"\nMCDEF \"SOMEWHERE\" AS \"{\"?A4.\"}\"\nMCDEF \"DO WITHS THE WITHS DEED\" AS \"{\"?A5.\"}\"\nMCDEF \"REPLENISH\" AS \"{\"?A6.\"}\"\nMCSET T1 = ?A1.\nMCDEF \"n\" AS \"(\"?T1.\")\"\nMCDEF \"N\" AS \"{\"n\"}\"\n?L1.n of CONTENTS SOMEWHERE,\n    n of CONTENTS.\nMCGO L2 UNLESS ?T1. GR 0\nMCSET T1 = T1 - 1\nMCDEF \"n\" AS \"(\"?T1.\")\"\nDO THE DEED:\n    n of CONTENTS SOMEWHERE.\n\nMCGO L1\n?L2.REPLENISH: \n    N of CONTENTS SOMEWHERE!}\n--\n-- (n): Wordify 0 to 99 CONTAINERS\nMCDEF \"()\" AS {MCSET T1=?A1.\nMCGO L1 UNLESS T1 GR 99\n?T1. CONTAINERS-- Return the decimal number instead of words.\nMCGO L0\n?L1.MCGO L2 IF T1 GR 9\nMCDEF \"0units\" AS ?T1.\"Unit\"\nMCGO L3\n?L2.MCSET T3 = T1 - T1\/10*10\nMCDEF \"0units\" AS ?T3.\"unit\"\nMCSET T1 = T1 \/ 10\nMCDEF \"0tens\" AS ?T1.\"Ten\"\n0tens?L3.0units CONTAINERS}\n-- Exceptions:\nMCDEF \"(WITH 0 WITH)\" AS {\"No more\" CONTAINERS}\nMCDEF \"(WITH 1 WITH)\" AS {\"One more\" CONTAINER}\nMCDEF \"(WITH 11 WITH)\" AS {\"Eleven\" CONTAINERS}\nMCDEF \"(WITH 12 WITH)\" AS {\"Twelve\" CONTAINERS}\nMCDEF \"(WITH 13 WITH)\" AS {\"Thirteen\" CONTAINERS}\nMCDEF \"(WITH 14 WITH)\" AS {\"Fourteen\" CONTAINERS}\nMCDEF \"(WITH 15 WITH)\" AS {\"Fifteen\" CONTAINERS}\nMCDEF \"(WITH 16 WITH)\" AS {\"Sixteen\" CONTAINERS}\nMCDEF \"(WITH 17 WITH)\" AS {\"Seventeen\" CONTAINERS}\nMCDEF \"(WITH 18 WITH)\" AS {\"Eighteen\" CONTAINERS}\nMCDEF \"(WITH 19 WITH)\" AS {\"Nineteen\" CONTAINERS}\n-- Regular cases:\nMCDEF \"2Unit\" AS {\"Two\"}\nMCDEF \"3Unit\" AS {\"Three\"}\nMCDEF \"4Unit\" AS {\"Four\"}\nMCDEF \"5Unit\" AS {\"Five\"}\nMCDEF \"6Unit\" AS {\"Six\"}\nMCDEF \"7Unit\" AS {\"Seven\"}\nMCDEF \"8Unit\" AS {\"Eight\"}\nMCDEF \"9Unit\" AS {\"Nine\"}\nMCDEF \"0unit\" AS \nMCDEF \"1unit\" AS {\" one\"}\nMCDEF \"2unit\" AS {\" two\"}\nMCDEF \"3unit\" AS {\" three\"}\nMCDEF \"4unit\" AS {\" four\"}\nMCDEF \"5unit\" AS {\" five\"}\nMCDEF \"6unit\" AS {\" six\"}\nMCDEF \"7unit\" AS {\" seven\"}\nMCDEF \"8unit\" AS {\" eight\"}\nMCDEF \"9unit\" AS {\" nine\"}\nMCDEF \"1Ten\" AS {\"Ten\"}\nMCDEF \"2Ten\" AS {\"Twenty\"}\nMCDEF \"3Ten\" AS {\"Thirty\"}\nMCDEF \"4Ten\" AS {\"Forty\"}\nMCDEF \"5Ten\" AS {\"Fifty\"}\nMCDEF \"6Ten\" AS {\"Sixty\"}\nMCDEF \"7Ten\" AS {\"Seventy\"}\nMCDEF \"8Ten\" AS {\"Eighty\"}\nMCDEF \"9Ten\" AS {\"Ninety\"}\n--\n-- The specified song:\nSing 99 bottles of beer on the wall: Take one down, pass it around! --\nGo to the store and buy some more.\n--\n--\n-- Try uncommenting the next two lines: \n-- Sing 7 flasks of Armagnac on the table: Take a swig, throw it down! \n-- Emilie vists, she brings some more.\n<\/lang>\n\n== Usage: ==\n ml1 \"Bottles of Beer.ml1\"\n\n\n== Output: ==\n<lang ML\/I>\nNinety nine bottles of beer on the wall,\n    Ninety nine bottles of beer.\nTake one down, pass it around:\n    Ninety eight bottles of beer on the wall.\n\nNinety eight bottles of beer on the wall,\n    Ninety eight bottles of beer.\nTake one down, pass it around:\n    Ninety seven bottles of beer on the wall.\n\n    ...\n\n\nOne more bottle of beer on the wall,\n    One more bottle of beer.\nTake one down, pass it around:\n    No more bottles of beer on the wall.\n\nNo more bottles of beer on the wall,\n    No more bottles of beer.\nGo to the store and buy some more:\n    Ninety nine bottles of beer on the wall!\n\n<\/lang>\n\n==[[:Category:Modula-2|Modula-2]][[Category:Modula-2]]==\n<lang modula2>MODULE b99;\nIMPORT  InOut;\n\nVAR     nr      : CARDINAL;\n\nBEGIN\n  nr := 99;\n  REPEAT\n    InOut.WriteCard (nr, 4);\n    InOut.WriteString (\" bottles of beer on the wall\");\n    InOut.WriteLn;\n    InOut.WriteCard (nr, 4);\n    InOut.WriteString (\" bottles of beer\");\n    InOut.WriteLn;\n    InOut.WriteString (\"Take one down, pass it around\");\n    InOut.WriteLn;\n    DEC (nr);\n    InOut.WriteCard (nr, 4);\n    InOut.WriteString (\" bottles of beer on the wall\");\n    InOut.WriteLn;\n    InOut.WriteLn\n  UNTIL nr = 0\nEND b99.<\/lang>\n\n==[[:Category:Modula-3|Modula-3]][[Category:Modula-3]]==\n<lang modula3>MODULE Bottles EXPORTS Main;\n\nIMPORT IO, Fmt;\n\nBEGIN\n  FOR i := 99 TO 1 BY -1 DO\n    IO.Put(Fmt.Int(i) & \" bottles of beer on the wall\\n\");\n    IO.Put(Fmt.Int(i) & \" bottles of beer\\n\");\n    IO.Put(\"Take one down, pass it around\\n\");\n    IO.Put(Fmt.Int(i - 1) & \" bottles of beer on the wall\\n\");\n    IO.Put(\"\\n\");\n  END;\nEND Bottles.<\/lang>\n\n\n==[[:Category:MOO|MOO]][[Category:MOO]]==\n<lang moo>bottles = 99;\nwhile (bottles > 0)\n  unit = (bottles == 1 ? \"bottle\" | \"bottles\");\n  player:tell(bottles, \" \", unit, \" of beer on the wall.\");\n  player:tell(bottles, \" \", unit, \" of beer.\");\n  player:tell(\"Take one down, pass it around.\");\n  bottles = bottles - 1;\nendwhile\nplayer:tell(\"0 bottles of beer on the wall.\");<\/lang>\n\n==[[:Category:MPIF90|MPIF90]][[Category:MPIF90]]==\n<lang fortran>program bottlesMPI\n\n  implicit none\n\n  integer :: ierr,rank,nproc\n  \n  character(len=*), parameter   :: bwall = \" on the wall\", &\n                                   bottles = \"bottles of beer\", &\n                                   bottle  = \"bottle of beer\", &\n                                   take = \"Take one down, pass it around\", &\n                                   form = \"(I0, ' ', A)\"\n\n  call mpi_init(ierr)\n  call mpi_comm_size(MPI_COMM_WORLD,nproc, ierr)\n  call mpi_comm_rank(MPI_COMM_WORLD,rank,ierr)\n\n  if ( rank \/= 1 ) then\n     write (*,form)  rank, bottles \/\/ bwall\n     if ( rank > 0 ) write (*,form)  rank, bottles\n  else\n     write (*,form)  rank, bottle \/\/ bwall\n     write (*,form)  rank, bottle\n  end if\n  if ( rank > 0 ) write (*,*) take\n\n  call mpi_finalize(ierr)\n\nend program bottlesMPI<\/lang>\n\nUsage\n\n  mpif90 filename.f90\n  mpiexec -np 99 a.out\n\n==[[:Category:MUMPS|MUMPS]][[Category:MUMPS]]==\n===Recursive===\n<lang MUMPS>beer(n)\tIf n<1 Write \"No bottles of beer on the wall... \" Quit\n\tWrite !!,n,\" bottle\",$Select(n=1:\"\",1:\"s\"),\" of beer on the wall.\"\n\tWrite !,n,\" bottle\",$Select(n=1:\"\",1:\"s\"),\" of beer.\"\n\tWrite !,\"Take one down, pass it around.\"\n\tDo beer(n-1)\n\tQuit\n\nDo beer(99)<\/lang>\n\n===Iterative===\n<lang MUMPS>beer(n)\tIf n<1 Write \"No bottles of beer on the wall... \" Quit\n\tWrite !!,n,\" bottle\",$Select(n=1:\"\",1:\"s\"),\" of beer on the wall.\"\n\tWrite !,n,\" bottle\",$Select(n=1:\"\",1:\"s\"),\" of beer.\"\n\tWrite !,\"Take one down, pass it around.\"\n\tQuit\n\nFor ii=99:-1:0 Do beer(ii)<\/lang>\n==[[:Category:Nemerle|Nemerle]][[Category:Nemerle]]==\n<lang Nemerle>using System;\nusing System.Console;\n\nmodule Bottles\n{\n    Sing(x : int, bev = \"beer\", surface = \"wall\") : void\n    {\n        match(x)\n        {\n            |0 => WriteLine($\"No more bottles of $bev on the $surface, no more bottles of $bev\");\n                  WriteLine($\"Go to the store and get some more $bev, 99 bottles of $bev on the $surface\")\n            |1 => WriteLine($\"One bottle of $bev on the $surface, one bottle of $bev\");\n                  WriteLine($\"Take it down, pass it around, no more bottles of $bev on the $surface\")\n            |_ => WriteLine($\"$x bottles of $bev on the $surface, $x bottles of $bev\");\n                  WriteLine($\"Take one down and pass it around, $(x-1) bottles of $bev on the $surface\")\n        }\n    }\n    \n    Main() : void \n    {\n        foreach (i in [99, 98 .. 0])\n            Sing(i)\n    }\n}<\/lang>\n\n==[[:Category:NetRexx|NetRexx]][[Category:NetRexx]]==\n<lang netrexx>\nbeer = \"bottles of beer on the wall\"\nremoveOne = \"Take one down, pass it arround,\"\nsay 99 beer\",\"\nsay 99 beer.subword(1,3)\",\"\nloop i = 98 to 2 by -1\n  say removeOne\n  say i beer\".\"\n  say\n  say i beer\",\"\n  say i beer.subword(1,3)\",\"\nend\nlastCall = \"bottle\" beer.delword(1,1)\nsay removeOne\nsay i lastCall\".\"\nsay\nsay i lastCall\",\"\nsay i lastCall.subword(1,3)\",\"\nsay removeOne\nsay \"No more\" beer\n<\/lang>\n\n==[[:Category:NewLISP|NewLISP]][[Category:NewLISP]]==\n<lang newlisp>(for (n 99 1) \n(println n \" bottles of beer on the wall,\" n \" bottles of beer. Take one down, pass it around. \")\n(println (- n 1) \"bottles of beer on the wall!\"))\n\n;;recursive\n;;also shows list afterword\n(define (rec bottles)\n\t(if (!= 0 bottles) (print \"\/n\" bottles \" bottles of beer on the wall\" bottles \" bottles of beer. \n\\nTake one down, pass it around, \" (- bottles 1) \n\" bottles of beer on the wall\" (rec ( - bottles 1))))(list bottles))\n\n(rec 99)<\/lang>\n\n==[[:Category:Nial|Nial]][[Category:Nial]]==\n<lang nial>line is fork [\n  0=, 'No more bottles of beer' first,\n  1=, 'One bottle of beer' first, \n  link [string,' bottles of beer' first]\n]\n\nverse is link [\n  line, ' on the wall, ' first,line,\n  '. Take it down and pass it around, ' first,\n  line (-1+),'on the wall. ' first\n]\n\nbottles is iterate (write verse) reverse count<\/lang>\n\n==[[:Category:Nimrod|Nimrod]][[Category:Nimrod]]==\n<lang nimrod>proc GetBottleNumber(n: int): string =\n  var bs: string\n  if n == 0:\n    bs = \"No more bottles\"\n  elif n == 1:\n    bs = \"1 bottle\"\n  else:\n    bs = $n & \" bottles\"\n  return bs & \" of beer\"\n\nfor bn in countdown(99, 1):\n  var cur = GetBottleNumber(bn)\n  echo(cur, \" on the wall, \", cur, \".\")\n  echo(\"Take one down and pass it around, \", GetBottleNumber(bn-1), \" on the wall.\\n\")\n\necho \"No more bottles of beer on the wall, no more bottles of beer.\"\necho \"Go to the store and buy some more, 99 bottles of beer on the wall.\"<\/lang>\n\n==[[:Category:Objective-C|Objective-C]][[Category:Objective-C]]==\n<lang objc>#import <Foundation\/Foundation.h>\n\nint main()\n{\n    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];\n    int bottles = 99;\n    do\n    {\n        NSLog(@\"%i bottles of beer on the wall\\n\", bottles);\n        NSLog(@\"%i bottles of beer\\n\", bottles);\n        NSLog(@\"Take one down, pass it around\\n\");\n        NSLog(@\"%i bottles of beer on the wall\\n\\n\", --bottles);\n    } while (bottles > 0);\n\t\n    [pool drain];\n    return 0;\n}<\/lang>\n\n==[[:Category:Oberon-2|Oberon-2]][[Category:Oberon-2]]==\n<lang oberon2>MODULE b99;\n\nIMPORT  Out;\n\nVAR     nr      : INTEGER;\n\nBEGIN\n  nr := 99;\n  REPEAT\n    Out.Int (nr, 4);\n    Out.String (\" bottles of beer on the wall\");\n    Out.Ln;\n    Out.Int (nr, 4);\n    Out.String (\" bottles of beer\");\n    Out.Ln;\n    Out.String (\"Take one down, pass it around\");\n    Out.Ln;\n    DEC (nr);\n    Out.Int (nr, 4);\n    Out.String (\" bottles of beer on the wall\");\n    Out.Ln;\n    Out.Ln\n  UNTIL nr = 0\nEND b99.<\/lang>\n\n==[[:Category:OCaml|OCaml]][[Category:OCaml]]==\n<lang ocaml>for n = 99 downto 1 do\n  Printf.printf \"%d bottles of beer on the wall\\n\" n;\n  Printf.printf \"%d bottles of beer\\n\" n;\n  Printf.printf \"Take one down, pass it around\\n\";\n  Printf.printf \"%d bottles of beer on the wall\\n\\n\" (pred n);\ndone<\/lang>\n\nRecursive version that handles plurals.\n\n<lang ocaml>let verse n = \n    let \n        line2 = function\n            | 0 -> \"No more bottles of beer\"\n            | 1 -> \"1 bottle of beer\"\n            | n -> string_of_int n ^ \" bottles of beer\" \n    in\n        let \n            line1or4 y = line2 y ^ \" on the wall\" \n        in\n            let \n                line3 = function\n                | 1 -> \"Take it down, pass it around\"\n                | _ -> \"Take one down, pass it around\" \n            in\n                line1or4 n ^ \"\\n\" ^ \n                line2 n ^ \"\\n\" ^\n                line3 n ^ \"\\n\" ^\n                line1or4 (n-1) ^ \"\\n\";;\n\nlet rec beer n =\n    print_endline (verse n);\n    if n > 1 then beer (n-1);;\n\nbeer 99;;<\/lang>\n\n==[[:Category:Octave|Octave]][[Category:Octave]]==\n<lang octave>function bottles(n)\n  bottle = \"bottle\";\n  ofbeer = \"of beer\";\n  wall = \"on the wall\";\n  for i = n:-1:0\n    if ( i == 1 )\n      s = \"\";\n    else\n      s = \"s\";\n    endif\n    for j = 0:1\n      w = wall;\n      if ( j == 1 )\n\tw = \"\";\n      endif\n      printf(\"%d %s%s %s %s\\n\",\\\n\t     i, bottle, s, ofbeer, w); \n    endfor\n    printf(\"Take one down, pass it around\\n\");\n  endfor\nendfunction\n\nbottles(99);<\/lang>\n==[[:Category:OpenEdge\/Progress|OpenEdge\/Progress]][[Category:OpenEdge\/Progress]]==\n<lang Progress (Openedge ABL)>DEFINE VARIABLE amountofbottles AS INTEGER NO-UNDO INITIAL 99.\n&GLOBAL-DEFINE bbm bottles of beer\n&GLOBAL-DEFINE bbs bottle of beer\n&GLOBAL-DEFINE otw on the wall\n&GLOBAL-DEFINE tow Take one down and pass it around,\n&GLOBAL-DEFINE gts Go to the store and buy some more,\nFUNCTION drinkBottle RETURNS INTEGER PRIVATE (INPUT bc AS INTEGER) FORWARD.\n\nOUTPUT TO OUTPUT.txt.\ndrinkBottle(amountofbottles).\nOUTPUT CLOSE.\n\nFUNCTION drinkBottle RETURNS INTEGER.\n    IF bc >= 0 THEN DO:\n        CASE bc:\n        WHEN 2 THEN\n            PUT UNFORMATTED bc \" {&bbm} {&otw}, \" bc \" {&bbm}\" SKIP \n                            \"{&tow} \" bc - 1 \" {&bbs} {&otw}\" SKIP.\n        WHEN 1 THEN\n            PUT UNFORMATTED bc \" {&bbs} {&otw}, \" bc \" {&bbs}\" SKIP \n                            \"{&tow} no more {&bbm} {&otw}\" SKIP.\n        WHEN 0 THEN\n            PUT UNFORMATTED \"no more\" \" {&bbm} {&otw}, no more {&bbm}\" SKIP \n                            \"{&gts} \" amountofbottles \" {&bbm} {&otw}\" SKIP.\n        OTHERWISE\n            PUT UNFORMATTED bc \" {&bbm} {&otw}, \" bc \" {&bbm}\" SKIP \n                            \"{&tow} \" bc - 1 \" {&bbm} {&otw}\" SKIP.\n        END CASE.        \n        drinkBottle(bc - 1).\n        RETURN bc.\n    END.\n    RETURN 0. \nEND FUNCTION.<\/lang>\n\n==[[:Category:Oz|Oz]][[Category:Oz]]==\n=== Constraint Programming ===\nNote: In real life, you would never solve a simple iterative task like this with constraint programming. This is just for fun.\n<lang oz>declare\n  %% describe the possible solutions of the beer 'puzzle'\n  proc {BeerDescription Solution}\n     N = {FD.int 1#99} %% N is an integer in [1, 99]\n  in\n    %% distribute starting with highest value\n    {FD.distribute generic(value:max) [N]}\n\n     Solution =\n     {Bottles N}#\" of beer on the wall\\n\"#\n     {Bottles N}#\" bottles of beer\\n\"#\n     \"Take one down, pass it around\\n\"#\n     {Bottles N-1}#\" of beer on the wall\\n\"\n  end\n\n  %% pluralization\n  proc {Bottles N Txt}\n     cond N = 1 then Txt =\"1 bottle\"\n     else Txt = N#\" bottles\"\n     end\n  end\nin\n  %% show all solutions to the 'puzzle'\n  {ForAll {SearchAll BeerDescription}\n   System.showInfo}<\/lang>\n\n=== Iterative ===\n<lang oz>declare\n  fun {Bottles N}\n     if N == 1 then \"1 bottle\"\n     else N#\" bottles\"\n     end\n  end\nin\n  for I in 99..1;~1 do\n     {System.showInfo\n      {Bottles I}#\" of beer on the wall\\n\"#\n      {Bottles I}#\" bottles of beer\\n\"#\n      \"Take one down, pass it around\\n\"#\n      {Bottles I-1}#\" of beer on the wall\\n\"}\n  end<\/lang>\n\n==[[:Category:PARI\/GP|PARI\/GP]][[Category:PARI\/GP]]==\n<lang parigp>forstep(n=99,3,-1,\n  print(n\" bottles of beer on the wall\");\n  print(n\" bottles of beer\");\n  print(\"Take one down, pass it around\");\n  print(n-1,\" bottles of beer on the wall\\n\")\n);\nprint(\"2 bottles of beer on the wall\\n2 bottles of beer\\nTake one down, pass it around\\n1 bottle of beer on the wall\\n\");\nprint(\"1 bottle of beer on the wall\\n1 bottle of beer\\nTake one down, pass it around\\nNo more bottles of beer on the wall\")<\/lang>\n\n==[[:Category:Pascal|Pascal]][[Category:Pascal]]==\n<lang pascal>procedure BottlesOfBeer;\nvar\n  i: Integer;\nbegin\n  for i := 99 downto 1 do\n  begin\n    if i = 1 then\n    begin\n      WriteLn('1 bottle of beer on the wall');\n      WriteLn('1 bottle of beer');\n      WriteLn('Take one down, pass it around');\n      WriteLn('No more bottles of beer on the wall');\n      Exit;\n    end;\n    WriteLn(Format('%d bottles of beer on the wall', [i]));\n    WriteLn(Format('%d bottles of beer', [i]));\n    WriteLn('Take one down, pass it around');\n    WriteLn(Format('%d bottles of beer on the wall', [Pred(i)]));\n    WriteLn('');\n  end;\nend;<\/lang>\n\n==[[:Category:Perl|Perl]][[Category:Perl]]==\n<lang perl>#!\/usr\/bin\/perl -w\n\nmy $verse = <<\"VERSE\";\n100 bottles of beer on the wall,\n100 bottles of beer!\nTake one down, pass it around!\n99 bottles of beer on the wall!\n\nVERSE\n\n{\n    $verse =~ s\/(\\d+)\/$1-1\/ge;\n    $verse =~ s\/\\b1 bottles\/1 bottle\/g;\n    my $done = $verse =~ s\/\\b0 bottle\/No bottles\/g; # if we make this replacement, we're also done.\n\n    print $verse;\n    redo unless $done;\n}<\/lang>\n\nAlternatively:\n<lang perl>for $n (reverse(0..99))\n{\n    $bottles = sprintf(\"%s bottle%s of beer on the wall\\n\",(($n==0)?\"No\":$n), (($n==1)?\"\":\"s\"));\n    print( (($n==99)?\"\":\"$bottles\\n\") . \n\t   (($n==0)?\"\":(substr(${bottles}x2,0,-12) . \"\\nTake one down, pass it around\\n\")) );\n}<\/lang>\n\nCorrect grammar and nice spacing in modern perl:\n<lang perl>use 5.10.0;                                                                        \n\n$num = 99;\nwhile ($num > 0) {\n    my $s = \"s\" unless ($num == 1);\n    say \"$num bottle$s of beer on the wall, $num bottle$s of beer\";\n    $num--;\n    my $s = \"s\" unless ($num == 1); \n    $num = \"No more\" if ($num == 0);\n    say \"Take one down, pass it around, $num bottle$s of beer on the wall\\n\"\n}\n\nsay \"No more bottles of beer on the wall, no more bottles of beer.\";\nsay \"Go to the store and buy some more, 99 bottles of beer on the wall.\";<\/lang>\n\n==[[:Category:Perl 6|Perl 6]][[Category:Perl 6]]==\n\n=== A Simple Way ===\n\n<lang perl6>my $b = 99;\n\nsub b($b) {\n    \"$b bottle{'s'.substr($b == 1)} of beer\";\n}\n\nrepeat while --$b {\n    .say for \"&b($b) on the wall\",\n             b($b),\n             'Take one down, pass it around',\n             \"&b($b-1) on the wall\",\n             '';\n}\n<\/lang>\n\n=== A More Extravagant Way ===\n\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Rakudo]] version #22 \"Thousand Oaks\"[[SMW::on]]<\/div>\n<lang perl6>my @quantities = (99 ... 1), 'No more', 99;\nmy @bottles = 'bottles' xx 98, 'bottle', 'bottles' xx 2;\nmy @actions = 'Take one down, pass it around' xx 99,\n              'Go to the store, buy some more';\n\nfor @quantities Z @bottles Z @actions Z\n    @quantities[1 .. *] Z @bottles[1 .. *]\n    -> $a, $b, $c, $d, $e {\n    say \"$a $b of beer on the wall\";\n    say \"$a $b of beer\";\n    say $c;\n    say \"$d $e of beer on the wall\\n\";\n}<\/lang>\n\n==[[:Category:PHP|PHP]][[Category:PHP]]==\n<lang php><?php\n$plural = 's';\nforeach (range(99, 1) as $i) {\n    echo \"$i bottle$plural of beer on the wall,\\n\";\n    echo \"$i bottle$plural of beer!\\n\";\n    echo \"Take one down, pass it around!\\n\";\n    if ($i - 1 == 1)\n        $plural = '';\n    \n    if ($i > 1)\n        echo ($i - 1) . \" bottle$plural of beer on the wall!\\n\\n\";\n    else\n        echo \"No more bottles of beer on the wall!\\n\";\n}\n?><\/lang>\n\nshorter way:\n<lang php><?php\nforeach(range(99,1) as $i) {\n    $p = ($i>1)?\"s\":\"\";\n    echo <<< EOV\n$i bottle$p of beer on the wall\n$i bottle$p of beer\nTake one down, pass it around\n\n\nEOV;\n}\necho \"No more Bottles of beer on the wall\";\n?><\/lang>\nmodifing way:\n<lang php><?php\n$verse = <<<VERSE\n100 bottles of beer on the wall,\n100 bottles of beer!\nTake one down, pass it around!\n99 bottles of beer on the wall!\n\n\nVERSE;\n\nforeach (range(1,99) as $i) { \/\/ loop 99 times\n    $verse = preg_replace('\/\\d+\/e', '$0 - 1', $verse);\n    $verse = preg_replace('\/\\b1 bottles\/', '1 bottle', $verse);\n    $verse = preg_replace('\/\\b0 bottle\/', 'No bottles', $verse);\n\n    echo $verse;\n}\n?><\/lang>\n\n==[[:Category:PicoLisp|PicoLisp]][[Category:PicoLisp]]==\n<lang PicoLisp>(de bottles (N)\n   (case N\n      (0 \"No more beer\")\n      (1 \"One bottle of beer\")\n      (T (cons N \" bottles of beer\")) ) )\n\n(for (N 99 (gt0 N))\n   (prinl (bottles N) \" on the wall,\")\n   (prinl (bottles N) \".\")\n   (prinl \"Take one down, pass it around,\")\n   (prinl (bottles (dec 'N)) \" on the wall.\")\n   (prinl) )<\/lang>\n\n==[[:Category:Piet|Piet]][[Category:Piet]]==\n[http:\/\/www.toothycat.net\/~sham\/piet\/99bottles.png see image]\n\n==[[:Category:Pike|Pike]][[Category:Pike]]==\n<lang pike>int main(){\n   for(int i = 99; i > 0; i--){\n      write(i + \" bottles of beer on the wall, \" + i + \" bottles of beer.\\n\");\n      write(\"Take one down and pass it around, \" + (i-1) + \" bottles of beer on the wall.\\n\\n\");\n   }\n   write(\"No more bottles of beer on the wall, no more bottles of beer.\\n\");\n   write(\"Go to the store and buy some more, 99 bottles of beer on the wall.\\n\");\n}<\/lang>\n\nalternate version:\n<lang Pike>\/\/ disclaimer: i prefer gingerale\n\nvoid main()\n{\n  array numbers = ({ \"no more\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \n                     \"eight\", \"nine\", \"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \n                     \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\" });\n  array decades = ({ \"twenty\", \"thirty\", \"fourty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\",\n                     \"ninety\" });\n\n  foreach (decades;; string decade)\n  { \n    numbers += decade+(({ \"\" }) + numbers[1..9])[*];\n  }\n  numbers = reverse(numbers);\n\n  array bottles = ((numbers[*]+\" bottles of ale on the wall, \")[*] + \n                   (numbers[*]+\" bottles of ale.\\n\")[*]);\n\n  bottles[-2] = replace(bottles[-2], \"one bottles\", \"one bottle\");\n\n  string song = bottles * \"take one down, pass it around,\\n\";\n  write(song);\n}<\/lang>\n\n==[[:Category:PIR|PIR]][[Category:PIR]]==\n\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Parrot]] version Tested with 2.4.0[[SMW::on]]<\/div>\n\n<lang pir>.sub sounding_smart_is_hard_after_drinking_this_many\n  .param int b\n  if b == 1 goto ONE\n  .return(\" bottles \")\nONE:\n  .return(\" bottle \")\n  end\n.end\n\n.sub main :main\n  .local int bottles\n  .local string b\n  bottles = 99\nLUSH:\n  if bottles == 0 goto DRUNK\n  b = sounding_smart_is_hard_after_drinking_this_many( bottles )\n  print bottles\n  print b\n  print \"of beer on the wall\\n\"\n  print bottles\n  print b\n  print \"of beer\\nTake one down, pass it around\\n\"\n  dec bottles\n  b = sounding_smart_is_hard_after_drinking_this_many( bottles )\n  print bottles\n  print b\n  print \"of beer on the wall\\n\\n\"\n  goto LUSH\nDRUNK:\n  end\n.end<\/lang>\n\n==[[:Category:PlainTeX|PlainTeX]][[Category:PlainTeX]]==\n<lang tex>\\def\\ifbeer{\\ifnum\\number\\bottles}\n\\def\\beers{\n\t\\par\\ifbeer>0 \\the\\bottles~\\else No more \\fi\n\tbottle\\ifbeer=1\\else s\\fi~of beer%\n}\n\n\\def\\take #1 down,{\n\t\\par\\advance\\bottles by -#1\n\tTake #1 down, pass it around,\\par\n}\n\n\\long\\def\\verse{\n\t\\beers~on the wall, \\beers.\n\t\\take 1 down,\t\t% curious TeX \\def syntax\n\t\\beers~on the wall.\n\t\\bigskip\n}\n\n\\newcount\\bottles\\bottles99\n\\loop\\verse\n\t\\ifnum\\number\\bottles>0\\repeat\n\n\\bye<\/lang>\n\n==[[:Category:Pop11|Pop11]][[Category:Pop11]]==\n<lang pop11>define bootles(n);\n    while n > 0 do\n        printf(n, '%p bottles of beer on the wall\\n');\n        printf(n, '%p bottles of beer\\n');\n        printf('Take one down, pass it around\\n');\n        n - 1 -> n;\n        printf(n, '%p bottles of beer on the wall\\n');\n    endwhile;\nenddefine;\n\nbootles(99);<\/lang>\n\n==[[:Category:PowerShell|PowerShell]][[Category:PowerShell]]==\n\n===A standard impementation using a For loop===\n<lang PowerShell>for($n=99; $n -gt 0; $n--) {\n   \"$n bottles of beer on the wall\"\n   \"$n bottles of beer\"\n   \"Take one down, pass it around\"\n   [string]($n-1) + \" bottles of beer on the wall\"\n   \"\"\n}<\/lang>\n\n===Consolidating the static text and using a Do...while loop===\n<lang PowerShell>$n=99\ndo {\n   \"{0} bottles of beer on the wall`n{0} bottles of beer`nTake one down, pass it around`n{1} bottles of beer on the wall`n\" -f $n, --$n\n} while ($n -gt 0)<\/lang>\n\n===Consolidating the static text and using a Do...until loop===\n<lang PowerShell>$n=99\ndo {\n   \"{0} bottles of beer on the wall`n{0} bottles of beer`nTake one down, pass it around`n{1} bottles of beer on the wall`n\" -f $n, --$n\n} until ($n -eq 0)<\/lang>\n\n\n===Consolidating the static text even more===\n<lang PowerShell>$s = \"{0} bottles of beer on the wall`n{0} bottles of beer`nTake one down, pass it around`n{1} bottles of beer on the wall`n\"\n$n=99\ndo { $s -f $n, --$n } while ($n -gt 0)<\/lang>\n\n===Using the Pipeline===\n<lang Powershell>99..1 | ForEach-Object { \n    $s=$( if( $_ -ne 1 ) { 's' } else { '' } )\n    $s2=$( if( $_ -ne 2 ) { 's' } else { '' } )\n    \"$_ bottle$s of beer on the wall`n$_ bottle$s of beer`nTake one down`npass it around`n$( $_ - 1 ) bottle$s2 of beer on the wall`n\"}<\/lang>\n\n==[[:Category:ProDOS|ProDOS]][[Category:ProDOS]]==\n<lang ProDOS>editvar \/newvar \/value=a=99\n:a\nprintline -a- bottles of beer on the wall\nprintline -a- bottles of beer\nprintline Take one down, pass it round\neditvar \/newvar \/value=a=-a-1\nif -a- \/hasvalue 1 goto :1\nprintline -a- bottles of beer on the wall.\ngoto :a\n:1 \nprintline 1 bottle of beer on the wall\nprintline 1 bottle of beer\nprintline take it down, pass it round\nprintline no bottles of beer on the wall.\neditvar \/newvar \/value=b \/userinput=1 \/title=Keep drinking?\nif -b- \/hasvalue yes goto :a else exitprogram<\/lang>\n\n==[[:Category:Prolog|Prolog]][[Category:Prolog]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[SWI Prolog]][[SMW::on]]<\/div>\n<lang prolog>bottles(0):-!.\nbottles(X):-\n    writef('%t bottles of beer on the wall \\n',[X]),\n    writef('%t bottles of beer\\n',[X]),\n    write('Take one down, pass it around\\n'),\n    succ(XN,X),\n    writef('%t bottles of beer on the wall \\n\\n',[XN]),\n    bottles(XN).\n\n:- bottles(99).<\/lang>\n\nAn other version that handles plural\/not plural conditions.\n\n<lang prolog>line1(X):- line2(X),write(' on the wall'). \nline2(0):- write('no more bottles of beer').\nline2(1):- write('1 bottle of beer').\nline2(X):- writef('%t bottles of beer',[X]).\nline3(1):- write('Take it down, pass it around').\nline3(X):- write('Take one down, pass it around').\nline4(X):- line1(X).\n \nbottles(0):-!.\nbottles(X):-\t\n    succ(XN,X),\n    line1(X),nl,\n    line2(X),nl,\n    line3(X),nl,\n    line4(XN),nl,nl,\n    !,\n    bottles(XN).\n \n:- bottles(99).<\/lang>\n\n==[[:Category:PureBasic|PureBasic]][[Category:PureBasic]]==\n===Normal version===\n<lang PureBasic>If OpenConsole()\n  Define Bottles=99\n  While Bottles\n    PrintN(Str(Bottles)+\" bottles of beer on the wall\")\n    PrintN(Str(Bottles)+\" bottles of beer\")\n    PrintN(\"Take one down, pass it around\")\n    Bottles-1\n    PrintN(Str(Bottles)+\" bottles of beer on the wall\"+#CRLF$)\n  Wend\n  \n  PrintN(#CRLF$+#CRLF$+\"Press ENTER to exit\"):Input()\n  CloseConsole()\nEndIf<\/lang>\n\n===An object-oriented solution===\n<lang PureBasic>Prototype Wall_Action(*Self, Number.i)\n\nStructure WallClass\n  Inventory.i\n  AddBottle.Wall_Action\n  DrinkAndSing.Wall_Action\nEndStructure\n\nProcedure.s _B(n, Short=#False)\n  Select n\n    Case 0 : result$=\"No more bottles \"\n    Case 1 : result$=Str(n)+\" bottle of beer\"\n    Default: result$=Str(n)+\" bottles of beer\"\n  EndSelect\n  If Not Short: result$+\" on the wall\": EndIf\n  ProcedureReturn result$+#CRLF$\nEndProcedure\n\nProcedure PrintBottles(*Self.WallClass, n)\n  Bottles$=\" bottles of beer \"\n  Bottle$ =\" bottle of beer \"\n  txt$ = _B(*Self\\Inventory)\n  txt$ + _B(*Self\\Inventory, #True)\n  txt$ + \"Take one down, pass it around\"+#CRLF$\n  *Self\\AddBottle(*Self, -1)\n  txt$ + _B(*self\\Inventory)\n  PrintN(txt$)\n  ProcedureReturn *Self\\Inventory\nEndProcedure\n\nProcedure AddBottle(*Self.WallClass, n)\n  i=*Self\\Inventory+n\n  If i>=0\n    *Self\\Inventory=i\n  EndIf\nEndProcedure\n\nProcedure InitClass()\n  *class.WallClass=AllocateMemory(SizeOf(WallClass))\n  If *class\n    InitializeStructure(*class, WallClass)\n    With *class\n      \\AddBottle    =@AddBottle()\n      \\DrinkAndSing =@PrintBottles()\n    EndWith\n  EndIf\n  ProcedureReturn *class\nEndProcedure\n\nIf OpenConsole()\n  *MyWall.WallClass=InitClass()\n  If *MyWall\n    *MyWall\\AddBottle(*MyWall, 99)\n    While *MyWall\\DrinkAndSing(*MyWall, #True): Wend\n    ;\n    PrintN(#CRLF$+#CRLF$+\"Press ENTER to exit\"):Input()\n    CloseConsole()\n  EndIf\nEndIf<\/lang>\n\n==[[:Category:Python|Python]][[Category:Python]]==\n===Normal Code===\n<lang python>def plural(word, amount): # Correctly pluralize a word.\n    if amount == 1:\n        return word\n    else:\n        return word + 's'\n\ndef sing(b, end): # Sing a phrase of the song, for b bottles, ending in end\n    print b or 'No more', plural('bottle', b), end\n\nfor i in range(99, 0, -1):\n    sing(i, 'of beer on the wall,')\n    sing(i, 'of beer,')\n    print 'Take one down, pass it around,'\n    sing(i-1, 'of beer on the wall.\\n')<\/lang>\n\n===Using a template===\n<lang python>verse = '''\\\n%i bottles of beer on the wall\n%i bottles of beer\nTake one down, pass it around\n%i bottles of beer on the wall\n'''\n\nfor bottles in range(99,0,-1):\n    print verse % (bottles, bottles, bottles-1) <\/lang>\n\n===New-style template (Python 2.6)===\n<lang python>verse = '''\\\n{some} bottles of beer on the wall\n{some} bottles of beer\nTake one down, pass it around\n{less} bottles of beer on the wall\n'''\n\nfor bottles in range(99,0,-1):\n    print verse.format(some=bottles, less=bottles-1) <\/lang>\n\n===\"Clever\" generator expression===\n<lang python>a, b, c, s = \" bottles of beer\", \" on the wall\\n\", \"Take one down, pass it around\\n\", str\nprint \"\\n\".join(s(x)+a+b+s(x)+a+\"\\n\"+c+s(x-1)+a+b for x in xrange(99, 0, -1))<\/lang>\n\n===Enhanced \"Clever\" generator expression using lambda===\n<lang python>a = lambda n: \"%u bottle%s of beer on the wall\\n\" % (n, \"s\"[n==1:])\nprint \"\\n\".join(a(x)+a(x)[:-13]+\"\\nTake one down, pass it around\\n\"+a(x-1) for x in xrange(99, 0, -1))<\/lang>\n\n===Using a generator expression (Python 3)===\n<lang python>#!\/usr\/bin\/env python3\n\"\"\"\\\n{0} {2} of beer on the wall\n{0} {2} of beer\nTake one down, pass it around\n{1} {3} of beer on the wall\n\"\"\"\nprint(\"\\n\".join(\n    __doc__.format(\n        i, i - 1,\n        \"bottle\" if i == 1 else \"bottles\",\n        \"bottle\" if i - 1 == 1 else \"bottles\"\n    ) for i in range(99, 0, -1)\n), end=\"\")<\/lang>\n\n===A wordy version===\n<lang python>ones = (\n'', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine'\n)\nprefixes = ('thir', 'four', 'fif', 'six', 'seven', 'eigh', 'nine')\ntens = ['', '', 'twenty' ]\nteens = ['ten', 'eleven', 'twelve']\nfor prefix in prefixes:\n    tens.append(prefix + 'ty')\n    teens.append(prefix +'teen')\ntens[4] = 'forty'\n\ndef number(num): \n    \"get the wordy version of a number\"\n    ten, one = divmod(num, 10)\n    if ten == 0 and one == 0:\n        return 'no'\n    elif ten == 0:\n        return ones[one]\n    elif ten == 1:\n        return teens[one]\n    elif one == 0:\n        return tens[ten]\n    else:\n        return \"%s-%s\" % (tens[ten], ones[one])\n\ndef bottles(beer):\n    \"our rephrase\"\n    return \"%s bottle%s of beer\" % ( \n            number(beer).capitalize(), 's' if beer > 1 else ''\n    )\n\nonthewall = 'on the wall'\ntakeonedown = 'Take one down, pass it around'\nfor beer in range(99, 0, -1): \n    print bottles(beer), onthewall\n    print bottles(beer)\n    print takeonedown\n    print bottles(beer-1), onthewall\n    print<\/lang>\n\n===String Formatting===\n<lang python>for n in xrange(99, 0, -1):\n    ##  The formatting performs a conditional check on the variable.\n    ##  If it formats the first open for False, and the second for True\n    print n, 'bottle%s of beer on the the wall.' % ('s', '')[n == 1]\n    print n, 'bottle%s of beer.' % ('s', '')[n == 1]\n    print 'Take one down, pass it around.'\n    print n - 1, 'bottle%s of beer on the wall.\\n' % ('s', '')[n - 1 == 1]<\/lang>\n\n==[[:Category:Quill|Quill]][[Category:Quill]]==\n<lang quill>bottles := void(int count) {\n  (count > 0) if {\n    new_count := count - 1;\n    (\n      count, \" bottles of beer on the wall\", nl,\n      count, \" bottles of beer\", nl,\n      \"Take one down, pass it around\", nl,\n      new_count, \" bottles of beer on the wall\"\n    ) print;\n    new_count bottles\n  } else {\n    \"No more bottles of beer on the wall!\" print\n  }\n};\n99 bottles<\/lang>\n\n==[[:Category:R|R]][[Category:R]]==\n===Simple looping solution===\n\n<lang R>#a naive function to sing for N bottles of beer...\n\nsong = function(bottles){\n  \n  for(i in bottles:1){ #for every integer bottles, bottles-1 ... 1\n      \n    cat(bottles,\" bottles of beer on the wall \\n\",bottles,\" bottles of beer \\nTake one down, pass it around \\n\",\n        bottles-1, \" bottles of beer on the wall \\n\",\" \\n\" ,sep=\"\")       #join and print the text (\\n means new line)\n    \n        bottles = bottles - 1 #take one down...\n    \n  }\n  \n}\n\nsong(99)#play the song by calling the function<\/lang>\n\n===Vector solutions===\n<lang R>#only one line!\ncat(paste(99:1,ifelse((99:1)!=1,\" bottles\",\" bottle\"),\" of beer on the wall\\n\",99:1,ifelse((99:1)!=1,\" bottles\",\" bottle\"),\" of beer\\n\",\"Take one down, pass it around\\n\",98:0,ifelse((98:0)!=1,\" bottles\",\" bottle\"),\" of beer on the wall\\n\\n\",sep=\"\"),sep=\"\")\n\n#alternative\ncat(paste(lapply(99:1,function(i){paste(paste(rep(paste(i,' bottle',if(i!=1)'s',' of beer',sep=''),2),collapse =' on the wall\\n'),'Take one down, pass it around',paste(i-1,' bottle',if(i!=2)'s',' of beer on the wall',sep=''), sep='\\n')}),collapse='\\n\\n'))<\/lang>\n\n==[[:Category:Rascal|Rascal]][[Category:Rascal]]==\n<lang rascal>\nmodule demo::basic::Bottles\n\nimport IO;\n\nstr bottles(0)     = \"no more bottles\"; \nstr bottles(1)     = \"1 bottle\";\ndefault str bottles(int n) = \"<n> bottles\"; \n\npublic void sing(){ \n  for(n <- [99 .. 1]){\n       println(\"<bottles(n)> of beer on the wall, <bottles(n)> of beer.\");\n       println(\"Take one down, pass it around, <bottles(n-1)> of beer on the wall.\\n\");\n  }  \n  println(\"No more bottles of beer on the wall, no more bottles of beer.\");\n  println(\"Go to the store and buy some more, 99 bottles of beer on the wall.\");\n}\n<\/lang>\n\n==[[:Category:REALbasic|REALbasic]][[Category:REALbasic]]==\nPlace the following in the \"open\" event of a console application.\n<lang REALBasic>dim bottles as Integer = 99\nWhile bottles > 0\nstdout.writeline(str(bottles) + \" bottles of beer on the wall\")\nstdout.writeline(str(bottles) + \" bottles of beer\")\nstdout.writeline(\"Take one down, pass it around\")\nbottles = bottles - 1\nstdout.writeline(str(bottles) + \" bottles of beer on the wall\")\nWend<\/lang>\n\n==[[:Category:REBOL|REBOL]][[Category:REBOL]]==\n<lang REBOL>rebol [\n    Title: \"99 Bottles of Beer\"\n    Author: oofoe\n    Date: 2009-12-11\n    URL: http:\/\/rosettacode.org\/wiki\/99_Bottles_of_Beer\n]\n\n; The 'bottles' function maintains correct grammar.\n\nbottles: func [n \/local b][\n\tb: either 1 = n [\"bottle\"][\"bottles\"]\n\tif 0 = n [n: \"no\"]\n\treform [n b]\n]\n\nfor n 99 1 -1 [print [\n\tbottles n  \"of beer on the wall\" crlf\n\tbottles n  \"of beer\" crlf\n\t\"Take one down, pass it around\" crlf\n\tbottles n - 1  \"of beer on the wall\" crlf\n]]<\/lang>\n\nOutput ''(selected highlights)'':\n\n<pre>\n99 bottles of beer on the wall    2 bottles of beer on the wall \n99 bottles of beer                2 bottles of beer             \nTake one down, pass it around     Take one down, pass it around \n98 bottles of beer on the wall    1 bottle of beer on the wall  \n                                                                \n...Continues...                   1 bottle of beer on the wall  \n                                  1 bottle of beer              \n                                  Take one down, pass it around \n                                  no bottles of beer on the wall\n\n<\/pre>\n\n==[[:Category:Retro|Retro]][[Category:Retro]]==\nThis is based on the [[Forth]] example.\n\n<lang Retro>[ dup \"%d bottles\" puts ]\n[ \"1 bottle\" puts ]\n[ \"no more bottles\" puts  ]\ncreate bottles , , ,\n \n: .bottles  dup 2 ^math'min bottles + @ do ;\n: .beer     .bottles \" of beer\" puts ;\n: .wall     .beer    \" on the wall\" puts ;\n: .take     \"Take one down, pass it around\" puts ;\n: .verse    .wall cr .beer cr\n            1- .take cr .wall cr ;\n: ?dup      dup 0; ;\n: verses    [ cr .verse dup 0 <> ] while drop ;\n \n99 verses\nbye<\/lang>\n\n==[[:Category:REXX|REXX]][[Category:REXX]]==\n<lang rexx>\/*REXX pgm displays the words to the song \"99 Bottles of Beer on the Wall\" *\/\n  do j=99 by -1 to 1\n  say j 'bottle's(j) \"of beer the wall,\"\n  say j 'bottle's(j) \"of beer.\"\n  say 'Take one down, pass it around,'\n  n=j-1\n  if n==0 then n='no'                         \/*cheating to use 0. *\/\n  say n 'bottle's(j-1) \"of beer the wall.\"\n  say\n  end\n\nsay 'No more bottles of beer on the wall,'    \/*the last verse. *\/\nsay 'no more bottles of beer.'\nsay 'Go to the store and buy some more,'\nsay '99 bottles of beer on the wall.'\nexit\n\ns: if arg(1)=1 then return '';   return 's'   \/*a simple pluralizer.*\/<\/lang>\n'''out0ut''' Below is the first and last three verses of the song.\n<pre style=\"height:30ex\">\n99 bottles of beer the wall,\n99 bottles of beer.\nTake one down, pass it around,\n98 bottles of beer the wall.\n\n98 bottles of beer the wall,\n98 bottles of beer.\nTake one down, pass it around,\n97 bottles of beer the wall.\n\n97 bottles of beer the wall,\n97 bottles of beer.\nTake one down, pass it around,\n96 bottles of beer the wall.\n\n  \u2219\n  \u2219\n  \u2219\n\n2 bottles of beer the wall,\n2 bottles of beer.\nTake one down, pass it around,\n1 bottle of beer the wall.\n\n1 bottle of beer the wall,\n1 bottle of beer.\nTake one down, pass it around,\nno bottles of beer the wall.\n\nNo more bottles of beer on the wall,\nno more bottles of beer.\nGo to the store and buy some more,\n99 bottles of beer on the wall.\n<\/pre>\n\n==[[:Category:RPL\/2|RPL\/2]][[Category:RPL\/2]]==\n===Simple solution===\n<lang rpl\/2>BEER\n<<\n    99 do\n        dup ->str PLURAL \" on the wall,\" + disp\n        dup ->str PLURAL \".\" + disp\n        \"Take one down, pass it around,\" disp\n        1 -\n        if dup then\n            dup ->str\n        else\n            \"No more\"\n        end\n        PLURAL \" on the wall.\" + disp\n        \"\" disp\n    until dup 0 == end\n    drop\n>>\n\nPLURAL\n<<\n    \" bottle\" + over if 1 <> then \"s\" + end \" of beer\" +\n>><\/lang>\n\n===Recursive and multithreaded solution===\n<lang rpl\/2>BOTTLES\n<<\n        \/\/ Child process is started.\n        100 'RECURSIVE' detach\n        -> PROC\n        <<\n                do PROC recv until end drop2\n\n                do\n                        \/\/ Parent waits for datas sent by child.\n                        do PROC recv until end\n                        list-> drop dup \" on the wall,\" + disp \".\" + disp\n                        \"Take one down, pass it around,\" disp\n\n                        if dup 1 same not then\n                                do PROC recv until end list-> drop\n                        else\n                                1 \"No more bottles of beer\"\n                        end\n                        \" on the wall.\" + disp drop \"\" disp\n                until\n                        1 same\n                end\n\n                \/\/ Parent waits for Child's death.\n                PROC wfproc\n        >>\n>>\n\nRECURSIVE\n<<\n        while\n                dup\n        repeat\n                1 - dup dup ->str\n                if over 1 > then \" bottles \" else \" bottle \" end +\n                \"of beer\" + 2 ->list dup\n                \/\/ Child send datas to parent process.\n                send send\n                \/\/ Recursive function is caught.\n                RECURSIVE\n        end\n>><\/lang>\n\n==[[:Category:Ruby|Ruby]][[Category:Ruby]]==\n<lang ruby>plural = 's'\n99.downto(1) do |i|\n  puts \"#{i} bottle#{plural} of beer on the wall,\"\n  puts \"#{i} bottle#{plural} of beer\"\n  puts \"Take one down, pass it around!\"\n  plural = '' if i - 1 == 1\n  if i > 1\n    puts \"#{i-1} bottle#{plural} of beer on the wall!\"\n    puts\n  else\n    puts \"No more bottles of beer on the wall!\"\n  end\nend<\/lang>\n\nRuby has variable traces, so we can do\n<lang ruby>trace_var :$bottle_num do |val|\n  $bottles = %Q{#{val == 0 ? 'No more' : val.to_s} bottle#{val == 1 ? '' : 's'}}\nend\n\n($bottle_num = 99).times do\n  puts \"#{$bottles} of beer on the wall\"\n  puts \"#{$bottles} of beer\"\n  puts \"Take one down, pass it around\"\n  $bottle_num -= 1\n  puts \"#{$bottles} of beer on the wall\"\n  puts \"\"\nend<\/lang>\nor...\n<lang ruby>def bottles(of_beer, ending)\n  puts \"#{of_beer} bottle#{ending} of beer on the wall,\"\n  puts \"#{of_beer} bottle#{ending} of beer\"\n  puts \"Take one down, pass it around!\"\nend\n\n99.downto(0) do |left|\n  if left > 1\n    bottles(left, \"s\")\n  elsif left == 1\n    bottles(left, \"\")\n  else\n    puts \"No more bottles of beer on the wall!\"\n  end\nend<\/lang>\nor...\n<lang ruby>def bottles(beer, wall = false)\n  \"#{beer>0 ? beer : \"no more\"} bottle#{\"s\" if beer!=1} of beer#{\" on the wall\" if wall}\"\nend\n\n99.downto(0) do |remaining|\n  puts \"#{bottles(remaining,true).capitalize}, #{bottles(remaining)}.\"\n  if remaining==0\n    print \"Go to the store and buy some more\"\n    remaining=100\n  else\n    print \"Take one down, pass it around\"\n  end\n  puts \", #{bottles(remaining-1,true)}.\\n\\n\"\nend<\/lang>\n\n==[[:Category:Run BASIC|Run BASIC]][[Category:Run BASIC]]==\n<lang Runbasic>b$ = \" bottles\"\nfor bottles = 99 To 1 Step -1\n   If (bottles = 1) then b$ = \" bottle\"\n   print  bottles;b$;\" of beer on the wall, \"\n   print bottles ;b$;\" of beer\"\n   print \"Take one down, pass it around, \"\n   if bottles = 1 then \n      print \"No bottles of beer on the wall\"\n   else\n      print bottles - 1;b$;\" of beer on the wall.\";chr$(10)\n   end if\nnext bottles<\/lang>\n\n==[[:Category:Sather|Sather]][[Category:Sather]]==\n<lang sather>class MAIN is\n  main is\n    s :STR;\n    p1 ::= \"<##> bottle<#> of beer\";\n    w  ::= \" on the wall\";\n    t  ::= \"Take one down, pass it around\\n\";\n    loop i ::= 99.downto!(0);\n      if i \/= 1 then s := \"s\" else s := \"\"; end;\n      #OUT + #FMT(p1 + w + \"\\n\", i, \"s\");\n      #OUT + #FMT(p1 + \"\\n\", i, \"s\");\n      if i > 0 then #OUT + t; end;\n    end;\n  end;\nend;<\/lang>\n\n==[[:Category:Scala|Scala]][[Category:Scala]]==\nSee [[99 Bottles of Beer\/Scala]]\n\n==[[:Category:Scheme|Scheme]][[Category:Scheme]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Chicken Scheme]][[SMW::on]]<\/div>\n<lang scheme>(define (bottles x)\n\t(format #t \"~a bottles of beer on the wall~%\" x)\n\t(format #t \"~a bottles of beer~%\" x)\n\t(format #t \"Take one down, pass it around~%\")\n\t(format #t \"~a bottles of beer on the wall~%\" (- x 1))\n\t(if (> (- x 1) 0)\n\t\t(bottles (- x 1))))<\/lang>\n\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Racket]][[SMW::on]]<\/div> (moved from the Racket language entry, may be redundant) \n<lang scheme>\n#lang racket\n\n(define (plural n)\n  (string-append (number->string n) \" bottle\" (if (equal? n 1) \"\" \"s\")))\n\n(define (sing bottles)\n    (printf \"~a of beer on the wall\\n~a of beer\\nTake on down, pass it around\\n~a of beer on the wall\\n\\n\" (plural bottles) (plural bottles) (plural (sub1 bottles))))\n\n(for ((i (in-range 100 0 -1)))\n  (sing i))\n<\/lang>\n==[[:Category:Scratch|Scratch]][[Category:Scratch]]==\n<div style=\"overflow: auto;\">\n[[File:Scratchbeer.jpg]]\n<\/div>\n\n==[[:Category:Seed7|Seed7]][[Category:Seed7]]==\n<lang seed7>$ include \"seed7_05.s7i\";\n\nconst proc: main is func\n  local\n    var integer: number is 0;\n  begin\n    for number range 99 downto 2 do\n      write(   number <& \" bottles of beer on the wall, \");\n      writeln( number <& \" bottles of beer.\");\n      write(  \"Take one down and pass it around, \");\n      writeln( pred(number) <& \" bottles of beer on the wall.\");\n      writeln;\n    end for;\n    writeln(\"1 bottle of beer on the wall, 1 bottle of beer.\");\n    writeln(\"Take one down and pass it around, no more bottles of beer on the wall.\");\n    writeln;\n    writeln(\"No more bottles of beer on the wall, no more bottles of beer.\");\n    writeln(\"Go to the store and buy some more, 99 bottles of beer on the wall.\")    \n  end func;<\/lang>\n\n==[[:Category:Shiny|Shiny]][[Category:Shiny]]==\n<lang shiny>for 99 i:99-a\n    s: if i > 1 's' end\n\n    if i > 0 and i < 99 switch\n        if i = 6  say \"A six-pack on the wall!\\n\" break\n        if i = 24 say \"A carton on the wall!\\n\"   break\n        say \"$i bottle$s of beer on the wall!\\n\"\n    ends\n\n    say \"$i bottle$s of beer on the wall,\"\n    say \"$i bottle$s of beer!\"\n    say \"Take one down, pass it around!\"\nend\nsay \"Aww...no more bottles of beer on the wall... it must be your shout :)\"<\/lang>\n\n==[[:Category:Slate|Slate]][[Category:Slate]]==\n<lang slate>n@(Integer traits) bottleVerse\n[| nprinted |\n  nprinted: n printString ; ' bottle' ; (n > 1 ifTrue: ['s'] ifFalse: ['']) ; ' of beer'.\n  inform: nprinted ; ' on the wall.'.\n  inform: nprinted.\n  inform: 'Take one down, pass it around.'.\n  inform: nprinted ; ' on the wall.'.\n].\n\nx@(Integer traits) bottles\n[\n  x downTo: 0 do: #bottleVerse `er\n].\n\n99 bottles.<\/lang>\n\n==[[:Category:Smalltalk|Smalltalk]][[Category:Smalltalk]]==\nA straightforward approach:\n<lang smalltalk>Smalltalk at: #sr put: 0 ; at: #s put: 0 !\nsr := Dictionary new.\nsr at: 0 put: ' bottle' ;\n   at: 1 put: ' bottles' ;\n   at: 2 put: ' of beer' ;\n   at: 3 put: ' on the wall' ;\n   at: 4 put: 'Take one down, pass it around' !\n99 to: 0 by: -1 do: [:v | v print.\n         ( v == 1 ) ifTrue: [ s := 0. ] \n\t            ifFalse: [ s := 1. ].\n\t Transcript show: (sr at:s) ; show: (sr at:2) ; show: (sr at:3) ; cr.\n\t            v print.\n\t Transcript show: (sr at:s) ; show: (sr at:2) ; cr.\n\t\t    (v ~~ 0) ifTrue: [ Transcript show: (sr at:4) ; cr. ].\n   ].<\/lang>\n\n==[[:Category:SNOBOL4|SNOBOL4]][[Category:SNOBOL4]]==\n<lang snobol>\tx = 99\nagain\toutput = X \" bottles of beer on the wall\"\n\toutput = X \" bottles of beer\"  ?eq(X,0)\t:s(zero)\n\toutput = \"Take one down, pass it around\"\n\toutput = (X = gt(x,0) X - 1) \" bottle of beer on the wall...\" :s(again)\nzero\toutput = \"Go to store, get some more\"\n\toutput = \"99 bottles of beer on the wall\"\nend<\/lang>\n\n===Function===\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Macro Spitbol]][[SMW::on]]<\/div>\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[CSnobol]][[SMW::on]]<\/div>\nFunction version with string composition. Function returns one verse for x bottles. Correctly handles bottle\/bottles.\n<lang SNOBOL4>        define('bottles(x)')\n        nl = char(13) char(10) ;* Win\/DOS, change as needed\n        s2 = ' of beer'; s3 = ' on the wall'\n        s4 = 'Take one down, pass it around'\n        s5 = 'Go to the store, get some more' :(bottles_end)\nbottles s1 = (s1 = ' Bottle') ne(x,1) 's'\n        output = nl x s1 s2 s3 nl x s1 s2\n        x = gt(x,0) x - 1 :f(done)\n        s1 = (s1 = ' Bottle') ne(x,1) 's'\n        output = s4 nl x s1 s2 s3 :(return)\ndone    output = s5 nl 99 s1 s2 s3 :(return)\nbottles_end\n\n*       # Test and display, only 2 bottles!\n        n = 2\nloop    bottles(n); n = gt(n,0) n - 1 :s(loop)\nend<\/lang>\n\nOutput:\n<pre>2 Bottles of beer on the wall\n2 Bottles of beer\nTake one down, pass it around\n1 Bottle of beer on the wall\n\n1 Bottle of beer on the wall\n1 Bottle of beer\nTake one down, pass it around\n0 Bottles of beer on the wall\n\n0 Bottles of beer on the wall\n0 Bottles of beer\nGo to the store, get some more\n99 Bottles of beer on the wall<\/pre>\n\n==[[:Category:SNUSP|SNUSP]][[Category:SNUSP]]==\n<lang snusp>   \/=!\/===========!\/==+++++++++#   +9\n   |  |  \/=!\/=====@\/==@@@+@+++++# +48 (itoa)\n   |  |  |  |  \/==!\/==@@@@=++++#  +32 (space)\n   |  |  |  |  |   \\==@@++\\!+++++++++++++\\!+++++\\ \n   9  9 '9  9' space     'b'            'o'    't'\n $@\/>@\/>@\/>@\/>@\/>========@\/>============@\/>====@\/>++++++++++  \\n  setup\n\/====================================loop=====>\\!=>\\!<<<<<<<< \/\n\\@\\@\\>cr.@\\< ?\\<->+++++++++>->+++++++++\\       |   |\n  ! |     |   \\===-========>=>-==BCD==!\\< @\\< ?\/< ?\/# no more beer!\n  \/=|=====|================================\/\n  | |     \\<++t.<<----a.>----k.<++++e.<_.>>++++o.-n.< e.<_.>-d.>+o.>+++w.<-n.<<_.\\ \n  | |     \/                                                                      \/\n  | |     \\>---a.>n.<+++d.<_.>>++p.<---a.>>----s.s.<<<_.>>-------i.>+t.<<<_.\\ \n  | |     \/                                                                 \/\n  | |     \\>a.>>--r.<++++++o.>+++u.<-n.<+++d.>>>cr.<-T<+O<--B<<<#\n  | !\n  \\@\\<<<_.>>o.-n.<<_.>>>++t.<<+++h.---e.<_.>>>+++w.<<----a.>--l.l.>>CR.<---T<+++O<+B<<<#\n    |\n    \\9.>9.>_.>B.>O.>T.t.<---l.<+++e.>>-s.<<<_.>>+++O.<+f.<_.>----b.+++e.E.>>-R.#<\/lang>\n\n==[[:Category:Squirrel|Squirrel]][[Category:Squirrel]]==\n<lang squirrel>\nfunction rec(bottles)\n{\n    if (bottles > 0)\n    {\n        print(bottles+\" bottles of beer on the wall\\n\")\n        print(bottles+\" bottles of beer\\n\");\n        print(\"Take one down, pass it around\\n\");\n        print(--bottles+\" bottles of beer on the wall\\n\\n\")\n        return rec(bottles);\n    }\n    print(\"No more bottles of beer on the wall, no more bottles of beer\\n\");\n    print(\"Go to the store and get some more beer, 99 bottles of beer on the wall\\n\");\n}\n\nrec(99);\n<\/lang>\n\n==[[:Category:Standard ML|Standard ML]][[Category:Standard ML]]==\n<lang sml>fun bottles 0 = ()\n  | bottles x = ( print (Int.toString x ^ \" bottles of beer on the wall\\n\");\n                  print (Int.toString x ^ \" bottles of beer\\n\");\n                  print \"Take one down, pass it around\\n\";\n                  print (Int.toString (x-1) ^ \" bottles of beer on the wall\\n\");\n                  bottles (x-1)\n                )<\/lang>\n\n==[[:Category:Suneido|Suneido]][[Category:Suneido]]==\n<lang Suneido>i = 99\nwhile (i > 0)\n    {\n    Print(i $ ' bottles of beer on the wall')\n    Print(i $ ' bottles of beer')\n    Print('Take one down, pass it around')\n    --i\n    if i is 0\n        Print('Ahh poo, we are out of beer\\n')\n    else\n        Print(i $ ' bottles of beer on the wall\\n')\n    }<\/lang>\n\n==[[:Category:Tcl|Tcl]][[Category:Tcl]]==\n<lang tcl>set s \"s\"; set ob \"of beer\"; set otw \"on the wall\"; set more \"Take one down and pass it around\"\nfor {set n 100} {$n ne \"No more\"} {} {\n\tswitch -- [incr n -1] {\n\t\t1 {set s \"\"} \n\t\t0 {set s \"s\"; set n \"No more\"; set more \"Go to the store and buy some more\"}\n\t}\n\tlappend verse \". $n bottle$s $ob $otw.\\n\"\n\tlappend verse \"\\n$n bottle$s $ob $otw, [string tolower $n] bottle$s $ob.\\n$more\"\n}\nputs -nonewline [join [lreplace $verse 0 0] \"\"][lindex $verse 0]<\/lang>\nVersion which converts numbers to words, optimized for script length while retaining readability:\n<lang tcl>proc 0-19 {n} {\n    lindex {\"no more\" one two three four five six seven eight nine ten eleven\n            twelve thirteen fourteen fifteen sixteen seventeen eighteen nineteen} $n\n}\n\nproc TENS {n} {\n    lindex {twenty thirty fourty fifty sixty seventy eighty ninety} [expr {$n - 2}]\n}\n\nproc num2words {n} {\n    if {$n < 20} {return [0-19 $n]}\n    set tens [expr {$n \/ 10}]\n    set ones [expr {$n % 10}]\n    if {$ones == 0} {return [TENS $tens]}\n    return \"[TENS $tens]-[0-19 $ones]\"\n}\n\nproc get_words {n} {\n    return \"[num2words $n] bottle[expr {$n != 1 ? \"s\" : \"\"}] of beer\"\n}\n\nfor {set i 99} {$i > 0} {incr i -1} {\n    puts [string totitle \"[get_words $i] on the wall, [get_words $i].\"]\n    puts \"Take one down and pass it around, [get_words [expr {$i - 1}]] on the wall.\\n\"\n}\n\nputs \"No more bottles of beer on the wall, no more bottles of beer.\"\nputs \"Go to the store and buy some more, 99 bottles of beer on the wall.\"<\/lang>\nSee also [[99 Bottles of Beer\/Tcl]]\n\n==[[:Category:Thyrd|Thyrd]][[Category:Thyrd]]==\n[[File:Thyrd-9bottles.png|300px|thumb|none|main]]\n[[File:Thyrd-9bottles-detail.png|300px|thumb|none|detail]]\n* [http:\/\/www.youtube.com\/watch?v=AwTQEJdh9aQ Screencast of program running (20s)]\n* [http:\/\/www.youtube.com\/watch?v=_DB9UhPr4rM Screencast of program begin debugged (2m 16s)]\n\n==[[:Category:TI-83 BASIC|TI-83 BASIC]][[Category:TI-83 BASIC]]==\n<lang ti83b>PROGRAM:BEER\n:For(I,99,1,-1)\n:Disp I\n:Disp \"BOTTLES OF BEER\"\n:Disp \"ON THE WALL,\"\n:Disp I\n:Pause \"BOTTLES OF BEER,\"\n:Disp \"TAKE ONE DOWN,\"\n:Disp \"PASS IT AROUND,\"\n:Disp I-1\n:Disp \"BOTTLES OF BEER\"\n:Disp \"ON THE WALL.\"\n:End\n<\/lang>\n\n==[[:Category:TI-89 BASIC|TI-89 BASIC]][[Category:TI-89 BASIC]]==\n<lang ti89b>Prgm\n  Local i,plural,clockWas,t,k,wait\n  \"s\" \u2192 plural\n  0 \u2192 k\n  isClkOn() \u2192 clockWas\n\n  Define wait() = Prgm\n  EndPrgm\n\n  ClockOn\n\n  For i,99,0,\u20131\n    Disp \"\"\n    Disp string(i) & \" bottle\" & plural & \" of beer on the\"\n    Disp \"wall, \" & string(i) & \" bottle\" & plural & \" of beer.\"\n\n    getTime()[3]\u2192t\n    While getTime()[3] = t and k = 0 : getKey() \u2192 k : EndWhile\n    If k \u2260 0 Then : Exit : EndIf\n\n    Disp \"Take one down, pass it\"\n    Disp \"around.\"\n\n    getTime()[3]\u2192t\n    While getTime()[3] = t and k = 0 : getKey() \u2192 k : EndWhile\n    If k \u2260 0 Then : Exit : EndIf\n\n    If i - 1 = 1 Then\n      \"\" \u2192 plural\n    EndIf\n    If i > 1 Then\n        Disp string(i-1) & \" bottle\" & plural & \" of beer on the\"\n        Disp \"wall.\"\n    Else\n        Disp \"No more bottles of beer on\"\n        Disp \"the wall.\"\n    EndIf\n\n    getTime()[3]\u2192t\n    While abs(getTime()[3] - t)<2 and k = 0 : getKey() \u2192 k : EndWhile\n    If k \u2260 0 Then : Exit : EndIf\n\n  EndFor\n  If not clockWas Then\n    ClockOff\n  ENdIf\nEndPrgm<\/lang>\n\n==[[:Category:TIScript|TIScript]][[Category:TIScript]]==\n<lang javascript>\nvar beer = 99;\nwhile (beer > 0)\n{\n stdout.printf( \"%d bottles of beer on the wall\\n\", beer);\n stdout.printf( \"%d bottles of beer\\n\", beer);\n stdout.println( \"Take one down, pass it around\" );\n stdout.printf( \"%d bottles of beer on the wall\\n\", --beer );\n}\n<\/lang>\n\n==[[:Category:TUSCRIPT|TUSCRIPT]][[Category:TUSCRIPT]]==\n<lang tuscript>\n$$ MODE TUSCRIPT\nLOOP bottle=1,100\nSET bottlenr=100-bottle\nIF (bottlenr==0) THEN\nPRINT \"no bottle of beer on the wall\"\nEXIT\nELSEIF (bottlenr==1) THEN\nPRINT bottlenr, \" bottle of beer on the wall\"\nPRINT bottlenr, \" bottle of beer\"\nELSE\nPRINT bottlenr, \" bottles of beer on the wall\"\nPRINT bottlenr, \" bottles of beer\"\nENDIF\nPRINT \"Take one down, pass it around\"\nENDLOOP\n<\/lang>\n\n==[[:Category:TXR|TXR]][[Category:TXR]]==\n\nThe <code>(range 99 -1 -1)<\/code> expression produces a lazy list of integers from 99 down to -1. The <code>mapcar*<\/code> function lazily maps these numbers to strings, and the rest of the code treats this lazy list as text stream to process, extracting the numbers with some pattern matching cases and interpolating them into the song's text. Functional programming with lazy semantics meets text processing, pattern matching and here documents.\n\n<lang txr>@(next :list @(mapcar* (fun tostring) (range 99 -1 -1)))\n@(collect)\n@number\n@  (trailer)\n@number_less_1\n@  (cases)\n@    (bind number \"1\")\n@    (output)\n1 bottle of beer one the wall\n1 bottle of beer\n@    (end)\n@  (or)\n@    (output)\n@number bottles of beer one the wall\n@number bottles of beer\n@    (end)\n@  (end)\n@  (cases)\n@    (bind number \"0\")\n@    (output)\nGo to the store and get some more,\n99 bottles of beer on the wall!\n\n@    (end)\n@  (or)\n@    (output)\nTake one down and pass it around\n@number_less_1 bottles of beer on the wall\n\n@    (end)\n@  (end)\n@(end)<\/lang>\n\nTo make the song repeat indefinitely, change the first line to:\n\n<lang txr>@(next :list @(mapcar* (fun tostring) (repeat (range 99 0 -1))))<\/lang>\n\nNow it's processing an infinite lazy lists consisting of\nrepetitions of the integer sequences 99 98 ... 0.\n\n==[[:Category:UNIX Shell|UNIX Shell]][[Category:UNIX Shell]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Bourne Shell]][[SMW::on]]<\/div>\n<lang bash>#!\/bin\/sh\n\ni=99 s=s\n\nwhile [ $i -gt 0 ]; do\n        echo \"$i bottle$s of beer on the wall\"\n        echo \"$i bottle$s of beer\nTake one down, pass it around\"\n        # POSIX allows for $(( i - 1 )) but some older Unices didn't have that\n        i=`expr $i - 1`\n\t[ $i -eq 1 ] && s= || s=s\n        echo \"$i bottle$s of beer on the wall\n\"\ndone<\/lang>\n\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Bash]][[SMW::on]]<\/div>\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[ksh93]][[SMW::on]]<\/div>\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[zsh]][[SMW::on]]<\/div>\n<lang bash>bottles() {\n  beer=$1\n  [ $((beer)) -gt 0 ] && echo -n $beer ||  echo -n \"No more\"\n  echo -n \" bottle\"\n  [ $((beer)) -ne 1 ] && echo -n \"s\"\n  echo -n \" of beer\"\n}\n\nfor ((i=99;i>=0;i--)); do\n  ((remaining=i))\n  echo \"$(bottles $remaining) on the wall\"\n  echo \"$(bottles $remaining)\"\n  if [ $((remaining)) -eq 0 ]; then\n    echo \"Go to the store and buy some more\"\n    ((remaining+=99))\n  else\n    echo \"Take one down, pass it around\"\n    ((remaining--))\n  fi\n  echo \"$(bottles $remaining) on the wall\"\n  echo\ndone<\/lang>\n\n===[[:Category:C Shell|C Shell]][[Category:C Shell]]===\n<lang csh>@ i=99\nset s=s\nwhile ($i > 0)\n\techo \"$i bottle$s of beer on the wall\"\n\techo \"$i bottle$s of beer\"\n\techo \"Take one down, pass it around\"\n\t@ i = $i - 1\n\tif ($i == 1) then\n\t\tset s=\n\telse\n\t\tset s=s\n\tendif\n\techo \"$i bottle$s of beer on the wall\"\n\techo \"\"\nend<\/lang>\n\n===[[:Category:es|es]][[Category:es]]===\n<lang es>i = 99\ns = s\nwhile {test $i -gt 0} {\n\techo $i bottle$s of beer on the wall\n\techo $i bottle$s of beer\n\techo Take one down, pass it around\n\ti = `{expr $i - 1}\n\tif {test $i -eq 1} {s = ''} {s = s}\n\techo $i bottle$s of beer on the wall\n\techo\n}<\/lang>\n\n==[[:Category:UnixPipes|UnixPipes]][[Category:UnixPipes]]==\n<lang bash># Unix Pipes, avoiding all the turing complete sub programs like sed, awk,dc etc.\nmkdir 99 || exit 1\ntrap \"rm -rf 99\" 1 2 3 4 5 6 7 8\n\n(cd 99\n   mkfifo p.b1 p.b2 p.verse1 p.wall p.take\n   yes \"on the wall\" > p.wall &\n   yes \"Take one down and pass it around, \" > p.take &\n   (yes \"bottles of beer\" | nl -s\\ | head -n 99 | tac | head -n 98 ;\n    echo \"One bottle of beer\";\n    echo \"No more bottles of beer\") | tee p.b1 p.b2 |\n   paste -d\"\\ \" - p.wall p.b1 p.take | head -n 99 > p.verse1 &\n   cat p.b2 | tail -99 | paste -d\"\\ \" p.verse1 - p.wall | head -n 99\n)\nrm -rf 99<\/lang>\n\n==[[:Category:Ursala|Ursala]][[Category:Ursala]]==\n<lang Ursala>#import nat\n\n# each function takes a natural number to a block of text\n\nquantity = # forms the plural as needed\n\n~&iNC+ --' of beer'+ ~&?(\n   1?=\/'1 bottle'! --' bottles'+ ~&h+ %nP,\n   'no more bottles'!)\n\nverse =\n\n^(successor,~&); (\"s\",\"n\"). -[\n   -[quantity \"s\"]- on the wall, -[quantity \"s\"]-,\n   Take one down and pass it around, -[quantity \"n\"]- on the wall.]-\n\nrefrain \"n\" =\n\n-[\n   No more bottles of beer on the wall, -[quantity 0]-.\n   Go to the store and buy some more, -[quantity \"n\"]- on the wall.]-\n\nwhole_song \"n\" = ~&ittt2BSSL (verse*x iota \"n\")--<refrain \"n\">\n\n#show+\n\nmain = whole_song 99<\/lang>\n\n==[[:Category:V|V]][[Category:V]]==\n<lang v>[bottles\n  [newline <nowiki>''<\/nowiki> puts].\n  [beer\n    [0 =] ['No more bottles of beer' put] if\n    [1 =] ['One bottle of beer' put] if\n    [1 >] [dup put ' bottles of beer' put] if].\n  [0 =] [newline]\n    [beer ' on the wall, ' put beer newline\n    'Take one down and pass it around, ' put pred beer ' on the wall' puts newline]\n  tailrec].\n\n99 bottles<\/lang>\n\n==[[:Category:VBA|VBA]][[Category:VBA]]==\nThis version uses tail recursion and inline if-statements, plus a Static variable to count the number of bottles emptied.\n\n<lang vb>Public Function countbottles(n As Integer, liquid As String) As String\n  countbottles = IIf(n > 1, Format$(n), IIf(n = 0, \"no more\", \"one\")) & \" bottle\" & IIf(n = 1, \"\", \"s\") & \" of \" & liquid\nEnd Function\n\nPublic Sub drink(fullbottles As Integer, Optional liquid As String = \"beer\")\nStatic emptybottles As Integer\n \n  Debug.Print countbottles(fullbottles, liquid) & \" on the wall\"\n  Debug.Print countbottles(fullbottles, liquid)\n\n  If fullbottles > 0 Then\n    Debug.Print \"take \" & IIf(fullbottles > 1, \"one\", \"it\") & \" down, pass it around\"\n    Debug.Print countbottles(fullbottles - 1, liquid) & \" on the wall\"\n    Debug.Print\n    emptybottles = emptybottles + 1\n    drink fullbottles - 1, liquid\n  Else\n    Debug.Print \"go to the store and buy some more\"\n    Debug.Print countbottles(emptybottles, liquid) & \" on the wall\"\n  End If\n \nEnd Sub<\/lang>\n\nUsage: type \"drink 99\" in the Immediate window of the VBA editor. If you're not a beer drinker, you can specify your own favourite drink as the second argument; for example:\n\n<pre>\ndrink 3, \"Johnnie Walker\"\n\n3 bottles of Johnnie Walker on the wall\n3 bottles of Johnnie Walker\ntake one down, pass it around\n2 bottles of Johnnie Walker on the wall\n\n2 bottles of Johnnie Walker on the wall\n2 bottles of Johnnie Walker\ntake one down, pass it around\none bottle of Johnnie Walker on the wall\n\none bottle of Johnnie Walker on the wall\none bottle of Johnnie Walker\ntake it down, pass it around\nno more bottles of Johnnie Walker on the wall\n\nno more bottles of Johnnie Walker on the wall\nno more bottles of Johnnie Walker\ngo to the store and buy some more\n3 bottles of Johnnie Walker on the wall\n\n<\/pre>\n\n==[[:Category:VBScript|VBScript]][[Category:VBScript]]==\n===Simple Method===\n<lang vb>sub song( numBottles )\n\tdim i\n\tfor i = numBottles to 0 step -1\n\t\tif i > 0 then\n\t\t\twscript.echo pluralBottles(i) & \" of beer on the wall\"\n\t\t\twscript.echo pluralBottles(i) & \" of beer\"\n\t\t\tif i = 1 then\n\t\t\t\twscript.echo \"take it down\"\n\t\t\telse\n\t\t\t\twscript.echo \"take one down\"\n\t\t\tend if \n\t\t\twscript.echo \"and pass it round\"\n\t\t\twscript.echo pluralBottles(i-1) & \" of beer on the wall\"\n\t\t\twscript.echo\n\t\telse\n\t\t\twscript.echo \"no more bottles of beer on the wall\"\n\t\t\twscript.echo \"no more bottles of beer\"\n\t\t\twscript.echo \"go to the store\"\n\t\t\twscript.echo \"and buy some more\"\n\t\t\twscript.echo pluralBottles(numBottles) & \" of beer on the wall\"\n\t\t\twscript.echo\n\t\tend if\n\tnext\nend sub\n\t\nfunction pluralBottles( n )\n\tselect case n\n\tcase 1\n\t\tpluralBottles = \"one bottle\"\n\tcase 0\n\t\tpluralBottles = \"no more bottles\"\n\tcase else \n\t\tpluralBottles = n & \" bottles\"\n\tend select\nend function\n\nsong 3<\/lang>\nOutputs:\n<lang vbscript>3 bottles of beer on the wall\n3 bottles of beer\ntake one down\nand pass it round\n2 bottles of beer on the wall\n\n2 bottles of beer on the wall\n2 bottles of beer\ntake one down\nand pass it round\none bottle of beer on the wall\n\none bottle of beer on the wall\none bottle of beer\ntake it down\nand pass it round\nno more bottles of beer on the wall\n\nno more bottles of beer on the wall\nno more bottles of beer\ngo to the store\nand buy some more\n3 bottles of beer on the wall<\/lang>\n\n===Regular Expressions and Embedded Scripting===\nAnother way of doing it, using Regular Expressions to locate executable code inside {} and replacing the code with the result of its evaluation.\n\n<lang vb>function pluralBottles( n )\n\tselect case n\n\tcase 1\n\t\tpluralBottles = \"one bottle\"\n\tcase 0\n\t\tpluralBottles = \"no more bottles\"\n\tcase else \n\t\tpluralBottles = n & \" bottles\"\n\tend select\nend function\n\nfunction eef( b, r1, r2 )\n\tif b then\n\t\teef = r1\n\telse\n\t\teef = r2\n\tend if\nend function\n\nFunction evalEmbedded(sInput, sP1)\n\tdim oRe, oMatch, oMatches\n\tdim sExpr, sResult\n\tSet oRe = New RegExp\n\t'Look for expressions as enclosed in braces\n\toRe.Pattern = \"{(.+?)}\"\n\tsResult = sInput\n\tdo\n\t\tSet oMatches = oRe.Execute(sResult)\n\t\tif oMatches.count = 0 then exit do\n\t\tfor each oMatch in oMatches\n\t\t\t'~ wscript.echo oMatch.Value\n\t\t\tfor j = 0 to omatch.submatches.count - 1\n\t\t\t\tsExpr = omatch.submatches(j)\n\t\t\t\tsResult  = Replace( sResult, \"{\" & sExpr & \"}\", eval(sExpr) ) \n\t\t\tnext\n\t\tnext\n\tloop\n\tevalEmbedded = sResult\nEnd Function\n\nsub sing( numBottles )\n\tdim i\n\tfor i = numBottles to 0 step -1\n\t\tif i = 0 then\n\t\t\twscript.echo evalEmbedded(\"no more bottles of beer on the wall\" & vbNewline & _\n\t\t\t\t\t\t\"no more bottles of beer\" & vbNewline & _\n\t\t\t\t\t\t\"go to the store and buy some more\" & vbNewline & _\n\t\t\t\t\t\t\"{pluralBottles(sP1)} of beer on the wall\" & vbNewline, numBottles)\n\t\telse\n\t\t\twscript.echo evalEmbedded(\"{pluralBottles(sP1)} of beer on the wall\" & vbNewline & _\n\t\t\t\t\t      \"{pluralBottles(sP1)} of beer\" & vbNewline & _\n\t\t\t\t\t      \"take {eef(sP1=1,\"\"it\"\",\"\"one\"\")} down and pass it round\" & vbNewline & _\n\t\t\t\t\t      \"{pluralBottles(sP1-1)} of beer on the wall\" & vbNewline, i)\n\t\tend if\n\tnext\nend sub\n\nsing 3<\/lang>\n\n==[[:Category:Visual Basic|Visual Basic]][[Category:Visual Basic]]==\n<lang vb>Sub Main()\n    Const bottlesofbeer As String = \" bottles of beer\"\n    Const onthewall As String = \" on the wall\"\n    Const takeonedown As String = \"Take one down, pass it around\"\n    Const onebeer As String = \"1 bottle of beer\"\n\n    Dim bottles As Long\n\n    For bottles = 99 To 3 Step -1\n        Debug.Print CStr(bottles) & bottlesofbeer & onthewall\n        Debug.Print CStr(bottles) & bottlesofbeer\n        Debug.Print takeonedown\n        Debug.Print CStr(bottles - 1) & bottlesofbeer & onthewall\n        Debug.Print\n    Next\n\n    Debug.Print \"2\" & bottlesofbeer & onthewall\n    Debug.Print \"2\" & bottlesofbeer\n    Debug.Print takeonedown\n    Debug.Print onebeer & onthewall\n    Debug.Print\n\n    Debug.Print onebeer & onthewall\n    Debug.Print onebeer\n    Debug.Print takeonedown\n    Debug.Print \"No more\" & bottlesofbeer & onthewall\n    Debug.Print\n\n    Debug.Print \"No\" & bottlesofbeer & onthewall\n    Debug.Print \"No\" & bottlesofbeer\n    Debug.Print \"Go to the store, buy some more\"\n    Debug.Print \"99\" & bottlesofbeer & onthewall\nEnd Sub<\/lang>\n\n==[[:Category:Visual Basic .NET|Visual Basic .NET]][[Category:Visual Basic .NET]]==\n'''Platform:''' [[.NET]]\n<lang vbnet>Module Module1\n   Sub Main()\n       Dim Bottles As Integer\n       For Bottles = 99 To 0 Step -1\n           If Bottles = 0 Then\n               Console.WriteLine(\"No more bottles of beer on the wall, no more bottles of beer.\")\n               Console.WriteLine(\"Go to the store and buy some more, 99 bottles of beer on the wall.\")\n               Console.ReadLine()\n           ElseIf Bottles = 1 Then\n               Console.WriteLine(Bottles & \" bottle of beer on the wall, \" & Bottles & \" bottle of beer.\")\n               Console.WriteLine(\"Take one down and pass it around, no more bottles of beer on the wall.\")\n               Console.ReadLine()\n           Else\n               Console.WriteLine(Bottles & \" bottles of beer on the wall, \" & Bottles & \" bottles of beer.\")\n               Console.WriteLine(\"Take one down and pass it around, \" & (Bottles - 1) & \" bottles of beer on the wall.\")\n               Console.ReadLine()\n           End If\n       Next\n   End Sub\nEnd Module<\/lang>\n\n==[[:Category:Vox|Vox]][[Category:Vox]]==\n<lang vox>\n\/\/ translated from <http:\/\/rosettacode.org\/wiki\/99_Bottles_of_Beer#JavaScript>\n\nlocal beer;\nwhile((beer = typeof beer == \"null\" ? 99 : beer) > 0)\n    println(\n        beer + \" bottle\" +\n        (beer != 1 ? \"s\" : \"\") +\n        \" of beer on the wall\\n\" + beer + \" bottle\" +\n        (beer != 1 ? \"s\" : \"\") +\n        \" of beer\\nTake one down, pass it around\\n\" +\n        (--beer) + \" bottle\" +\n        (beer != 1 ? \"s\" : \"\") + \" of beer on the wall\\n\"\n    );\n<\/lang>\n\n==[[:Category:Whenever|Whenever]][[Category:Whenever]]==\n<lang whenever>1 defer (4 || N(1)<N(2) && N(2)<N(3)) print(N(1)+\" bottles of beer on the wall, \"+N(1)+\" bottles of beer,\");\n2 defer (4 || N(1)==N(2)) print(\"Take one down and pass it around,\");\n3 defer (4 || N(2)==N(3)) print(N(1)+\" bottles of beer on the wall.\");\n4 1#98,2#98,3#98;<\/lang>\n\n==[[:Category:Wrapl|Wrapl]][[Category:Wrapl]]==\n<lang wrapl>MOD Bottles;\n\nIMP IO.Terminal USE Out;\nIMP Std.String;\n\nVAR i, s <- \"s\", ob <- \"of beer\", otw <- \"on the wall\",\n    more <- \"Take one down and pass it around\", verse <- [];\n\nEVERY i <- 99:to(0,-1) DO (\n    (i = 1) & (s <- \"\");\n    (i = 0) & (s <- \"s\"; i <- \"No more\"; more <- \"Go to the store and buy some more\");\n    verse:put('. {i} bottle{s} {ob} {otw}.\\n');\n    verse:put('\\n{i} bottle{s} {ob} {otw}, {(i@String.T):lower} bottle{s} {ob}.\\n{more}');\n);\n\nOut:write(verse[2,0]@(String.T, \"\") + verse[1]);\n\nEND Bottles.<\/lang>\n\n==[[:Category:X86 Assembly|X86 Assembly]][[Category:X86 Assembly]]==\nUsing Windows\/MASM32.\n<lang asm>.386\n.model flat, stdcall\noption casemap :none\n\ninclude \\masm32\\include\\kernel32.inc\ninclude \\masm32\\include\\masm32.inc\ninclude \\masm32\\include\\user32.inc\nincludelib \\masm32\\lib\\kernel32.lib\nincludelib \\masm32\\lib\\masm32.lib\nincludelib \\masm32\\lib\\user32.lib\n\n.DATA\n buffer db 1024 dup(?)\n str1 db \"%d bottles of beer on the wall.\",10,13,0\n str2 db \"%d bottles of beer\",10,13,0\n str3 db \"Take one down, pass it around\",10,13,0\n str4 db \"No more bottles of beer on the wall!\",10,13,0\n nline db 13,10,0\n\n bottles dd 99\n\n.CODE\n start:\n  INVOKE wsprintfA, offset buffer, offset str1, [bottles]\n  INVOKE StdOut, offset buffer\n\n  INVOKE wsprintfA, offset buffer, offset str2, [bottles]\n  INVOKE StdOut, offset buffer\n\n  INVOKE StdOut, offset str3\n\n  DEC [bottles]\n\n  INVOKE wsprintfA, offset buffer, offset str1, [bottles]\n  INVOKE StdOut, offset buffer\n  INVOKE StdOut, offset nline\n\n  CMP [bottles], 1\n  JNE start\n\n  INVOKE StdOut, offset str4\n  INVOKE ExitProcess, 0\n end start<\/lang>\n\n==[[:Category:XPL0|XPL0]][[Category:XPL0]]==\n<lang XPL0>code IntOut=11, Text=12;\nint B;\n[B:= 99;\nrepeat  IntOut(0, B);  Text(0, \" bottles of beer on the wall^M^J\");\n        IntOut(0, B);  Text(0, \" bottles of beer^M^J\");\n        Text(0, \"Take one down, pass it around^M^J\");\n        B:= B-1;\n        IntOut(0, B);  Text(0, \" bottles of beer on the wall^M^J^J\");\nuntil   B=0;\n]<\/lang>\n\n==[[:Category:Yorick|Yorick]][[Category:Yorick]]==\n\n=== Looped version ===\n<lang yorick>bottles = 99;\nwhile(bottles) {\n    write, format=\" %d bottles of beer on the wall\\n\", bottles;\n    write, format=\" %d bottles of beer\\n\", bottles;\n    write, \"Take one down, pass it around\";\n    write, format=\" %d bottles of beer on the wall\\n\\n\", --bottles;\n}<\/lang>\n\n=== Vectorized version ===\n<lang yorick>song = \"%d bottles of beer on the wall\\n\";\nsong += \"%d bottles of beer\\n\";\nsong += \"Take one down, pass it around\\n\";\nsong += \"%d bottles of beer on the wall\\n\";\nbeer = indgen(99:1:-1);\nwrite, format=song, beer, beer, beer-1;<\/lang>"}]}}}}