{"query":{"pages":{"6036":{"pageid":6036,"ns":0,"title":"Arbitrary-precision integers (included)","revisions":[{"*":"<div class=\"infobox\" style=\"width: 2in\">[[File:Rcode-button-task-crushed.png|64px|left|alt=Task|link=Category:Solutions by Programming Task]]'''Arbitrary-precision integers (included)'''<br\/>\nYou are encouraged to [[Rosetta Code:Solve a Task|solve this task]] according to the task description, using any language you may know.[[Category:Programming Tasks]][[Category:Arbitrary precision]]<\/div>\nUsing the in-built capabilities of your language, calculate the integer value of:\n\n::<math>5^{4^{3^2}}<\/math>\n\n*  Confirm that the first and last twenty digits of the answer are: <code>62060698786608744707...92256259918212890625<\/code>\n*  Find and show the number of decimal digits in the answer.\n\nC.F. [[Long multiplication]]\n\n<small>Note: <ul><li>Do not submit an ''implementation'' of [[wp:arbitrary precision arithmetic|arbitrary precision arithmetic]]. The intention is to show the capabilities of the language as supplied. If a language has a [[Talk:Arbitrary-precision integers (included)#Use of external libraries|single, overwhelming, library]] of varied modules that is endorsed by its home site \u2013 such as [[CPAN]] for Perl or [[Boost]] for C++ \u2013 then that ''may'' be used instead.\n<\/li><li>Strictly speaking, this should not be solved by fixed-precision numeric libraries where the precision has to be manually set to a large value; although if this is the '''only''' recourse then it may be used with a note explaining that the precision must be set manually to a large enough value.<\/li><\/ul><\/small>\n\n==[[:Category:ACL2|ACL2]][[Category:ACL2]]==\n<lang Lisp>(in-package \"ACL2\")\n\n(include-book \"arithmetic-3\/floor-mod\/floor-mod\" :dir :system)\n\n(set-print-length 0 state)\n\n(defun arbitrary-precision ()\n   (declare (xargs :mode :program))\n   (let* ((x (expt 5 (expt 4 (expt 3 2))))\n          (s (mv-let (col str)\n                     (fmt1-to-string \"~xx\" \n                                     (list (cons #\\x x))\n                                     0)\n                (declare (ignore col))\n                str)))\n         (cw \"~s0 ... ~x1 (~x2 digits)~%\"\n             (subseq s 1 21)\n             (mod x (expt 10 20))\n             (1- (length s)))))<\/lang>\n\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>20606987866087447074 ... 92256259918212890625 (183231 digits)<\/pre>\n\n==[[:Category:Ada|Ada]][[Category:Ada]]==\n<div class=\"examplemeta libheader\">'''Library:''' [[SMW::off]][[:Category:GMP|GMP]][[Category:GMP]][[SMW::on]]<\/div> Using GMP, Ada bindings provided in GNATColl\n<lang Ada>with Ada.Text_IO; use Ada.Text_IO;\nwith GNATCOLL.GMP; use GNATCOLL.GMP;\nwith GNATCOLL.GMP.Integers; use GNATCOLL.GMP.Integers;\nprocedure ArbitraryInt is\n   type stracc is access String;\n   BigInt : Big_Integer;\n   len : Natural;\n   str : stracc;\nbegin\n   Set (BigInt, 5);\n   Raise_To_N (BigInt, Unsigned_Long (4**(3**2)));\n   str := new String'(Image (BigInt));\n   len := str'Length;\n   Put_Line (\"Size is:\"& Natural'Image (len));\n   Put_Line (str (1 .. 20) & \".....\" & str (len - 19 .. len));\nend ArbitraryInt;<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>Size is: 183231\n62060698786608744707.....92256259918212890625<\/pre>\n\n==[[:Category:Alore|Alore]][[Category:Alore]]==\n<lang Alore>def Main()\n  var len as Int\n  var result as Str\n  result = Str(5**4**3**2)\n  len = result.length()\n  Print(len)  \n  Print(result[:20])\n  Print(result[len-20:])\nend<\/lang>\n\n==[[:Category:bc|bc]][[Category:bc]]==\n<lang bc>\/* 5432.bc *\/\n\ny = 5 ^ 4 ^ 3 ^ 2\nc = length(y)\n\" First 20 digits: \"; y \/ (10 ^ (c - 20))\n\"  Last 20 digits: \"; y % (10 ^ 20)\n\"Number of digits: \"; c\nquit<\/lang>\n\nOutput: <pre>$ time bc 5432.bc  \n First 20 digits: 62060698786608744707\n  Last 20 digits: 92256259918212890625\nNumber of digits: 183231\n    0m24.81s real     0m24.81s user     0m0.00s system<\/pre>\n\n==[[:Category:Bracmat|Bracmat]][[Category:Bracmat]]==\nAt the prompt type the following one-liner:\n<lang bracmat>{?} @(5^4^3^2:?first [20 ? [-21 ?last [?length)&str$(!first \"...\" !last \"\\nlength \" !length)\n{!} 62060698786608744707...92256259918212890625\nlength 183231\n    S   2,46 sec<\/lang>\n\n==[[:Category:C|C]][[Category:C]]==\n=== <div class=\"examplemeta libheader\">'''Library:''' [[SMW::off]][[:Category:GMP|GMP]][[Category:GMP]][[SMW::on]]<\/div> ===\n<lang c>#include <gmp.h>\n#include <stdio.h>\n#include <string.h>\n\nint main()\n{\n\tmpz_t a;\n\tmpz_init_set_ui(a, 5);\n\tmpz_pow_ui(a, a, 1 << 18); \/* 2**18 == 4**9 *\/\n\n\tint len = mpz_sizeinbase(a, 10);\n\tprintf(\"GMP says size is: %d\\n\", len);\n\n\t\/* because GMP may report size 1 too big; see doc *\/\n\tchar *s = mpz_get_str(0, 10, a);\n\tprintf(\"size really is %d\\n\", len = strlen(s));\n\tprintf(\"Digits: %.20s...%s\\n\", s, s + len - 20);\n\n\t\/\/ free(s); \/* we could, but we won't. we are exiting anyway *\/\n\treturn 0;\n}<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>GMP says size is: 183231\nsize really is 183231\nDigits: 62060698786608744707...92256259918212890625<\/pre>\n===<div class=\"examplemeta libheader\">'''Library:''' [[SMW::off]][[:Category:OpenSSL|OpenSSL]][[Category:OpenSSL]][[SMW::on]]<\/div>===\nOpenSSL is about 17 times slower than GMP (on one computer), but still fast enough for this small task.\n<lang c>\/* 5432.c *\/\n\n#include <openssl\/bn.h>\t\t\/* BN_*() *\/\n#include <openssl\/err.h>\t\/* ERR_*() *\/\n#include <stdlib.h>\t\t\/* exit() *\/\n#include <stdio.h>\t\t\/* fprintf() *\/\n#include <string.h>\t\t\/* strlen() *\/\n\nvoid\nfail(const char *message)\n{\n\tfprintf(stderr, \"%s: error 0x%08lx\\n\", ERR_get_error());\n\texit(1);\n}\n\nint\nmain()\n{\n\tBIGNUM two, three, four, five;\n\tBIGNUM answer;\n\tBN_CTX *context;\n\tsize_t length;\n\tchar *string;\n\n\tcontext = BN_CTX_new();\n\tif (context == NULL)\n\t\tfail(\"BN_CTX_new\");\n\n\t\/* answer = 5 ** 4 ** 3 ** 2 *\/\n\tBN_init(&two);\n\tBN_init(&three);\n\tBN_init(&four);\n\tBN_init(&five);\n\tif (BN_set_word(&two, 2) == 0 ||\n\t    BN_set_word(&three, 3) == 0 ||\n\t    BN_set_word(&four, 4) == 0 ||\n\t    BN_set_word(&five, 5) == 0)\n\t\tfail(\"BN_set_word\");\n\tBN_init(&answer);\n\tif (BN_exp(&answer, &three, &two, context) == 0 ||\n\t    BN_exp(&answer, &four, &answer, context) == 0 ||\n\t    BN_exp(&answer, &five, &answer, context) == 0)\n\t\tfail(\"BN_exp\");\n\n\t\/* string = decimal answer *\/\n\tstring = BN_bn2dec(&answer);\n\tif (string == NULL)\n\t\tfail(\"BN_bn2dec\");\n\n\tlength = strlen(string);\n\tprintf(\" First 20 digits: %.20s\\n\", string);\n\tif (length >= 20)\n\t\tprintf(\"  Last 20 digits: %.20s\\n\", string + length - 20);\n\tprintf(\"Number of digits: %zd\\n\", length);\n\n\tOPENSSL_free(string);\n\tBN_free(&answer);\n\tBN_free(&five);\n\tBN_free(&four);\n\tBN_free(&three);\n\tBN_free(&two);\n\tBN_CTX_free(context);\n\n\treturn 0;\n}<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>$ make LDLIBS=-lcrypto 5432 \ncc -O2 -pipe    -o 5432 5432.c -lcrypto\n$ time .\/5432 \n First 20 digits: 62060698786608744707\n  Last 20 digits: 92256259918212890625\nNumber of digits: 183231\n    0m1.30s real     0m1.30s user     0m0.00s system<\/pre>\n\n==<span id=\"C sharp\">[[:Category:C sharp|C#]]<\/span>[[Category:C sharp]]==\n<code>System.Numerics.BigInteger<\/code> was added in C# 4. The exponent of <code>BigInteger.Pow()<\/code> is limited to a 32-bit signed integer, which is not a problem in this specific task.\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[C sharp|C#]] version 4+[[SMW::on]]<\/div>\n<lang csharp>using System;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Numerics;\n\nstatic class Program {\n    static void Main() {\n        BigInteger n = BigInteger.Pow(5, (int)BigInteger.Pow(4, (int)BigInteger.Pow(3, 2)));\n        string result = n.ToString();\n\n        Debug.Assert(result.Length == 183231);\n        Debug.Assert(result.StartsWith(\"62060698786608744707\"));\n        Debug.Assert(result.EndsWith(\"92256259918212890625\"));\n\n        Console.WriteLine(\"n = 5^4^3^2\");\n        Console.WriteLine(\"n = {0}...{1}\", \n            result.Substring(0, 20),\n            result.Substring(result.Length - 20, 20)\n            );\n\n        Console.WriteLine(\"n digits = {0}\", result.Length);\n    }\n}<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>\nn = 5^4^3^2\nn = 62060698786608744707...92256259918212890625\nn digits = 183231\n<\/pre>\n\n==[[:Category:Clojure|Clojure]][[Category:Clojure]]==\n<lang clojure>(defn exp [n k] (reduce * (repeat k n)))\n\n(def big (->> 2 (exp 3) (exp 4) (exp 5)))\n(def sbig (str big))\n\n(assert (= \"62060698786608744707\" (.substring sbig 0 20)))\n(assert (= \"92256259918212890625\" (.substring sbig (- (count sbig) 20))))\n(println (count sbig) \"digits\")\n\n(println (str (.substring sbig 0 20) \"..\"\n\t      (.substring sbig (- (count sbig) 20)))\n\t (str \"(\" (count sbig) \" digits)\"))<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>output> 62060698786608744707..92256259918212890625 (183231 digits)<\/pre>\nRedefining ''exp'' as follows speeds up the calculation of ''big'' about a hundred times:\n<lang clojure>(defn exp [n k]\n  (cond\n    (zero? (mod k 2)) (recur (* n n) (\/ k 2))\n    (zero? (mod k 3)) (recur (* n n n) (\/ k 3))\n    :else (reduce * (repeat k n))))<\/lang>\n\n==[[:Category:Common Lisp|Common Lisp]][[Category:Common Lisp]]==\nCommon Lisp has arbitrary precision integers, inherited from MacLisp: \"[B]ignums\u2014arbitrary precision integer arithmetic\u2014were added [to MacLisp] in 1970 or 1971 to meet the needs of Macsyma users.\" [''Evolution of Lisp'' [http:\/\/dreamsongs.com\/Files\/Hopl2.pdf], 2.2.2]\n<lang lisp>(let ((s (format () \"~s\" (expt 5 (expt 4 (expt 3 2))))))\n  (format t \"~a...~a, length ~a\" (subseq s 0 20) \n          (subseq s (- (length s) 20)) (length s)))<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>\n62060698786608744707...92256259918212890625, length 183231\n<\/pre>\n\n==[[:Category:D|D]][[Category:D]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[D]] version 2.051[[SMW::on]]<\/div>\n<lang d>import std.stdio, std.bigint, std.conv;\n\nvoid main() {\n  auto s = text(BigInt(5) ^^ 4 ^^ 3 ^^ 2);\n  writefln(\"5^4^3^2 = %s..%s (%d digits)\", s[0..20], s[$-20..$], s.length);\n}<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>5^4^3^2 = 62060698786608744707..92256259918212890625 (183231 digits)<\/pre>\n0.8 seconds compilation time with DMD, about 3.4 seconds run time.\n\n==[[:Category:dc|dc]][[Category:dc]]==\n<div class=\"examplemeta translation\">'''Translation of''': [[Arbitrary-precision integers (included)#bc|bc]]<\/div>\n<lang dc>[5432.dc]sz\n\n5 4 3 2 ^ ^ ^ sy\t\t\t\t[y = 5 ^ 4 ^ 3 ^ 2]sz\nly Z sc\t\t\t\t\t\t[c = length of y]sz\n[ First 20 digits: ]P ly 10 lc 20 - ^ \/ p sz\t[y \/ (10 ^ (c - 20))]sz\n[  Last 20 digits: ]P ly 10 20 ^ % p sz\t\t[y % (10 ^ 20)]sz\n[Number of digits: ]P lc p sz<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>$ time dc 5432.dc                                                              \n First 20 digits: 62060698786608744707\n  Last 20 digits: 92256259918212890625\nNumber of digits: 183231\n    0m24.80s real     0m24.81s user     0m0.00s system<\/pre>\n\n==[[:Category:E|E]][[Category:E]]==\nE implementations are required to support arbitrary-size integers transparently.\n<lang e>? def value := 5**(4**(3**2)); null\n? def decimal := value.toString(10); null\n? decimal(0, 20)\n# value: \"62060698786608744707\"\n\n? decimal(decimal.size() - 20)\n# value: \"92256259918212890625\"\n\n? decimal.size()\n# value: 183231<\/lang>\n\n==<span id=\"F Sharp\">[[:Category:F Sharp|F#]]<\/span>[[Category:F Sharp]]==\nYou can specifiy arbitrary-precision integers (bigint or System.Numeric.BigInteger) in F# by postfixing the number with the letter 'I'. While '**' is the power function, two things should be noted: \n* bigint does not support raising to a power of a bigint\n* The int type does not support the power method\n<lang fsharp>let () =\n    let answer = 5I **(int (4I ** (int (3I ** 2))))\n    let sans = answer.ToString()\n    printfn \"Length = %d, digits %s ... %s\" sans.Length (sans.Substring(0,20)) (sans.Substring(sans.Length-20))\n;;\nLength = 183231, digits 62060698786608744707 ... 92256259918212890625<\/lang>\n\n==[[:Category:Factor|Factor]][[Category:Factor]]==\nFactor has built-in bignum support. Operations on integers overflow to bignums.\n<lang factor>USING: formatting kernel math.functions math.parser sequences ;\nIN: rosettacode.bignums\n\n: test-bignums ( -- )\n    5 4 3 2 ^ ^ ^ number>string\n    [ 20 head ] [ 20 tail* ] [ length ] tri\n    \"5^4^3^2 is %s...%s and has %d digits\\n\" printf ;<\/lang>\nIt prints: <code>5^4^3^2 is 62060698786608744707...92256259918212890625 and has 183231 digits<\/code>\n\n==[[:Category:Frink|Frink]][[Category:Frink]]==\nFrink has built-in arbitrary-precision integers and all operations automatically promote when necessary.\n<lang frink>a = 5^4^3^2\nas = \"$a\"     \/\/ Coerce to string\nprintln[\"Length=\" + length[as] + \", \" + left[as,20] + \"...\" + right[as,20]]<\/lang>\nThis prints <CODE>Length=183231, 62060698786608744707...92256259918212890625<\/CODE>\n\n==[[:Category:GAP|GAP]][[Category:GAP]]==\n<lang gap>n:=5^(4^(3^2));; \ns := String(n);;\nm := Length(s);\n# 183231\ns{[1..20]};\n# \"62060698786608744707\"\ns{[m-19..m]};\n# \"92256259918212890625\"<\/lang>\n\n==[[:Category:Go|Go]][[Category:Go]]==\n<lang go>package main\n\nimport (\n    \"fmt\"\n    \"math\/big\"\n)\n\nfunc main() {\n    answer := big.NewInt(42)\n    answer.Exp(big.NewInt(5), answer.Exp(big.NewInt(4),\n        answer.Exp(big.NewInt(3), big.NewInt(2), nil), nil), nil)\n    answer_string := answer.String()\n    length := len(answer_string)\n    fmt.Printf(\"has %d digits: %s ... %s\\n\",\n        length,\n        answer_string[0:20],\n        answer_string[length-20:])\n}<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>\nhas 183231 digits: 62060698786608744707 ... 92256259918212890625\n<\/pre>\n\n==[[:Category:Golfscript|Golfscript]][[Category:Golfscript]]==\n<lang golfscript>5 4 3 2???  # Calculate 5^(4^(3^2))\n`..         # Convert to string and make two copies\n20<p        # Print the first 20 digits\n-20>p       # Print the last 20 digits\n,p          # Print the length<\/lang>\nThe ''p'' command prints the top element from the stack, so the output of this program is just three lines:\n<pre>\"62060698786608744707\"\n\"92256259918212890625\"\n183231<\/pre>\n\n==[[:Category:Groovy|Groovy]][[Category:Groovy]]==\nSolution:\n<lang groovy>def bigNumber = 5G ** (4 ** (3 ** 2))<\/lang>\nTest:\n<lang groovy>def bigString = bigNumber.toString()\n\nassert bigString[0..<20] == \"62060698786608744707\"\nassert bigString[-20..-1] == \"92256259918212890625\"\n\nprintln bigString.size()<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>183231<\/pre>\n\n==[[:Category:Haskell|Haskell]][[Category:Haskell]]==\nHaskell comes with built-in support for arbitrary precision integers. The type of arbitrary precision integers is <tt>Integer<\/tt>.\n<lang haskell>main = do\n    let y = show ( 5^4^3^2 )\n    let l = length y\n    putStrLn (\"5**4**3**2 = \" ++ take 20 y ++ \"...\" ++ drop (l-20) y ++ \" and has \" ++ show l ++ \" digits\")<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>5**4**3**2 = 62060698786608744707...92256259918212890625 and has 183231 digits<\/pre>\n\n==[[:Category:Icon|Icon]][[Category:Icon]] and [[:Category:Unicon|Unicon]][[Category:Unicon]]==\nBoth Icon and Unicon have built-in support for bignums. \n\nNote: It takes far longer to convert the result to a string than it does to do the computation itself.\n<lang icon>procedure main()\n    x := 5^4^3^2\n    write(\"done with computation\")\n    x := string(x)\n    write(\"5 ^ 4 ^ 3 ^ 2 has \",*x,\" digits\")\n    write(\"The first twenty digits are \",x[1+:20])\n    write(\"The last twenty digits are  \",x[0-:20])\nend<\/lang>\n<div>\n;Sample run<nowiki>:<\/nowiki><\/div>\n<pre>->ap\ndone with computation\n5 ^ 4 ^ 3 ^ 2 has 183231 digits\nThe first twenty digits are 62060698786608744707\nThe last twenty digits are  92256259918212890625\n-><\/pre>\n\n==[[:Category:J|J]][[Category:J]]==\nJ has built-in support for extended precision integers. See also [[J:Essays\/Extended%20Precision%20Functions]].\n<lang j>   Pow5432=: 5^4^3^2x\n   Pow5432=: ^\/ 5 4 3 2x                    NB. alternate J solution\n   # \": Pow5432                             NB. number of digits\n183231\n   20 ({. , '...' , -@[ {. ]) \": Pow5432    NB. 20 first & 20 last digits\n62060698786608744707...92256259918212890625<\/lang>\n\n==[[:Category:Java|Java]][[Category:Java]]==\nJava library's <tt>BigInteger<\/tt> class provides support for arbitrary precision integers.\n<lang java>import java.math.BigInteger;\n\nclass Program {\n    public static void main(String[] args) {\n        BigInteger x = BigInteger.valueOf(5).pow(BigInteger.valueOf(4).pow(BigInteger.valueOf(3).pow(2).intValue()).intValue());\n        String y = x.toString();\n        int l = y.length();\n        System.out.printf(\"5**4**3**2 = %s...%s and has %d digits\\n\",\n                          y.substring(0,20), y.substring(l-20), l);\n    }\n}<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>5**4**3**2 = 62060698786608744707...92256259918212890625 and has 183231 digits<\/pre>\n\n==[[:Category:Liberty BASIC|Liberty BASIC]][[Category:Liberty BASIC]]==\nInterestingly this takes a LONG time in LB.\n\nIt takes however only seconds in RunBASIC, which is written by the same author, shares most of LB's syntax, and is based on later Smalltalk implementation.\n\nNote the brackets are needed to enforce the desired order of exponentiating.\n<lang lb>a$ = str$( 5^(4^(3^2))) \nprint len( a$)\nprint left$( a$, 20); \"......\"; right$( a$, 20)<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n 183231\n 62060698786608744707......92256259918212890625\n\n==[[:Category:Mathematica|Mathematica]][[Category:Mathematica]]==\nMathematica can handle arbitrary precision integers on almost any size without further declarations.\nTo view only the first and last twenty digits:\n<lang Mathematica>s:=ToString[5^4^3^2];\nPrint[StringTake[s,20]<>\"...\"<>StringTake[s,-20]<>\" (\"<>ToString@StringLength@s<>\" digits)\"];<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n 62060698786608744707...92256259918212890625 (183231 digits)\n\n==[[:Category:MATLAB|MATLAB]][[Category:MATLAB]]==\nUsing the [http:\/\/www.mathworks.com\/matlabcentral\/fileexchange\/22725-variable-precision-integer-arithmetic Variable Precision Integer] library this task is accomplished thusly:\n<lang MATLAB>>> answer = vpi(5)^(vpi(4)^(vpi(3)^vpi(2)));\n>> numDigits = order(answer) + 1\n\nnumDigits =\n\n      183231\n\n>> [sprintf('%d',leadingdigit(answer,20)) '...' sprintf('%d',trailingdigit(answer,20))] \n%First and Last 20 Digits\n\nans =\n\n62060698786608744707...92256259918212890625<\/lang>\n\n==[[:Category:Maxima|Maxima]][[Category:Maxima]]==\n<lang maxima>block([s, n], s: string(5^4^3^2), n: slength(s), print(substring(s, 1, 21), \"...\", substring(s, n - 19)), n);\n\/* 62060698786608744707...92256259918212890625\n183231 *\/<\/lang>\n\n==[[:Category:NetRexx|NetRexx]][[Category:NetRexx]]==\n=== Using Java's BigInteger Class ===\n<lang NetRexx>\/* NetRexx *\/\n\noptions replace format comments java crossref savelog symbols\n\nimport java.math.BigInteger\n\nnumeric digits 30 -- needed to report the run-time\n\nnanoFactor = 10 ** 9\n\nt1 = System.nanoTime\nx = BigInteger.valueOf(5)\nx = x.pow(BigInteger.valueOf(4).pow(BigInteger.valueOf(3).pow(2).intValue()).intValue())\nn = Rexx(x.toString)\nt2 = System.nanoTime\ntd = t2 - t1\nsay \"Run time in seconds:\" td \/ nanoFactor\nsay\n\ncheck = \"62060698786608744707...92256259918212890625\"\nsample = n.left(20)\"...\"n.right(20)\n\nsay \"Expected result:\" check\nsay \"  Actual result:\" sample\nsay \"         digits:\" n.length\nsay\n\nif check = sample\nthen\n  say \"Result confirmed\"\nelse\n  say \"Result does not satisfy test\"\n\nreturn<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>\nRun time in seconds: 6.696671 \n \nExpected result: 62060698786608744707...92256259918212890625 \n  Actual result: 62060698786608744707...92256259918212890625 \n         digits: 183231 \n \nResult confirmed\n<\/pre>\n=== Using Java's BigDecimal Class ===\n<lang NetRexx>\/* NetRexx *\/\n\noptions replace format comments java crossref savelog symbols\n\nimport java.math.BigDecimal\n\nnumeric digits 30 -- needed to report the run-time\n\nnanoFactor = 10 ** 9\n\nt1 = System.nanoTime\nx = BigDecimal.valueOf(5)\nx = x.pow(BigDecimal.valueOf(4).pow(BigDecimal.valueOf(3).pow(2).intValue()).intValue())\nn = Rexx(x.toString)\nt2 = System.nanoTime\ntd = t2 - t1\nsay \"Run time in seconds:\" td \/ nanoFactor\nsay\n\ncheck = \"62060698786608744707...92256259918212890625\"\nsample = n.left(20)\"...\"n.right(20)\n\nsay \"Expected result:\" check\nsay \"  Actual result:\" sample\nsay \"         digits:\" n.length\nsay\n\nif check = sample\nthen\n  say \"Result confirmed\"\nelse\n  say \"Result does not satisfy test\"\n\nreturn<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>\nRun time in seconds: 7.103424 \n \nExpected result: 62060698786608744707...92256259918212890625 \n  Actual result: 62060698786608744707...92256259918212890625 \n         digits: 183231 \n \nResult confirmed\n<\/pre>\n=== Using NetRexx Built-In Math ===\nLike [[REXX|Rexx]], NetRexx comes with built-in support for numbers that can be manually set to very large values of precision.\nCompared to the two methods shown above however, the performance is extremely poor.\n==== Note ====\n<div class=\"examplemeta translation\">'''Translation of''': [[Arbitrary-precision integers (included)#REXX|REXX]]<\/div>\n<lang NetRexx>\/* NetRexx *\/\n\noptions replace format comments java crossref savelog symbols\n\n\/* precision must be set manually *\/\n\nnumeric digits 190000\n\nnanoFactor = 10 ** 9\n\nt1 = System.nanoTime\nn = 5 ** (4  ** (3 ** 2))\nt2 = System.nanoTime\ntd = t2 - t1\nsay \"Run time in seconds:\" td \/ nanoFactor\nsay\n\ncheck = \"62060698786608744707...92256259918212890625\"\nsample = n.left(20)\"...\"n.right(20)\n\nsay \"Expected result:\" check\nsay \"  Actual result:\" sample\nsay \"         digits:\" n.length\nsay\n\nif check = sample\nthen\n  say \"Result confirmed\"\nelse\n  say \"Result does not satisfy test\"<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>\nRun time in seconds: 719.660995\n\nExpected result: 62060698786608744707...92256259918212890625\n  Actual result: 62060698786608744707...92256259918212890625\n         digits: 183231\n\nResult confirmed\n<\/pre>\n\n==[[:Category:OCaml|OCaml]][[Category:OCaml]]==\n<lang ocaml>open Num\nopen Str\nopen String\n\nlet () =\n  let answer = (Int 5) **\/ (Int 4) **\/ (Int 3) **\/ (Int 2) in\n  let answer_string = string_of_num answer in\n  Printf.printf \"has %d digits: %s ... %s\\n\"\n                (length answer_string)\n                (first_chars answer_string 20)\n                (last_chars answer_string 20)<\/lang>\n\nA more readable program can be obtained using [http:\/\/forge.ocamlcore.org\/projects\/pa-do\/ Delimited Overloading]:\n<lang ocaml>let () =\n  let answer = Num.(5**4**3**2) in\n  let s = Num.(to_string answer) in\n  Printf.printf \"has %d digits: %s ... %s\\n\"\n    (String.length s) (Str.first_chars s 20) (Str.last_chars s 20)<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>\nhas 183231 digits: 62060698786608744707 ... 92256259918212890625\n<\/pre>\n\n==[[:Category:Oz|Oz]][[Category:Oz]]==\n<lang oz>declare\n  Pow5432 = {Pow 5 {Pow 4 {Pow 3 2}}}\n  S = {Int.toString Pow5432}\n  Len = {Length S}\nin\n  {System.showInfo\n   {List.take S 20}#\"...\"#\n   {List.drop S Len-20}#\" (\"#Len#\" Digits)\"}<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>\n62060698786608744707...92256259918212890625 (183231 Digits)\n<\/pre>\n\n==[[:Category:PARI\/GP|PARI\/GP]][[Category:PARI\/GP]]==\nAn alternate, but slightly slower, method for counting decimal digits is <code>#Str(n)<\/code>. Note that <code>sizedigit<\/code> is not exact&mdash;in particular, it may be off by one (thus the function below).\n<lang parigp>digits(x)={\n\tmy(s=sizedigit(x)-1);\n\tif(x<10^s,s,s+1)\n};\n\nN=5^(4^(3^2));\n[precision(N*1.,20), Mod(N,10^20), digits(N)]<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>[6.20606987866087447074832055728 E183230, Mod(92256259918212890625, 100000000000000000000), 183231]<\/pre>\n\n==[[:Category:Pascal|Pascal]][[Category:Pascal]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Free_Pascal]][[SMW::on]]<\/div>\n<div class=\"examplemeta libheader\">'''Library:''' [[SMW::off]][[:Category:math|math]][[Category:math]][[SMW::on]]<\/div>\n<div class=\"examplemeta libheader\">'''Library:''' [[SMW::off]][[:Category:GMP|GMP]][[Category:GMP]][[SMW::on]]<\/div>\nFreePascal comes with a header unit for gmp. Starting from the C program,  this is a Pascal version:\n<lang pascal>program GMP_Demo;\n\nuses\n  math, gmp;\n\nvar\n  a:   mpz_t;\n  out: pchar;\n  len: longint;\n  i:   longint;\n\nbegin\n  mpz_init_set_ui(a, 5);\n  mpz_pow_ui(a, a, 4 ** (3 ** 2));\n  len := mpz_sizeinbase(a, 10);\n  writeln('GMP says size is: ', len);\n  out := mpz_get_str(NIL, 10, a);\n  writeln('Actual size is:   ', length(out));\n  write('Digits: ');\n  for i := 0 to 19 do\n    write(out[i]);\n  write ('...');\n  for i := len - 20 to len do\n    write(out[i]);\n  writeln;\nend.<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>\nGMP says size is: 183231\nActual size is:   183231\nDigits: 62060698786608744707...92256259918212890625\n<\/pre>\n\n==[[:Category:Perl|Perl]][[Category:Perl]]==\nPerl's <tt>Math::BigInt<\/tt> core module handles big integers:\n<lang perl>use Math::BigInt;\nmy $x = Math::BigInt->new('5') ** Math::BigInt->new('4') ** Math::BigInt->new('3') ** Math::BigInt->new('2');\nmy $y = \"$x\";\nprintf(\"5**4**3**2 = %s...%s and has %i digits\\n\", substr($y,0,20), substr($y,-20), length($y));<\/lang>\nYou can enable \"transparent\" big integer support by enabling the <tt>bigint<\/tt> pragma:\n<lang perl>use bigint;\nmy $x = 5**4**3**2;\nmy $y = \"$x\";\nprintf(\"5**4**3**2 = %s...%s and has %i digits\\n\", substr($y,0,20), substr($y,-20), length($y));<\/lang>\n\n<tt>Math::BigInt<\/tt> is very slow. Perl 5.10 was about 120 times slower than Ruby 1.9.2 (on one computer); Perl used more than one minute, but Ruby used less than one second.\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<lang perl>$ time perl transparent-bigint.pl \n5**4**3**2 = 62060698786608744707...92256259918212890625 and has 183231 digits\n    1m4.28s real     1m4.30s user     0m0.00s system<\/lang>\n\n==[[:Category:Perl 6|Perl 6]][[Category:Perl 6]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[niecza]][[SMW::on]]<\/div>\n<lang perl6>my $x = ~[**] 5, 4, 3, 2;\nsay \"5**4**3**2 = {substr($x,0,20)}...{substr($x,$x.chars-20)} and has {$x.chars} digits\";<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>5**4**3**2 = 62060698786608744707...92256259918212890625 and has 183231 digits<\/pre>\n\n==[[:Category:PHP|PHP]][[Category:PHP]]==\nPHP has two separate arbitrary-precision integer services.\n\nThe first is the BC library.[http:\/\/us3.php.net\/manual\/en\/book.bc.php] It represents the integers as strings, so may not be very efficient. The advantage is that it is more likely to be included with PHP.\n<lang php><?php\n$y = bcpow('5', bcpow('4', bcpow('3', '2')));\nprintf(\"5**4**3**2 = %s...%s and has %d digits\\n\", substr($y,0,20), substr($y,-20), strlen($y));\n?><\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>\n5**4**3**2 = 62060698786608744707...92256259918212890625 and has 183231 digits\n<\/pre>\nThe second is the GMP library.[http:\/\/us3.php.net\/manual\/en\/book.gmp.php] It represents the integers as an opaque type, so may be faster. However, it is less likely to be compiled into your version of PHP (it isn't compiled into mine).\n\n==[[:Category:PicoLisp|PicoLisp]][[Category:PicoLisp]]==\n<lang PicoLisp>(let L (chop (** 5 (** 4 (** 3 2))))\n   (prinl (head 20 L) \"...\" (tail 20 L))\n   (length L) )<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>62060698786608744707...92256259918212890625\n-> 183231<\/pre>\n\n==[[:Category:Pike|Pike]][[Category:Pike]]==\n<lang Pike>> string res = (string)pow(5,pow(4,pow(3,2)));\n> res[..19] == \"62060698786608744707\";\nResult: 1\n> res[<19..] == \"92256259918212890625\";\nResult: 1\n> sizeof(result);\nResult: 183231<\/lang>\n\n==[[:Category:PureBasic|PureBasic]][[Category:PureBasic]]==\nPureBasic has in its current version (today 4.50) no internal support for large numbers, but there are several free libraries for this.\n\nUsing [http:\/\/www.purebasic.fr\/english\/viewtopic.php?p=309763#p309763 Decimal.pbi], e.g. the same included library as in [[Long multiplication#PureBasic]], this task is solved as below.\n<lang PureBasic>IncludeFile \"Decimal.pbi\"\n\n;- Declare the variables that will be used\nDefine.Decimal *a\nDefine n, L$, R$, out$, digits.s\n\n;- 4^3^2 is withing 32 bit range, so normal procedures can be used\nn=Pow(4,Pow(3,2))\n\n;- 5^n is larger then 31^2, so the same library call as in the \"Long multiplication\" task is used\n*a=PowerDecimal(IntegerToDecimal(5),IntegerToDecimal(n))\n\n;- Convert the large number into a string & present the results\nout$=DecimalToString(*a)\nL$ = Left(out$,20)\nR$ = Right(out$,20)\ndigits=Str(Len(out$))\nout$=\"First 20 & last 20 chars of 5^4^3^2 are;\"+#CRLF$+L$+#CRLF$+R$+#CRLF$\nout$+\"and the result is \"+digits+\" digits long.\"\n\nMessageRequester(\"Arbitrary-precision integers, PureBasic\",out$)<\/lang>\n[[Image:Arbitrary-precision_integers,_PureBasic.png]]\n\n==[[:Category:Python|Python]][[Category:Python]]==\nPython comes with built-in support for arbitrary precision integers. The type of arbitrary precision integers is <tt>[http:\/\/docs.python.org\/library\/stdtypes.html#typesnumeric long]<\/tt> in Python 2.x (overflowing operations on <tt>int<\/tt>'s are automatically converted into <tt>long<\/tt>'s), and <tt>[http:\/\/docs.python.org\/3.1\/library\/stdtypes.html#typesnumeric int]<\/tt> in Python 3.x.\n<lang python>>>> y = str( 5**4**3**2 )\n>>> print (\"5**4**3**2 = %s...%s and has %i digits\" % (y[:20], y[-20:], len(y)))\n5**4**3**2 = 62060698786608744707...92256259918212890625 and has 183231 digits<\/lang>\n\n==[[:Category:R|R]][[Category:R]]==\nR does not come with built-in support for arbitrary precision integers, but it can be implemented with the GMP library (there is also an interface to bc).\n<lang R>library(gmp)\nlarge=pow.bigz(5,pow.bigz(4,pow.bigz(3,2)))\nlargestr=as.character(large)\ncat(\"first 20 digits:\",substr(largestr,1,20),\"\\n\",\n    \"last 20 digits:\",substr(largestr,nchar(largestr)-19,nchar(largestr)),\"\\n\",\n    \"number of digits: \",nchar(largestr),\"\\n\")<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>first 20 digits: 62060698786608744707 \n last 20 digits: 92256259918212890625 \n number of digits:  183231<\/pre>\n\n==[[:Category:REXX|REXX]][[Category:REXX]]==\nREXX comes with built-in support for fixed precision integers that can be manually set to a large value of precision.\n<lang rexx>\/*REXX program to show arbitrary precision integers. *\/\nnumeric digits 200000     \ncheck = '62060698786608744707...92256259918212890625'\n\ncall time 'R' \n    n = 5 ** (4 ** (3**2))\nsay 'elapsed time for the calculation:' format(time('E'),,2) \"seconds.'\nsay\nsampl = left(n, 20)\"...\"right(n, 20)\n\nsay ' check:' check\nsay 'sSample:' sampl\nsay 'digits:' length(n)\nsay\n\nif check=sampl then say 'passed!\n               else say 'failed!<\/lang>\n'''output'''\n<pre>\nelapsed time for the calculation: 52.90 seconds.\n\n check: 62060698786608744707...92256259918212890625\nsample: 62060698786608744707...92256259918212890625\ndigits: 183231\n\npassed!\n<\/pre>\n\n==[[:Category:Ruby|Ruby]][[Category:Ruby]]==\nRuby comes with built-in support for arbitrary precision integers. The type of arbitrary precision integers is <tt>Bignum<\/tt>; overflowing operations on <tt>Fixnum<\/tt>'s are automatically converted into <tt>Bignum<\/tt>'s.\n<lang ruby>irb(main):001:0> y = ( 5**4**3**2 ).to_s; puts \"5**4**3**2 = #{y[0..19]}...#{y[-20..-1]} and has #{y.length} digits\"\n5**4**3**2 = 62060698786608744707...92256259918212890625 and has 183231 digits<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>$ time ruby19 -e 'y = ... digits\"'\n5**4**3**2 = 62060698786608744707...92256259918212890625 and has 183231 digits\n    0m0.52s real     0m0.47s user     0m0.05s system<\/pre>\n\n==[[:Category:Run BASIC|Run BASIC]][[Category:Run BASIC]]==\n<lang runbasic>x$ = str$( 5^(4^(3^2))) \nprint \"Length:\";len( x$)\nprint left$( x$, 20); \"......\"; right$( x$, 20)<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>Length:183231\n62060698786608744707......92256259918212890625<\/pre>\n\n==[[:Category:Sather|Sather]][[Category:Sather]]==\n<lang sather>class MAIN is\n  main is\n    r:INTI;\n    p1 ::= \"62060698786608744707\";\n    p2 ::= \"92256259918212890625\";\n\n    -- computing 5^(4^(3^2)), it could be written\n    -- also e.g. (5.inti)^((4.inti)^((3.inti)^(2.inti)))\n    r  := (3.pow(2)).inti;\n    r  := (4.inti).pow(r);\n    r  := (5.inti).pow(r);\n\n    sr ::= r.str; -- string rappr. of the number\n    if sr.head(p1.size) = p1\n       and sr.tail(p2.size) = p2 then\n         #OUT + \"result is ok..\\n\";\n    else\n         #OUT + \"oops\\n\";\n    end;\n    #OUT + \"# of digits: \" + sr.size + \"\\n\";\n  end;\nend;<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>result is ok..\n# of digits: 183231<\/pre>\n\n==[[:Category:Scala|Scala]][[Category:Scala]]==\nScala does not come with support for arbitrary precision integers powered to arbitrary precision integers, except if performed on a module. It can use arbitrary precision integers in other ways, including powering them to 32-bits integers.\n<lang scala>scala> BigInt(5) modPow (BigInt(4) pow (BigInt(3) pow 2).toInt, BigInt(10) pow 20)\nres21: scala.math.BigInt = 92256259918212890625\n\nscala> (BigInt(5) pow (BigInt(4) pow (BigInt(3) pow 2).toInt).toInt).toString\nres22: String = 6206069878660874470748320557284679309194219265199117173177383244\n78446890420544620839553285931321349485035253770303663683982841794590287939217907\n89641300156281305613064874236198955114921296922487632406742326659692228562195387\n46210423235340883954495598715281862895110697243759768434501295076608139350684049\n01191160699929926568099301259938271975526587719565309995276438998093283175080241\n55833224724855977970015112594128926594587205662421861723789001208275184293399910\n13912158886504596553858675842231519094813553261073608575593794241686443569888058\n92732524316323249492420512640962691673104618378381545202638771401061171968052873\n21414945463925055899307933774904078819911387324217976311238875802878310483037255\n33789567769926391314746986316354035923183981697660495275234703657750678459919...\nscala> res22 take 20\nres23: String = 62060698786608744707\n\nscala> res22 length\nres24: Int = 183231\n\nscala> <\/lang>\n\n==[[:Category:Scheme|Scheme]][[Category:Scheme]]==\n[http:\/\/people.csail.mit.edu\/jaffer\/r4rs_8.html#SEC52 R<sup>4<\/sup>RS] and [http:\/\/schemers.org\/Documents\/Standards\/R5RS\/HTML\/r5rs-Z-H-9.html#%_sec_6.2.3 R<sup>5<\/sup>RS] encourage, and [http:\/\/www.r6rs.org\/final\/html\/r6rs\/r6rs-Z-H-6.html#node_sec_3.4 R<sup>6<\/sup>RS] requires, that exact integers be of arbitrary precision.\n<lang scheme>(define x (expt 5 (expt 4 (expt 3 2))))\n(define y (number->string x))\n(define l (string-length y))\n(display (string-append \"5**4**3**2 = \" (substring y 0 20) \"...\" (substring y (- l 20) l) \" and has \" (number->string l) \" digits\"))\n(newline)<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>5**4**3**2 = 62060698786608744707...92256259918212890625 and has 183231 digits<\/pre>\n\n==[[:Category:Seed7|Seed7]][[Category:Seed7]]==\n<lang seed7>$ include \"seed7_05.s7i\";\n  include \"bigint.s7i\";\n\nconst proc: main is func\n  local\n    var bigInteger: fiveToThePowerOf262144 is 5_ ** 4 ** 3 ** 2;\n    var string: numberAsString is str(fiveToThePowerOf262144);\n  begin\n    writeln(\"5**4**3**2 = \" <& numberAsString[..20] <&\n            \"...\" <& numberAsString[length(numberAsString) - 19 ..]);\n    writeln(\"decimal digits: \" <& length(numberAsString));\n  end func;<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>\n5**4**3**2 = 62060698786608744707...92256259918212890625\ndecimal digits: 183231\n<\/pre>\n\n==[[:Category:SIMPOL|SIMPOL]][[Category:SIMPOL]]==\n{| class=\"messagebox\" style=\"text-align: center; background-color: #ffc8c8; clear: both;\"\n| This example is '''incomplete'''. Number of digits in result not given. Please ensure that it meets all task requirements and remove this message.\n|}[[Category:SIMPOL examples needing attention]][[Category:Examples needing attention]]\nSIMPOL supports arbitrary precision integers powered to arbitrary precision integers. This is the only integer data type in SIMPOL. SIMPOL supports conversion from its integer data type to other formats when calling external library functions.\n<lang simpol>constant FIRST20 \"62060698786608744707\"\nconstant LAST20  \"92256259918212890625\"\n\nfunction main()\n  integer i\n  string s, s2\n\n  i = .ipower(5, .ipower(4, .ipower(3, 2)))\n  s2 = .tostr(i, 10)\n  if .lstr(s2, 20) == FIRST20 and .rstr(s2, 20) == LAST20\n    s = \"Success! The integer matches both the first 20 and the last 20 digits. There are \" + .tostr(.len(s2), 10) + \" digits in the result.{d}{a}\"\n  else\n    s = \"\"\n    if .lstr(s2, 20) != FIRST20 \n      s = \"Failure! The first 20 digits are: \" + .lstr(s2, 20) + \" but they should be: \" + FIRST20 + \"{d}{a}\"\n    end if\n    if .rstr(s2, 20) != LAST20 \n      s = s + \"Failure! The first 20 digits are: \" + .lstr(s2, 20) + \" but they should be: \" + LAST20 + \"{d}{a}\"\n    end if\n  end if\nend function s<\/lang>\n\n==[[:Category:Smalltalk|Smalltalk]][[Category:Smalltalk]]==\nThis code in Squeak Smalltalk returns a string containing the first 20 digits, last 20 digits and length of the result.\n\nA very simple approach:\n<lang smalltalk>|num|\nnum := (5 raisedTo: (4 raisedTo: (3 raisedTo: 2))) asString.\nTranscript\n   show: (num first: 20), '...', (num last: 20); cr;\n   show: 'digits: ', num size asString.<\/lang>\n\nOn a Transcript window:\n<pre>62060698786608744707...92256259918212890625\ndigits: 183231<\/pre>\nAnd a more advanced one:\n<lang smalltalk>|num numstr|\nnum := (2 to: 5) fold: [:exp :base| base raisedTo: exp].\nnumstr := num asString.\n'<1s>...<2s>  digits:<3p>'\n   expandMacrosWith: (numstr first: 20)\n   with: (numstr last: 20)\n   with: numstr size.<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>'62060698786608744707...92256259918212890625  digits: 183231'<\/pre>\n\n==[[:Category:Standard ML|Standard ML]][[Category:Standard ML]]==\n<lang sml>let\n  val answer = IntInf.pow (5, IntInf.toInt (IntInf.pow (4, IntInf.toInt (IntInf.pow (3, 2)))))\n  val s = IntInf.toString answer\n  val len = size s\nin\n  print (\"has \" ^ Int.toString len ^ \" digits: \" ^\n         substring (s, 0, 20) ^ \" ... \" ^\n         substring (s, len-20, 20) ^ \"\\n\")\nend;<\/lang>\nit took too long to run\n\n==[[:Category:Tcl|Tcl]][[Category:Tcl]]==\nTcl supports arbitrary precision integers (and an exponentiation operator) from 8.5 onwards.\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Tcl]] version 8.5[[SMW::on]]<\/div>\n<lang tcl>set bigValue [expr {5**4**3**2}]\nputs \"5**4**3**2 has [string length $bigValue] digits\"\nif {[string match \"62060698786608744707*92256259918212890625\" $bigValue]} {\n    puts \"Value starts with 62060698786608744707, ends with 92256259918212890625\"\n} else {\n    puts \"Value does not match 62060698786608744707...92256259918212890625\"\n}<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>\n5**4**3**2 has 183231 digits\nValue starts with 62060698786608744707, ends with 92256259918212890625\n<\/pre>\n\n==[[:Category:TXR|TXR]][[Category:TXR]]==\n<lang txr>@(bind (f20 l20 ndig) \n       @(let* ((num (expt 5 4 3 2))\n               (str (format nil \"~s\" num))\n               (len (length str)))\n          '(,(sub-str str 0 20) ,(sub-str str (- len 20) len) ,len)))\n@(bind f20 \"62060698786608744707\")\n@(bind l20 \"92256259918212890625\")\n@(output)\n@f20...@l20\nndigits=@ndig\n@(end)<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>62060698786608744707...92256259918212890625\nndigits=183231<\/pre>\n\n==[[:Category:Ursala|Ursala]][[Category:Ursala]]==\nThere are no infix arithmetic operators in the language, but there is a <code>power<\/code> function in the <code>bcd<\/code> library, which is part of the standard distribution from the home site.\n\nThere is no distinction between ordinary and arbitrary precision integers, but the binary converted decimal representation used here is more efficient than the usual binary representation in calculations that would otherwise be dominated by the conversion to decimal output.\n<lang Ursala>#import std\n#import nat\n#import bcd\n\n#show+\n\nmain = <.@ixtPX take\/$20; ^|T\/~& '...'--@x,'length: '--@h+ %nP+ length@t>@h %vP power=> <5_,4_,3_,2_><\/lang>\nWith this calculation taking about a day to run, correct results are attainable but not performant.\n<pre>62060698786608744707...92256259918212890625\nlength: 183231<\/pre>\n\n[[Category:AWK\/Omit]]\n[[Category:AutoHotkey\/Omit]]\n[[Category:Batch File\/Omit]]\n[[Category:Brainf***\/Omit]]\n[[Category:PostScript\/Omit]]\n[[Category:PowerShell\/Omit]]\n[[Category:SAS\/Omit]]\n[[Category:Scratch\/Omit]]\n[[Category:sed\/Omit]]"}]}}},"query-continue":{"revisions":{"rvstartid":135879}}}