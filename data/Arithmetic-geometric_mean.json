{"query-continue":{"search":{"gsroffset":1},"revisions":{"rvstartid":137834}},"query":{"pages":{"2069":{"pageid":2069,"ns":0,"title":"Arithmetic\/Integer","revisions":[{"*":"<div class=\"infobox\" style=\"width: 2in\">[[File:Rcode-button-task-crushed.png|64px|left|alt=Task|link=Category:Solutions by Programming Task]]'''Arithmetic\/Integer'''<br\/>\nYou are encouraged to [[Rosetta Code:Solve a Task|solve this task]] according to the task description, using any language you may know.[[Category:Programming Tasks]][[Category:Basic language learning]]<\/div>[[Category:Arithmetic operations]]<div class=\"infobox\" style=\"width: 2in\">\n<big>'''Basic Data Operation'''<\/big><br>\nThis is a basic data operation.  It represents a fundamental action on a basic data type.\n\nYou may see other such operations in the [[:Category:Basic Data Operations|Basic Data Operations]] category, or:\n\n<center><small>\n'''Integer Operations'''\n<br>\n[[Arithmetic\/Integer|Arithmetic]] |\n[[Integer comparison|Comparison]]\n\n'''Boolean Operations'''\n<br>\n[[Bitwise operations|Bitwise]] |\n[[Logical operations|Logical]]\n\n'''String Operations'''\n<br>\n[[String concatenation|Concatenation]] |\n[[String interpolation (included)|Interpolation]] |\n[[Character matching|Matching]]\n\n'''Memory Operations'''\n<br>\n[[Pointers and references|Pointers &amp; references]] |\n[[Address of a variable|Addresses]]\n<\/small><\/center><\/div>\n[[Category:Basic Data Operations]]\nGet two integers from the user, and then output the sum, difference, product, integer quotient and remainder of those numbers. Don't include error handling. For quotient, indicate how it rounds (e.g. towards 0, towards negative infinity, etc.). For remainder, indicate whether its sign matches the sign of the first operand or of the second operand, if they are different.\n\nAlso include the exponentiation operator if one exists.\n\n==[[:Category:6502 Assembly|6502 Assembly]][[Category:6502 Assembly]]== \nCode is called as a subroutine (i.e. JSR Arithmetic).  Specific OS\/hardware routines for user input and printing are left unimplemented.\n<lang 6502asm>Arithmetic:\tPHA\t\t\t;push accumulator and X register onto stack\n\t\tTXA\n\t\tPHA\n\t\tJSR GetUserInput\t;routine not implemented\n\t\t;two integers now in memory locations A and B\n\t\t;addition\n\t\tLDA A\n\t\tCLC\n\t\tADC B\n\t\tJSR DisplayAddition\t;routine not implemented\n\n\t\t;subtraction\n\t\tLDA A\n\t\tSEC\n\t\tSBC B\n\t\tJSR DisplaySubtraction\t;routine not implemented\n\n\t\t;multiplication - overflow not handled\n\t\tLDA A\n\t\tLDX B\nMultiply:\tCLC\n\t\tADC A\n\t\tDEX\n\t\tBNE Multiply\n\t\tJSR DisplayMultiply\t;routine not implemented\n\n\t\t;division\t- rounds up\n\t\tLDA A\n\t\tLDX #0\n\t\tSEC\nDivide:\t\tINX\n\t\tSBC B\n\t\tBCS Divide\n\t\tTXA\t\t\t;get result into accumulator\n\t\tJSR DisplayDivide\t;routine not implemented\n\n\t\t;modulus\n\t\tLDA A\n\t\tSEC\nModulus:\tSBC B\n\t\tBCS Modulus\n\t\tADC B\n\t\tJSR DisplayModulus\t;routine not implemented\n\n\t\tPLA\t\t\t;restore accumulator and X register from stack\n\t\tTAX\n\t\tPLA\n\t\tRTS\t\t\t;return from subroutine<\/lang>\nThe 6502 has no opcodes for multiplication, division, or modulus; the routines for multiplication, division, and modulus given above can be heavily optimized at the expense of some clarity.\n\n==[[:Category:ABAP|ABAP]][[Category:ABAP]]==\n<lang ABAP>report zz_arithmetic no standard page heading.\n\n\" Read in the two numbers from the user.\nselection-screen begin of block input.\n  parameters: p_first type i,\n              p_second type i.\nselection-screen end of block input.\n\n\" Set the text value that is displayed on input request.\nat selection-screen output.\n  %_p_first_%_app_%-text  = 'First Number: '.\n  %_p_second_%_app_%-text = 'Second Number: '.\n\nend-of-selection.\n  data: lv_result type i.\n  lv_result = p_first + p_second.\n  write: \/ 'Addition:', lv_result.\n  lv_result = p_first - p_second.\n  write: \/ 'Substraction:', lv_result.\n  lv_result = p_first * p_second.\n  write: \/ 'Multiplication:', lv_result.\n  lv_result = p_first div p_second.\n  write: \/ 'Integer quotient:', lv_result. \" Truncated towards zero.\n  lv_result = p_first mod p_second.\n  write: \/ 'Remainder:',  lv_result.<\/lang>\n\n==[[:Category:ACL2|ACL2]][[Category:ACL2]]==\n<lang Lisp>\n:set-state-ok t\n\n(defun get-two-nums (state)\n   (mv-let (_ a state)\n           (read-object *standard-oi* state)\n      (declare (ignore _))\n      (mv-let (_ b state)\n              (read-object *standard-oi* state)\n         (declare (ignore _))\n         (mv a b state))))\n\n(defun integer-arithmetic (state)\n   (mv-let (a b state)\n           (get-two-nums state)\n      (mv state\n          (progn$ (cw \"Sum:        ~x0~%\" (+ a b))\n                  (cw \"Difference: ~x0~%\" (- a b))\n                  (cw \"Product:    ~x0~%\" (* a b))\n                  (cw \"Quotient:   ~x0~%\" (floor a b))\n                  (cw \"Remainder:  ~x0~%\" (mod a b))))))<\/lang>\n\n==[[:Category:Ada|Ada]][[Category:Ada]]==\n<lang ada>with Ada.Text_Io;\nwith Ada.Integer_Text_IO;\n\nprocedure Integer_Arithmetic is\n   use Ada.Text_IO;\n   use Ada.Integer_Text_Io;\n\n   A, B : Integer;\nbegin\n   Get(A);\n   Get(B);\n   Put_Line(\"a+b = \" & Integer'Image(A + B));\n   Put_Line(\"a-b = \" & Integer'Image(A - B));\n   Put_Line(\"a*b = \" & Integer'Image(A * B));\n   Put_Line(\"a\/b = \" & Integer'Image(A \/ B) & \", remainder \" & Integer'Image(A mod B));  \n   Put_Line(\"a**b = \" & Integer'Image(A ** B));  \n\nend Integer_Arithmetic;<\/lang>\n\n==[[:Category:Aikido|Aikido]][[Category:Aikido]]==\n<lang aikido>var a = 0\nvar b = 0\nstdin -> a    \/\/ read int from stdin\nstdin -> b    \/\/ read int from stdin\n\nprintln (\"a+b=\" + (a + b))\nprintln (\"a-b=\" + (a - b))\nprintln (\"a*b=\" + (a * b))\nprintln (\"a\/b=\" + (a \/ b))\nprintln (\"a%b=\" + (a % b))<\/lang>\n\n==[[:Category:ALGOL 68|ALGOL 68]][[Category:ALGOL 68]]==\n<div class=\"examplemeta translation\">'''Translation of''': [[Arithmetic\/Integer#C|C]]<\/div>\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[ALGOL 68]] version Revision 1 - no extensions to language used[[SMW::on]]<\/div>\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[ALGOL 68G]] version Any - tested with release [http:\/\/sourceforge.net\/projects\/algol68\/files\/algol68g\/algol68g-1.18.0\/algol68g-1.18.0-9h.tiny.el5.centos.fc11.i386.rpm\/download 1.18.0-9h.tiny][[SMW::on]]<\/div>\n\n<lang algol68>main:(\n  LONG INT a=355, b=113;\n  printf(($\"a+b = \"gl$, a + b));\n  printf(($\"a-b = \"gl$, a - b));\n  printf(($\"a*b = a\u00d7b = \"gl$, a * b));\n  printf(($\"a\/b = \"gl$, a \/ b));\n  printf(($\"a OVER b = a%b = a\u00f7b = \"gl$, a % b));\n  printf(($\"a MOD b = a%*b = a%\u00d7b = a\u00f7\u00d7b = a\u00f7*b = \"gl$, a %* b));\n  printf(($\"a UP b = a**b = a\u2191b = \"gl$, a ** b))\n)<\/lang>\nOutput:\n<pre>\na+b =                                 +468\na-b =                                 +242\na*b = a\u00d7b =                               +40115\na\/b = +3.141592920353982300884955752e  +0\na OVER b = a%b = a\u00f7b =                                   +3\na MOD b = a%*b = a%\u00d7b = a\u00f7\u00d7b = a\u00f7*b =                                  +16\na UP b = a**b = a\u2191b = +1.499007808785573768814747570e+288\n<\/pre>\n[[ALGOL 68R]] has the curious (and consequently non-standard) \/:= operator.  This operator\ndelivers two INTs as a result.  eg.\n INT quotient:=355, remainder;\n remainder := quotient \/:= 113;\nGiving a quotient of 3, and a remainder of 16.\n\n==[[:Category:AmigaE|AmigaE]][[Category:AmigaE]]==\n<lang amigae>PROC main()\n  DEF a, b, t\n  WriteF('A = ')\n  ReadStr(stdin, t)\n  a := Val(t)\n  WriteF('B = ')\n  ReadStr(stdin, t)\n  b := Val(t)\n  WriteF('A+B=\\d\\nA-B=\\d\\n', a+b, a-b)\n  WriteF('A*B=\\d\\nA\/B=\\d\\n', a*b, a\/b)\n  \/* * and \/ are 16 bit ops; Mul and Div are 32bit ops *\/\n  WriteF('A*B=\\d\\nA\/B=\\d\\n', Mul(a,b), Div(a,b))\n  WriteF('A mod B =\\d\\n', Mod(a,b))\nENDPROC<\/lang>\n\n==[[:Category:AutoHotkey|AutoHotkey]][[Category:AutoHotkey]]==\nThe quotient rounds towards 0 if both inputs are integers or towards negative infinity if either input is floating point. The sign of the remainder is always the same as the sign of the first parameter (dividend).\n<lang autohotkey>Gui, Add, Edit, va, 5\nGui, Add, Edit, vb, -3\nGui, Add, Button, Default, Compute\nGui, Show\nReturn\n\nButtonCompute:\n  Gui, Submit\n  MsgBox,%\n  (Join`s\"`n\"\n   a \"+\" b \" = \" a+b\n   a \"-\" b \" = \" a-b\n   a \"*\" b \" = \" a*b\n   a \"\/\/\" b \" = \" a\/\/b \" remainder \" Mod(a,b)\n   a \"**\" b \" = \" a**b\n  )\n; fallthrough\nGuiClose:\n  ExitApp<\/lang>\n\n==[[:Category:AWK|AWK]][[Category:AWK]]==\n<lang awk>\/^[ \\t]*-?[0-9]+[ \\t]+-?[0-9]+[ \\t]*$\/ {\n\tprint \"add:\", $1 + $2\n\tprint \"sub:\", $1 - $2\n\tprint \"mul:\", $1 * $2\n\tprint \"div:\", int($1 \/ $2) # truncates toward zero\n\tprint \"mod:\", $1 % $2      # same sign as first operand\n\tprint \"exp:\", $1 ^ $2\n\texit }<\/lang>\n\nFor division and modulus, Awk should act like C.\n\n'''Exponentiation's note:''' With [[nawk]] or [[gawk]], <code>$1 ** $2<\/code> acts like <code>$1 ^ $2<\/code>. With [[mawk]], <code>$1 ** $2<\/code> is a syntax error. Nawk allows <code>**<\/code>, but its manual page only has <code>^<\/code>. Gawk's manual warns, ''\"The POSIX standard only specifies the use of `^' for exponentiation. For maximum portability, do not use the `**' operator.\"''\n\n==[[:Category:BASIC|BASIC]][[Category:BASIC]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[QuickBasic]] version 4.5[[SMW::on]]<\/div>\n<lang qbasic>function math(a!, b!)\n\tprint a + b\n\tprint a - b\n\tprint a * b\n\tprint a \/ b\n\tprint a mod b\nend function<\/lang>\nTruncate towards: 0\n\nRemainder sign matches: first operand\n\n==[[:Category:Batch File|Batch File]][[Category:Batch File]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Windows NT]] version 4 or later (includes Windows XP and onward)[[SMW::on]]<\/div>\n<lang dos>\n@echo off\nset \/P A=Enter 1st Number :\nset \/P B=Enter 2nd Number :\nset D=%A% + %B% & call :printC\nset D=%A% - %B% & call :printC\nset D=%A% * %B% & call :printC\nset D=%A% \/ %B% & call :printC & rem truncates toward 0\nset D=%A% %% %B% & call :printC & rem matches sign of 1st operand\nexit \/b\n\n:printC\nset \/A C=%D%\necho %D% = %C%\n<\/lang>\n\n==[[:Category:BBC BASIC|BBC BASIC]][[Category:BBC BASIC]]==\n<lang bbcbasic>      INPUT \"Enter the first integer: \" first%\n      INPUT \"Enter the second integer: \" second%\n      \n      PRINT \"The sum is \" ; first% + second%\n      PRINT \"The difference is \" ; first% - second%\n      PRINT \"The product is \" ; first% * second%\n      PRINT \"The integer quotient is \" ; first% DIV second% \" (rounds towards 0)\"\n      PRINT \"The remainder is \" ; first% MOD second% \" (sign matches first operand)\"\n      PRINT \"The first raised to the power of the second is \" ; first% ^ second%<\/lang>\n\n==[[:Category:bc|bc]][[Category:bc]]==\n<lang bc>define f(a, b) {\n\t\"add: \"; a + b\n\t\"sub: \"; a - b\n\t\"mul: \"; a * b\n\t\"div: \"; a \/ b  \/* truncates toward zero *\/\n\t\"mod: \"; a % b  \/* same sign as first operand *\/\n\t\"pow: \"; a ^ b\n}<\/lang>\n\n==[[:Category:Befunge|Befunge]][[Category:Befunge]]==\n<lang befunge>&&00p\"=A\",,:.\"=B \",,,00g.55+,v\n        v,+55.+g00:,,,,\"A+B=\"<\n        >\"=B-A\",,,,:00g-.55+,v\n        v,+55.*g00:,,,,\"A*B=\"<\n        >\"=B\/A\",,,,:00g\/.55+,v\n         @,+55.%g00,,,,\"A%B=\"<<\/lang>\n\n==[[:Category:Brat|Brat]][[Category:Brat]]==\nInspired by the second VBScript version.\n<lang brat>x = ask(\"First number: \").to_i\ny = ask(\"Second number: \").to_i\n\n#Division uses floating point\n#Remainder uses sign of right hand side\n[:+ :- :* :\/ :% :^].each { op |\n  p \"#{x} #{op} #{y} = #{x.call_method op, y}\"<\/lang>\n\n==[[:Category:C|C]][[Category:C]]==\n<lang c>#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[])\n{\n  int a, b;\n  if (argc < 3) exit(1);\n  b = atoi(argv[--argc]);\n  if (b == 0) exit(2);\n  a = atoi(argv[--argc]);\n  printf(\"a+b = %d\\n\", a+b);\n  printf(\"a-b = %d\\n\", a-b);\n  printf(\"a*b = %d\\n\", a*b);\n  printf(\"a\/b = %d\\n\", a\/b); \/* truncates towards 0 (in C99) *\/\n  printf(\"a%%b = %d\\n\", a%b); \/* same sign as first operand (in C99) *\/\n  return 0;\n}<\/lang>\n\n==[[:Category:C++|C++]][[Category:C++]]==\n<lang cpp>#include <iostream>\n\nint main()\n{\n  int a, b;\n  std::cin >> a >> b;\n  std::cout << \"a+b = \" << a+b << \"\\n\";\n  std::cout << \"a-b = \" << a-b << \"\\n\";\n  std::cout << \"a*b = \" << a*b << \"\\n\";\n  std::cout << \"a\/b = \" << a\/b << \", remainder \" << a%b << \"\\n\";\n  return 0;\n}<\/lang>\n\n==<span id=\"C sharp\">[[:Category:C sharp|C#]]<\/span>[[Category:C sharp]]==\n<lang csharp>using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        int a = Convert.ToInt32(args[0]);\n        int b = Convert.ToInt32(args[1]);\n\n        Console.WriteLine(\"{0} + {1} = {2}\", a, b, a + b);\n        Console.WriteLine(\"{0} - {1} = {2}\", a, b, a - b);\n        Console.WriteLine(\"{0} * {1} = {2}\", a, b, a * b);\n        Console.WriteLine(\"{0} \/ {1} = {2}\", a, b, a \/ b); \/\/ truncates towards 0\n        Console.WriteLine(\"{0} % {1} = {2}\", a, b, a % b); \/\/ matches sign of first operand\n        Console.WriteLine(\"{0} to the power of {1} = {2}\", a, b, Math.Pow(a, b));\n    }\n}<\/lang>\nSample output:\n<pre>5 + 3 = 8\n5 - 3 = 2\n5 * 3 = 15\n5 \/ 3 = 1\n5 % 3 = 2\n5 to the power of 3 = 125<\/pre>\n\n==[[:Category:Chef|Chef]][[Category:Chef]]==\n\n<lang Chef>Number Soup.\n\nOnly reads single values.\n\nIngredients.\n1 g Numbers\n3 g Water\n5 g Soup\n\nMethod.\nTake Numbers from refrigerator.\nTake Soup from refrigerator.\nPut Numbers into 1st mixing bowl.\nAdd Soup into the 1st mixing bowl.\nPour contents of the 1st mixing bowl into 1st baking dish.\nClean 1st mixing bowl.\nPut Numbers into 1st mixing bowl.\nRemove Soup from 1st mixing bowl.\nPour contents of the 1st mixing bowl into 2nd baking dish.\nClean 1st mixing bowl.\nPut Numbers into 1st mixing bowl.\nCombine Soup into 1st mixing bowl.\nPour contents of the 1st mixing bowl into 3rd baking dish.\nClean 1st mixing bowl.\nPut Numbers into 1st mixing bowl.\nDivide Soup into 1st mixing bowl.\nPour contents of the 1st mixing bowl into 4th baking dish.\nClean 1st mixing bowl.\nPut Water into 1st mixing bowl.\nVerb the Soup.\nCombine Numbers into 1st mixing bowl.\nVerb the Soup until verbed.\nPour contents of the 1st mixing bowl into 5th baking dish.\nClean 1st mixing bowl.\n\nServes 5.<\/lang>\n\n==[[:Category:Clojure|Clojure]][[Category:Clojure]]==\n<lang clojure>(defn myfunc []\n  (println \"Enter x and y\")\n  (let [x (read), y (read)]\n    (doseq [op '(+ - * \/ Math\/pow rem)]\n      (let [exp (list op x y)]\n\t(printf \"%s=%s\\n\" exp (eval exp))))))<\/lang>\n\n<pre>user=> (myfunc)\nEnter x and y\n3\n6\n(+ 3 6)=9\n(- 3 6)=-3\n(* 3 6)=18\n(\/ 3 6)=1\/2\n(Math\/pow 3 6)=729.0\n(rem 3 6)=3\nnil<\/pre>\n\n==[[:Category:Common Lisp|Common Lisp]][[Category:Common Lisp]]==\n\n<lang lisp>(defun arithmetic (&optional (a (read *query-io*)) (b (read *query-io*)))\n  (mapc\n    (lambda (op)\n      (format t \"~a => ~a~%\" (list op a b) (funcall (symbol-function op) a b)))\n    '(+ - * mod rem floor ceiling truncate round expt))\n  (values))<\/lang>\n\nCommon Lisp's integer division functions are <code>floor<\/code>, <code>ceiling<\/code>, <code>truncate<\/code>, and <code>round<\/code>. They differ in how they round their quotient.\n\n{| class=\"wikitable\"\n! The function !! rounds its quotient towards\n|-\n! <code>floor<\/code>\n| negative infinity\n|-\n! <code>ceiling<\/code>\n| positive infinity\n|-\n! <code>truncate<\/code>\n| zero\n|-\n! <code>round<\/code>\n| the nearest integer (preferring the even integer if the mathematical quotient is equidistant from two integers)\n|}\n\nEach function also returns a remainder as its secondary value, such that\n  quotient * divisor + remainder = dividend .\n<code>(mod a b)<\/code> and <code>(rem a b)<\/code> return numbers equal to the secondary values of <code>(floor a b)<\/code> and <code>(truncate a b)<\/code>, respectively.\n\n==[[:Category:D|D]][[Category:D]]==\n<lang d>import std.stdio, std.string, std.conv;\n\nvoid main() {\n    int a = 10, b = 20;\n    try {\n        a = readln().strip().to!int();\n        b = readln().strip().to!int();\n    } catch (StdioException e) {}\n    writeln(\"a = \", a, \", b = \", b);\n\n    writeln(\"a + b = \", a + b);\n    writeln(\"a - b = \", a - b);\n    writeln(\"a * b = \", a * b);\n    writeln(\"a \/ b = \", a \/ b);\n    writeln(\"a % b = \", a % b);\n    writeln(\"a ^^ b = \", a ^^ b);\n}<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>a = -16, b = 5\na + b = -11\na - b = -21\na * b = -80\na \/ b = -3\na % b = -1\na ^^ b = -1048576<\/pre>\n===Shorter Version===\nSame output.\n<lang d>import std.stdio, std.string, std.conv, std.typetuple;\n\nvoid main() {\n    int a = -16, b = 5;\n    try {\n        a = readln().strip().to!int();\n        b = readln().strip().to!int();\n    } catch (StdioException e) {}\n    writeln(\"a = \", a, \", b = \", b);\n\n    foreach (op; TypeTuple!(\"+\", \"-\", \"*\", \"\/\", \"%\", \"^^\"))\n        mixin(`writeln(\"a ` ~ op ~ ` b = \", a` ~ op ~ `b);`);\n}<\/lang>\nDivision and modulus are defined as in C99.\n\n==[[:Category:dc|dc]][[Category:dc]]==\n<lang dc>[Enter 2 integers on 1 line.\n  Use whitespace to separate. Example: 2 3\n  Use underscore for negative integers. Example: _10\n]P ? sb sa\n[add: ]P la lb + p sz\n[sub: ]P la lb - p sz\n[mul: ]P la lb * p sz\n[div: ]P la lb \/ p sz  [truncates toward zero]sz\n[mod: ]P la lb % p sz  [sign matches first operand]sz\n[pow: ]P la lb ^ p sz<\/lang>\n\n==[[:Category:Delphi|Delphi]][[Category:Delphi]]==\n<lang Delphi>program IntegerArithmetic;\n\n{$APPTYPE CONSOLE}\n\nuses SysUtils, Math;\n\nvar\n  a, b: Integer;\nbegin\n  a := StrToInt(ParamStr(1));\n  b := StrToInt(ParamStr(2));\n\n  WriteLn(Format('%d + %d = %d', [a, b, a + b]));\n  WriteLn(Format('%d - %d = %d', [a, b, a - b]));\n  WriteLn(Format('%d * %d = %d', [a, b, a * b]));\n  WriteLn(Format('%d \/ %d = %d', [a, b, a div b])); \/\/ rounds towards 0\n  WriteLn(Format('%d %% %d = %d', [a, b, a mod b])); \/\/ matches sign of the first operand\n  WriteLn(Format('%d ^ %d = %d', [a, b, Trunc(Power(a, b))]));\nend.<\/lang>\n\n==[[:Category:DWScript|DWScript]][[Category:DWScript]]==\n<lang delphi>var a := StrToInt(ParamStr(0));\nvar b := StrToInt(ParamStr(1));\n\nPrintLn(Format('%d + %d = %d', [a, b, a + b]));\nPrintLn(Format('%d - %d = %d', [a, b, a - b]));\nPrintLn(Format('%d * %d = %d', [a, b, a * b]));\nPrintLn(Format('%d \/ %d = %d', [a, b, a div b])); \nPrintLn(Format('%d mod %d = %d', [a, b, a mod b])); \nPrintLn(Format('%d ^ %d = %d', [a, b, Trunc(Power(a, b))]));<\/lang>\n\n==[[:Category:E|E]][[Category:E]]==\n\n<lang e>def arithmetic(a :int, b :int) {\n  return `$\\\n   Sum:        ${a + b}\n   Difference: ${a - b}\n   Product:    ${a * b}\n   Quotient:   ${a \/\/ b}\n   Remainder:  ${a % b}$\\n`\n}<\/lang>\n\n==[[:Category:Efene|Efene]][[Category:Efene]]==\n\n<lang efene>@public\nrun = fn () {\n\n    First = io.get_line(\"First number: \")\n    Second = io.get_line(\"Second number: \")\n\n    A = list_to_integer(lists.delete($\\n, First))\n    B = list_to_integer(lists.delete($\\n, Second))\n\n    io.format(\"Sum: ~p~n\", [A + B])\n    io.format(\"Difference: ~p~n\", [A - B])\n    io.format(\"Product: ~p~n\", [A * B])\n    io.format(\"Quotient: ~p~n\", [A \/ B])\n    io.format(\"Remainder: ~p~n\", [A % B])\n}<\/lang>\n\n==[[:Category:Eiffel|Eiffel]][[Category:Eiffel]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[SmartEiffel]] version 2.4[[SMW::on]]<\/div>\nIn a file called main.e:\n<lang eiffel>class MAIN\n    creation make\n    feature make is\n        local\n            a, b: REAL;\n        do\n            print(\"a = \");\n            io.read_real;\n            a := io.last_real;\n\n            print(\"b = \");\n            io.read_real;\n            b := io.last_real;\n\n            print(\"a + b = \");\n            io.put_real(a + b);\n            print(\"%Na - b = \");\n            io.put_real(a - b);\n            print(\"%Na * b = \");\n            io.put_real(a * b);\n            print(\"%Na \/ b = \");\n            io.put_real(a \/ b);\n            print(\"%Na %% b = \");\n            io.put_real(((a \/ b) - (a \/ b).floor) * b);\n            print(\"%Na ^ b = \");\n            io.put_real(a.pow(b));\n            print(\"%N\");\n        end\nend<\/lang>\nNote that there actually is a builtin modulo operator (\\\\). However, it seems impossible to use that instruction with SmartEiffel.\n\n==[[:Category:Elena|Elena]][[Category:Elena]]==\n<lang elena>#define std'basic'*.\n#define std'math'*.\n\n\/\/ --- Program ---\n\n#symbol Program =>\n[\n    #var a := 'program'input >> Integer.\n    #var b := 'program'input >> Integer.\n    \n    'program'output << a << \" + \" << b << \" = \" << a + b << \"%n\".\n    'program'output << a << \" - \" << b << \" = \" << a - b << \"%n\".\n    'program'output << a << \" * \" << b << \" = \" << a * b << \"%n\".\n    'program'output << a << \" \/ \" << b << \" = \" << a \/ b << \"%n\". \/\/ truncates towards 0\n    'program'output << a << \" %% \" << b << \" = \" << (a~emath modulus:b) << \"%n\". \/\/ matches sign of first operand\n].\n<\/lang>\n\n==[[:Category:Euphoria|Euphoria]][[Category:Euphoria]]==\n<lang euphoria>include get.e\n\ninteger a,b\n\na = floor(prompt_number(\"a = \",{}))\nb = floor(prompt_number(\"b = \",{}))\n\nprintf(1,\"a + b = %d\\n\", a+b)\nprintf(1,\"a - b = %d\\n\", a-b)\nprintf(1,\"a * b = %d\\n\", a*b)\nprintf(1,\"a \/ b = %g\\n\", a\/b) -- does not truncate\nprintf(1,\"remainder(a,b) = %d\\n\", remainder(a,b)) -- same sign as first operand\nprintf(1,\"power(a,b) = %g\\n\", power(a,b))<\/lang>\n\nOutput:\n<pre>a = 2\nb = 3\na + b = 5\na - b = -1\na * b = 6\na \/ b = 0.666667\nremainder(a,b) = 2\npower(a,b) = 8<\/pre>\n\n==[[:Category:Factor|Factor]][[Category:Factor]]==\n<lang factor>USING: combinators io kernel math math.functions math.order\nmath.parser prettyprint ;\n\n\"a=\" \"b=\" [ write readln string>number ] bi@\n{\n    [ + \"sum: \" write . ]\n    [ - \"difference: \" write . ] \n    [ * \"product: \" write . ]\n    [ \/ \"quotient: \" write . ]\n    [ \/i \"integer quotient: \" write . ]\n    [ rem \"remainder: \" write . ]\n    [ mod \"modulo: \" write . ]\n    [ max \"maximum: \" write . ]\n    [ min \"minimum: \" write . ]\n    [ gcd \"gcd: \" write . drop ]\n    [ lcm \"lcm: \" write . ]\n} 2cleave<\/lang>\n\noutput:\n\n<lang factor>a=8\nb=12\nsum: 20\ndifference: -4\nproduct: 96\nquotient: 2\/3\ninteger quotient: 0\nremainder: 8\nmodulo: 8\nmaximum: 12\nminimum: 8\ngcd: 4\nlcm: 24<\/lang>\n\nThis example illustrates the use of cleave and apply combinators to alleviate the usage of shuffle words in a concatenative language. bi@ applies a quotation to 2 inputs and 2cleave applies a sequence of quotations to 2 inputs.\n\n==[[:Category:FALSE|FALSE]][[Category:FALSE]]==\n<lang false>12 7\n\\$@$@$@$@$@$@$@$@$@$@\\  { 6 copies }\n\"sum = \"+.\"\ndifference = \"-.\"\nproduct = \"*.\"\nquotient = \"\/.\"\nmodulus = \"\/*-.\"\n\"<\/lang>\n\n==[[:Category:Forth|Forth]][[Category:Forth]]==\nTo keep the example simple, the word takes the two numbers from the stack.  '''\/mod''' returns two results; the stack effect is ( a b -- a%b a\/b ).\n<lang forth>: arithmetic ( a b -- )\n  cr .\" a=\" over . .\" b=\" dup .\n  cr .\" a+b=\" 2dup + .\n  cr .\" a-b=\" 2dup - .\n  cr .\" a*b=\" 2dup * .\n  cr .\" a\/b=\" \/mod .\n  cr .\" a mod b = \" . cr ;<\/lang>\n\nDifferent host systems have different native signed division behavior. ANS Forth defines two primitive double-precision signed division operations, from which the implementation may choose the most natural to implement the basic divide operations ( \/ , \/mod , mod , *\/ ). This is partly due to differing specifications in the two previous standards, Forth-79 and Forth-83.\n\n<lang forth>FM\/MOD ( d n -- mod div )   \\ floored\nSM\/REM ( d n -- rem div )   \\ symmetric\nM* ( n n -- d )<\/lang>\n\nIn addition, there are unsigned variants.\n\n<lang forth>UM\/MOD ( ud u -- umod udiv )\nUM* ( u u -- ud )<\/lang>\n\n==[[:Category:Fortran|Fortran]][[Category:Fortran]]==\nIn ANSI FORTRAN 77 or later:\n<lang fortran> INTEGER A, B\n PRINT *, 'Type in two integer numbers separated by white space',\n+         ' and press ENTER'\n READ *, A, B\n PRINT *, '   A + B = ', (A + B)\n PRINT *, '   A - B = ', (A - B)\n PRINT *, '   A * B = ', (A * B)\n PRINT *, '   A \/ B = ', (A \/ B)\n PRINT *, 'MOD(A,B) = ', MOD(A,B)\n PRINT *\n PRINT *, 'Even though you did not ask, ',\n+         'exponentiation is an intrinsic op in Fortran, so...'\n PRINT *, '  A ** B = ', (A ** B)\n END<\/lang>\n\n==<span id=\"F_Sharp\">[[:Category:F_Sharp|F#]]<\/span>[[Category:F_Sharp]]==\nAs F# is a functional language, we can easily create a list of pairs of the string name of a function and the function itself to iterate over printing the operation and applying the function to obtain the result:\n<lang fsharp>\ndo\n  let a, b = int Sys.argv.[1], int Sys.argv.[2]\n  for str, f in [\"+\", ( + ); \"-\", ( - ); \"*\", ( * ); \"\/\", ( \/ ); \"%\", ( % )] do\n    printf \"%d %s %d = %d\\n\" a str b (f a b)\n<\/lang>\nFor example, the output with the arguments 4 and 3 is:\n<lang fsharp>\n4 + 3 = 7\n4 - 3 = 1\n4 * 3 = 12\n4 \/ 3 = 1\n4 % 3 = 1\n<\/lang>\n\n\n==[[:Category:Frink|Frink]][[Category:Frink]]==\nThis demonstrates normal division (which produces rational numbers when possible), <CODE>div<\/CODE>, and <CODE>mod<\/CODE>.  <CODE>div<\/CODE> rounds toward negative infinity (defined as <CODE>floor[x\/y]<\/CODE>).  <CODE>mod<\/CODE> uses the sign of the second number (defined as <CODE>x - y * floor[x\/y]<\/CODE>).  All operators automatically produce big integers or exact rational numbers when necessary.\n<lang frink>\n[a,b] = input[\"Enter numbers\",[\"a\",\"b\"]]\nops=[\"+\", \"-\", \"*\", \"\/\", \"div\" ,\"mod\" ,\"^\"]\nfor op = ops\n{\n   str = \"$a $op $b\"\n   println[\"$str = \" + eval[str]]\n}\n<\/lang>\n\nOutput is:\n<lang frink>\n10 + 20 = 30\n10 - 20 = -10\n10 * 20 = 200\n10 \/ 20 = 1\/2 (exactly 0.5)\n10 div 20 = 0\n10 mod 20 = 10\n10 ^ 20 = 100000000000000000000\n<\/lang>\n\n==[[:Category:GAP|GAP]][[Category:GAP]]==\n<lang gap>run := function()\n  local a, b, f;\n  f := InputTextUser();\n  Print(\"a =\\n\");\n  a := Int(Chomp(ReadLine(f)));\n  Print(\"b =\\n\");\n  b := Int(Chomp(ReadLine(f)));\n  Display(Concatenation(String(a), \" + \", String(b), \" = \", String(a + b)));\n  Display(Concatenation(String(a), \" - \", String(b), \" = \", String(a - b)));\n  Display(Concatenation(String(a), \" * \", String(b), \" = \", String(a * b)));\n  Display(Concatenation(String(a), \" \/ \", String(b), \" = \", String(QuoInt(a, b)))); # toward 0\n  Display(Concatenation(String(a), \" mod \", String(b), \" = \", String(RemInt(a, b)))); # nonnegative\n  Display(Concatenation(String(a), \" ^ \", String(b), \" = \", String(a ^ b)));\n  CloseStream(f);\nend;<\/lang>\n\n==[[:Category:Go|Go]][[Category:Go]]==\n<lang go>package main\n\nimport \"fmt\"\n\nfunc main() {\n    var a, b int\n    fmt.Print(\"enter two integers: \")\n    fmt.Scanln(&a, &b)\n    fmt.Printf(\"%d + %d = %d\\n\", a, b, a+b)\n    fmt.Printf(\"%d - %d = %d\\n\", a, b, a-b)\n    fmt.Printf(\"%d * %d = %d\\n\", a, b, a*b)\n    fmt.Printf(\"%d \/ %d = %d\\n\", a, b, a\/b)  \/\/ truncates towards 0\n    fmt.Printf(\"%d %% %d = %d\\n\", a, b, a%b) \/\/ same sign as first operand\n    \/\/ no exponentiation operator\n}<\/lang>\nExample run:\n<pre>\nenter two integers: -5 3\n-5 + 3 = -2\n-5 - 3 = -8\n-5 * 3 = -15\n-5 \/ 3 = -1\n-5 % 3 = -2\n<\/pre>\n\n==[[:Category:Groovy|Groovy]][[Category:Groovy]]==\n<lang groovy>def arithmetic = { a, b ->\n    println \"\"\"\n       a + b =        ${a} + ${b} = ${a + b}\n       a - b =        ${a} - ${b} = ${a - b}\n       a * b =        ${a} * ${b} = ${a * b}\n       a \/ b =        ${a} \/ ${b} = ${a \/ b}   !!! Converts to floating point!\n(int)(a \/ b) = (int)(${a} \/ ${b}) = ${(int)(a \/ b)}              !!! Truncates downward after the fact\n a.intdiv(b) =  ${a}.intdiv(${b}) = ${a.intdiv(b)}              !!! Behaves as if truncating downward, actual implementation varies\n       a % b =        ${a} % ${b} = ${a % b}\n\nExponentiation is also a base arithmetic operation in Groovy, so:\n      a ** b =       ${a} ** ${b} = ${a ** b}\n\"\"\"\n}<\/lang>\n\nProgram:\n<lang groovy>arithmetic(5,3)<\/lang>\n\nOutput:\n<pre>       a + b =        5 + 3 = 8\n       a - b =        5 - 3 = 2\n       a * b =        5 * 3 = 15\n       a \/ b =        5 \/ 3 = 1.6666666667   !!! Converts to floating point!\n(int)(a \/ b) = (int)(5 \/ 3) = 1              !!! Truncates downward after the fact\n a.intdiv(b) =  5.intdiv(3) = 1              !!! Behaves as if truncating downward, actual implementation varies\n       a % b =        5 % 3 = 2\n\nExponentiation is also a base arithmetic operation in Groovy, so:\n      a ** b =       5 ** 3 = 125<\/pre>\n\n==[[:Category:Haskell|Haskell]][[Category:Haskell]]==\n\n<lang haskell>main = do\n  a <- readLn :: IO Integer\n  b <- readLn :: IO Integer\n  putStrLn $ \"a + b = \" ++ show (a + b)\n  putStrLn $ \"a - b = \" ++ show (a - b)\n  putStrLn $ \"a * b = \" ++ show (a * b)\n  putStrLn $ \"a to the power of b = \" ++ show (a ** b)\n  putStrLn $ \"a to the power of b = \" ++ show (a ^ b)\n  putStrLn $ \"a to the power of b = \" ++ show (a ^^ b)\n  putStrLn $ \"a `div` b = \"  ++ show (a `div` b)  -- truncates towards negative infinity\n  putStrLn $ \"a `mod` b = \"  ++ show (a `mod` b)  -- same sign as second operand\n  putStrLn $ \"a `divMod` b = \"  ++ show (a `divMod` b)\n  putStrLn $ \"a `quot` b = \" ++ show (a `quot` b) -- truncates towards 0\n  putStrLn $ \"a `rem` b = \"  ++ show (a `rem` b)  -- same sign as first operand\n  putStrLn $ \"a `quotRem` b = \"  ++ show (a `quotRem` b)<\/lang>\n\n==[[:Category:haXe|haXe]][[Category:haXe]]==\n\nCompile on Neko with\n<lang haxe>haxe -neko basic_integer_arithmetic.n -main BasicIntegerArithmetic<\/lang>\n\n<lang haxe>class BasicIntegerArithmetic {\n    public static function main() {\n        var args = neko.Sys.args();\n        if (args.length < 2)\n            neko.Sys.exit(0);\n        var a = Std.int(args[0]);\n        var b = Std.int(args[1]);\n        trace(\"a+b = \" + (a+b));\n        trace(\"a-b = \" + (a-b));\n        trace(\"a*b = \" + (a*b));\n        trace(\"a\/b = \" + (a\/b));\n        trace(\"a%b = \" + (a%b));\n    }\n}<\/lang>\n\n==[[:Category:HicEst|HicEst]][[Category:HicEst]]==\nAll numeric is 8-byte-float. Conversions are by INT, NINT, FLOOR, CEILING, or Formatted IO\n<lang hicest>DLG(Edit=A, Edit=B, TItle='Enter numeric A and B')\nWRITE(Name) A, B\nWRITE() '              A + B = ', A + B\nWRITE() '              A - B = ', A - B\nWRITE() '              A * B = ', A * B\nWRITE() '              A \/ B = ', A \/ B          ! no truncation\nWRITE() 'truncate      A \/ B = ', INT(A \/ B)     ! truncates towards 0\nWRITE() 'round next    A \/ B = ', NINT(A \/ B)    ! truncates towards next integer\nWRITE() 'round down    A \/ B = ', FLOOR(A \/ B)   ! truncates towards minus infinity\nWRITE() 'round up      A \/ B = ', CEILING(A \/ B) ! truncates towards plus infinity\nWRITE() 'remainder of  A \/ B = ', MOD(A, B)      ! same sign as A\nWRITE() 'A to the power of B = ', A ^ B\nWRITE() 'A to the power of B = ', A ** B<\/lang>\n<lang hicest>A=5; B=-4;\n              A + B = 1 \n              A - B = 9 \n              A * B = -20 \n              A \/ B = -1.25 \ntruncate      A \/ B = -1 \nround next    A \/ B = -1 \nround down    A \/ B = -2 \nround up      A \/ B = -1 \nremainder of  A \/ B = 1 \nA to the power of B = 16E-4 \nA to the power of B = 16E-4 <\/lang>\n\n==[[:Category:Icon|Icon]][[Category:Icon]] and [[:Category:Unicon|Unicon]][[Category:Unicon]]==\n<lang Icon>procedure main()\nwrites(\"Input 1st integer a := \")\na := integer(read())\nwrites(\"Input 2nd integer b := \")\nb := integer(read())\n\nwrite(\" a + b = \",a+b)\nwrite(\" a - b = \",a-b)\nwrite(\" a * b = \",a*b)\nwrite(\" a \/ b = \",a\/b, \" rounds toward 0\")\nwrite(\" a % b = \",a%b, \" remainder sign matches a\")\nwrite(\" a ^ b = \",a^b)\nend<\/lang>\n\n==[[:Category:Inform 7|Inform 7]][[Category:Inform 7]]==\n\n<lang inform7>Enter Two Numbers is a room.\n\nNumerically entering is an action applying to one number. Understand \"[number]\" as numerically entering.\n\nThe first number is a number that varies.\n\nAfter numerically entering for the first time:\n\tnow the first number is the number understood.\n\nAfter numerically entering for the second time:\n\tlet A be the first number;\n\tlet B be the number understood;\n\tsay \"[A] + [B] = [A + B].\"; [operator syntax]\n\tsay \"[A] - [B] = [A minus B].\"; [English syntax]\n\tlet P be given by P = A * B where P is a number; [inline equation]\n\tsay \"[A] * [B] = [P].\";\n\tlet Q be given by the Division Formula; [named equation]\n\tsay \"[A] \/ [B] = [Q].\";\n\tsay \"[A] mod [B] = [remainder after dividing A by B].\";\n\tend the story.\n\nEquation - Division Formula\n\tQ = A \/ B\nwhere Q is a number, A is a number, and B is a number.<\/lang>\n\nThis solution shows four syntaxes: mathematical operators, English operators, inline equations, and named equations. Division rounds toward zero, and the remainder has the same sign as the quotient.\n\n==[[:Category:J|J]][[Category:J]]==\n<lang j>calc =:    + , - , * , <.@% , |~ , ^<\/lang>\nThe function <code>calc<\/code> constructs a list of numeric results for this task.\n<lang j>   17 calc 3\n20 14 51 5 2 4913<\/lang>\n\nThe function <code>bia<\/code> assembles these results, textually:\n\n<lang j>labels  =: ];.2 'Sum: Difference: Product: Quotient: Remainder: Exponentiation: '\ncombine =: ,. \":@,.\nbia     =: labels combine calc\n\n   17 bia 3\nSum:              20\nDifference:       14\nProduct:          51\nQuotient:          5\nRemainder:         2\nExponentiation: 4913<\/lang>\n\n==[[:Category:Java|Java]][[Category:Java]]==\n<lang java>import java.util.Scanner;\npublic class Int{\n  public static void main(String[] args){\n    Scanner sc = new Scanner(System.in);\n    int a = sc.nextInt();\n    int b = sc.nextInt();\n  \n    int sum = a + b;\/\/integer addition is discouraged in print statements due to confusion with String concatenation\n    System.out.println(\"a + b = \" + sum);\n    System.out.println(\"a - b = \" + (a - b));\n    System.out.println(\"a * b = \" + (a * b));\n    System.out.println(\"quotient of a \/ b = \" + (a \/ b)); \/\/ truncates towards 0\n    System.out.println(\"remainder of a \/ b = \" + (a % b)); \/\/ same sign as first operand\n  }\n}<\/lang>\n\n==[[:Category:JavaScript|JavaScript]][[Category:JavaScript]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[JScript]][[SMW::on]]<\/div>\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[SpiderMonkey]][[SMW::on]]<\/div>\nNote that the operators work the same in all versions of JavaScript; the requirement for specific implementations is in order to get user input.\n<lang javascript>var a = parseInt(get_input(\"Enter an integer\"), 10);\nvar b = parseInt(get_input(\"Enter an integer\"), 10);\n\nWScript.Echo(\"a = \" + a);\nWScript.Echo(\"b = \" + b);\nWScript.Echo(\"sum: a + b = \"        + (a + b));\nWScript.Echo(\"difference: a - b = \" + (a - b));\nWScript.Echo(\"product: a * b = \"    + (a * b));\nWScript.Echo(\"quotient: a \/ b = \"   + (a \/ b | 0)); \/\/ \"| 0\" casts it to an integer\nWScript.Echo(\"remainder: a % b = \"  + (a % b));\n\nfunction get_input(prompt) {\n    output(prompt);\n    try {\n        return WScript.StdIn.readLine();\n    } catch(e) {\n        return readline();\n    }\n}\nfunction output(prompt) {\n    try {\n        WScript.Echo(prompt);\n    } catch(e) {\n        print(prompt);\n    }\n}<\/lang>\noutput:\n<pre>Enter an integer\n-147\nEnter an integer\n63\na = -147\nb = 63\nsum: a + b = -84\ndifference: a - b = -210\nproduct: a * b = -9261\nquotient: a \/ b = -2\nremainder: a % b = -21<\/pre>\n\n==[[:Category:LabVIEW|LabVIEW]][[Category:LabVIEW]]==\nThis image is a [http:\/\/zone.ni.com\/devzone\/cda\/tut\/p\/id\/9330 VI Snippet], an executable image of [[LabVIEW]] code. The LabVIEW version is shown on the top-right hand corner. You can download it, then drag-and-drop it onto the LabVIEW block diagram from a file browser, and it will appear as runnable, editable code.<br\/>\n[[File:LabVIEW_Arithmetic_Integer.png]]\n==[[:Category:Liberty BASIC|Liberty BASIC]][[Category:Liberty BASIC]]==\nNote that raising to a power can display very large integers without going to approximate power-of-ten notation.\n<lang lb>\ninput \"Enter the first integer:  \"; first\ninput \"Enter the second integer: \"; second\n\nprint \"The sum is \" ; first + second\nprint \"The difference is \" ; first -second\nprint \"The product is \" ; first *second\nif second <>0 then print \"The integer quotient is \" ; int( first \/second); \" (rounds towards 0)\" else print \"Division by zero unallowed.\"\nprint \"The remainder is \" ; first MOD second; \" (sign matches first operand)\"\nprint \"The first raised to the power of the second is \" ; first ^second\n<\/lang>\n\n==[[:Category:Logo|Logo]][[Category:Logo]]==\n<lang logo>to operate :a :b\n  (print [a =] :a)\n  (print [b =] :b)\n  (print [a + b =] :a + :b)\n  (print [a - b =] :a - :b)\n  (print [a * b =] :a * :b)\n  (print [a \/ b =] int :a \/ :b)\n  (print [a mod b =] modulo :a :b)\nend<\/lang>\n\nEach infix operator also has a prefix synonym (sum, difference, product, quotient). Sum and product can also have arity greater than two when used in parentheses (sum 1 2 3). Infix operators in general have high precedence; you may need to enclose their arguments in parentheses to obtain the correct expression.\n\n==[[:Category:LSE64|LSE64]][[Category:LSE64]]==\n<lang lse64>over : 2 pick\n2dup : over over\n\narithmetic : \\\n  \" A=\" ,t over , sp \" B=\" ,t dup , nl \\\n  \" A+B=\" ,t 2dup + , nl \\\n  \" A-B=\" ,t 2dup - , nl \\\n  \" A*B=\" ,t 2dup * , nl \\\n  \" A\/B=\" ,t 2dup \/ , nl \\\n  \" A%B=\" ,t      % , nl<\/lang>\n\n==[[:Category:Lua|Lua]][[Category:Lua]]==\n<lang lua>local x = io.read()\nlocal y = io.read()\n\nprint (\"Sum: \"       , (x + y))\nprint (\"Difference: \", (x - y))\nprint (\"Product: \"   , (x * y))\nprint (\"Quotient: \"  , (x \/ y)) -- Does not truncate\nprint (\"Remainder: \" , (x % y)) -- Result has sign of right operand\nprint (\"Exponent: \"  , (x ^ y))<\/lang>\n\n==[[:Category:M4|M4]][[Category:M4]]==\n\nBecause of the particular nature of M4, the only user-input is the code itself. Anyway the following code can be used:\n<lang m4>eval(A+B)\neval(A-B)\neval(A*B)\neval(A\/B)\neval(A%B)<\/lang>\n\nonce saved in a file, e.g. <tt>operations.m4<\/tt>:\n\n<pre>m4 -DA=4 -DB=6 operations.m4<\/pre>\n\nor using a sort of ''driver'':\n\n<lang m4>define(`A', 4)dnl\ndefine(`B', 6)dnl\ninclude(`operations.m4')<\/lang>\n\n==[[:Category:Mathematica|Mathematica]][[Category:Mathematica]]==\nMathematica has all the function built-in to handle this task. Example:\n<lang Mathematica>a = Input[\"Give me an integer please!\"];\nb = Input[\"Give me another integer please!\"];\nPrint[\"You gave me \", a, \" and \", b];\nPrint[\"sum: \", a + b];\nPrint[\"difference: \", a - b];\nPrint[\"product: \", a b];\nPrint[\"integer quotient: \", IntegerPart[a\/b]];\nPrint[\"remainder: \", Mod[a, b]];\nPrint[\"exponentiation: \", a^b];<\/lang>\ngives back for input 17 and 3:\n<preMathematica>You gave me 17 and 3\nsum: 20\ndifference: 14\nproduct: 51\ninteger quotient: 5\nremainder: 2\nexponentiation: 4913<\/pre>\n\n==[[:Category:MATLAB|MATLAB]][[Category:MATLAB]] \/ [[:Category:Octave|Octave]][[Category:Octave]]==\n<lang octave>disp(\"integer a: \"); a = scanf(\"%d\", 1);\ndisp(\"integer b: \"); b = scanf(\"%d\", 1);\na+b\na-b\na*b\nfloor(a\/b)\nmod(a,b)\na^b<\/lang>\n\n==[[:Category:MAXScript|MAXScript]][[Category:MAXScript]]==\n<lang maxscript>x = getKBValue prompt:\"First number\"\ny = getKBValue prompt:\"Second number:\"\n\nformat \"Sum: %\\n\" (x + y) \nformat \"Difference: %\\n\" (x - y) \nformat \"Product: %\\n\" (x * y) \nformat \"Quotient: %\\n\" (x \/ y) \nformat \"Remainder: %\\n\" (mod x y)<\/lang>\n\n==[[:Category:Mercury|Mercury]][[Category:Mercury]]==\n<lang>\n:- module arith_int.\n:- interface.\n\n:- import_module io.\n:- pred main(io::di, io::uo) is det.\n\n:- implementation.\n:- import_module int, list, string.\n\nmain(!IO) :-\n    io.command_line_arguments(Args, !IO),\n    ( if\n        Args = [AStr, BStr],\n        string.to_int(AStr, A),\n        string.to_int(BStr, B)\n      then\n        io.format(\"A + B = %d\\n\", [i(A + B)], !IO),\n        io.format(\"A - B = %d\\n\", [i(A - B)], !IO),\n        io.format(\"A * B = %d\\n\", [i(A * B)], !IO),\n\n        % Division: round towards zero.\n        %\n        io.format(\"A \/ B = %d\\n\", [i(A \/ B)], !IO),\n\n        % Division: round towards minus infinity.\n        %\n        io.format(\"A div B = %d\\n\", [i(A div B)], !IO), \n    \n        % Modulus: X mod Y = X - (X div Y) * Y.\n        %\n        io.format(\"A mod B = %d\\n\", [i(A mod B)], !IO),\n\n        % Remainder: X rem Y = X - (X \/ Y) * Y.\n        %\n        io.format(\"A rem B = %d\\n\", [i(A rem B)], !IO),\n\n        % Exponentiation is done using the function int.pow\/2.\n        %\n        io.format(\"A `pow` B = %d\\n\", [i(A `pow` B)], !IO)\n      else\n        io.set_exit_status(1, !IO)\n    ).\n<\/lang>\n\n==[[:Category:Metafont|Metafont]][[Category:Metafont]]==\n\n<lang metafont>string s[];\nmessage \"input number a: \";\ns1 := readstring;\nmessage \"input number b: \";\ns2 := readstring;\na := scantokens s1;\nb := scantokens s2;\n\ndef outp(expr op) =\n  message \"a \" & op & \" b = \" & decimal(a scantokens(op) b) enddef;\n\noutp(\"+\");\noutp(\"-\");\noutp(\"*\");\noutp(\"div\");\noutp(\"mod\");\n\nend<\/lang>\n\n==[[:Category:ML\/I|ML\/I]][[Category:ML\/I]]==\nML\/I will read two integers from 'standard input' or similar, and then output the results to 'standard output' or similar.\n\n<lang ML\/I>MCSKIP \"WITH\" NL\n\"\" Arithmetic\/Integer\n\"\" assumes macros on input stream 1, terminal on stream 2\nMCSKIP MT,<>\nMCINS %.\nMCDEF SL SPACES NL AS <MCSET T1=%A1.\nMCSET T2=%A2.\na + b   = %%T1.+%T2..\na - b   = %%T1.-%T2..\na * b   = %%T1.*%T2..\na \/ b   = %%T1.\/%T2..\na rem b = %%T1.-%%%T1.\/%T2..*%T2...\nDivision is truncated to the greatest integer\nthat does not exceed the exact result. Remainder matches\nthe sign of the second operand, if the signs differ.<\/lang>\n\n==[[:Category:Modula-2|Modula-2]][[Category:Modula-2]]==\n<lang modula2>MODULE ints;\n\nIMPORT  InOut;\n\nVAR     a, b    : INTEGER;\n\nBEGIN\n  InOut.WriteString (\"Enter two integer numbers : \");   InOut.WriteBf;\n  InOut.ReadInt (a);\n  InOut.ReadInt (b);\n  InOut.WriteString (\"a + b   = \");  InOut.WriteInt (a + b, 9);    InOut.WriteLn;\n  InOut.WriteString (\"a - b   = \");  InOut.WriteInt (a - b, 9);    InOut.WriteLn;\n  InOut.WriteString (\"a * b   = \");  InOut.WriteInt (a * b, 9);    InOut.WriteLn;\n  InOut.WriteString (\"a \/ b   = \");  InOut.WriteInt (a DIV b, 9);  InOut.WriteLn;\n  InOut.WriteString (\"a MOD b = \");  InOut.WriteInt (a MOD b, 9);  InOut.WriteLn;\n  InOut.WriteLn;\nEND ints.<\/lang>Producing:<pre>$$ ints\nEnter two integer numbers : 12 7\na + b   =        19\na - b   =         5\na * b   =        84\na \/ b   =         1\na MOD b =         5\n\n$$ ints\nEnter two integer numbers : 123 -111\na + b   =        12\na - b   =       234\na * b   =    -13653\na \/ b   =        -1\na MOD b =        12<\/pre>\n\n==[[:Category:Modula-3|Modula-3]][[Category:Modula-3]]==\n<lang modula3>MODULE Arith EXPORTS Main;\n\nIMPORT IO, Fmt;\n\nVAR a, b: INTEGER;\n\nBEGIN\n  a := IO.GetInt();\n  b := IO.GetInt();\n  IO.Put(\"a+b = \" & Fmt.Int(a + b) & \"\\n\");\n  IO.Put(\"a-b = \" & Fmt.Int(a - b) & \"\\n\");\n  IO.Put(\"a*b = \" & Fmt.Int(a * b) & \"\\n\");\n  IO.Put(\"a DIV b = \" & Fmt.Int(a DIV b) & \"\\n\");\n  IO.Put(\"a MOD b = \" & Fmt.Int(a MOD b) & \"\\n\");\nEND Arith.<\/lang>\n\n==[[:Category:MUMPS|MUMPS]][[Category:MUMPS]]==\n<p>Note: M[UMPS] has an operator called \"modulo\".\nWhen both operands are positive numbers, \"modulo\" has a result that looks a lot like \"remainder\";\nhowever, there is an important difference.<\/p>\n\n<p>To better understand the intricacies of \"modulo\" and how it is\ndifferent from \"remainder\", see Donald Knuth's definition (Volume 1 of the \"big books\"), or\nfind out the beauty of cyclic algebra as formulated by Niels Henrik Abel (August 5, 1802 \u2013 April 6, 1829).<\/p>\n\n<lang MUMPS>Arith(first,second)\t; Mathematical operators\n\tWrite \"Plus\",?12,first,\"+\",second,?25,\" = \",first+second,!\n\tWrite \"Minus\",?12,first,\"-\",second,?25,\" = \",first-second,!\n\tWrite \"Multiply\",?12,first,\"*\",second,?25,\" = \",first*second,!\n\tWrite \"Divide\",?12,first,\"\/\",second,?25,\" = \",first\/second,!\n\tWrite \"Int Divide\",?12,first,\"\\\",second,?25,\" = \",first\\second,!\n\tWrite \"Power\",?12,first,\"**\",second,?25,\" = \",first**second,!\n\tWrite \"Modulo\",?12,first,\"#\",second,?25,\" = \",first#second,!\n\tWrite \"And\",?12,first,\"&\",second,?25,\" = \",first&second,!\n\tWrite \"Or\",?12,first,\"!\",second,?25,\" = \",first!second,!\n\tQuit\n\nDo Arith(2,3)\nPlus        2+3           = 5\nMinus       2-3           = -1\nMultiply    2*3           = 6\nDivide      2\/3           = .6666666666666666667\nInt Divide  2\\3           = 0\nPower       2**3          = 8\nModulo      2#3           = 2\nAnd         2&3           = 1\nOr          2!3           = 1\n \nDo Arith(16,0.5)\nPlus        16+.5         = 16.5\nMinus       16-.5         = 15.5\nMultiply    16*.5         = 8\nDivide      16\/.5         = 32\nInt Divide  16\\.5         = 32\nPower       16**.5        = 4\nModulo      16#.5         = 0\nAnd         16&.5         = 1\nOr          16!.5         = 1\n \nDo Arith(0,2)\nPlus        0+2           = 2\nMinus       0-2           = -2\nMultiply    0*2           = 0\nDivide      0\/2           = 0\nInt Divide  0\\2           = 0\nPower       0**2          = 0\nModulo      0#2           = 0\nAnd         0&2           = 0\nOr          0!2           = 1<\/lang>\n\n\n==[[:Category:Nemerle|Nemerle]][[Category:Nemerle]]==\nAdapted nearly verbatim from C# solution above. Note that I've used the exponentiation operator (**), but Math.Pow() as used in the C# solution would also work.\n<lang Nemerle>using System;\n \nclass Program\n{\n    static Main(args : array[string]) : void\n    {\n        def a = Convert.ToInt32(args[0]);\n        def b = Convert.ToInt32(args[1]);\n \n        Console.WriteLine(\"{0} + {1} = {2}\", a, b, a + b);\n        Console.WriteLine(\"{0} - {1} = {2}\", a, b, a - b);\n        Console.WriteLine(\"{0} * {1} = {2}\", a, b, a * b);\n        Console.WriteLine(\"{0} \/ {1} = {2}\", a, b, a \/ b); \/\/ truncates towards 0\n        Console.WriteLine(\"{0} % {1} = {2}\", a, b, a % b); \/\/ matches sign of first operand\n        Console.WriteLine(\"{0} ** {1} = {2}\", a, b, a ** b);\n    }\n}<\/lang>\n\n==[[:Category:NetRexx|NetRexx]][[Category:NetRexx]]==\n<div class=\"examplemeta translation\">'''Translation of''': [[Arithmetic\/Integer#REXX|REXX]]<\/div>\n<lang NetRexx>\/* NetRexx *\/\n\noptions replace format comments java crossref savelog symbols binary\n\nsay \"enter 2 integer values separated by blanks\"\nparse ask a b\nsay a \"+\" b \"=\" a + b\nsay a \"-\" b \"=\" a - b\nsay a \"*\" b \"=\" a * b\nsay a \"\/\" b \"=\" a % b \"remaining\" a \/\/ b \"(sign from first operand)\"\nsay a \"^\" b \"=\" a ** b\n\nreturn\n<\/lang>\n;Output\n<pre style=\"height: 15ex; overflow:scroll;\">\nenter 2 integer values separated by blanks\n17 -4\n17 + -4 = 13\n17 - -4 = 21\n17 * -4 = -68\n17 \/ -4 = -4 remaining 1 (sign from first operand)\n17 ^ -4 = 0.0000119730367\n<\/pre>\n\n==[[:Category:NewLISP|NewLISP]][[Category:NewLISP]]==\n\n<lang NewLISP>; integer.lsp\n; oofoe 2012-01-17\n\n(define (aski msg) (print msg) (int (read-line)))\n(setq x (aski \"Please type in an integer and press [enter]: \"))\n(setq y (aski \"Please type in another integer             : \"))\n\n; Note that +, -, *, \/ and % are all integer operations.\n(println)\n(println \"Sum: \" (+ x y))\n(println \"Difference: \" (- x y))\n(println \"Product: \" (* x y))\n(println \"Integer quotient (rounds to 0): \" (\/ x y))\n(println \"Remainder: \" (setq r (% x y)))\n\n(println \"Remainder sign matches: \"\n\t (cond ((= (sgn r) (sgn x) (sgn y)) \"both\")\n\t       ((= (sgn r) (sgn x))         \"first\")\n\t       ((= (sgn r) (sgn y))         \"second\")))\n\t \n(println)\n(println \"Exponentiation: \" (pow x y))\n\n(exit) ; NewLisp normally goes to listener after running script.\n<\/lang>\n\nSample output:\n\n<pre>\nPlease type in an integer and press [enter]: 17\nPlease type in another integer             : -4\n\nSum: 13\nDifference: 21\nProduct: -68\nInteger quotient (rounds to 0): -4\nRemainder: 1\nRemainder sign matches: first\n\nExponentiation: 1.197303672e-005\n<\/pre>\n\n==[[:Category:NSIS|NSIS]][[Category:NSIS]]==\nAll Arithmetic in NSIS is handled by the [http:\/\/nsis.sourceforge.net\/Docs\/Chapter4.html#4.9.10.2 IntOp] instruction.  It is beyond the scope of this task to implement user input (a fairly involved task), so I will be providing hard-coded values simulating the user input, with the intention of later adding the user-input piece.\n<lang nsis>Function Arithmetic\n\tPush $0\n\tPush $1\n\tPush $2\n\tStrCpy $0 21\n\tStrCpy $1 -2\n\t\n\tIntOp $2 $0 + $1\n\tDetailPrint \"$0 + $1 = $2\"\n\tIntOp $2 $0 - $1\n\tDetailPrint \"$0 - $1 = $2\"\n\tIntOp $2 $0 * $1\n\tDetailPrint \"$0 * $1 = $2\"\n\tIntOp $2 $0 \/ $1\n\tDetailPrint \"$0 \/ $1 = $2\"\n\tDetailPrint \"Rounding is toward negative infinity\"\n\tIntOp $2 $0 % $1\n\tDetailPrint \"$0 % $1 = $2\"\n\tDetailPrint \"Sign of remainder matches the first number\"\n\t\n\tPop $2\n\tPop $1\n\tPop $0\nFunctionEnd<\/lang>\n\n==[[:Category:Objeck|Objeck]][[Category:Objeck]]==\n<lang objeck>bundle Default {\n  class Arithmetic {\n    function : Main(args : System.String[]) ~ Nil {\n      DoArithmetic();\n    }\n\t\n    function : native : DoArithmetic() ~ Nil {\n      a := IO.Console->GetInstance()->ReadString()->ToInt();\n      b := IO.Console->GetInstance()->ReadString()->ToInt();\n  \n      IO.Console->GetInstance()->Print(\"a+b = \")->PrintLine(a+b);\n      IO.Console->GetInstance()->Print(\"a-b = \")->PrintLine(a-b);\n      IO.Console->GetInstance()->Print(\"a*b = \")->PrintLine(a*b);\n      IO.Console->GetInstance()->Print(\"a\/b = \")->PrintLine(a\/b);\n    }\n  }\n}<\/lang>\n\n==[[:Category:OCaml|OCaml]][[Category:OCaml]]==\n<lang ocaml>let _ =\n  let a = read_int ()\n  and b = read_int () in\n\n  Printf.printf \"a + b = %d\\n\" (a + b);\n  Printf.printf \"a - b = %d\\n\" (a - b);\n  Printf.printf \"a * b = %d\\n\" (a * b);\n  Printf.printf \"a \/ b = %d\\n\" (a \/ b);    (* truncates towards 0 *)\n  Printf.printf \"a mod b = %d\\n\" (a mod b) (* same sign as first operand *)<\/lang>\n\n==[[:Category:Openscad|Openscad]][[Category:Openscad]]==\n\n<lang openscad>echo (a+b);  \/* Sum *\/\necho (a-b);  \/* Difference *\/\necho (a*b);  \/* Product *\/\necho (a\/b);  \/* Quotient *\/\necho (a%b);  \/* Modulus *\/<\/lang>\n\n==[[:Category:Oz|Oz]][[Category:Oz]]==\n<lang oz>declare\n  StdIn = {New class $ from Open.file Open.text end init(name:stdin)}\n\n  fun {ReadInt}\n     {String.toInt {StdIn getS($)}}\n  end\n\n  A = {ReadInt}\n  B = {ReadInt}\nin\n  {ForAll\n   [\"A+B = \"#A+B\n    \"A-B = \"#A-B\n    \"A*B = \"#A*B\n    \"A\/B = \"#A div B  %% truncates towards 0\n    \"remainder \"#A mod B  %% has the same sign as A\n    \"A^B = \"#{Pow A B}\n   ]\n   System.showInfo}<\/lang>\n\n==[[:Category:PARI\/GP|PARI\/GP]][[Category:PARI\/GP]]==\nInteger division with <code>\\<\/code> rounds to <math>-\\infty<\/math>. There also exists the <code>\\\/<\/code> round-to-nearest (ties to <math>+\\infty<\/math>) operator.  Ordinary division <code>\/<\/code> does not round but returns rationals if given integers with a non-integral quotient.\n<lang parigp>arith(a,b)={\n  print(a+b);\n  print(a-b);\n  print(a*b);\n  print(a\\b);\n  print(a%b);\n  print(a^b);\n};<\/lang>\n\n==[[:Category:Pascal|Pascal]][[Category:Pascal]]==\n<lang pascal>program arithmetic(input, output)\n\nvar\n a, b: integer;\n\nbegin\n readln(a, b);\n writeln('a+b = ', a+b);\n writeln('a-b = ', a-b);\n writeln('a*b = ', a*b);\n writeln('a\/b = ', a div b, ', remainder ', a mod b);\nend.<\/lang>\n\n==[[:Category:Perl|Perl]][[Category:Perl]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Perl]] version 5.x[[SMW::on]]<\/div>\n<lang perl>my $a = <>;\nmy $b = <>;\n\nprint\n    \"sum:              \", $a + $b, \"\\n\",\n    \"difference:       \", $a - $b, \"\\n\",\n    \"product:          \", $a * $b, \"\\n\",\n    \"integer quotient: \", int($a \/ $b), \"\\n\",\n    \"remainder:        \", $a % $b, \"\\n\",\n    \"exponent:         \", $a ** $b, \"\\n\"\n    ;<\/lang>\n\n==[[:Category:Perl 6|Perl 6]][[Category:Perl 6]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Rakudo]] version #21 \"Seattle\"[[SMW::on]]<\/div>\n<lang perl6>my Int $a = floor $*IN.get;\nmy Int $b = floor $*IN.get;\n\nsay 'sum:              ', $a + $b;\nsay 'difference:       ', $a - $b;\nsay 'product:          ', $a * $b;\nsay 'integer quotient: ', $a div $b;\nsay 'remainder:        ', $a % $b;\nsay 'exponentiation:   ', $a**$b;<\/lang>\n\nNote that <code>div<\/code> doesn't always do integer division; it performs the operation \"most appropriate to the\noperand types\". [http:\/\/perlcabal.org\/syn\/S03.html#line_729 Synopsis 3] guarantees that <code>div<\/code> \"on built-in integer types is equivalent to taking the floor of a real division\". If you want integer division with other types, say <code>floor($a\/$b)<\/code>.\n\n==[[:Category:PHP|PHP]][[Category:PHP]]==\n<lang php><?php\n$a = fgets(STDIN);\n$b = fgets(STDIN);\n\necho\n    \"sum:                 \", $a + $b, \"\\n\",\n    \"difference:          \", $a - $b, \"\\n\",\n    \"product:             \", $a * $b, \"\\n\",\n    \"truncating quotient: \", (int)($a \/ $b), \"\\n\",\n    \"flooring quotient:   \", floor($a \/ $b), \"\\n\",\n    \"remainder:           \", $a % $b, \"\\n\";\n?><\/lang>\n\n==[[:Category:PicoLisp|PicoLisp]][[Category:PicoLisp]]==\n<lang PicoLisp>(de math (A B)\n   (prinl \"Add      \" (+ A B))\n   (prinl \"Subtract \" (- A B))\n   (prinl \"Multiply \" (* A B))\n   (prinl \"Divide   \" (\/ A B))        # Trucates towards zero\n   (prinl \"Div\/rnd  \" (*\/ A B))       # Rounds to next integer\n   (prinl \"Modulus  \" (% A B))        # Sign of the first operand\n   (prinl \"Power    \" (** A B)) )<\/lang>\n==[[:Category:Piet|Piet]][[Category:Piet]]==\n[[File:PietArithmaticInteger.png]]<br>\n <code>\n command   stack\n in(int)   A\n duplicate AA\n duplicate AAA\n duplicate AAAA\n duplicate AAAAA\n in(int)   BAAAAA\n duplicate BBAAAAA\n duplicate BBBAAAAA\n duplicate BBBBAAAAA\n duplicate BBBBBAAAAA\n push 9    9BBBBBAAAAA\n push 1    19BBBBBAAAAA\n roll      BBBBAAAABA\n push 7    7BBBBAAAABA\n push 1    17BBBBAAAABA\n roll      BBBAAABABA\n push 5    5BBBAAABABA\n push 1    15BBBAAABABA\n roll      BBAABABABA\n push 3    3BBAABABABA\n push 1    13BBAABABABA\n roll      BABABABABA\n add       (A+B)BABABABA\n out(int)  BABABABA\n sub       (A-B)BABABA\n out(int)  BABABA\n mult      (A*B)BABA\n out(int)  BABA\n divide    (A\/B)BA\n out(int)  BA\n mod       (A%B)\n out(int)  NULL\n push 1    1\n exit<\/code>\nHow rounding is handled is up to the interpreter, but I believe the intent was round towards 0.\n\n==[[:Category:PL\/I|PL\/I]][[Category:PL\/I]]==\n<lang PL\/I>\nget list (a, b);\nput skip list (a+b);\nput skip list (a-b);\nput skip list (a*b);\nput skip list (trunc(a\/b));\nput skip list (mod(a, b));\nput skip list (rem(a, b));\n<\/lang>\n\n==[[:Category:Pop11|Pop11]][[Category:Pop11]]==\n\n<lang pop11>;;; Setup token reader\nvars itemrep;\nincharitem(charin) -> itemrep;\n;;; read the numbers\nlvars a = itemrep(), b = itemrep();\n;;; Print results\nprintf(a + b, 'a + b = %p\\n');\nprintf(a - b, 'a - b = %p\\n');\nprintf(a * b, 'a * b = %p\\n');\nprintf(a div b, 'a div b = %p\\n');\nprintf(a mod b, 'a mod b = %p\\n');<\/lang>\n\n==[[:Category:PostScript|PostScript]][[Category:PostScript]]==\n<lang ps>\/arithInteger {\n   \/x exch def\n   \/y exch def\n   x y add =\n   x y sub =\n   x y mul =\n   x y idiv =\n   x y mod =\n   x y exp =\n} def<\/lang>\n==[[:Category:PowerShell|PowerShell]][[Category:PowerShell]]==\n<lang powershell>$a = [int] (Read-Host First Number)\n$b = [int] (Read-Host Second Number)\n\nWrite-Host \"Sum:                              $($a + $b)\"\nWrite-Host \"Difference:                       $($a - $b)\"\nWrite-Host \"Product:                          $($a * $b)\"\nWrite-Host \"Quotient:                         $($a \/ $b)\"\nWrite-Host \"Quotient, round to even:          $([Math]::Round($a \/ $b))\"\nWrite-Host \"Remainder, sign follows first:    $($a % $b)\"<\/lang>\nNumbers are automatically converted to accomodate for the result. This means not only that Int32 will be expanded to Int64 but also that a non-integer quotient will cause the result to be of a floating-point type.\n\nThe remainder has the sign of the first operand.\n\nNo exponentiation operator exists, but can be worked around with the .NET BCL:\n<lang powershell>[Math]::Pow($a, $b)<\/lang>\n==[[:Category:ProDOS|ProDOS]][[Category:ProDOS]]==\n<lang ProDOS>IGNORELINE Note: This example includes the math module.\ninclude arithmeticmodule\n:a\neditvar \/newvar \/value=a \/title=Enter first integer: \neditvar \/newvar \/value=b \/title=Enter second integer:\neditvar \/newvar \/value=c \ndo add -a-,-b-=-c-\nprintline -c-\ndo subtract a,b\nprintline -c-\ndo multiply a,b\nprintline -c-\ndo divide a,b\nprintline -c-\ndo modulus a,b\nprintline -c-\neditvar \/newvar \/value=d \/title=Do you want to calculate more numbers?\nif -d- \/hasvalue yes goto :a else goto :end\n:end<\/lang>\n\n<lang ProDOS>IGNORELINE Note: This example does not use the math module.\n:a\neditvar \/newvar \/value=a \/title=Enter first integer: \neditvar \/newvar \/value=b \/title=Enter second integer:\neditvar \/newvar \/value=-a-+-b-=-c-\nprintline -c-\neditvar \/newvar \/value=a*b=c\nprintline -c-\neditvar \/newvar \/value=a\/b=c\nprintline -c-\neditvar \/newvar \/value=a %% b=c\nprintline -c-\neditvar \/newvar \/value=d \/title=Do you want to calculate more numbers?\nif -d- \/hasvalue yes goto :a else goto :end\n:end<\/lang>\n\n==[[:Category:PureBasic|PureBasic]][[Category:PureBasic]]==\n<lang purebasic>OpenConsole()\n \nDefine a, b\n\nPrint(\"Number 1: \"): a = Val(Input())\nPrint(\"Number 2: \"): b = Val(Input())\n\nPrintN(\"Sum:        \" + Str(a + b))\nPrintN(\"Difference: \" + Str(a - b))\nPrintN(\"Product:    \" + Str(a * b))\nPrintN(\"Quotient:   \" + Str(a \/ b)) ; Integer division (rounding mode=truncate)\nPrintN(\"Remainder: \" + Str(a % b))\nPrintN(\"Power:      \" + Str(Pow(a, b)))\n \nInput()\n \nCloseConsole()<\/lang>\n\n==[[:Category:Python|Python]][[Category:Python]]==\n\n<lang python>x = int(raw_input(\"Number 1: \"))\ny = int(raw_input(\"Number 2: \"))\n\nprint \"Sum: %d\" % (x + y)\nprint \"Difference: %d\" % (x - y)\nprint \"Product: %d\" % (x * y)\nprint \"Quotient: %d\" % (x \/ y)     #  or x \/\/ y  for newer python versions.\n                                   # truncates towards negative infinity\nprint \"Remainder: %d\" % (x % y)    # same sign as second operand\nprint \"Quotient: %d with Remainder: %d\" % divmod(x, y)\nprint \"Power: %d\" % x**y\n\n## Only used to keep the display up when the program ends\nraw_input( )<\/lang>\n\nNotes: In Python3 ''raw_input()'' will be renamed to ''input()'' (the old ''input()'' built-in will go away, though one could use ''eval(input())'' to emulate the old ... and ill-advised ... behavior).  Also a better program would wrap the attempted ''int()'' conversions in a ''try: ... except ValueError:...'' construct such as:\n\n<lang python>def getnum(prompt):\n    while True: # retrying ...\n        try:\n            n = int(raw_input(prompt))\n        except ValueError:\n            print \"Input could not be parsed as an integer. Please try again.\"\\\n            continue\n        break\n    return n\n\nx = getnum(\"Number1: \")\ny = getnum(\"Number2: \")\n...<\/lang>\n\n(In general it's good practice to perform parsing of all input in exception handling blocks.  This is especially true of interactive user input, but also applies to data read from configuration and other files, and marshaled from other processes via any IPC mechanism).\n\nPython also has the procedure ''divmod'' that returns both quotient and remainder. eg\n quotient, remainder = divmod(355,113)\nGiving a quotient of 3, and a remainder of 16. \n\n=== Python 3.0 compatible code ===\n<lang python>def arithmetic(x, y):\n    for op in \"+ - * \/\/ % **\".split():\n        expr = \"%(x)s %(op)s %(y)s\" % vars()\n        print(\"%s\\t=> %s\" % (expr, eval(expr)))\n\n\narithmetic(12, 8)\narithmetic(input(\"Number 1: \"), input(\"Number 2: \"))<\/lang>\nOutput:\n<pre>12 + 8  => 20\n12 - 8  => 4\n12 * 8  => 96\n12 \/\/ 8 => 1\n12 % 8  => 4\n12 ** 8\t=> 429981696\nNumber 1: 20\nNumber 2: 4\n20 + 4  => 24\n20 - 4  => 16\n20 * 4  => 80\n20 \/\/ 4 => 5\n20 % 4  => 0\n20 ** 4 => 160000<\/pre>\n\n==[[:Category:R|R]][[Category:R]]==\n<lang R>cat(\"insert number \")\na <- scan(nmax=1, quiet=TRUE)\ncat(\"insert number \")\nb <- scan(nmax=1, quiet=TRUE)\nprint(paste('a+b=', a+b))\nprint(paste('a-b=', a-b))\nprint(paste('a*b=', a*b))\nprint(paste('a%\/%b=', a%\/%b))\nprint(paste('a%%b=', a%%b))\nprint(paste('a^b=', a^b))\n<\/lang>\n\n==[[:Category:Raven|Raven]][[Category:Raven]]==\n\n<lang raven>'  Number 1: ' print expect 0 prefer as x\n'  Number 2: ' print expect 0 prefer as y\n\nx y + \"       sum: %d\\n\" print\nx y - \"difference: %d\\n\" print\nx y * \"   product: %d\\n\" print\nx y \/ \"  quotient: %d\\n\" print\nx y % \" remainder: %d\\n\" print<\/lang>\n\n==[[:Category:REBOL|REBOL]][[Category:REBOL]]==\n<lang rebol>REBOL [\n\tTitle: \"Integer\"\n\tAuthor: oofoe\n\tDate: 2010-09-29\n\tURL: http:\/\/rosettacode.org\/wiki\/Arithmetic\/Integer\n]\n\nx: to-integer ask \"Please type in an integer, and press [enter]: \"\ny: to-integer ask \"Please enter another integer: \"\nprint \"\"\n\nprint [\"Sum:\"  x + y]\nprint [\"Difference:\"  x - y]\nprint [\"Product:\" x * y]\n\nprint [\"Integer quotient (coercion)                          :\"  to-integer x \/ y]\nprint [\"Integer quotient (away from zero)                    :\"  round x \/ y]\nprint [\"Integer quotient (halves round towards even digits)  :\"  round\/even x \/ y]\nprint [\"Integer quotient (halves round towards zero)         :\"  round\/half-down x \/ y]\nprint [\"Integer quotient (round in negative direction)       :\"  round\/floor x \/ y]\nprint [\"Integer quotient (round in positive direction)       :\"  round\/ceiling x \/ y]\nprint [\"Integer quotient (halves round in positive direction):\"  round\/half-ceiling x \/ y]\n\nprint [\"Remainder:\"  r: x \/\/ y]\n\n; REBOL evaluates infix expressions from left to right. There are no\n; precedence rules -- whatever is first gets evaluated. Therefore when\n; performing this comparison, I put parens around the first term\n; (\"sign? a\") of the expression so that the value of \/a\/ isn't\n; compared to the sign of \/b\/. To make up for it, notice that I don't\n; have to use a specific return keyword. The final value in the\n; function is returned automatically.\n\nmatch?: func [a b][(sign? a) = sign? b]\n\nresult: copy []\nif match? r x [append result \"first\"]\nif match? r y [append result \"second\"]\n\n; You can evaluate arbitrary expressions in the middle of a print, so\n; I use a \"switch\" to provide a more readable result based on the\n; length of the \/results\/ list.\n\nprint [\n\t\"Remainder sign matches:\" \n\tswitch length? result [\n\t\t0 [\"neither\"]\n\t\t1 [result\/1]\n\t\t2 [\"both\"]\n\t] \n]\n\nprint [\"Exponentiation:\" x ** y]<\/lang>\n\nSample output:\n\n<pre>Please type in an integer, and press [enter]: 17\nPlease enter another integer: -4\n\nSum: 13\nDifference: 21\nProduct: -68\nInteger quotient (coercion)                          : -4\nInteger quotient (away from zero)                    : -4\nInteger quotient (halves round towards even digits)  : -4\nInteger quotient (halves round towards zero)         : -4\nInteger quotient (round in negative direction)       : -5\nInteger quotient (round in positive direction)       : -4\nInteger quotient (halves round in positive direction): -4\nRemainder: 1\nRemainder sign matches: first\nExponentiation: 1.19730367213036E-5<\/pre>\n\n==[[:Category:Retro|Retro]][[Category:Retro]]==\nRetro's arithmetic functions are based on those in [[Forth]]. The example is an adaption of the one from Forth.\n \n<lang Retro>: arithmetic ( ab- )\n  over    \"\\na       = %d\" puts\n  dup     \"\\nb       = %d\" puts\n  2over + \"\\na + b   = %d\" puts\n  2over - \"\\na - b   = %d\" puts\n  2over * \"\\na * b   = %d\" puts\n  \/mod    \"\\na \/ b   = %d\" puts\n          \"\\na mod b = %d\\n\" puts ;<\/lang>\n\n==[[:Category:REXX|REXX]][[Category:REXX]]==\n<lang rexx>\/*REXX*\/\nsay \"enter 2 integer values separated by blanks\"\nparse pull a b\nsay a \"+\" b \"=\" a+b\nsay a \"-\" b \"=\" a-b\nsay a \"*\" b \"=\" a*b\nsay a \"\/\" b \"=\" a%b \"remaining\" a\/\/b \"(sign from first operand)\"\nsay a \"^\" b \"=\" a**b<\/lang>\n'''output'''\n<pre>enter 2 integer values separated by blanks\n17 -4\n17 + -4 = 13\n17 - -4 = 21\n17 * -4 = -68\n17 \/ -4 = -4 remaining 1 (sign from first operand)\n17 ^ -4 = 0.0000119730367<\/pre>\n\n==[[:Category:Ruby|Ruby]][[Category:Ruby]]==\n\n<lang ruby>puts 'Enter x and y'\nx=gets.to_i  # to check errors, use x=Integer(gets)\ny=gets.to_i\n\nputs \"Sum: #{x+y}\",\n     \"Difference: #{x-y}\",\n     \"Product: #{x*y}\",\n     \"Quotient: #{x\/y}\",  # truncates towards negative infinity\n     \"Remainder: #{x%y}\", # same sign as second operand\n     \"Exponentiation: #{x**y}\"<\/lang>\n\n==[[:Category:Run BASIC|Run BASIC]][[Category:Run BASIC]]==\n<lang runbasic>input \"Enter 1st integer: \"; integer1\ninput \"Enter 2nd integer: \"; integer2\n \nprint \"The sum is:\" ; integer1 + integer2\nprint \"The difference is:\" ; integer1 - integer2\nprint \"The product is:\" ; integer1 * integer2\nif integer2 <> 0 then print \"The integer quotient is:\" ; int( integer1 \/ integer2); \" (rounds towards 0)\" else print \"Division by zero unallowed.\"\nprint \"The remainder is:\" ; integer1 MOD integer2; \" (sign matches integer1 operand)\"\nprint \"The integer1 to power of the integer2 is:\" ; integer1 ^ integer2\n<\/lang>\n\n==[[:Category:Scala|Scala]][[Category:Scala]]==\n<lang scala>val a = Console.readInt\nval b = Console.readInt\n \nval sum = a + b;\/\/integer addition is discouraged in print statements due to confusion with String concatenation\nprintln(\"a + b = \" + sum);\nprintln(\"a - b = \" + (a - b));\nprintln(\"a * b = \" + (a * b));\nprintln(\"quotient of a \/ b = \" + (a \/ b)); \/\/ truncates towards 0\nprintln(\"remainder of a \/ b = \" + (a % b)); \/\/ same sign as first operand<\/lang>\n\n==[[:Category:Scheme|Scheme]][[Category:Scheme]]==\n\n<lang scheme>(define (arithmetic x y)\n  (for-each (lambda (op)\n              (write  (list op x y))\n              (display \" => \")\n              (write ((eval op) x y))\n              (write-char #\\newline))\n            '(+ - * \/ quotient remainder modulo max min gcd lcm)))\n           \n(arithmetic 8 12)<\/lang>\nquotient - truncates towards 0\nremainder - same sign as first operand\nmodulo - same sign as second operand\n \n  prints this:\n \n (+ 8 12) => 20\n (- 8 12) => -4\n (* 8 12) => 96\n (\/ 8 12) => 2\/3\n (quotient 8 12) => 0\n (remainder 8 12) => 8\n (modulo 8 12) => 8\n (max 8 12) => 12\n (min 8 12) => 8\n (gcd 8 12) => 4\n (lcm 8 12) => 24\n\n==[[:Category:Seed7|Seed7]][[Category:Seed7]]==\n<lang seed7>$ include \"seed7_05.s7i\";\n\nconst proc: main is func\n  local\n    var integer: a is 0;\n    var integer: b is 0;\n  begin\n    write(\"a = \");\n    readln(a);\n    write(\"b = \");\n    readln(b);\n \n    writeln(\"a + b = \" <& a + b);\n    writeln(\"a - b = \" <& a - b);\n    writeln(\"a * b = \" <& a * b);\n    writeln(\"a div b = \" <& a div b);    # Rounds towards zero\n    writeln(\"a rem b = \" <& a rem b);    # Sign of the first operand\n    writeln(\"a mdiv b = \" <& a mdiv b);  # Rounds towards negative infinity\n    writeln(\"a mod b = \" <& a mod b);    # Sign of the second operand\n  end func;<\/lang>\n\n==[[:Category:Slate|Slate]][[Category:Slate]]==\n<lang slate>[| :a :b |\ninform: (a + b) printString.\ninform: (a - b) printString.\ninform: (a * b) printString.\ninform: (a \/ b) printString.\ninform: (a \/\/ b) printString.\ninform: (a \\\\ b) printString.\n\n] applyTo: {Integer readFrom: (query: 'Enter a: '). Integer readFrom: (query: 'Enter b: ')}.<\/lang>\n\n==[[:Category:Smalltalk|Smalltalk]][[Category:Smalltalk]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[GNU Smalltalk]][[SMW::on]]<\/div>\n<lang smalltalk>| a b |\n'Input number a: ' display.\na := (stdin nextLine) asInteger.\n'Input number b: ' display.\nb := (stdin nextLine) asInteger.\n('a+b=%1' % { a + b }) displayNl.\n('a-b=%1' % { a - b }) displayNl.\n('a*b=%1' % { a * b }) displayNl.\n('a\/b=%1' % { a \/\/ b }) displayNl.\n('a%%b=%1' % { a \\\\ b }) displayNl.<\/lang>\n\n==[[:Category:SNOBOL4|SNOBOL4]][[Category:SNOBOL4]]==\n<lang snobol4>\n        output = \"Enter first integer:\"\n  \tfirst = input\n\toutput = \"Enter second integer:\"\n\tsecond = input\n\toutput = \"sum  = \" first + second\n\toutput = \"diff = \" first - second\n\toutput = \"prod = \" first * second\n\toutput = \"quot = \" (qout = first \/ second)\n\toutput = \"rem  = \" first - (qout * second)\nend<\/lang>\n\n==[[:Category:Standard ML|Standard ML]][[Category:Standard ML]]==\n<lang sml>val () = let\n  val a = valOf (Int.fromString (valOf (TextIO.inputLine TextIO.stdIn)))\n  val b = valOf (Int.fromString (valOf (TextIO.inputLine TextIO.stdIn)))\nin\n  print (\"a + b = \"   ^ Int.toString (a + b)   ^ \"\\n\");\n  print (\"a - b = \"   ^ Int.toString (a - b)   ^ \"\\n\");\n  print (\"a * b = \"   ^ Int.toString (a * b)   ^ \"\\n\");\n  print (\"a div b = \" ^ Int.toString (a div b) ^ \"\\n\");         (* truncates towards negative infinity *)\n  print (\"a mod b = \" ^ Int.toString (a mod b) ^ \"\\n\");         (* same sign as second operand *)\n  print (\"a quot b = \" ^ Int.toString (Int.quot (a, b)) ^ \"\\n\");(* truncates towards 0 *)\n  print (\"a rem b = \" ^ Int.toString (Int.rem (a, b)) ^ \"\\n\");  (* same sign as first operand *)\n  print (\"~a = \"      ^ Int.toString (~a)      ^ \"\\n\")          (* unary negation, unusual notation compared to other languages *)\nend<\/lang>\n\n==[[:Category:SNUSP|SNUSP]][[Category:SNUSP]]==\nAs a BF derivative, SNUSP only has increment and decrement as native operations. Here are routines for other basic arithmetic upon single digit numbers and results.\n\n''See also: [[Ethiopian Multiplication]]''\n<lang SNUSP>$\\\n ,\n @\n \\=@@@-@-----#  atoi\n >\n ,\n @\n \\=@@@-@-----#\n <\n @     #        4 copies\n \\=!\/?!\/->>+>>+>>+>>+<<<<<<<<?\\#\n >  | #\\?<<<<<<<<+>>+>>+>>+>>-\/\n @  |\n \\==\/\n \\>>>>\\\n \/>>>>\/\n @\n \\==!\/===?\\#    add\n <   \\>+<-\/\n @\n \\=@@@+@+++++#  itoa\n .\n <\n @\n \\==!\/===?\\#    subtract\n <   \\>-<-\/\n @\n \\=@@@+@+++++#\n .\n !\n \/\\\n ?-             multiply\n \\\/ #\/?<<+>+>-==\\     \/==-<+<+>>?\\#    \/==-<<+>>?\\#\n <   \\->+>+<<!\/?\/#   #\\?\\!>>+<+<-\/    #\\?\\!>>+<<-\/\n @         \/==|=========|=====\\   \/-\\    |\n \\======<?!\/>@\/<-?!\\>>>@\/<<<-?\\=>!\\?\/>!\/@\/<#\n <         \\=======|==========\/   \/-\\  |\n @                 \\done======>>>!\\?\/<=\/\n \\=@@@+@+++++#\n .\n !\n \/\\\n ?-  zero\n \\\/\n <              divmod\n @    \/-\\\n \\?\\<!\\?\/#!===+<<<\\      \/-\\\n | \\<==@\\>@\\>>!\/?!\/=<?\\>!\\?\/<<#\n |      |  |  #\\->->+<\/\n |      \\=!\\=?!\/->>+<<?\\#\n @            #\\?<<+>>-\/\n \\=@@@+@+++++#\n .\n <\n @\n \\=@@@+@+++++#\n .\n #<\/lang>\n\n==[[:Category:Tcl|Tcl]][[Category:Tcl]]==\n<lang tcl>puts \"Please enter two numbers:\"\n\nset x [expr {int([gets stdin])}]; # Force integer interpretation\nset y [expr {int([gets stdin])}]; # Force integer interpretation\n\nputs \"$x + $y = [expr {$x + $y}]\"\nputs \"$x - $y = [expr {$x - $y}]\"\nputs \"$x * $y = [expr {$x * $y}]\"\nputs \"$x \/ $y = [expr {$x \/ $y}]\"\nputs \"$x mod $y = [expr {$x % $y}]\"\nputs \"$x 'to the' $y = [expr {$x ** $y}]\"<\/lang>\n\nSince Tcl doesn't really know about the \"type\" of a variable, the \"<tt>expr<\/tt>\" command is used to declare whatever follows as an \"expression\". This means there is no such thing as \"integer arithmetic\" and hence the kludge with <tt>int([gets&nbsp;stdin])<\/tt>.\n\nOften, these operations would be performed in a different way from what is shown here. For example, to increase the variable \"x\" by the value of the variable \"y\", one would write\n\n<lang tcl>incr x $y<\/lang>\n\nAlso, it's important to surround the arguments to the <code>expr<\/code> in braces, especially when any of the parts of the expression are not literal constants.  Discussion of this is on [http:\/\/wiki.tcl.tk\/10225 The Tcler's Wiki].\n\n==[[:Category:TI-83 BASIC|TI-83 BASIC]][[Category:TI-83 BASIC]]==\nPauses added due to TI-83's lack of screen size.\n<lang ti83b>\nPrompt A,B\nDisp \"SUM\"\nPause A+B\nDisp \"DIFFERENCE\"\nPause A-B\nDisp \"PRODUCT\"\nPause AB\nDisp \"INTEGER QUOTIENT\"\nPause int(A\/B)\nDisp \"REMAINDER\"\nPause A-B*int(A\/B)\n<\/lang>\n\n==[[:Category:TI-89 BASIC|TI-89 BASIC]][[Category:TI-89 BASIC]]==\n\n<lang ti89b>Local a, b\nPrompt a, b\nDisp \"Sum: \" & string(a + b)\nDisp \"Difference: \" & string(a - b)\nDisp \"Product: \" & string(a * b)\nDisp \"Integer quotient: \" & string(intDiv(a, b))\nDisp \"Remainder: \" & string(remain(a, b))<\/lang>\n\n==[[:Category:Toka|Toka]][[Category:Toka]]==\n\n<lang toka>[ ( a b -- )\n  2dup .\" a+b = \" + . cr  \n  2dup .\" a-b = \" - . cr  \n  2dup .\" a*b = \" * . cr  \n  2dup .\" a\/b = \" \/ . .\" remainder \" mod . cr  \n] is mathops<\/lang>\n\n==[[:Category:TUSCRIPT|TUSCRIPT]][[Category:TUSCRIPT]]==\n<lang tuscript>\n$$ MODE TUSCRIPT\na=5\nb=3\nc=a+b\nc=a-b\nc=a*b\nc=a\/b\nc=a%b\n<\/lang>\nOutput:\n<pre>\na=5\nb=3\nc=a+b\nc            = 8\nc=a-b\nc            = 2\nc=a*b\nc            = 15\nc=a\/b\nc            = 1\nc=a%b\nc            = 2\n<\/pre>\n\n==[[:Category:UNIX Shell|UNIX Shell]][[Category:UNIX Shell]]==\n\nThe Unix shell does not directly support arithmetic operations, so external tools, such as ''expr'' are used to perform arithmetic calculations when required:\n\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Bourne Shell]][[SMW::on]]<\/div>\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Almquist SHell]][[SMW::on]]<\/div>\n<lang bash>#!\/bin\/sh\nread a; read b;\necho \"a+b     = \"  `expr $a  +  $b`\necho \"a-b     = \"  `expr $a  -  $b`\necho \"a*b     = \"  `expr $a \\*  $b`\necho \"a\/b     = \"  `expr $a  \/  $b` # truncates towards 0\necho \"a mod b = \"  `expr $a  %  $b` # same sign as first operand<\/lang>\n\nNotes: Using the ` (backtick operators, also available in most Bourne shells via the ''$(...)'' syntax) allows us to keep the results on their labels in the most efficient and portable way. The spaces around the operators in the ''expr'' command line arguments are required and the shell requires us to quote or escape the ''*'' character has shown, to prevent any possible \"globbing\" --- filename expansion of the ''*'' as a wildcard character.\n\nWith SUSv3 parameter expansions:\n\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Bourne Again SHell]] version 3.2[[SMW::on]]<\/div>\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[pdksh]] version 5.2.14[[SMW::on]]<\/div>\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Z SHell]][[SMW::on]]<\/div>\n<lang bash>#!\/bin\/sh\nread a; read b;\necho \"a+b     = $((a+b))\"\necho \"a-b     = $((a-b))\"\necho \"a*b     = $((a*b))\"\necho \"a\/b     = $((a\/b))\" # truncates towards 0\necho \"a mod b = $((a%b))\" # same sign as first operand<\/lang>\n\nNote: spaces inside the ''$((...))'' are optional and not required; the ''$((...))'' can be inside or outside the double quotes, but the `...` expressions from the previous example can also be inside or outside the double quotes.\n\n==[[:Category:Vedit macro language|Vedit macro language]][[Category:Vedit macro language]]==\n<lang vedit>#1 = Get_Num(\"Give number a: \")\n#2 = Get_Num(\"Give number b: \")\nMessage(\"a + b = \") Num_Type(#1 + #2)\nMessage(\"a - b = \") Num_Type(#1 - #2)\nMessage(\"a * b = \") Num_Type(#1 * #2)\nMessage(\"a \/ b = \") Num_Type(#1 \/ #2)\nMessage(\"a % b = \") Num_Type(#1 % #2)<\/lang>\n\n==[[:Category:VBScript|VBScript]][[Category:VBScript]]==\nVBScript's variables are all Variants. What starts out as an integer may be converted to something else if the need arises.\n\n===Implementation===\n<lang vb>option explicit\ndim a, b\nwscript.stdout.write \"A? \"\na = wscript.stdin.readline\nwscript.stdout.write \"B? \"\nb = wscript.stdin.readline\n\na = int( a )\nb = int( b )\n\nwscript.echo \"a + b=\", a + b\nwscript.echo \"a - b=\", a - b\nwscript.echo \"a * b=\", a * b\nwscript.echo \"a \/ b=\", a \/ b\nwscript.echo \"a \\ b=\", a \\ b\nwscript.echo \"a mod b=\", a mod b\nwscript.echo \"a ^ b=\", a ^ b<\/lang>\n\n===Another Implementation===\nGives the same output for the same input. Inspired by Python version.\n<lang vb>option explicit\ndim a, b\nwscript.stdout.write \"A? \"\na = wscript.stdin.readline\nwscript.stdout.write \"B? \"\nb = wscript.stdin.readline\n\na = int( a )\nb = int( b )\n\ndim op\nfor each op in split(\"+ - * \/ \\ mod ^\", \" \")\n\twscript.echo \"a\",op,\"b=\",eval( \"a \" & op & \" b\")\nnext<\/lang>\n\n===Invocation===\n<pre>\nC:\\foo>arithmetic.vbs\nA? 45\nB? 11\na + b= 4511\na - b= 34\na * b= 495\na \/ b= 4.09090909090909\na \\ b= 4\na mod b= 1\na ^ b= 1.5322783012207E+18\n<\/pre>\n\n==[[:Category:Visual Basic .NET|Visual Basic .NET]][[Category:Visual Basic .NET]]==\n<lang vbnet>Imports System.Console\nModule Module1\n  Sub Main\n    Dim a = CInt(ReadLine)\n    Dim b = CInt(ReadLine)\n    WriteLine(\"Sum \" & a + b)\n    WriteLine(\"Difference \" & a - b)\n    WriteLine(\"Product \" & a - b)\n    WriteLine(\"Quotient \" & a \/ b)\n    WriteLine(\"Integer Quotient \" & a \\ b)\n    WriteLine(\"Remainder \" & a Mod b)\n    WriteLine(\"Exponent \" & a ^ b)\n  End Sub\nEnd Module<\/lang>\n\n==[[:Category:XPL0|XPL0]][[Category:XPL0]]==\n<lang XPL0>include c:\\cxpl\\codes;\nint A, B;\n[A:= IntIn(0);\n B:= IntIn(0);\nIntOut(0, A+B); CrLf(0);\nIntOut(0, A-B); CrLf(0);\nIntOut(0, A*B); CrLf(0);\nIntOut(0, A\/B); CrLf(0);        \\truncates toward zero\nIntOut(0, rem(0)); CrLf(0);     \\remainder's sign matches first operand (A)\n]<\/lang>\n\n==[[:Category:XSLT|XSLT]][[Category:XSLT]]==\n<lang xml><xsl:template name=\"arithmetic\">\n  <xsl:param name=\"a\">5<\/xsl:param>\n  <xsl:param name=\"b\">2<\/xsl:param>\n  <fo:block>a + b = <xsl:value-of select=\"$a + $b\"\/><\/fo:block>\n  <fo:block>a - b = <xsl:value-of select=\"$a - $b\"\/><\/fo:block>\n  <fo:block>a * b = <xsl:value-of select=\"$a * $b\"\/><\/fo:block>\n  <fo:block>a \/ b = <xsl:value-of select=\"round($a div $b)\"\/><\/fo:block>\n  <fo:block>a mod b = <xsl:value-of select=\"$a mod $b\"\/><\/fo:block>\n <\/xsl:template><\/lang>\n\n==[[:Category:Yorick|Yorick]][[Category:Yorick]]==\n<lang yorick>x = y = 0;\nread, x, y;\nwrite, \"x + y =\", x + y;\nwrite, \"x - y =\", x - y;\nwrite, \"x * y =\", x * y;\nwrite, \"x \/ y =\", x \/ y; \/\/ rounds toward zero\nwrite, \"x % y =\", x % y; \/\/ remainder; matches sign of first operand when operands' signs differ\nwrite, \"x ^ y =\", x ^ y; \/\/ exponentiation<\/lang>\n\n[[Category:Arithmetic]]"}]}}}}