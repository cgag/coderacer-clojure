{"query":{"pages":{"3099":{"pageid":3099,"ns":0,"title":"Active object","revisions":[{"*":"<div class=\"infobox\" style=\"width: 2in\">[[File:Rcode-button-task-crushed.png|64px|left|alt=Task|link=Category:Solutions by Programming Task]]'''Active object'''<br\/>\nYou are encouraged to [[Rosetta Code:Solve a Task|solve this task]] according to the task description, using any language you may know.[[Category:Programming Tasks]][[Category:Concurrency]]<\/div>\n[[Category:Object oriented]]\n\nIn [[object-oriented programming]] an object is active when its state depends on clock. Usually an active object encapsulates a [[task]] that updates the object's state. To the outer world the object looks like a normal object with methods that can be called from outside. Implementation of such methods must have a certain synchronization mechanism with the encapsulated task in order to prevent object's state corruption.\n\nA typical instance of an active object is an animation widget. The widget state changes with the time, while as an object it has all properties of a normal widget.\n\n'''The task'''\n\nImplement an active integrator object. The object has an input and output. The input can be set using the method ''Input''. The input is a function of time. The output can be queried using the method ''Output''. The object integrates its input over the time and the result becomes the object's output. So if the input is ''K''(''t'') and the output is ''S'', the object state ''S'' is changed to ''S'' + (''K''(''t''<sub>1<\/sub>) + ''K''(''t''<sub>0<\/sub>)) * (''t''<sub>1<\/sub> - ''t''<sub>0<\/sub>) \/ 2, i.e. it integrates ''K'' using the trapeze method. Initially ''K'' is constant 0 and ''S'' is 0.\n\nIn order to test the object:\n# set its input to sin (2\u03c0 ''f t''), where the frequency ''f''=0.5Hz. The phase is irrelevant.\n# wait 2s\n# set the input to constant 0\n# wait 0.5s\n\nVerify that now the object's output is approximately 0 (the sine has the period of 2s). The accuracy of the result will depend on the [[OS]] scheduler time slicing and the accuracy of the clock.\n\n[[Category:VBScript\/Omit]]\n==[[:Category:Ada|Ada]][[Category:Ada]]==\n<lang ada>with Ada.Calendar;                       use Ada.Calendar;\nwith Ada.Numerics;                       use Ada.Numerics;\nwith Ada.Numerics.Elementary_Functions;  use Ada.Numerics.Elementary_Functions;\nwith Ada.Text_IO;                        use Ada.Text_IO;\n \nprocedure Test_Integrator is\n   type Func is access function (T : Time) return Float;\n\n   function Zero (T : Time) return Float is\n   begin\n      return 0.0;\n   end Zero;\n\n   Epoch : constant Time := Clock;\n\n   function Sine (T : Time) return Float is\n   begin\n      return Sin (Pi * Float (T - Epoch));\n   end Sine;\n\n   task type Integrator is\n      entry Input  (Value : Func);\n      entry Output (Value : out Float);\n      entry Shut_Down;\n   end Integrator;\n \n   task body Integrator is\n      K  : Func  := Zero'Access;\n      S  : Float := 0.0;\n      F0 : Float := 0.0;\n      F1 : Float;\n      T0 : Time  := Clock;\n      T1 : Time;\n   begin\n      loop\n         select\n            accept Input (Value : Func) do\n               K := Value;\n            end Input;\n         or accept Output (Value : out Float) do\n               Value := S;\n            end Output;\n         or accept Shut_Down;\n            exit;\n         else\n            T1 := Clock;\n            F1 := K (T1);\n            S  := S + 0.5 * (F1 + F0) * Float (T1 - T0);\n            T0 := T1;\n            F0 := F1;\n         end select;\n      end loop;\n   end Integrator;\n \n   I : Integrator;\n   S : Float;\nbegin\n   I.Input (Sine'Access);\n   delay 2.0;\n   I.Input (Zero'Access);\n   delay 0.5;\n   I.Output (S);\n   Put_Line (\"Integrated\" & Float'Image (S) & \"s\");\n   I.Shut_Down;\nend Test_Integrator;<\/lang>\nSample output:\n<pre>\nIntegrated-5.34100E-05s\n<\/pre>\n\n==[[:Category:C|C]][[Category:C]]==\nUses POSIX threads.\n<div class=\"examplemeta libheader\">'''Library:''' [[SMW::off]][[:Category:pthread|pthread]][[Category:pthread]][[SMW::on]]<\/div>\n\n<lang c>#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <math.h>\n#include <sys\/time.h>\n#include <pthread.h>\n\n\/* no need to lock the object: at worst the readout would be 1 tick off,\n   which is no worse than integrator's inate inaccuracy *\/\ntypedef struct {\n\tdouble (*func)(double);\n\tstruct timeval start;\n\tdouble v, last_v, last_t;\n\tpthread_t id;\n} integ_t, *integ;\n\nvoid update(integ x)\n{\n\tstruct timeval tv;\n\tdouble t, v, (*f)(double);\n\n\tf = x->func;\n\tgettimeofday(&tv, 0);\n\tt = ((tv.tv_sec - x->start.tv_sec) * 1000000\n\t\t+ tv.tv_usec - x->start.tv_usec) * 1e-6;\n\tv = f ? f(t) : 0;\n\tx->v += (x->last_v + v) * (t - x->last_t) \/ 2;\n\tx->last_t = t;\n}\n\nvoid* tick(void *a)\n{\n\tinteg x = a;\n\twhile (1) {\n\t\tusleep(100000); \/* update every .1 sec *\/\n\t\tupdate(x);\n\t}\n}\n\nvoid set_input(integ x, double (*func)(double))\n{\n\tupdate(x);\n\tx->func = func;\n\tx->last_t = 0;\n\tx->last_v = func ? func(0) : 0;\n}\n\ninteg new_integ(double (*func)(double))\n{\n\tinteg x = malloc(sizeof(integ_t));\n\tx->v = x->last_v = 0;\n\tx->func = 0;\n\tgettimeofday(&x->start, 0);\n\tset_input(x, func);\n\tpthread_create(&x->id, 0, tick, x);\n\treturn x;\n}\n\ndouble sine(double t) { return sin(4 * atan2(1, 1) * t); }\n\nint main()\n{\n\tinteg x = new_integ(sine);\n\tsleep(2);\n\tset_input(x, 0);\n\tusleep(500000);\n\tprintf(\"%g\\n\", x->v);\n\n\treturn 0;\n}<\/lang>\noutput\n<pre>-9.99348e-05<\/pre>\n\n==[[:Category:Clojure|Clojure]][[Category:Clojure]]==\n<lang clojure>(ns active-object\n  (:import (java.util Timer TimerTask)))\n\n(defn input [integrator k]\n  (send integrator assoc :k k))\n\n(defn output [integrator]\n  (:s @integrator))\n\n(defn tick [integrator t1]\n  (send integrator\n        (fn [{:keys [k s t0] :as m}]\n          (assoc m :s (+ s (\/ (* (+ (k t1) (k t0)) (- t1 t0)) 2.0)) :t0 t1))))\n\n(defn start-timer [integrator interval]\n  (let [timer (Timer. true)\n        start (System\/currentTimeMillis)]\n    (.scheduleAtFixedRate timer\n                          (proxy [TimerTask] []\n                            (run [] (tick integrator (double (\/ (- (System\/currentTimeMillis) start) 1000)))))\n                          (long 0)\n                          (long interval))\n    #(.cancel timer)))\n\n(defn test-integrator []\n  (let [integrator (agent {:k (constantly 0.0) :s 0.0 :t0 0.0})\n        stop-timer (start-timer integrator 10)]\n    (input integrator #(Math\/sin (* 2.0 Math\/PI 0.5 %)))\n    (Thread\/sleep 2000)\n    (input integrator (constantly 0.0))\n    (Thread\/sleep 500)\n    (println (output integrator))\n    (stop-timer)))\n\nuser> (test-integrator)\n1.414065859052494E-5\n<\/lang>\n==[[:Category:E|E]][[Category:E]]==\n\n<lang e>def makeIntegrator() {\n    var value := 0.0\n    var input := fn { 0.0 }\n    \n    var input1 := input()\n    var t1 := timer.now()\n    \n    def update() {\n        def t2 := timer.now()\n        def input2 :float64 := input()\n        def dt := (t2 - t1) \/ 1000\n        \n        value += (input1 + input2) * dt \/ 2\n        \n        t1 := t2\n        input1 := input2\n    }\n    \n    var task() {\n        update <- ()\n        task <- ()\n    }\n    task()\n    \n    def integrator {\n        to input(new) :void  { input := new }\n        to output() :float64 { return value }\n        to shutdown()        { task := fn {} }\n    }\n    return integrator\n}\n\ndef test() {\n    def result\n    \n    def pi := (-1.0).acos()\n    def freq := pi \/ 1000\n    \n    def base := timer.now()\n    def i := makeIntegrator()\n    \n    i.input(fn { (freq * timer.now()).sin() })\n    timer.whenPast(base + 2000, fn {\n        i.input(fn {0})\n    })\n    timer.whenPast(base + 2500, fn {\n        bind result := i.output()\n        i.shutdown()\n    })\n    return result\n}<\/lang>\n\n==[[:Category:Factor|Factor]][[Category:Factor]]==\nWorking with dynamic quotations requires the stack effect to be known in advance. The apply-stack-effect serves this purpose.\n<lang factor>USING: accessors alarms calendar combinators kernel locals math\nmath.constants math.functions prettyprint system threads ;\nIN: rosettacode.active\n \nTUPLE: active-object alarm function state previous-time ;\n\n: apply-stack-effect ( quot -- quot' ) \n    [ call( x -- x ) ] curry ; inline\n \n: nano-to-seconds ( -- seconds ) nano-count 9 10^ \/ ;\n \n: object-times ( active-object -- t1 t2 ) \n    [ previous-time>> ] \n    [ nano-to-seconds [ >>previous-time drop ] keep ] bi ;\n:: adding-function ( t1 t2 active-object -- function )\n    t2 t1 active-object function>> apply-stack-effect bi@ +\n    t2 t1 - * 2 \/ [ + ] curry ;\n: integrate ( active-object -- )\n    [ object-times ]\n    [ adding-function ]\n    [ swap apply-stack-effect change-state drop ] tri ;\n \n: <active-object> ( -- object )\n    active-object new\n    0 >>state\n    nano-to-seconds >>previous-time\n    [ drop 0 ] >>function\n    dup [ integrate ] curry 1 nanoseconds every >>alarm ;\n: destroy ( active-object -- ) alarm>> cancel-alarm ;\n \n: input ( object quot -- object ) >>function ;\n: output ( object -- val ) state>> ;\n \n: active-test ( -- )\n    <active-object>\n    [ 2 pi 0.5 * * * sin ] input\n    2 seconds sleep\n    [ drop 0 ] input\n    0.5 seconds sleep\n    [ output . ] [ destroy ] bi ;\nMAIN: active-test<\/lang>\n    ( scratchpad ) \"rosettacode.active\" run\n    -5.294207647335787e-05\n\n==<span id=\"F_Sharp\">[[:Category:F_Sharp|F#]]<\/span>[[Category:F_Sharp]]==\n<lang fsharp>open System\nopen System.Threading\n\n\/\/ current time in seconds\nlet now() = float( DateTime.Now.Ticks \/ 10000L ) \/ 1000.0\n\ntype Integrator( intervalMs ) as x =\n  let mutable k = fun _ -> 0.0  \/\/ function to integrate\n  let mutable s = 0.0           \/\/ current value\n  let mutable t0 = now()        \/\/ last time s was updated\n  let mutable running = true    \/\/ still running?\n\n  do x.ScheduleNextUpdate()\n\n  member x.Input(f) = k <- f\n\n  member x.Output() = s\n\n  member x.Stop() = running <- false\n\n  member private x.Update() =\n    let t1 = now()\n    s <- s + (k t0 + k t1) * (t1 - t0) \/ 2.0\n    t0 <- t1\n    x.ScheduleNextUpdate()\n\n  member private x.ScheduleNextUpdate() =\n    if running then\n      async { do! Async.Sleep( intervalMs )\n              x.Update()\n            }\n      |> Async.Start\n    \nlet i = new Integrator(10)\n\ni.Input( fun t -> Math.Sin (2.0 * Math.PI * 0.5 * t) )\nThread.Sleep(2000)\n\ni.Input( fun _ -> 0.0 )\nThread.Sleep(500)\n\nprintfn \"%f\" (i.Output())\ni.Stop()<\/lang>\n\n==[[:Category:Go|Go]][[Category:Go]]==\nUsing time.Tick to sample K at a constant frequency.  Three goroutines are involved, main, aif, and tk.  Aif controls access to the accumulator s and the integration function K.  Tk and main must talk to aif through channels to access s and K.\n<lang go>package main\n\nimport (\n    \"fmt\"\n    \"math\"\n    \"time\"\n)\n\n\/\/ type for input function, k.\n\/\/ input is duration since an arbitrary start time t0.\ntype tFunc func(time.Duration) float64\n\n\/\/ active integrator object.  state variables are not here, but in\n\/\/ function aif, started as a goroutine in the constructor.\ntype aio struct {\n    iCh chan tFunc        \/\/ channel for setting input function\n    oCh chan chan float64 \/\/ channel for requesting output\n}\n\n\/\/ constructor\nfunc newAio() *aio {\n    var a aio\n    a.iCh = make(chan tFunc)\n    a.oCh = make(chan chan float64)\n    go aif(&a)\n    return &a\n}\n\n\/\/ input method required by task description.  in practice, this method is\n\/\/ unnecessary; you would just put that single channel send statement in\n\/\/ your code wherever you wanted to set the input function.\nfunc (a aio) input(f tFunc) {\n    a.iCh <- f\n}\n\n\/\/ output method required by task description.  in practice, this method too\n\/\/ would not likely be best.  instead any client interested in the value would\n\/\/ likely make a return channel sCh once, and then reuse it as needed.\nfunc (a aio) output() float64 {\n    sCh := make(chan float64)\n    a.oCh <- sCh\n    return <-sCh\n}\n\n\/\/ integration function that returns constant 0\nfunc zeroFunc(time.Duration) float64 { return 0 }\n\n\/\/ goroutine serializes access to integrated function k and state variable s\nfunc aif(a *aio) {\n    var k tFunc = zeroFunc \/\/ integration function\n    s := 0.                \/\/ \"object state\" initialized to 0\n    t0 := time.Now()       \/\/ initial time\n    k0 := k(0)             \/\/ initial sample value\n    t1 := t0               \/\/ t1, k1 used for trapezoid formula\n    k1 := k0\n\n    tk := time.Tick(10 * time.Millisecond) \/\/ 10 ms -> 100 Hz\n    for {\n        select {\n        case t2 := <-tk: \/\/ timer tick event\n            k2 := k(t2.Sub(t0))                        \/\/ new sample value\n            s += (k1 + k2) * .5 * t2.Sub(t1).Seconds() \/\/ trapezoid formula\n            t1, k1 = t2, k2                            \/\/ save time and value\n        case k = <-a.iCh: \/\/ input method event: function change\n        case sCh := <-a.oCh: \/\/ output method event: sample object state\n            sCh <- s\n        }\n    }\n}\n\nfunc main() {\n    a := newAio()                           \/\/ create object\n    a.input(func(t time.Duration) float64 { \/\/ 1. set input to sin function\n        return math.Sin(t.Seconds() * math.Pi)\n    })\n    time.Sleep(2 * time.Second) \/\/ 2. sleep 2 sec\n    a.input(zeroFunc)           \/\/ 3. set input to zero function\n    time.Sleep(time.Second \/ 2) \/\/ 4. sleep .5 sec\n    fmt.Println(a.output())     \/\/ output should be near zero\n}<\/lang>\nOutput:\n<pre>\n2.4517135756807704e-05\n<\/pre>\n\n==[[:Category:Haskell|Haskell]][[Category:Haskell]]==\n\n<lang haskell>module Integrator (\n  newIntegrator, input, output, stop,\n  Time, timeInterval\n) where\nimport Control.Concurrent (forkIO, threadDelay)\nimport Control.Concurrent.MVar (MVar, newMVar, modifyMVar_, modifyMVar, readMVar)\nimport Control.Exception (evaluate)\nimport Data.Time (UTCTime)\nimport Data.Time.Clock (getCurrentTime, diffUTCTime)\n\n-- RC task\nmain = do let f = 0.5 {- Hz -}\n          t0 <- getCurrentTime\n          i <- newIntegrator\n          input i (\\t -> sin(2*pi * f * timeInterval t0 t)) -- task step 1\n          threadDelay 2000000 {- \u00b5s -}                      -- task step 2\n          input i (const 0)                                 -- task step 3\n          threadDelay 500000 {- \u00b5s -}                       -- task step 4\n          result <- output i\n          stop i\n          print result\n\n---- Implementation ------------------------------------------------------\n\n-- Utilities for working with the time type\ntype Time = UTCTime\ntype Func a = Time -> a\ntimeInterval t0 t1 = realToFrac $ diffUTCTime t1 t0\n\n-- Type signatures of the module's interface\nnewIntegrator :: Fractional a => IO (Integrator a) -- Create an integrator\ninput  :: Integrator a -> Func a -> IO ()          -- Set the input function\noutput :: Integrator a           -> IO a           -- Get the current value\nstop   :: Integrator a           -> IO ()          -- Stop integration, don't waste CPU\n\n-- Data structures\ndata Integrator a = Integrator (MVar (IntState a)) -- MVar is a thread-safe mutable cell\n  deriving Eq\ndata IntState a = IntState { func  :: Func a,      -- The current function\n                             run   :: Bool,        -- Whether to keep going\n                             value :: a,           -- The current accumulated value\n                             time  :: Time }       -- The time of the previous update\n\nnewIntegrator = do\n  now <- getCurrentTime\n  state <- newMVar $ IntState { func  = const 0,\n                                run   = True,\n                                value = 0,\n                                time  = now }\n  thread <- forkIO (intThread state)  -- The state variable is shared between the thread\n  return (Integrator state)           --   and the client interface object.     \n                   \ninput  (Integrator stv) f = modifyMVar_ stv (\\st -> return st { func = f })\noutput (Integrator stv)   = fmap value $ readMVar stv\nstop   (Integrator stv)   = modifyMVar_ stv (\\st -> return st { run = False })\n  -- modifyMVar_ takes an MVar and replaces its contents according to the provided function.\n  -- a { b = c } is record-update syntax: \"the record a, except with field b changed to c\"\n\n-- Integration thread\nintThread :: Fractional a => MVar (IntState a) -> IO ()\nintThread stv = whileM $ modifyMVar stv updateAndCheckRun\n  -- modifyMVar is like modifyMVar_ but the function returns a tuple of the new value\n  -- and an arbitrary extra value, which in this case ends up telling whileM whether\n  -- to keep looping.\n  where updateAndCheckRun st = do\n          now <- getCurrentTime\n          let value' = integrate (func st) (value st) (time st) now\n          evaluate value'                             -- avoid undesired laziness\n          return (st { value = value', time  = now }, -- updated state\n                  run st)                             -- whether to continue\n\nintegrate :: Fractional a => Func a -> a -> Time -> Time -> a\nintegrate f value t0 t1 = value + (f t0 + f t1)\/2 * dt\n  where dt = timeInterval t0 t1\n\n-- Execute 'action' until it returns false.\nwhileM action = do b <- action; if b then whileM action else return ()<\/lang>\n\n==[[:Category:JavaScript|JavaScript]][[Category:JavaScript]]==\n\n<div class=\"examplemeta translation\">'''Translation of''': [[Active object#E|E]]<\/div>\n\n<lang javascript>function Integrator(sampleIntervalMS) {\n    var inputF = function () { return 0.0 };\n    var sum = 0.0;\n  \n    var t1 = new Date().getTime();\n    var input1 = inputF(t1 \/ 1000);\n  \n    function update() {\n        var t2 = new Date().getTime();\n        var input2 = inputF(t2 \/ 1000);\n        var dt = (t2 - t1) \/ 1000;\n        \n        sum += (input1 + input2) * dt \/ 2;\n        \n        t1 = t2;\n        input1 = input2;\n    }\n    \n    var updater = setInterval(update, sampleIntervalMS);\n  \n    return ({\n        input: function (newF) { inputF = newF },\n        output: function () { return sum },\n        shutdown: function () { clearInterval(updater) },\n    });\n}<\/lang>\n\nTest program as a HTML fragment:\n\n<lang html4strict><p><span id=\"a\">Test running...<\/span> <code id=\"b\">-<\/code><\/p>\n\n<script type=\"text\/javascript\">\n    var f = 0.5;\n\n    var i = new Integrator(1);\n    var displayer = setInterval(function () { document.getElementById(\"b\").firstChild.data = i.output() }, 100)\n  \n    setTimeout(function () {\n        i.input(function (t) { return Math.sin(2*Math.PI*f*t) }); \/\/ test step 1\n        setTimeout(function () { \/\/ test step 2\n            i.input(function (t) { return 0 }); \/\/ test step 3\n            setTimeout(function () { \/\/ test step 3\n                i.shutdown();\n                clearInterval(displayer);\n                document.getElementById(\"a\").firstChild.data = \"Done, should be about 0: \"\n            }, 500);      \n        }, 2000);\n    }, 1)\n<\/script><\/lang>\n\n==[[:Category:Mathematica|Mathematica]][[Category:Mathematica]]==\n<lang Mathematica>Block[{start = SessionTime[], K, t0 = 0, t1, kt0, S = 0}, \n K[t_] = Sin[2 Pi f t] \/. f -> 0.5; kt0 = K[t0]; \n While[True, t1 = SessionTime[] - start; \n  S += (kt0 + (kt0 = K[t1])) (t1 - t0)\/2; t0 = t1; \n  If[t1 > 2, K[t_] = 0; If[t1 > 2.5, Break[]]]]; S]<\/lang>\n\n 1.1309*10^-6\n\nCuriously, this value never changes; it is always exactly the same (at 1.1309E-6). Note that closer answers could be achieved by using Mathematica's better interpolation methods, but it would require collecting the data (in a list), which would have a speed penalty large enough to negate the improved estimation.\n\n==[[:Category:Oz|Oz]][[Category:Oz]]==\n<lang oz>declare\n  fun {Const X}\n     fun {$ _} X end\n  end\n\n  fun {Now}\n     {Int.toFloat {Property.get 'time.total'}} \/ 1000.0\n  end\n\n  class Integrator from Time.repeat\n     attr\n        k:{Const 0.0}\n        s:0.0\n        t1 k_t1\n        t2 k_t2\n      \n     meth init(SampleIntervalMS)\n        t1 := {Now}\n        k_t1 := {@k @t1}\n        {self setRepAll(action:Update\n                        delay:SampleIntervalMS)}\n        thread\n           {self go}\n        end\n     end\n\n     meth input(K)\n        k := K\n     end\n\n     meth output($)\n        @s\n     end\n\n     meth Update\n        t2 := {Now}\n        k_t2 := {@k @t2}\n        s := @s + (@k_t1 + @k_t2) * (@t2 - @t1) \/ 2.0\n        t1 := @t2\n        k_t1 := @k_t2\n     end\n  end\n\n  Pi = 3.14159265\n  F = 0.5\n\n  I = {New Integrator init(10)}\nin\n  {I input(fun {$ T}\n              {Sin 2.0 * Pi * F * T}\n           end)}\n\n  {Delay 2000} %% ms\n\n  {I input({Const 0.0})}\n\n  {Delay 500} %% ms\n\n  {Show {I output($)}}\n  {I stop}<\/lang>\n\n==[[:Category:Perl|Perl]][[Category:Perl]]==\n<lang perl>#!\/usr\/bin\/perl\n\nuse strict;\nuse 5.10.0;\n\npackage Integrator;\nuse threads;\nuse threads::shared;\n\nsub new {\n\tmy $cls = shift;\n\tmy $obj = bless {\tt\t=> 0,\n\t\t\t\tsum\t=> 0,\n\t\t\t\tref $cls ? %$cls : (),\n\t\t\t\tstop\t=> 0,\n\t\t\t\ttid\t=> 0,\n\t\t\t\tfunc\t=> shift,\n\t\t\t}, ref $cls || $cls;\n\n\tshare($obj->{sum});\n\tshare($obj->{stop});\n\n\t$obj->{tid} = async {\n\t\tmy $upd = 0.1; # update every 0.1 second\n\t\twhile (!$obj->{stop}) {\n\t\t\t{\n\t\t\t\tmy $f = $obj->{func};\n\t\t\t\tmy $t = $obj->{t};\n\n\t\t\t\t$obj->{sum} += ($f->($t) + $f->($t + $upd))* $upd\/ 2;\n\t\t\t\t$obj->{t} += $upd;\n\t\t\t}\n\t\t\tselect(undef, undef, undef, $upd);\n\t\t}\n\t#\tsay \"stopping $obj\";\n\t};\n\t$obj\n}\n\nsub output { shift->{sum} }\n\nsub delete {\n\tmy $obj = shift;\n\t$obj->{stop} = 1;\n\t$obj->{tid}->join;\n}\n\nsub setinput {\n\t# This is surprisingly difficult because of the perl sharing model.\n\t# Func refs can't be shared, thus can't be replaced by another thread.\n\t# Have to create a whole new object... there must be a better way.\n\tmy $obj = shift;\n\t$obj->delete;\n\t$obj->new(shift);\n}\n\npackage main;\n\nmy $x = Integrator->new(sub { sin(atan2(1, 1) * 8 * .5 * shift) });\n\nsleep(2);\nsay \"sin after 2 seconds: \", $x->output;\n\n$x = $x->setinput(sub {0});\n\nselect(undef, undef, undef, .5);\nsay \"0 after .5 seconds: \", $x->output;\n\n$x->delete;<\/lang>\n==[[:Category:PicoLisp|PicoLisp]][[Category:PicoLisp]]==\n<lang PicoLisp>(load \"@lib\/math.l\")\n\n(class +Active)\n# inp val sum usec\n\n(dm T ()\n   (unless (assoc -100 *Run)           # Install timer task\n      (task -100 100                   # Update objects every 0.1 sec\n         (mapc 'update> *Actives) ) )\n   (=: inp '((U) 0))                   # Set zero input function\n   (=: val 0)                          # Initialize last value\n   (=: sum 0)                          # Initialize sum\n   (=: usec (usec))                    # and time\n   (push '*Actives This) )             # Install in notification list\n\n(dm input> (Fun)\n   (=: inp Fun) )\n\n(dm update> ()\n   (let (U (usec)  V ((: inp) U))      # Get current time, calculate value\n      (inc (:: sum)\n         (*\/\n            (+ V (: val))              # (K(t[1]) + K(t[0])) *\n            (- U (: usec))             # (t[1] - t[0]) \/\n            2.0 ) )                    # 2.0\n      (=: val V)\n      (=: usec U) ) )\n\n(dm output> ()\n   (format (: sum) *Scl) )             # Get result\n\n(dm stop> ()\n   (unless (del This '*Actives)        # Removing the last active object?\n      (task -100) ) )                  # Yes: Uninstall timer task\n\n(de integrate ()                       # Test it\n   (let Obj (new '(+Active))           # Create an active object\n      (input> Obj                      # Set input function\n         '((U) (sin (*\/ pi U 1.0))) )  # to sin(\u03c0 * t)\n      (wait 2000)                      # Wait 2 sec\n      (input> Obj '((U) 0))            # Reset input function\n      (wait 500)                       # Wait 0.5 sec\n      (prinl \"Output: \" (output> Obj)) # Print return value\n      (stop> Obj) ) )                  # Stop active object<\/lang>\n\n==[[:Category:PureBasic|PureBasic]][[Category:PureBasic]]==\nUsing the open-source precompiler [http:\/\/www.development-lounge.de\/viewtopic.php?t=5915 SimpleOOP].\n<lang PureBasic>Prototype.d ValueFunction(f.d, t.d)\n\nClass IntegralClass\n  Time0.i\n  Mutex.i\n  S.d\n  Freq.d\n  Thread.i\n  Quit.i\n  *func.ValueFunction\n  \n  Protect Method Sampler()\n    Repeat\n      Delay(1)\n      If This\\func And This\\Mutex\n        LockMutex(This\\Mutex)\n        This\\S + This\\func(This\\Freq, ElapsedMilliseconds()-This\\Time0)\n        UnlockMutex(This\\Mutex)\n      EndIf\n    Until This\\Quit \n  EndMethod\n  \n  BeginPublic\n    Method Input(*func.ValueFunction)\n      LockMutex(This\\Mutex)\n      This\\func = *func\n      UnlockMutex(This\\Mutex)\n    EndMethod\n    \n    Method.d Output()\n      Protected Result.d\n      LockMutex(This\\Mutex)\n      Result = This\\S\n      UnlockMutex(This\\Mutex)\n      MethodReturn Result\n    EndMethod\n    \n    Method Init(F.d, *f)\n      This\\Freq   = F\n      This\\func   = *f\n      This\\Mutex  = CreateMutex()\n      This\\Time0  = ElapsedMilliseconds()\n      This\\Thread = CreateThread(This\\Sampler, This)\n      ThreadPriority(This\\Thread, 10)\n    EndMethod\n    \n    Method Release()\n      This\\Quit = #True\n      WaitThread(This\\Thread)\n    EndMethod\n  EndPublic\n  \nEndClass\n\n;- Procedures for generating values\nProcedure.d n(f.d, t.d)\n  ; Returns nothing\nEndProcedure\n\nProcedure.d f(f.d, t.d)\n  ; Returns the function of this task\n  ProcedureReturn Sin(2*#PI*f*t)\nEndProcedure\n\n;- Test Code\n*a.IntegralClass = NewObject.IntegralClass(0.5, @n()) ; Create the AO\n*a\\Input(@f()) ; Start sampling function f()\nDelay(2000)    ; Delay 2 sec\n*a\\Input(@n()) ; Change to sampling 'nothing'\nDelay( 500)    ; Wait 1\/2 sec\nMessageRequester(\"Info\", StrD(*a\\Output()))           ; Present the result\n*a= FreeObject<\/lang>\n\n==[[:Category:Python|Python]][[Category:Python]]==\nAssignment is thread-safe in Python, so no extra locks are needed in this case.\n\n\n<lang python>from time import time, sleep\nfrom threading import Thread\n\nclass Integrator(Thread):\n    'continuously integrate a function `K`, at each `interval` seconds'\n    def __init__(self, K=lambda t:0, interval=1e-4):\n        Thread.__init__(self)\n        self.interval  = interval\n        self.K   = K\n        self.S   = 0.0\n        self.__run = True\n        self.start()\n\n    def run(self):\n        \"entry point for the thread\"\n        interval = self.interval\n        start = time()\n        t0, k0 = 0, self.K(0)\n        while self.__run:\n            sleep(interval)\n            t1 = time() - start\n            k1 = self.K(t1)\n            self.S += (k1 + k0)*(t1 - t0)\/2.0\n            t0, k0 = t1, k1\n\n    def join(self):\n        self.__run = False\n        Thread.join(self)\n\nif __name__ == \"__main__\":\n    from math import sin, pi\n \n    ai = Integrator(lambda t: sin(pi*t))\n    sleep(2)\n    print ai.S\n    ai.K = lambda t: 0\n    sleep(0.5)\n    print ai.S<\/lang>\n\n==[[:Category:Scala|Scala]][[Category:Scala]]==\n\n<lang Scala>object ActiveObject {\n\n  class Integrator {\n    \n    import java.util._\n    import scala.actors.Actor._\n\n    case class Pulse(t: Double)\n    case class Input(k: Double => Double)\n    case object Output\n    case object Bye\n\n    val timer = new Timer(true)\n    var k: Double => Double = (_ => 0.0)\n    var s: Double = 0.0\n    var t0: Double = 0.0\n\n    val handler = actor {\n      loop {\n        react {\n          case Pulse(t1) => s += (k(t1) + k(t0)) * (t1 - t0) \/ 2.0; t0 = t1\n          case Input(k) => this.k = k\n          case Output => reply(s)\n          case Bye => timer.cancel; exit\n        }\n      }\n    }\n\n    timer.scheduleAtFixedRate(new TimerTask {\n      val start = System.currentTimeMillis\n      def run { handler ! Pulse((System.currentTimeMillis - start) \/ 1000.0) }\n    }, 0, 10) \/\/ send Pulse every 10 ms\n\n    def input(k: Double => Double) = handler ! Input(k)\n    def output = handler !? Output\n    def bye = handler ! Bye\n  }\n\n  def main(args: Array[String]) {\n    val integrator = new Integrator\n    integrator.input(t => Math.sin(2.0 * Math.Pi * 0.5 * t))\n    Thread.sleep(2000)\n    integrator.input(_ => 0.0)\n    Thread.sleep(500)\n    println(integrator.output)\n    integrator.bye\n  }\n}<\/lang>\n\n==[[:Category:Tcl|Tcl]][[Category:Tcl]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Tcl]] version 8.6[[SMW::on]]<\/div> or <div class=\"examplemeta libheader\">'''Library:''' [[SMW::off]][[:Category:TclOO|TclOO]][[Category:TclOO]][[SMW::on]]<\/div>\n\nThis implementation Tcl 8.6 for object support (for the active integrator object) and coroutine support (for the controller task). It could be rewritten to only use 8.5 plus the TclOO library.\n<lang Tcl>package require Tcl 8.6\noo::class create integrator {\n    variable e sum delay tBase t0 k0 aid\n    constructor {{interval 1}} {\n\tset delay $interval\n\tset tBase [clock microseconds]\n\tset t0 0\n\tset e { 0.0 }\n\tset k0 0.0\n\tset sum 0.0\n\tset aid [after $delay [namespace code {my Step}]]\n    }\n    destructor {\n\tafter cancel $aid\n    }\n    method input expression {\n\tset e $expression\n    }\n    method output {} {\n\treturn $sum\n    }\n    method Eval t {\n\texpr $e\n    }\n    method Step {} {\n\tset aid [after $delay [namespace code {my Step}]]\n\tset t [expr {([clock microseconds] - $tBase) \/ 1e6}]\n\tset k1 [my Eval $t]\n\tset sum [expr {$sum + ($k1 + $k0) * ($t - $t0) \/ 2.}]\n\tset t0 $t\n\tset k0 $k1\n    }\n}\n\nset pi 3.14159265\nproc pause {time} {\n    yield [after [expr {int($time * 1000)}] [info coroutine]]\n}\nproc task {script} {\n    coroutine task_ apply [list {} \"$script;set ::done ok\"]\n    vwait done\n}\ntask {\n    integrator create i\n    i input {sin(2*$::pi * 0.5 * $t)}\n    pause 2\n    i input { 0.0 }\n    pause 0.5\n    puts [format %.15f [i output]]\n}<\/lang>\nSample output:\n -0.000000168952702\n\n==[[:Category:Visual Basic .NET|Visual Basic .NET]][[Category:Visual Basic .NET]]==\n\nSince this object is CPU intensive, shutting it down when done is crucial. To facilitate this, the IDisposable pattern was used.\n\n<lang vbnet>Module Module1\n \n    Sub Main()\n        Using active As New Integrator\n            active.Operation = Function(t As Double) Math.Sin(2 * Math.PI * 0.5 * t)\n            Threading.Thread.Sleep(TimeSpan.FromSeconds(2))\n            Console.WriteLine(active.Value)\n            active.Operation = Function(t As Double) 0\n            Threading.Thread.Sleep(TimeSpan.FromSeconds(0.5))\n            Console.WriteLine(active.Value)\n        End Using\n        Console.ReadLine()\n    End Sub\n \nEnd Module\n  \nClass Integrator\n    Implements IDisposable\n \n    Private m_Operation As Func(Of Double, Double)\n    Private m_Disposed As Boolean\n    Private m_SyncRoot As New Object\n    Private m_Value As Double\n \n    Public Sub New()\n        m_Operation = Function(void) 0.0\n        Dim t As New Threading.Thread(AddressOf MainLoop)\n        t.Start()\n    End Sub\n \n    Private Sub MainLoop()\n        Dim epoch = Now\n        Dim t0 = 0.0\n        Do\n            SyncLock m_SyncRoot\n                Dim t1 = (Now - epoch).TotalSeconds\n                m_Value = m_Value + (Operation(t1) + Operation(t0)) * (t1 - t0) \/ 2\n                t0 = t1\n            End SyncLock\n            Threading.Thread.Sleep(10)\n        Loop Until m_Disposed\n    End Sub\n \n    Public Property Operation() As Func(Of Double, Double)\n        Get\n            SyncLock m_SyncRoot\n                Return m_Operation\n            End SyncLock\n        End Get\n        Set(ByVal value As Func(Of Double, Double))\n            SyncLock m_SyncRoot\n                m_Operation = value\n            End SyncLock\n        End Set\n    End Property\n \n    Public ReadOnly Property Value() As Double\n        Get\n            SyncLock m_SyncRoot\n                Return m_Value\n            End SyncLock\n        End Get\n    End Property\n \n    Protected Overridable Sub Dispose(ByVal disposing As Boolean)\n        m_Disposed = True\n    End Sub\n \n    Public Sub Dispose() Implements IDisposable.Dispose\n        Dispose(True)\n        GC.SuppressFinalize(Me)\n    End Sub\n \nEnd Class<\/lang>\n\n\n Output: 0.000241446762282308\n\n[[Category:ACL2\/Omit]]\n[[Category:AWK\/Omit]]\n[[Category:gnuplot\/Omit]]\n[[Category:GUISS\/Omit]]\n[[Category:LaTeX\/Omit]]\n[[Category:Locomotive Basic\/Omit]]\n[[Category:Make\/Omit]]\n[[Category:Metafont\/Omit]]\n[[Category:M4\/Omit]]\n[[Category:ML\/I\/Omit]]\n[[Category:Octave\/Omit]]\n[[Category:PlainTeX\/Omit]]\n[[Category:TI-89 BASIC\/Omit]] \n[[Category:Retro\/Omit]]\n[[Category:UNIX Shell\/Omit]]\n[[Category:ZX Spectrum Basic\/Omit]]"}]}}},"query-continue":{"revisions":{"rvstartid":128145}}}