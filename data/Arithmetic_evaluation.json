{"query-continue":{"search":{"gsroffset":1},"revisions":{"rvstartid":129567}},"query":{"pages":{"2414":{"pageid":2414,"ns":0,"title":"Arithmetic evaluation","revisions":[{"*":"<div class=\"infobox\" style=\"width: 2in\">[[File:Rcode-button-task-crushed.png|64px|left|alt=Task|link=Category:Solutions by Programming Task]]'''Arithmetic evaluation'''<br\/>\nYou are encouraged to [[Rosetta Code:Solve a Task|solve this task]] according to the task description, using any language you may know.[[Category:Programming Tasks]][[Category:Solutions by Programming Task]]<\/div>[[Category:Recursion]]\nCreate a program which parses and evaluates arithmetic expressions.\n\n;Requirements:\n* An [[wp:Abstract_syntax_tree|abstract-syntax tree]] (AST) for the expression must be created from parsing the input. \n* The AST must be used in evaluation, also, so the input may not be directly evaluated (e.g. by calling eval or a similar language feature.) \n* The expression will be a string or list of symbols like \"(1+3)*7\". \n* The four symbols + - * \/ must be supported as binary operators with conventional precedence rules. \n* Precedence-control parentheses must also be supported.\n\n;Note:\nFor those who don't remember, mathematical precedence is as follows:\n* Parentheses\n* Multiplication\/Division (left to right)\n* Addition\/Subtraction (left to right)\n\n\n;C.f: \n* [[24 game Player]].\n* [[Parsing\/RPN calculator algorithm]].\n* [[Parsing\/RPN to infix conversion]].\n\n==[[:Category:Ada|Ada]][[Category:Ada]]==\nSee [[Arithmetic Evaluator\/Ada]].\n\n==[[:Category:ALGOL 68|ALGOL 68]][[Category:ALGOL 68]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[ALGOL 68]] version Revision 1 - no extensions to language used[[SMW::on]]<\/div>\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[ALGOL 68G]] version Any - tested with release [http:\/\/sourceforge.net\/projects\/algol68\/files\/algol68g\/algol68g-1.18.0\/algol68g-1.18.0-9h.tiny.el5.centos.fc11.i386.rpm\/download 1.18.0-9h.tiny][[SMW::on]]<\/div>\n\n<lang algol68>INT base=10;\nMODE FIXED = LONG REAL; # numbers in the format 9,999.999 #\n\n#IF build abstract syntax tree and then EVAL tree #\nMODE AST = UNION(NODE, FIXED);\nMODE NUM = REF AST;\nMODE NODE = STRUCT(NUM a, PROC (FIXED,FIXED)FIXED op, NUM b);\n\nOP EVAL = (NUM ast)FIXED:(\n  CASE ast IN\n    (FIXED num): num,\n    (NODE fork): (op OF fork)(EVAL( a OF fork), EVAL (b OF fork))\n  ESAC\n);\n\nOP + = (NUM a,b)NUM: ( HEAP AST := NODE(a, (FIXED a,b)FIXED:a+b, b) );\nOP - = (NUM a,b)NUM: ( HEAP AST := NODE(a, (FIXED a,b)FIXED:a-b, b) );\nOP * = (NUM a,b)NUM: ( HEAP AST := NODE(a, (FIXED a,b)FIXED:a*b, b) );\nOP \/ = (NUM a,b)NUM: ( HEAP AST := NODE(a, (FIXED a,b)FIXED:a\/b, b) );\nOP **= (NUM a,b)NUM: ( HEAP AST := NODE(a, (FIXED a,b)FIXED:a**b, b) );\n\n#ELSE simply use REAL arithmetic with no abstract syntax tree at all # CO\nMODE NUM = FIXED, AST = FIXED;\nOP EVAL = (FIXED num)FIXED: num;\n#FI# END CO\n\nMODE LEX = PROC (TOK)NUM;\nMODE MONADIC =PROC (NUM)NUM;\nMODE DIADIC = PROC (NUM,NUM)NUM;\n\nMODE TOK = CHAR;\nMODE ACTION = UNION(STACKACTION, LEX, MONADIC, DIADIC);\nMODE OPVAL = STRUCT(INT prio, ACTION action);\nMODE OPITEM = STRUCT(TOK token, OPVAL opval);\n\n[256]STACKITEM stack;\nMODE STACKITEM = STRUCT(NUM value, OPVAL op);\nMODE STACKACTION = PROC (REF STACKITEM)VOID;\n\nPROC begin = (REF STACKITEM top)VOID: prio OF op OF top -:= +10;\nPROC end = (REF STACKITEM top)VOID: prio OF op OF top -:= -10;\n\nOP ** = (COMPL a,b)COMPL: complex exp(complex ln(a)*b);\n\n[8]OPITEM op list :=(\n#  OP  PRIO ACTION #\n  (\"^\", (8, (NUM a,b)NUM: a**b)),\n  (\"*\", (7, (NUM a,b)NUM: a*b)),\n  (\"\/\", (7, (NUM a,b)NUM: a\/b)),\n  (\"+\", (6, (NUM a,b)NUM: a+b)),\n  (\"-\", (6, (NUM a,b)NUM: a-b)),\n  (\"(\",(+10, begin)),\n  (\")\",(-10, end)),\n  (\"?\", (9, LEX:SKIP))\n);\n\nPROC op dict = (TOK op)REF OPVAL:(\n# This can be unrolled to increase performance #\n  REF OPITEM candidate;\n  FOR i TO UPB op list WHILE\n    candidate := op list[i];\n# WHILE # op \/= token OF candidate DO\n    SKIP\n  OD;\n  opval OF candidate\n);\n\nPROC build ast = (STRING expr)NUM:(\n\n  INT top:=0;\n\n  PROC compress ast stack = (INT prio, NUM in value)NUM:(\n    NUM out value := in value;\n    FOR loc FROM top BY -1 TO 1 WHILE \n      REF STACKITEM stack top := stack[loc];\n  # WHILE # ( top >= LWB stack | prio <= prio OF op OF stack top | FALSE ) DO\n      top := loc - 1;\n      out value := \n        CASE action OF op OF stack top IN\n          (MONADIC op): op(value OF stack top), # not implemented #\n          (DIADIC op): op(value OF stack top,out value)\n        ESAC\n    OD;\n    out value\n  );\n\n  NUM value := NIL;\n  FIXED num value;\n  INT decimal places;\n\n  FOR i TO UPB expr DO\n    TOK token = expr[i];\n    REF OPVAL this op := op dict(token); \n    CASE action OF this op IN\n      (STACKACTION action):(\n        IF prio OF thisop = -10 THEN\n          value := compress ast stack(0, value)\n        FI;\n        IF top >= LWB stack THEN\n          action(stack[top])\n        FI\n      ),\n      (LEX):( # a crude lexer #\n        SHORT INT digit = ABS token - ABS \"0\";\n        IF 0<= digit AND digit < base THEN\n          IF NUM(value) IS NIL THEN # first digit #\n            decimal places := 0;\n            value := HEAP AST := num value := digit\n          ELSE\n            NUM(value) := num value := IF decimal places = 0 \n              THEN\n                num value * base + digit\n              ELSE\n                decimal places *:= base;\n                num value + digit \/ decimal places\n              FI\n          FI\n        ELIF token = \".\" THEN\n          decimal places := 1\n        ELSE\n          SKIP # and ignore spaces and any unrecognised characters #\n        FI\n      ),\n      (MONADIC): SKIP, # not implemented #\n      (DIADIC):(\n        value := compress ast stack(prio OF this op, value);\n        IF top=UPB stack THEN index error FI;\n        stack[top+:=1]:=STACKITEM(value, this op);\n        value:=NIL\n      )\n    ESAC\n  OD;\n  compress ast stack(-max int, value)\n);\n\ntest:(\n   printf(($\" euler's number is about: \"g(-long real width,long real width-2)l$,\n     EVAL build ast(\"1+1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(1+1\/15)\/14)\/13)\/12)\/11)\/10)\/9)\/8)\/7)\/6)\/5)\/4)\/3)\/2\")));\n  SKIP EXIT\n  index error:\n    printf((\"Stack over flow\"))\n)<\/lang>\nOutput:\n<pre>\n euler's number is about: 2.71828182845899446428546958\n<\/pre>\n\n==[[:Category:AutoHotkey|AutoHotkey]][[Category:AutoHotkey]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[AutoHotkey_L]][[SMW::on]]<\/div>\n<lang AutoHotkey>\/*\nhand coded recursive descent parser \nexpr\t: term ( ( PLUS | MINUS )  term )* ;\nterm\t: factor ( ( MULT | DIV ) factor )* ;\nfactor\t: NUMBER | '(' expr ')';\n*\/\n\ncalcLexer := makeCalcLexer()\nstring := \"((3+4)*(7*9)+3)+4\"\ntokens := tokenize(string, calcLexer)\nmsgbox % printTokens(tokens)\nast := expr()\nmsgbox % printTree(ast)\nmsgbox % expression := evalTree(ast)\nfiledelete expression.ahk\nfileappend, % \"msgbox % \" expression, expression.ahk\nrun, expression.ahk\nreturn\n\n\nexpr()\n{\n  global tokens\n  ast := object(1, \"expr\")\n  if node := term()\n    ast._Insert(node)    \n  loop \n  {\n    if peek(\"PLUS\") or peek(\"MINUS\")\n    {  \n      op := getsym()\n      newop := object(1, op.type, 2, op.value)\n      node := term()\n      ast._Insert(newop)\n      ast._Insert(node)\n    }\n    Else  \n      Break\n  }\n  return ast\n}\n\nterm()\n{\n  global tokens\n  tree := object(1, \"term\")\n  if node := factor()\n    tree._Insert(node)\n  loop \n  {\n    if  peek(\"MULT\") or peek(\"DIV\")\n    {  \n      op := getsym()\n      newop := object(1, op.type, 2, op.value)\n      node := factor()\n      tree._Insert(newop)\n      tree._Insert(node)\n    }\n    else\n      Break\n  }\n  return tree\n}\n\nfactor()\n{\n  global tokens\n  if peek(\"NUMBER\")\n  {  \n    token := getsym()\n    tree := object(1, token.type, 2, token.value)\n    return tree\n  }\n  else if  peek(\"OPEN\")\n  {\n    getsym()\n    tree := expr()\n    if  peek(\"CLOSE\")\n    {\n      getsym()\n      return tree\n    }\n    else\n      error(\"miss closing parentheses \")\n  }\n  else  \n    error(\"no factor found\")\n}\n\npeek(type, n=1)\n{\nglobal tokens\n  if (tokens[n, \"type\"] == type)\n  return 1\n}\n\ngetsym(n=1)\n{\nglobal tokens\nreturn token := tokens._Remove(n)\n}\n\nerror(msg)\n{\nglobal tokens\nmsgbox % msg \" at:`n\" printToken(tokens[1])\n}\n\n\nprintTree(ast)\n{\nif !ast\nreturn\n\nn := 0\n  loop\n  {\n  n += 1\n    if !node := ast[n]\n      break\n    if !isobject(node)\n      treeString .= node\n    else\n      treeString .= printTree(node)\n  }\n  return (\"(\" treeString \")\" )\n}\n\nevalTree(ast)\n{\nif !ast\nreturn\n\nn := 1\n  loop\n  {\n  n += 1\n    if !node := ast[n]\n      break\n    if !isobject(node)\n      treeString .= node\n    else\n      treeString .= evalTree(node)\n  }\nif (n == 3)\nreturn treeString\n  return (\"(\" treeString \")\" )\n}\n\n#include calclex.ahk<\/lang>\ncalclex.ahk<lang AutoHotkey>tokenize(string, lexer)\n{\n  stringo := string  ; store original string\n  locationInString := 1\n  size := strlen(string)\n  tokens := object()\n  \nstart:\n  Enum := Lexer._NewEnum()\n  While Enum[type, value]  ; loop through regular expression lexing rules\n  {\n    if (1 == regexmatch(string, value, tokenValue))\n    {\n      token := object()     \n      token.pos := locationInString \n      token.value := tokenValue\n      token.length := strlen(tokenValue)\n      token.type := type\n      tokens._Insert(token)\n      locationInString += token.length\n      string := substr(string, token.length + 1)\n      goto start\n    } \n    continue\n  }\n  if (locationInString < size)\n    msgbox % \"unrecognized token at \" substr(stringo, locationInstring)\n  return tokens\n}\n\nmakeCalcLexer()\n{\n  calcLexer := object()\n  PLUS := \"\\+\"\n  MINUS := \"-\"\n  MULT := \"\\*\"\n  DIV := \"\/\"\n  OPEN := \"\\(\"\n  CLOSE := \"\\)\"\n  NUMBER := \"\\d+\"\n  WS := \"[ \\t\\n]+\"\n  END := \"\\.\"\n  RULES := \"PLUS,MINUS,MULT,DIV,OPEN,CLOSE,NUMBER,WS,END\"\n  loop, parse, rules, `,\n  {\n    type := A_LoopField\n    value := %A_LoopField%\n    calcLexer._Insert(type, value)\n  }\n  return calcLexer\n}\n\nprintTokens(tokens)\n{\n  loop % tokens._MaxIndex()\n  {  \n    tokenString .= printToken(tokens[A_Index]) \"`n`n\"\n  }\n  return tokenString\n}\n\n\nprintToken(token)\n{\n  string := \"pos= \" token.pos \"`nvalue= \" token.value \"`ntype= \" token.type\n  return string\n}<\/lang>\n\n==[[:Category:C|C]][[Category:C]]==\nSee [[Arithmetic Evaluator\/C]].\n\n==[[:Category:C++|C++]][[Category:C++]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[g++]] version 4.1.2 20061115 (prerelease) (SUSE Linux)[[SMW::on]]<\/div>\n\n<div class=\"examplemeta libheader\">'''Library:''' [[SMW::off]][[:Category:Boost.Spirit|Boost.Spirit]][[Category:Boost.Spirit]][[SMW::on]]&nbsp;'''version''' 1.8.4<\/div>\n<lang cpp> #include <boost\/spirit.hpp>\n #include <boost\/spirit\/tree\/ast.hpp>\n #include <string>\n #include <cassert>\n #include <iostream>\n #include <istream>\n #include <ostream>\n \n using boost::spirit::rule;\n using boost::spirit::parser_tag;\n using boost::spirit::ch_p;\n using boost::spirit::real_p;\n \n using boost::spirit::tree_node;\n using boost::spirit::node_val_data;\n \n \/\/ The grammar\n struct parser: public boost::spirit::grammar<parser>\n {\n   enum rule_ids { addsub_id, multdiv_id, value_id, real_id };\n \n   struct set_value\n   {\n     set_value(parser const& p): self(p) {}\n     void operator()(tree_node<node_val_data<std::string::iterator,\n                                             double> >& node,\n                     std::string::iterator begin,\n                     std::string::iterator end) const\n     {\n       node.value.value(self.tmp);\n     }\n     parser const& self;\n   };\n \n   mutable double tmp;\n \n   template<typename Scanner> struct definition\n   {\n     rule<Scanner, parser_tag<addsub_id> > addsub;\n     rule<Scanner, parser_tag<multdiv_id> > multdiv;\n     rule<Scanner, parser_tag<value_id> > value;\n     rule<Scanner, parser_tag<real_id> > real;\n \n     definition(parser const& self)\n     {\n       using namespace boost::spirit;\n       addsub = multdiv\n         >> *((root_node_d[ch_p('+')] | root_node_d[ch_p('-')]) >> multdiv);\n       multdiv = value\n         >> *((root_node_d[ch_p('*')] | root_node_d[ch_p('\/')]) >> value);\n       value = real | inner_node_d[('(' >> addsub >> ')')];\n       real = leaf_node_d[access_node_d[real_p[assign_a(self.tmp)]][set_value(self)]];\n     }\n \n     rule<Scanner, parser_tag<addsub_id> > const& start() const\n     {\n       return addsub;\n     }\n   };\n };\n \n template<typename TreeIter>\n double evaluate(TreeIter const& i)\n {\n   double op1, op2;\n   switch (i->value.id().to_long())\n   {\n   case parser::real_id:\n     return i->value.value();\n   case parser::value_id:\n   case parser::addsub_id:\n   case parser::multdiv_id:\n     op1 = evaluate(i->children.begin());\n     op2 = evaluate(i->children.begin()+1);\n     switch(*i->value.begin())\n     {\n     case '+':\n       return op1 + op2;\n     case '-':\n       return op1 - op2;\n     case '*':\n       return op1 * op2;\n     case '\/':\n       return op1 \/ op2;\n     default:\n       assert(!\"Should not happen\");\n     }\n   default:\n     assert(!\"Should not happen\");\n   }\n   return 0;\n }\n \n \/\/ the read\/eval\/write loop\n int main()\n {\n   parser eval;\n   std::string line;\n   while (std::cout << \"Expression: \"\n          && std::getline(std::cin, line)\n          && !line.empty())\n   {\n     typedef boost::spirit::node_val_data_factory<double> factory_t;\n     boost::spirit::tree_parse_info<std::string::iterator, factory_t> info =\n       boost::spirit::ast_parse<factory_t>(line.begin(), line.end(),\n                                           eval, boost::spirit::space_p);\n     if (info.full)\n     {\n       std::cout << \"Result: \" << evaluate(info.trees.begin()) << std::endl;\n     }\n     else\n     {\n       std::cout << \"Error in expression.\" << std::endl;\n     }\n   }\n };<\/lang>\n\n==[[:Category:Clojure|Clojure]][[Category:Clojure]]==\n<lang Clojure>(def precedence '{* 0, \/ 0\n\t\t  + 1, - 1})\n\n(defn order-ops\n  \"((A x B) y C) or (A x (B y C)) depending on precedence of x and y\"\n  [[A x B y C & more]]\n  (let [ret (if (<=  (precedence x)\n\t\t     (precedence y))\n\t      (list (list A x B) y C)\n\t      (list A x (list B y C)))]\n    (if more\n      (recur (concat ret more))\n      ret)))\n\n(defn add-parens\n  \"Tree walk to add parens.  All lists are length 3 afterwards.\"\n  [s]\n  (clojure.walk\/postwalk\n   #(if (seq? %)\n      (let [c (count %)]\n\t(cond (even? c) (throw (Exception. \"Must be an odd number of forms\"))\n\t      (= c 1) (first %)\n\t      (= c 3) %\n\t      (>= c 5) (order-ops %)))\n      %)\n   s))\n\n(defn make-ast\n  \"Parse a string into a list of numbers, ops, and lists\"\n  [s]\n  (-> (format \"'(%s)\" s)\n      (.replaceAll , \"([*+-\/])\" \" $1 \")\n      load-string\n      add-parens))\n\n(def ops {'* *\n\t  '+ +\n\t  '- -\n\t  '\/ \/})\n\n(def eval-ast\n     (partial clojure.walk\/postwalk\n\t      #(if (seq? %)\n\t\t (let [[a o b] %]\n\t\t   ((ops o) a b))\n\t\t %)))\n\n(defn evaluate [s]\n  \"Parse and evaluate an infix arithmetic expression\"\n  (eval-ast (make-ast s)))\n\nuser> (evaluate \"1 + 2*(3 - 2*(3 - 2)*((2 - 4)*5 - 22\/(7 + 2*(3 - 1)) - 1)) + 1\")\n60<\/lang>\n\n==[[:Category:Common Lisp|Common Lisp]][[Category:Common Lisp]]==\n\nThe following code processes the data in a pipeline of steps which are combined in the <code>evaluate<\/code> function.\n\nFirst, the string is converted into a sequence of tokens, represented as a list.  Operator tokens are represented directly by the corresponding Lisp symbols, and the integer terms are represented by Lisp integer objects. The symbols <code>:lparen<\/code> and <code>:rparen<\/code> represent the the parentheses. So for instance the input\n<code>\"1*(3+2)\"<\/code> tokenizes as <code>(1 * :lparen 3 + 2 :rparen)<\/code>.\n\nNext, that sequence of tokens is then transformed by eliminating the parentheses. Subsequences of the form <code>:lparen ... :rparen<\/code> with a sublist containing the tokens between the <code>:lparen<\/code> and <code>:rparen<\/code>. The sequence now has an intermediate tree structure, in which parenthesized fragments like <code>1 + 2 * 3 + 4 \/ 9<\/code> still remain flat.\n\nAt this point, another processing stage parses the operator precedence, and fully parenthesizes fragments, turning <code>(1 + 2 \/ 3 + 5)<\/code> into <code>(1 + (2 \/ 3) + 5)<\/code>. The result is a Lisp-ified infix representation.\n\nFinally, this infix representation can be easily converted to prefix, forming the final AST which is a Lisp expression. \n(Lisp expressions '''are''' abstract syntax trees!) This representation evaluates directly with <code>eval<\/code>.\n\nThis implementation can read integers, and produce integral and rational values.\n\n<lang lisp>(defun tokenize-stream (stream)\n  (labels ((whitespace-p (char)\n             (find char #(#\\space #\\newline #\\return #\\tab)))\n           (consume-whitespace ()\n             (loop while (whitespace-p (peek-char nil stream nil #\\a))\n                   do (read-char stream)))\n           (read-integer ()\n             (loop while (digit-char-p (peek-char nil stream nil #\\space))\n                   collect (read-char stream) into digits\n                   finally (return (parse-integer (coerce digits 'string))))))\n    (consume-whitespace)\n    (let ((c (peek-char nil stream nil nil)))\n      (let ((token (case c\n                     ((nil) nil)\n                     ((#\\() :lparen)\n                     ((#\\)) :rparen)\n                     ((#\\*) '*)\n                     ((#\\\/) '\/)\n                     ((#\\+) '+)\n                     ((#\\-) '-)\n                     (otherwise\n                       (unless (digit-char-p c)\n                         (cerror \"Skip it.\" \"Unexpected character ~w.\" c)\n                         (read-char stream)\n                         (return-from tokenize-stream\n                                      (tokenize-stream stream)))\n                       (read-integer)))))\n        (unless (or (null token) (integerp token))\n          (read-char stream))\n        token))))\n\n(defun group-parentheses (tokens &optional (delimited nil))\n  (do ((new-tokens '()))\n      ((endp tokens)\n       (when delimited\n         (cerror \"Insert it.\"  \"Expected right parenthesis.\"))\n       (values (nreverse new-tokens) '()))\n    (let ((token (pop tokens)))\n      (case token\n        ((:lparen)\n         (multiple-value-bind (group remaining-tokens)\n             (group-parentheses tokens t)\n           (setf new-tokens (cons group new-tokens)\n                 tokens remaining-tokens)))\n        ((:rparen)\n         (if (not delimited)\n           (cerror \"Ignore it.\" \"Unexpected right parenthesis.\")\n           (return (values (nreverse new-tokens) tokens))))\n        (otherwise\n         (push token new-tokens))))))\n\n(defun group-operations (expression)\n  (flet ((gop (exp) (group-operations exp)))\n    (if (integerp expression)\n      expression\n      (destructuring-bind (a &optional op1 b op2 c &rest others)\n                          expression\n        (unless (member op1 '(+ - * \/ nil))\n          (error \"syntax error: in expr ~a expecting operator, not ~a\"\n                 expression op1))\n        (unless (member op2 '(+ - * \/ nil))\n          (error \"syntax error: in expr ~a expecting operator, not ~a\"\n                 expression op2))\n        (cond\n         ((not op1) (gop a))\n         ((not op2) `(,(gop a) ,op1 ,(gop b)))\n         (t (let ((a (gop a)) (b (gop b)) (c (gop c)))\n              (if (and (member op1 '(+ -)) (member op2 '(* \/)))\n                (gop `(,a ,op1 (,b ,op2 ,c) ,@others))\n                (gop `((,a ,op1 ,b) ,op2 ,c ,@others))))))))))\n\n(defun infix-to-prefix (expression)\n  (if (integerp expression)\n    expression\n    (destructuring-bind (a op b) expression\n      `(,op ,(infix-to-prefix a) ,(infix-to-prefix b)))))\n\n(defun evaluate (string)\n  (with-input-from-string (in string)\n    (eval\n      (infix-to-prefix\n        (group-operations\n          (group-parentheses\n            (loop for token = (tokenize-stream in)\n                  until (null token)\n                  collect token)))))))<\/lang>\n \nExamples\n\n > (evaluate \"1 - 5 * 2 \/ 20 + 1\")\n 3\/2\n\n > (evaluate \"(1 - 5) * 2 \/ (20 + 1)\")\n -8\/21\n\n > (evaluate \"2 * (3 + ((5) \/ (7 - 11)))\")\n 7\/2\n\n > (evaluate \"(2 + 3) \/ (10 - 5)\")\n 1\n\nExamples of error handling\n\n<pre>> (evaluate \"(3 * 2) a - (1 + 2) \/ 4\")\n\n Error: Unexpected character a.\n  1 (continue) Skip it.\n  2 (abort) Return to level 0.\n  3 Return to top loop level 0.\n\nType :b for backtrace, :c <option number> to proceed,  or :? for other options\n\n : 1 > :c 1\n21\/4<\/pre>\n\n<pre>> (evaluate \"(3 * 2) - (1 + 2) \/ (4\")\n\nError: Expected right parenthesis.\n  1 (continue) Insert it.\n  2 (abort) Return to level 0.\n  3 Return to top loop level 0.\n\nType :b for backtrace, :c <option number> to proceed,  or :? for other options\n\n: 1 > :c 1\n21\/4<\/pre>\n\n==[[:Category:D|D]][[Category:D]]==\nFollowing the previous number-operator dual stacks approach, an AST is built while previous version is evaluating the expression value. After the AST tree is constructed, a visitor pattern is used to display the AST structure and calculate the value.\n<lang d>\/\/module evaluate ;\nimport std.stdio, std.string, std.ctype, std.conv ;\n\n\/\/ simple stack template\nvoid push(T)(inout T[] stk, T top) { stk ~= top ; }\nT pop(T)(inout T[] stk, bool discard = true) {\n  T top ;\n  if (stk.length == 0) throw new Exception(\"Stack Empty\") ;\n  top = stk[$-1] ;\n  if (discard) stk.length = stk.length - 1 ;\n  return top ;\n}\n\nalias int Type ;\nenum { Num, OBkt, CBkt, Add, Sub, Mul, Div } ; \/\/ Type\nstring[] opChar = [\"#\",\"(\",\")\",\"+\",\"-\",\"*\",\"\/\"] ;\nint[]    opPrec = [0,-9,-9,1,1,2,2] ;\n\nabstract class Visitor { void visit(XP e) ; } \n\nclass XP {\n  Type type ;\n  string str ;\n  int pos ;  \/\/ optional, for dispalying AST struct.\n  XP LHS, RHS = null ;\n  this(string s = \")\", int p = -1) {\n    str = s ; pos = p ;\n    type = Num ;\n    for(Type t = Div ; t > Num ; t--)\n      if(opChar[t] == s) type = t ;\n  }\n  int opCmp(XP rhs) { return opPrec[type] - opPrec[rhs.type] ; }\n  void accept(Visitor v) { v.visit(this) ; } ;\n}\n\nclass AST {\n  XP root ;\n  XP[] num, opr ;\n  string xpr, token ;\n  int xpHead, xpTail ;\n\n  void joinXP(XP x) { x.RHS = num.pop() ; x.LHS = num.pop() ; num.push(x) ; }\n\n  string nextToken() {\n    while (xpHead < xpr.length && xpr[xpHead] == ' ') \n      xpHead++ ; \/\/ skip spc\n    xpTail = xpHead ;\n    if(xpHead < xpr.length) {\n      token = xpr[xpTail..xpTail+1] ;\n      switch(token) {\n        case \"(\",\")\",\"+\",\"-\",\"*\",\"\/\": \/\/ valid non-number\n          xpTail++ ; \n          return token ;\n        default: \/\/ should be number\n          if(isdigit(token[0])) {\n            while(xpTail < xpr.length && isdigit(xpr[xpTail]))\n              xpTail++ ;\n            return xpr[xpHead..xpTail] ;          \n          } \/\/ else may be error \n      } \/\/ end switch \n    }\n    if(xpTail < xpr.length)\n      throw new Exception(\"Invalid Char <\" ~ xpr[xpTail] ~ \">\") ; \n    return null ;\n  } \/\/ end nextToken\n\n  AST parse(string s) {\n    bool expectingOP ;\n    xpr = s ;\n    try {\n      xpHead = xpTail = 0 ; \n      num = opr = null ;\n      root = null ;\n      opr.push(new XP) ; \/\/ CBkt, prevent evaluate null OP precidence\n      while((token = nextToken) !is null) {\n        XP tokenXP = new XP(token, xpHead) ;\n        if(expectingOP) {   \/\/ process OP-alike XP\n          switch(token) {\n            case \")\":\n              while(opr.pop(false).type != OBkt)\n                joinXP(opr.pop()) ;\n              opr.pop() ;\n              expectingOP = true ; break ;\n            case \"+\",\"-\",\"*\",\"\/\":\n              while (tokenXP <= opr.pop(false))\n                joinXP(opr.pop()) ;\n              opr.push(tokenXP) ;\n              expectingOP = false ; break ;\n            default:\n              throw new Exception(\"Expecting Operator or ), not <\" ~ token ~ \">\") ;\n          }\n        } else {            \/\/ process Num-alike XP\n          switch(token) {\n            case \"+\",\"-\",\"*\",\"\/\",\")\":\n              throw new Exception(\"Expecting Number or (, not <\" ~ token ~ \">\") ;\n            case \"(\":\n              opr.push(tokenXP) ;\n              expectingOP = false ; break ;\n            default: \/\/ number\n              num.push(tokenXP) ;\n              expectingOP = true ; \n          }\n        } \n        xpHead = xpTail ;       \n      } \/\/ end while              \n      \n      while (opr.length > 1) \/\/ join pending Op\n        joinXP(opr.pop()) ;\n        \n    }catch(Exception e) {\n      writefln(\"%s\\n%s\\n%s^\", e.msg, xpr, repeat(\" \", xpHead)) ;\n      root = null ;\n      return this ;\n    }\n  \n    if(num.length != 1) { \/\/ should be one XP left\n      writefln(\"Parse Error...\") ;\n      root = null ;\n    } else\n      root = num.pop() ;\n    return this ;\n  } \/\/ end Parse\n\n}  \/\/ end class AST\n\n\/\/ for display AST fancy struct\nvoid ins(inout char[][] s, string v, int p, int l) {\n  while(s.length < l + 1) s.length = s.length + 1 ;\n  while(s[l].length < p + v.length + 1) s[l] ~= \" \" ;\n  s[l][p..p +v.length] = v ;    \n}\n\nclass calcVis : Visitor {\n  int result, level = 0 ;\n  string Result = null ;\n  char[][] Tree = null ;\n  static void opCall(AST a) {\n    if (a && a.root) {\n      calcVis c = new calcVis ;\n      a.root.accept(c) ;\n      for(int i = 1; i < c.Tree.length ; i++) { \/\/ more fancy\n        bool flipflop = false ; char mk = '.' ;\n        for(int j = 0 ; j < c.Tree[i].length ; j++) {\n          while(j >= c.Tree[i-1].length) c.Tree[i-1] ~= \" \" ;         \n          char c1 = c.Tree[i][j] ; char c2 = c.Tree[i-1][j] ;\n          if(flipflop && (c1 == ' ') && c2 == ' ')\n            c.Tree[i-1][j] = mk ;\n          if(c1 != mk && c1 != ' ' && (j == 0 || !isdigit(c.Tree[i][j-1])))\n            flipflop = !flipflop ;\n        }\n      }\n      foreach(t; c.Tree) writefln(t) ;\n      writefln(\"%s ==>\\n%s = %s\", a.xpr,c.Result,c.result) ;\n    } else\n      writefln(\"Evalute invalid or null Expression\") ;\n  }\n  void visit(XP xp) {\/\/ calc. the value, display AST struct and eval order.\n    ins(Tree, xp.str, xp.pos, level) ;\n    level++ ;\n    if (xp.type == Num) {\n      Result ~= xp.str ;\n      result = toInt(xp.str) ;\n    } else {\n      Result ~= \"(\" ;\n      xp.LHS.accept(this) ;\n      int lhs = result ; \n      Result ~= opChar[xp.type] ;\n      xp.RHS.accept(this) ;\n      Result ~= \")\" ;\n      switch(xp.type) {\n        case Add: result = lhs + result ; break ;\n        case Sub: result = lhs - result ; break ;\n        case Mul: result = lhs * result ; break ;\n        case Div: result = lhs \/ result ; break ;\n        default: throw new Exception(\"Invalid type\") ;\n      }\n    } \/\/ \n    level-- ;\n  }\n}\n\nvoid main(string[] args) {\n  string expression = args.length > 1 ? join(args[1..$],\" \") : \n    \"1 + 2*(3 - 2*(3 - 2)*((2 - 4)*5 - 22\/(7 + 2*(3 - 1)) - 1)) + 1\" ; \/\/ should be 60    \n  calcVis((new AST).parse(expression)) ;\n}<\/lang>\n\n==[[:Category:E|E]][[Category:E]]==\n\nWhile the task requirements specify not evaluating using the language's built-in eval, they don't say that you have to write your own ''parser''...\n\n<lang e>def eParser := <elang:syntax.makeEParser>\ndef LiteralExpr := <elang:evm.makeLiteralExpr>.asType()\ndef arithEvaluate(expr :String) {\n  def ast := eParser(expr)\n  \n  def evalAST(ast) {\n    return switch (ast) {\n      match e`@a + @b` { evalAST(a) + evalAST(b) }\n      match e`@a - @b` { evalAST(a) - evalAST(b) }\n      match e`@a * @b` { evalAST(a) * evalAST(b) }\n      match e`@a \/ @b` { evalAST(a) \/ evalAST(b) }\n      match e`-@a` { -(evalAST(a)) }\n      match l :LiteralExpr { l.getValue() }\n    }\n  }\n  \n  return evalAST(ast)\n}<\/lang>\n\nParentheses are handled by the parser.\n\n<lang e>? arithEvaluate(\"1 + 2\")\n# value: 3\n\n? arithEvaluate(\"(1 + 2) * 10 \/ 100\")\n# value: 0.3\n\n? arithEvaluate(\"(1 + 2 \/ 2) * (5 + 5)\")\n# value: 20.0<\/lang>\n\n==[[:Category:Elena|Elena]][[Category:Elena]]==\n<lang elena>#define std'dictionary'*.\n#define std'basic'*.\n#define std'patterns'*.\n#define ext'io'*.\n#define ext'convertors'*.\n\n#subject parse_order.\n\n#class Token\n{\n    #field theValue.\n    \n    #method parse_order'get = 0.\n    \n    #method += aChar\n    [\n        theValue += aChar.\n    ]\n    \n    #method + aNode\n    [\n        ^ aNode += self.\n    ]\n    \n    #method new\n    [\n        theValue := String.\n    ]\n    \n    #method numeric = theValue~EReal64Convertor numeric.\n}\n\n#class Node\n{\n    #field theLeft.\n    #field theRight.\n    \n    #role Empty\n    {\n        #method += aNode\n        [\n            theLeft := aNode.            \n            $self $setLeftAssigned.\n        ]\n    }\n    \n    #role LeftAssigned\n    {\n        #method += aNode\n        [\n            theRight := aNode.\n            #shift.\n        ]\n    }\n    \n    #method $setLeftAssigned\n    [\n        #shift LeftAssigned.\n    ]\n\n    #method + aNode\n    [\n        #if (self parse_order > aNode parse_order)?\n        [\n            self += aNode.\n        ]\n        | [\n            aNode += self.            \n            ^ aNode.\n        ].\n    ]\n        \n    #method += aNode\n    [\n        #if (theRight parse_order > aNode parse_order)?\n        [\n            theRight += aNode.\n        ]\n        | [\n            theRight := aNode += theRight.\n        ].        \n    ]\n    \n    #method new\n    [\n        #shift Empty.\n    ]\n}\n\n#class SummaryNode (Node)\n{\n    #method parse_order'get = 2.\n    \n    #method numeric = theLeft numeric + theRight numeric.\n}\n\n#class DifferenceNode (Node)\n{\n    #method parse_order'get = 2.\n    \n    #method numeric = theLeft numeric - theRight numeric.\n}\n\n#class ProductNode (Node)\n{\n    #method parse_order'get = 1.\n    \n    #method numeric = theLeft numeric * theRight numeric.\n}\n\n#class FractionNode (Node)\n{\n    #method parse_order'get = 1.\n    \n    #method numeric = theLeft numeric \/ theRight numeric.\n}\n\n#class SubExpression\n{\n    #field theParser.\n    #field theCounter.\n    \n    #role EOF\n    {\n        #method eof'is []\n        \n        #method += aChar [ $self fail. ]\n    }\n    \n    #method parse_order'get = 0.\n    \n    #method + aNode\n    [\n        ^ aNode += self.\n    ]\n    \n    #method append : aChar\n    [\n        #var aCode := Int32Value::aChar.\n        #if control if:(aCode == 41)\n        [\n            theCounter -= 1.\n        ]\n        | if:(aCode == 40)\n        [\n            theCounter += 1.\n        ].\n        #if(theCounter == 0)?\n            [ #shift EOF. ^ $self. ].\n        theParser evaluate:aChar.\n    ]\n    \n    #method numeric = theParser numeric.\n    \n    #method new\n    [\n        theParser := arithmeval'Parser.\n        theCounter := Integer << 1.\n    ]\n}\n\n#class Parser\n{\n    #field theToken.\n    #field theTopNode.\n    \n    #role Start\n    {\n        #method evaluate : aChar\n        [\n            #if (40 == aChar)?\n            [\n                theToken := SubExpression.\n                theTopNode := theToken.\n                $self $setBrackets.\n            ]\n            | [\n                theToken := Token.\n                theTopNode := theToken.\n                theToken += aChar.\n                #shift.\n            ].\n        ]\n    }\n    \n    #role Brackets\n    {\n        #method evaluate : aChar\n        [\n            theToken += aChar.\n            \n            #if theToken eof'is\n            [\n                #shift.\n            ].\n        ]\n    }\n    \n    #role Operator\n    {\n        #method evaluate : aChar\n        [\n            #if Control if:(48 < aChar) if:(58 > aChar)\n            [\n                theToken := (Token += aChar).\n                \n                theTopNode += theToken.\n                \n                #shift.\n            ]\n            | if:(40 == aChar)\n            [\n                theToken := SubExpression.\n                theTopNode += theToken.\n                \n                #shift Brackets.\n            ]\n            | [ $self fail. ].\n        ]\n    }\n    \n    #method numeric = theTopNode numeric.\n    \n    #method evaluate : aChar\n    [\n        #if Control if:(48 < aChar) if:(58 > aChar)\n        [\n            theToken += aChar.\n        ]\n        | if:(42 == aChar)  \/\/ *\n        [\n            theTopNode := theTopNode + ProductNode.\n            \n            #shift Operator.\n        ]\n        | if:(47 == aChar)  \/\/ \/\n        [\n            theTopNode := theTopNode + FractionNode.\n            \n            #shift Operator.\n        ]\n        | if:(43 == aChar)  \/\/ +\n        [\n            theTopNode := theTopNode + SummaryNode.\n            \n            #shift Operator.\n        ]\n        | if:(45 == aChar)  \/\/ -\n        [\n            theTopNode := theTopNode + DifferenceNode.\n            \n            #shift Operator.\n        ]\n        | if:(40 == aChar)\n        [\n            theToken := SubExpression.\n            theTopNode := theToken.\n            \n            #shift Brackets.\n        ]\n        | [ $self fail. ].\n    ]\n    \n    #method new\n    [\n        #shift Start.\n    ]\n    \n    #method $setBrackets\n    [\n        #shift Brackets.\n    ]\n}\n\n#symbol Program =>\n[\n    #var aText := String.\n    \n    #loop ((Console >> aText) length > 0)?\n    [\n        #var aParser := Parser.\n\n        Console << \"=\" << aText then: aText =>\n        [\n            Scan::aText run:aParser.\n            \n            ^ aParser numeric.\n        ]\n        | << \"Invalid Expression\".\n        \n        Console << \"%n\".\n    ].\n].\n<\/lang>\n\n=== ELENA VM script ===\n<lang elena>numeric           ::= \"(\" sub_expr;\nnumeric           ::= $numeric;\nfactor            ::= $numeric factor_r;\nfactor            ::= \"(\" sub_expr;\nsum               ::= \"+\" factor ;\ndifference        ::= \"-\" factor ;\nmultiply          ::= \"*\" numeric;\ndivide            ::= \"\/\" numeric;\nfactor_r          ::= multiply factor_r;\nfactor_r          ::= divide factor_r;\nfactor_r          ::= $eps;\nexpr_r            ::= sum expr_r;\nexpr_r            ::= difference expr_r;\nexpr_r            ::= $eps;\nneg_r             ::= factor_r expr_r;\nsub_expr          ::= expression sub_expr_r;\nsub_expr_r        ::= \")\" factor_r;\nneg_expression    ::= $numeric neg_r;\nexpression        ::= factor expr_r;\nexpression        ::= \"-\" neg_expression;\nprint             ::= \"?\" expression;\nstart             ::= print;\nprint             => &nil 'program'output $body ^write;\nmultiply          => $body ^multiply;\ndivide            => $body ^divide;\nsum               => $body ^add;\ndifference        => $body ^subtract;\nneg_expression    => 0 $token ^subtract;<\/lang>\n\n==[[:Category:Factor|Factor]][[Category:Factor]]==\n<lang factor>USING: accessors kernel locals math math.parser peg.ebnf ;\nIN: rosetta.arith\n\nTUPLE: operator left right ;\nTUPLE: add < operator ;   C: <add> add\nTUPLE: sub < operator ;   C: <sub> sub\nTUPLE: mul < operator ;   C: <mul> mul\nTUPLE: div < operator ;   C: <div> div\n\nEBNF: expr-ast\nspaces   = [\\n\\t ]*\ndigit    = [0-9]\nnumber   = (digit)+                         => [[ string>number ]]\n\nvalue    =   spaces number:n                => [[ n ]]\n           | spaces \"(\" exp:e spaces \")\"    => [[ e ]]\n\nfac      =   fac:a spaces \"*\" value:b       => [[ a b <mul> ]]\n           | fac:a spaces \"\/\" value:b       => [[ a b <div> ]]\n           | value\n\nexp      =   exp:a spaces \"+\" fac:b         => [[ a b <add> ]]\n           | exp:a spaces \"-\" fac:b         => [[ a b <sub> ]]\n           | fac\n\nmain     = exp:e spaces !(.)                => [[ e ]]\n;EBNF\n\nGENERIC: eval-ast ( ast -- result )\n\nM: number eval-ast ;\n\n: recursive-eval ( ast -- left-result right-result )\n    [ left>> eval-ast ] [ right>> eval-ast ] bi ;\n\nM: add eval-ast recursive-eval + ;\nM: sub eval-ast recursive-eval - ;\nM: mul eval-ast recursive-eval * ;\nM: div eval-ast recursive-eval \/ ;\n\n: evaluate ( string -- result )\n    expr-ast eval-ast ;<\/lang>\n\n==<span id=\"F_Sharp\">[[:Category:F_Sharp|F#]]<\/span>[[Category:F_Sharp]]==\nUsing FsLex and FsYacc from the F# PowerPack, we implement this with multiple source files:\n\n<code>AbstractSyntaxTree.fs<\/code>:\n<lang fsharp>module AbstractSyntaxTree\n \ntype Expression = \n  | Int    of int \n  | Plus   of Expression * Expression \n  | Minus  of Expression * Expression \n  | Times  of Expression * Expression \n  | Divide of Expression * Expression<\/lang>\n\n<code>Lexer.fsl<\/code>:\n<lang fsharp>{\nmodule Lexer\n\nopen Parser  \/\/ we need the terminal tokens from the Parser\n\nlet lexeme = Lexing.LexBuffer<_>.LexemeString\n}\n\nlet intNum     = '-'? ['0'-'9']+\nlet whitespace = ' ' | '\\t'\nlet newline    = '\\n' | '\\r' '\\n'\n\nrule token = parse\n    | intNum     { INT (lexeme lexbuf |> int) }\n    | '+'        { PLUS }\n    | '-'        { MINUS }\n    | '*'        { TIMES }\n    | '\/'        { DIVIDE }\n    | '('        { LPAREN }\n    | ')'        { RPAREN }\n    | whitespace { token lexbuf }\n    | newline    { lexbuf.EndPos <- lexbuf.EndPos.NextLine; token lexbuf }\n    | eof        { EOF }\n    | _          { failwithf \"unrecognized input: '%s'\" <| lexeme lexbuf }<\/lang>\n\n<code>Parser.fsy<\/code>:\n<lang fsharp>%{ \nopen AbstractSyntaxTree \n%} \n\n%start Expr \n\n\/\/ terminal tokens\n%token <int> INT \n%token PLUS MINUS TIMES DIVIDE LPAREN RPAREN\n%token EOF\n\n\/\/ associativity and precedences\n%left PLUS MINUS \n%left TIMES DIVIDE\n\n\/\/ return type of Expr\n%type <Expression> Expr\n \n%% \n \nExpr: INT                     { Int $1 } \n    | Expr PLUS Expr          { Plus ($1, $3) } \n    | Expr MINUS Expr         { Minus ($1, $3) } \n    | Expr TIMES Expr         { Times ($1, $3) } \n    | Expr DIVIDE Expr        { Divide ($1, $3) } \n    | LPAREN Expr RPAREN      { $2 } <\/lang>\n\n<code>Program.fs<\/code>:\n<lang fsharp>open AbstractSyntaxTree\nopen Lexer\nopen Parser \n\nlet parse txt =\n  txt\n  |> Lexing.LexBuffer<_>.FromString\n  |> Parser.Expr Lexer.token\n\nlet rec eval = function\n  | Int i        -> i\n  | Plus (a,b)   -> eval a + eval b\n  | Minus (a,b)  -> eval a - eval b\n  | Times (a,b)  -> eval a * eval b\n  | Divide (a,b) -> eval a \/ eval b\n\ndo\n  \"((11+15)*15)*2-(3)*4*1\"\n  |> parse \n  |> eval\n  |> printfn \"%d\"<\/lang>\n\n==[[:Category:Go|Go]][[Category:Go]]==\n\nSee [[Arithmetic Evaluator\/Go]]\n\n\n==[[:Category:Groovy|Groovy]][[Category:Groovy]]==\nSolution:\n<lang groovy>enum Op {\n    ADD('+', 2),\n    SUBTRACT('-', 2),\n    MULTIPLY('*', 1),\n    DIVIDE('\/', 1);\n    \n    static {\n        ADD.operation = { a, b -> a + b }\n        SUBTRACT.operation = { a, b -> a - b }\n        MULTIPLY.operation = { a, b -> a * b }\n        DIVIDE.operation = { a, b -> a \/ b }\n    }\n    \n    final String symbol\n    final int precedence\n    Closure operation\n\n    private Op(String symbol, int precedence) {\n        this.symbol = symbol\n        this.precedence = precedence\n    }\n\n    String toString() { symbol }\n\n    static Op fromSymbol(String symbol) {\n        Op.values().find { it.symbol == symbol }\n    }\n}\n\ninterface Expression {\n    Number evaluate();\n}\n\nclass Constant implements Expression {\n    Number value\n\n    Constant (Number value) { this.value = value }\n\n    Constant (String str) {\n        try { this.value = str as BigInteger }\n        catch (e) { this.value = str as BigDecimal }\n    }\n\n    Number evaluate() { value }\n\n    String toString() { \"${value}\" }\n}\n\nclass Term implements Expression {\n    Op op\n    Expression left, right\n\n    Number evaluate() { op.operation(left.evaluate(), right.evaluate()) }\n\n    String toString() { \"(${op} ${left} ${right})\" }\n}\n\nvoid fail(String msg, Closure cond = {true}) {\n    if (cond()) throw new IllegalArgumentException(\"Cannot parse expression: ${msg}\")\n}\n\nExpression parse(String expr) {\n    def tokens = tokenize(expr)\n    def elements = groupByParens(tokens, 0)\n    parse(elements)\n}\n\nList tokenize(String expr) {\n    def tokens = []\n    def constStr = \"\"\n    def captureConstant = { i ->\n        if (constStr) {\n            try { tokens << new Constant(constStr) }\n            catch (NumberFormatException e) { fail \"Invalid constant '${constStr}' near position ${i}\" }\n            constStr = ''\n        }\n    }\n    for(def i = 0; i<expr.size(); i++) {\n        def c = expr[i]\n        def constSign = c in ['+','-'] && constStr.empty && (tokens.empty || tokens[-1] != ')') \n        def isConstChar = { it in ['.'] + ('0'..'9') || constSign }\n        if (c in ([')'] + Op.values()*.symbol) && !constSign) { captureConstant(i) }\n        switch (c) {\n            case ~\/\\s\/:               break\n            case isConstChar:         constStr += c; break\n            case Op.values()*.symbol: tokens << Op.fromSymbol(c); break\n            case ['(',')']:           tokens << c; break\n            default:                  fail \"Invalid character '${c}' at position ${i+1}\"\n        }\n    }\n    captureConstant(expr.size())\n    tokens\n}\n\nList groupByParens(List tokens, int depth) {\n    def deepness = depth\n    def tokenGroups = []\n    for (def i = 0; i < tokens.size(); i++) {\n        def token = tokens[i]\n        switch (token) {\n            case '(':\n                fail(\"'(' too close to end of expression\") { i+2 > tokens.size() }\n                def subGroup = groupByParens(tokens[i+1..-1], depth+1)\n                tokenGroups << subGroup[0..-2]\n                i += subGroup[-1] + 1\n                break\n            case ')':\n                fail(\"Unbalanced parens, found extra ')'\") { deepness == 0 }\n                tokenGroups << i\n                return tokenGroups\n            default:\n                tokenGroups << token\n        }\n    }\n    fail(\"Unbalanced parens, unclosed groupings at end of expression\") { deepness != 0 }\n    def n = tokenGroups.size()\n    fail(\"The operand\/operator sequence is wrong\") { n%2 == 0 }\n    (0..<n).each {\n        def i = it\n        fail(\"The operand\/operator sequence is wrong\") { (i%2 == 0) == (tokenGroups[i] instanceof Op) }\n    }\n    tokenGroups\n}\n\nExpression parse(List elements) {\n    while (elements.size() > 1) {\n        def n = elements.size()\n        fail (\"The operand\/operator sequence is wrong\") { n%2 == 0 }\n        def groupLoc = (0..<n).find { i -> elements[i] instanceof List }\n        if (groupLoc != null) {\n            elements[groupLoc] = parse(elements[groupLoc])\n            continue\n        }\n        def opLoc = (0..<n).find { i -> elements[i] instanceof Op && elements[i].precedence == 1 } \\\n                        ?: (0..<n).find { i -> elements[i] instanceof Op && elements[i].precedence == 2 }\n        if (opLoc != null) {\n            fail (\"Operator out of sequence\") { opLoc%2 == 0 }\n            def term = new Term(left:elements[opLoc-1], op:elements[opLoc], right:elements[opLoc+1])\n            elements[(opLoc-1)..(opLoc+1)] = [term]\n            continue\n        }\n    }\n    return elements[0] instanceof List ? parse(elements[0]) : elements[0]\n}<\/lang>\n\nTest:\n<lang groovy>def testParse = {\n    def ex = parse(it)\n    print \"\"\"\nInput: ${it}\nAST:   ${ex}\nvalue: ${ex.evaluate()}\n\"\"\"\n}\n\n\ntestParse('1+1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(1+1\/15)\/14)\/13)\/12)\/11)\/10)\/9)\/8)\/7)\/6)\/5)\/4)\/3)\/2')\nassert (parse('1+1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(1+1\/15)\/14)\/13)\/12)\/11)\/10)\/9)\/8)\/7)\/6)\/5)\/4)\/3)\/2')\n        .evaluate() - Math.E).abs() < 0.0000000000001\ntestParse('1 + 2*(3 - 2*(3 - 2)*((2 - 4)*5 - 22\/(7 + 2*(3 - 1)) - 1)) + 1')\ntestParse('1 - 5 * 2 \/ 20 + 1')\ntestParse('(1 - 5) * 2 \/ (20 + 1)')\ntestParse('2 * (3 + ((5) \/ (7 - 11)))')\ntestParse('(2 + 3) \/ (10 - 5)')\ntestParse('(1 + 2) * 10 \/ 100')\ntestParse('(1 + 2 \/ 2) * (5 + 5)')\ntestParse('2*-3--4+-.25')\ntestParse('2*(-3)-(-4)+(-.25)')\ntestParse('((11+15)*15)*2-(3)*4*1')\ntestParse('((11+15)*15)* 2 + (3) * -4 *1')\ntestParse('(((((1)))))')\ntestParse('-35')\nprintln()\n\ntry { testParse('((11+15)*1') } catch (e) { println e }\ntry { testParse('((11+15)*1)))') } catch (e) { println e }\ntry { testParse('((11+15)*x)') } catch (e) { println e }\ntry { testParse('+++++') } catch (e) { println e }\ntry { testParse('1 \/') } catch (e) { println e }\ntry { testParse('1++') } catch (e) { println e }\ntry { testParse('*1') } catch (e) { println e }\ntry { testParse('\/ 1 \/') } catch (e) { println e }<\/lang>\n\nOutput:\n<pre style=\"height:30ex;overflow:scroll;\">Input: 1+1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(1+1\/15)\/14)\/13)\/12)\/11)\/10)\/9)\/8)\/7)\/6)\/5)\/4)\/3)\/2\nAST:   (+ (+ 1 1) (\/ (+ 1 (\/ (+ 1 (\/ (+ 1 (\/ (+ 1 (\/ (+ 1 (\/ (+ 1 (\/ (+ 1 (\/ (+ 1 (\/ (+ 1 (\/ (+ 1 (\/ (+ 1 (\/ (+ 1 (\/ (+ 1 (\/ 1 15)) 14)) 13)) 12)) 11)) 10)) 9)) 8)) 7)) 6)) 5)) 4)) 3)) 2))\nvalue: 2.7182818284589946\n\nInput: 1 + 2*(3 - 2*(3 - 2)*((2 - 4)*5 - 22\/(7 + 2*(3 - 1)) - 1)) + 1\nAST:   (+ (+ 1 (* 2 (- 3 (* (* 2 (- 3 2)) (- (- (* (- 2 4) 5) (\/ 22 (+ 7 (* 2 (- 3 1))))) 1))))) 1)\nvalue: 60\n\nInput: 1 - 5 * 2 \/ 20 + 1\nAST:   (+ (- 1 (\/ (* 5 2) 20)) 1)\nvalue: 1.5\n\nInput: (1 - 5) * 2 \/ (20 + 1)\nAST:   (\/ (* (- 1 5) 2) (+ 20 1))\nvalue: -0.3809523810\n\nInput: 2 * (3 + ((5) \/ (7 - 11)))\nAST:   (* 2 (+ 3 (\/ 5 (- 7 11))))\nvalue: 3.50\n\nInput: (2 + 3) \/ (10 - 5)\nAST:   (\/ (+ 2 3) (- 10 5))\nvalue: 1\n\nInput: (1 + 2) * 10 \/ 100\nAST:   (\/ (* (+ 1 2) 10) 100)\nvalue: 0.3\n\nInput: (1 + 2 \/ 2) * (5 + 5)\nAST:   (* (+ 1 (\/ 2 2)) (+ 5 5))\nvalue: 20\n\nInput: 2*-3--4+-.25\nAST:   (+ (- (* 2 -3) -4) -0.25)\nvalue: -2.25\n\nInput: 2*(-3)-(-4)+(-.25)\nAST:   (+ (- (* 2 -3) -4) -0.25)\nvalue: -2.25\n\nInput: ((11+15)*15)*2-(3)*4*1\nAST:   (- (* (* (+ 11 15) 15) 2) (* (* 3 4) 1))\nvalue: 768\n\nInput: ((11+15)*15)* 2 + (3) * -4 *1\nAST:   (+ (* (* (+ 11 15) 15) 2) (* (* 3 -4) 1))\nvalue: 768\n\nInput: (((((1)))))\nAST:   1\nvalue: 1\n\nInput: -35\nAST:   -35\nvalue: -35\n\njava.lang.IllegalArgumentException: Cannot parse expression: Unbalanced parens, unclosed groupings at end of expression\njava.lang.IllegalArgumentException: Cannot parse expression: Unbalanced parens, found extra ')'\njava.lang.IllegalArgumentException: Cannot parse expression: Invalid character 'x' at position 10\njava.lang.IllegalArgumentException: Cannot parse expression: Invalid constant '+' near position 1\njava.lang.IllegalArgumentException: Cannot parse expression: The operand\/operator sequence is wrong\njava.lang.IllegalArgumentException: Cannot parse expression: Invalid constant '+' near position 3\njava.lang.IllegalArgumentException: Cannot parse expression: The operand\/operator sequence is wrong\njava.lang.IllegalArgumentException: Cannot parse expression: The operand\/operator sequence is wrong<\/pre>\n\n==[[:Category:Haskell|Haskell]][[Category:Haskell]]==\n<lang haskell>import Text.ParserCombinators.Parsec\nimport Text.ParserCombinators.Parsec.Expr\n\ndata Exp = Num Int\n         | Add Exp Exp\n         | Sub Exp Exp\n         | Mul Exp Exp\n         | Div Exp Exp\n\nexpr = buildExpressionParser table factor\n\ntable = [[op \"*\" (Mul) AssocLeft, op \"\/\" (Div) AssocLeft]\n        ,[op \"+\" (Add) AssocLeft, op \"-\" (Sub) AssocLeft]]\n        where op s f assoc = Infix (do string s; return f) assoc\n\nfactor =  do char '(' ; x <- expr ; char ')'\n             return x \n      <|> do ds <- many1 digit\n             return $ Num (read ds)\n\nevaluate (Num x) = fromIntegral x\nevaluate (Add a b) = (evaluate a)   +   (evaluate b)\nevaluate (Sub a b) = (evaluate a)   -   (evaluate b)\nevaluate (Mul a b) = (evaluate a)   *   (evaluate b)\nevaluate (Div a b) = (evaluate a) `div` (evaluate b)\n\nsolution exp = case parse expr [] exp of\n                 Right expr -> evaluate expr\n                 Left _ -> error \"Did not parse\"<\/lang>\n\n==[[:Category:Icon|Icon]][[Category:Icon]] and [[:Category:Unicon|Unicon]][[Category:Unicon]]==\nA compact recursive descent parser using Hanson's device.  This program \n*  handles left and right associativity and different precedences\n*  is ready to handle any number of infix operators without adding more functions to handle the precedences\n*  accepts integers, reals, and radix constants (e.g. 3r10 is 3 in base 3)\n*  currently accepts the Icon operators + - * \/ % (remainder) and ^ (exponentiation) and unary operators + and -\n*  string invocation is used to evaluate binary operators hence other Icon binary operators (including handle multiple character ones) can be easily added\n*  uses Icon style type coercion on operands\n*  represents the AST as a nested list eliminating unneeded parenthesis\n\n*  Notice that the code looks remarkably like a typical grammar, rather than being an opaque cryptic solution\n*  Does not rely on any library to silently solve 1\/2 the problem; in fact, this code would probably suit being put into a library almost verbatim\n<lang Icon>procedure main()                                                #: simple arithmetical parser \/ evaluator\n   write(\"Usage: Input expression = Abstract Syntax Tree = Value, ^Z to end.\")\n   repeat {\n      writes(\"Input expression : \")\n      if not writes(line := read()) then break\n      if map(line) ? { (x := E()) & pos(0) } then\n         write(\" = \", showAST(x), \" = \", evalAST(x))\n      else\n         write(\" rejected\")\n   }\nend\n\nprocedure evalAST(X)                                            #: return the evaluated AST\n   local x\n\n   if type(X) == \"list\" then {\n      x := evalAST(get(X))\n      while x := get(X)(x, evalAST(get(X) | stop(\"Malformed AST.\")))\n   }\n   return \\x | X\nend\n\nprocedure showAST(X)                                            #: return a string representing the AST\n   local x,s\n\n   s := \"\"\n   every x := !X do\n      s ||:= if type(x) == \"list\" then \"(\" || showAST(x) || \")\" else x\n   return s\nend\n\n########\n# When you're writing a big parser, a few utility recognisers are very useful\n#\nprocedure ws()    # skip optional whitespace\n   suspend tab(many(' \\t')) | \"\"\nend\n\nprocedure digits()\n   suspend tab(many(&digits))\nend\n\nprocedure radixNum(r)    # r sets the radix\n   static chars\n   initial chars := &digits || &lcase\n   suspend tab(many(chars[1 +: r]))\nend\n########\n\nglobal token\nrecord HansonsDevice(precedence,associativity)\n\nprocedure opinfo()\n   static O\n   initial {\n      O := HansonsDevice([], table(&null))                         # parsing table\n      put(O.precedence, [\"+\", \"-\"], [\"*\", \"\/\", \"%\"], [\"^\"])        # Lowest to Highest precedence\n      every O.associativity[!!O.precedence] := 1                   # default to 1 for LEFT associativity\n      O.associativity[\"^\"] := 0                                    # RIGHT associativity\n   }\n   return O\nend\n\nprocedure E(k)                                                  #: Expression\n   local lex, pL\n   static opT\n   initial opT := opinfo()\n\n   \/k := 1\n   lex := []\n   if not (pL := opT.precedence[k]) then                        # this op at this level?\n      put(lex, F())\n   else {\n      put(lex, E(k + 1))\n      while ws() & put(lex, token := =!pL) do\n         put(lex, E(k + opT.associativity[token]))\n   }\n   suspend if *lex = 1 then lex[1] else lex                     # strip useless []\nend\n\nprocedure F()                                                   #: Factor\n   suspend ws() & (    # skip optional whitespace, and ...\n      (=\"+\" & F())              |          # unary + and a Factor, or ...\n      (=\"-\" || V())             |          # unary - and a Value, or ...\n      (=\"-\" & [-1, \"*\", F()])   |          # unary - and a Factor, or ...\n     2(=\"(\", E(), ws(), =\")\")   |          # parenthesized subexpression, or ...\n       V()                                 # just a value\n   )\nend\n\nprocedure V()                                                   #: Value\n   local r\n   suspend ws() & numeric(    # skip optional whitespace, and ...\n       =(r := 1 to 36) || =\"r\" || radixNum(r)             |     # N-based number, or ...\n       digits() || (=\".\" || digits() | \"\") || exponent()        # plain number with optional fraction\n   )\nend\n\nprocedure exponent()\n   suspend tab(any('eE')) || =(\"+\" | \"-\" | \"\") || digits() | \"\"\nend<\/lang>\n\nSample Output:\n<pre>#matheval.exe \n\nUsage: Input expression = Abstract Syntax Tree = Value, ^Z to end.\nInput expression : 1\n1 = 1 = 1\nInput expression : -1\n-1 = -1 = -1\nInput expression : (-15\/2.0)\n(-15\/2.0) = -15\/2.0 = -7.5\nInput expression : -(15\/2.0)\n-(15\/2.0) = -1*(15\/2.0) = -7.5\nInput expression : 2+(3-4)*6\/5^2^3%3\n2+(3-4)*6\/5^2^3%3 = 2+((3-4)*6\/(5^(2^3))%3) = 2\nInput expression : 1+2+3+4\n1+2+3+4 = 1+2+3+4 = 10\nInput expression : ((((2))))+3*5\n((((2))))+3*5 = 2+(3*5) = 17\nInput expression : 3r10*3\n3r10*3 = 3r10*3 = 9\nInput expression : ^Z<\/pre>\n\n==[[:Category:J|J]][[Category:J]]==\n\nNote that once you get beyond a few basic arithmetic operations, what we commonly call \"mathematical precedence\" stops making sense, and primary value for this kind of precedence has been that it allows polynomials to be expressed simply (but expressing polynomials as a sequence of coefficients, one for each exponent, is even simpler).\n\nNevertheless, this task deals only with simple arithmetic, so this kind of precedence is an arguably appropriate choice for this task.\n\nThe implementation here uses a shift\/reduce parser to build a tree structure which J happens to support for evaluation:\n\n<lang j>parse=:parse_parser_\neval=:monad define\n  'gerund structure'=:y\n  gerund@.structure\n)\n\ncoclass 'parser' \nclassify=: '$()*\/+-'&(((>:@#@[ # 2:) #: 2 ^ i.)&;:)\n \nrules=: ''\npatterns=: ,\"0 assert 1\n\naddrule=: dyad define\n   rules=: rules,;:x\n   patterns=: patterns,+.\/@classify\"1 y\n)\n \n'Term'   addrule '$()',   '0',     '+-',: '0'\n'Factor' addrule '$()+-', '0',     '*\/',: '0'\n'Parens' addrule '(',    '*\/+-0', ')',:  ')*\/+-0$'\nrules=: rules,;:'Move'\n\nbuildTree=: monad define\n  words=: ;:'$',y\n  queue=: classify '$',y\n  stack=: classify '$$$$'\n  tokens=: ]&.>i.#words\n  tree=: ''\n  while.(#queue)+.6<#stack do.\n    rule=: rules {~ i.&1 patterns (*.\/\"1)@:(+.\/\"1) .(*.\"1)4{.stack\n    rule`:6''\n  end.\n  'syntax' assert 1 0 1 1 1 1 -: {:\"1 stack\n  gerund=: literal&.> (<,'%') (I. words=<,'\/')} words\n  gerund;1{tree\n)\n\nliteral=:monad define ::]\n  \".'t=.',y\n  5!:1<'t'\n)\n\nTerm=: Factor=: monad define\n  stack=: ({.stack),(classify '0'),4}.stack\n  tree=: ({.tree),(<1 2 3{tree),4}.tree\n)\n \nParens=: monad define\n  stack=: (1{stack),3}.stack\n  tree=: (1{tree),3}.tree\n)\n \nMove=: monad define\n  'syntax' assert 0<#queue\n  stack=: ({:queue),stack\n  queue=: }:queue\n  tree=: ({:tokens),tree\n  tokens=: }:tokens\n)\n\nparse=:monad define\n  tmp=: conew 'parser'\n  r=: buildTree__tmp y\n  coerase tmp\n  r\n)<\/lang>\nexample use:\n<lang j>   eval parse '1+2*3\/(4-5+6)'\n2.2<\/lang>\n\nYou can also display the syntax tree, for example:\n<lang j>   parse '2*3\/(4-5)'\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502\u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2510\u2502\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502\n\u2502\u2502\u250c\u2500\u2510\u2502\u250c\u2500\u2500\u2500\u2500\u2500\u2510\u2502\u250c\u2500\u2510\u2502\u250c\u2500\u2500\u2500\u2500\u2500\u2510\u2502\u250c\u2500\u2510\u2502(\u2502\u250c\u2500\u2500\u2500\u2500\u2500\u2510\u2502\u250c\u2500\u2510\u2502\u250c\u2500\u2500\u2500\u2500\u2500\u2510\u2502)\u2502\u2502\u2502\u250c\u2500\u252c\u2500\u252c\u2500\u2510\u25024\u2502\u250c\u2500\u252c\u2500\u252c\u2500\u2510\u2502\u2502\n\u2502\u2502\u2502$\u2502\u2502\u2502\u250c\u2500\u252c\u2500\u2510\u2502\u2502\u2502*\u2502\u2502\u2502\u250c\u2500\u252c\u2500\u2510\u2502\u2502\u2502%\u2502\u2502 \u2502\u2502\u250c\u2500\u252c\u2500\u2510\u2502\u2502\u2502-\u2502\u2502\u2502\u250c\u2500\u252c\u2500\u2510\u2502\u2502 \u2502\u2502\u2502\u25021\u25022\u25023\u2502\u2502 \u2502\u25026\u25027\u25028\u2502\u2502\u2502\n\u2502\u2502\u2514\u2500\u2518\u2502\u2502\u25020\u25022\u2502\u2502\u2502\u2514\u2500\u2518\u2502\u2502\u25020\u25023\u2502\u2502\u2502\u2514\u2500\u2518\u2502 \u2502\u2502\u25020\u25024\u2502\u2502\u2502\u2514\u2500\u2518\u2502\u2502\u25020\u25025\u2502\u2502\u2502 \u2502\u2502\u2502\u2514\u2500\u2534\u2500\u2534\u2500\u2518\u2502 \u2502\u2514\u2500\u2534\u2500\u2534\u2500\u2518\u2502\u2502\n\u2502\u2502   \u2502\u2502\u2514\u2500\u2534\u2500\u2518\u2502\u2502   \u2502\u2502\u2514\u2500\u2534\u2500\u2518\u2502\u2502   \u2502 \u2502\u2502\u2514\u2500\u2534\u2500\u2518\u2502\u2502   \u2502\u2502\u2514\u2500\u2534\u2500\u2518\u2502\u2502 \u2502\u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502\n\u2502\u2502   \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2518\u2502   \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2518\u2502   \u2502 \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2518\u2502   \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2518\u2502 \u2502\u2502                   \u2502\n\u2502\u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2518\u2502                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518<\/lang>\n\nAt the top level, the first box is a list of terminals, and the second box represents their parsed structure within the source sentence, with numbers indexing the respective terminals.\n\n==[[:Category:Java|Java]][[Category:Java]]==\n\nUses the [[Arithmetic\/Rational\/Java|BigRational class]] to handle arbitrary-precision numbers (rational numbers since basic arithmetic will result in rational values).\n\n<lang java>import java.util.Stack;\n\npublic class ArithmeticEvaluation\n{\n  public static enum Parentheses { LEFT, RIGHT }\n  \n  public static enum BinaryOperator\n  {\n    ADD('+', 1) {\n      public BigRational eval(BigRational leftValue, BigRational rightValue) {  return leftValue.add(rightValue);  }\n    },\n    SUB('-', 1) {\n      public BigRational eval(BigRational leftValue, BigRational rightValue) {  return leftValue.subtract(rightValue);  }\n    },\n    MUL('*', 2) {\n      public BigRational eval(BigRational leftValue, BigRational rightValue) {  return leftValue.multiply(rightValue);  }\n    },\n    DIV('\/', 2) {\n      public BigRational eval(BigRational leftValue, BigRational rightValue) {  return leftValue.divide(rightValue);  }\n    };\n    \n    public final char symbol;\n    public final int precedence;\n    \n    BinaryOperator(char symbol, int precedence)\n    {\n      this.symbol = symbol;\n      this.precedence = precedence;\n    }\n    \n    public abstract BigRational eval(BigRational leftValue, BigRational rightValue);\n  }\n  \n  public static class BinaryExpression\n  {\n    public Object leftOperand = null;\n    public BinaryOperator operator = null;\n    public Object rightOperand = null;\n    \n    public BinaryExpression(Object leftOperand, BinaryOperator operator, Object rightOperand)\n    {\n      this.leftOperand = leftOperand;\n      this.operator = operator;\n      this.rightOperand = rightOperand;\n    }\n    \n    public BigRational eval()\n    {\n      BigRational leftValue = (leftOperand instanceof BinaryExpression) ? ((BinaryExpression)leftOperand).eval() : (BigRational)leftOperand;\n      BigRational rightValue = (rightOperand instanceof BinaryExpression) ? ((BinaryExpression)rightOperand).eval() : (BigRational)rightOperand;\n      return operator.eval(leftValue, rightValue);\n    }\n    \n    public String toString()\n    {  return \"(\" + leftOperand + \" \" + operator.symbol + \" \" + rightOperand + \")\";  }\n  }\n  \n  public static void createNewOperand(BinaryOperator operator, Stack<Object> operands)\n  {\n    Object rightOperand = operands.pop();\n    operands.push(new BinaryExpression(operands.pop(), operator, rightOperand));\n    return;\n  }\n  \n  public static Object createExpression(String inputString)\n  {\n    int curIndex = 0;\n    boolean afterOperand = false;\n    Stack<Object> operands = new Stack<Object>();\n    Stack<Object> operators = new Stack<Object>();\ninputStringLoop:\n    while (curIndex < inputString.length())\n    {\n      int startIndex = curIndex;\n      char c = inputString.charAt(curIndex++);\n      if (Character.isWhitespace(c))\n        continue;\n      if (afterOperand)\n      {\n        if (c == ')')\n        {\n          Object operator = null;\n          while (!operators.isEmpty() && ((operator = operators.pop()) != Parentheses.LEFT))\n            createNewOperand((BinaryOperator)operator, operands);\n          continue;\n        }\n        afterOperand = false;\n        for (BinaryOperator operator : BinaryOperator.values())\n        {\n          if (c == operator.symbol)\n          {\n            while (!operators.isEmpty() && (operators.peek() != Parentheses.LEFT) && (((BinaryOperator)operators.peek()).precedence >= operator.precedence))\n              createNewOperand((BinaryOperator)operators.pop(), operands);\n            operators.push(operator);\n            continue inputStringLoop;\n          }\n        }\n        throw new IllegalArgumentException();\n      }\n      if (c == '(')\n      {\n        operators.push(Parentheses.LEFT);\n        continue;\n      }\n      afterOperand = true;\n      while (curIndex < inputString.length())\n      {\n        c = inputString.charAt(curIndex);\n        if (((c < '0') || (c > '9')) && (c != '.'))\n          break;\n        curIndex++;\n      }\n      operands.push(BigRational.valueOf(inputString.substring(startIndex, curIndex)));\n    }\n    \n    while (!operators.isEmpty())\n    {\n      Object operator = operators.pop();\n      if (operator == Parentheses.LEFT)\n        throw new IllegalArgumentException();\n      createNewOperand((BinaryOperator)operator, operands);\n    }\n    Object expression = operands.pop();\n    if (!operands.isEmpty())\n      throw new IllegalArgumentException();\n    return expression;\n  }\n  \n  public static void main(String[] args)\n  {\n    String[] testExpressions = { \"2+3\", \"2+3\/4\", \"2*3-4\", \"2*(3+4)+5\/6\", \"2 * (3 + (4 * 5 + (6 * 7) * 8) - 9) * 10\", \"2*-3--4+-.25\" };\n    for (String testExpression : testExpressions)\n    {\n      Object expression = createExpression(testExpression);\n      System.out.println(\"Input: \\\"\" + testExpression + \"\\\", AST: \\\"\" + expression + \"\\\", eval=\" + (expression instanceof BinaryExpression ? ((BinaryExpression)expression).eval() : expression));\n    }\n  }\n}<\/lang>\n\nOutput:\n<pre>Input: \"2+3\", AST: \"(2 + 3)\", eval=5\nInput: \"2+3\/4\", AST: \"(2 + (3 \/ 4))\", eval=11\/4\nInput: \"2*3-4\", AST: \"((2 * 3) - 4)\", eval=2\nInput: \"2*(3+4)+5\/6\", AST: \"((2 * (3 + 4)) + (5 \/ 6))\", eval=89\/6\nInput: \"2 * (3 + (4 * 5 + (6 * 7) * 8) - 9) * 10\", AST: \"((2 * ((3 + ((4 * 5) + ((6 * 7) * 8))) - 9)) * 10)\", eval=7000\nInput: \"2*-3--4+-.25\", AST: \"(((2 * -3) - -4) + -1\/4)\", eval=-9\/4<\/pre>\n\n==[[:Category:JavaScript|JavaScript]][[Category:JavaScript]]==\nNumbers must have a digit before the decimal point, so 0.1 not .1. \n\nSpaces are removed, expressions like <code>5--1<\/code> are treated as <code>5 - -1<\/code>\n\n<lang javascript>function evalArithmeticExp(s) {\n  s = s.replace(\/\\s\/g,'').replace(\/^\\+\/,'');\n  var rePara = \/\\([^\\(\\)]*\\)\/;\n  var exp = s.match(rePara);\n\n  while (exp = s.match(rePara)) {\n    s = s.replace(exp[0], evalExp(exp[0]));\n  }\n  return evalExp(s);\n  \n  function evalExp(s) {\n    s = s.replace(\/[\\(\\)]\/g,'');\n    var reMD = \/\\d+\\.?\\d*\\s*[\\*\\\/]\\s*[+-]?\\d+\\.?\\d*\/;\n    var reM = \/\\*\/;\n    var reAS = \/-?\\d+\\.?\\d*\\s*[\\+-]\\s*[+-]?\\d+\\.?\\d*\/;\n    var reA  = \/\\d\\+\/;\n    var exp;\n\n    while (exp = s.match(reMD)) {\n      s = exp[0].match(reM)? s.replace(exp[0], multiply(exp[0])) : s.replace(exp[0], divide(exp[0]));\n    }\n    \n    while (exp = s.match(reAS)) {\n      s = exp[0].match(reA)? s.replace(exp[0], add(exp[0])) : s.replace(exp[0], subtract(exp[0]));\n    }\n    \n    return '' + s;\n\n    function multiply(s, b) {\n      b = s.split('*');\n      return b[0] * b[1];\n    }\n    \n    function divide(s, b) {\n      b = s.split('\/');\n      return b[0] \/ b[1];\n    }\n    \n    function add(s, b) {\n      s = s.replace(\/^\\+\/,'').replace(\/\\++\/,'+');\n      b = s.split('+');\n      return Number(b[0]) + Number(b[1]);\n    }\n    \n    function subtract(s, b) {\n      s = s.replace(\/\\+-|-\\+\/g,'-');\n\n      if (s.match(\/--\/)) {\n        return add(s.replace(\/--\/,'+'));\n      }\n      b = s.split('-');\n      return b.length == 3? -1 * b[1] - b[2] : b[0] - b[1];\n    }\n  }\n}<\/lang>\n\n\nSample output:\n<pre>evalArithmeticExp('2+3') \/\/ 5\nevalArithmeticExp('2+3\/4') \/\/ 2.75\nevalArithmeticExp('2*3-4') \/\/ 2\nevalArithmeticExp('2*(3+4)+5\/6') \/\/ 14.833333333333334\nevalArithmeticExp('2 * (3 + (4 * 5 + (6 * 7) * 8) - 9) * 10') \/\/ 7000\nevalArithmeticExp('2*-3--4+-0.25' \/\/ -2.25<\/pre>\n\n==[[:Category:Lua|Lua]][[Category:Lua]]==\n\n<lang lua>require\"lpeg\"\n\nP, R, C, S, V = lpeg.P, lpeg.R, lpeg.C, lpeg.S, lpeg.V\n\n--matches arithmetic expressions and returns a syntax tree\nexpression = P{\"expr\";\nws = P\" \"^0,\nnumber = C(R\"09\"^1) * V\"ws\",\nlp = \"(\" * V\"ws\",\nrp = \")\" * V\"ws\",\nsym = C(S\"+-*\/\") * V\"ws\",\nmore = (V\"sym\" * V\"expr\")^0,\nexpr = V\"number\" * V\"more\" + V\"lp\" * lpeg.Ct(V\"expr\" * V\"more\") * V\"rp\" * V\"more\"}\n\n--evaluates a tree\nfunction eval(expr)\n  --empty\n  if type(expr) == \"string\" or type(expr) == \"number\" then return expr + 0 end\n  \n  --arithmetic functions\n  tb = {[\"+\"] = function(a,b) return eval(a) + eval(b) end,\n\t\t[\"-\"] = function(a,b) return eval(a) - eval(b) end,\n\t\t[\"*\"] = function(a,b) return eval(a) * eval(b) end,\n\t\t[\"\/\"] = function(a,b) return eval(a) \/ eval(b) end}\n  \n  --you could add ^ or other operators to this pretty easily\n  for i, v in ipairs{\"*\/\", \"+-\"} do\n    for s, u in ipairs(expr) do\n\t  local k = type(u) == \"string\" and C(S(v)):match(u)\n\t  if k then\n\t    expr[s-1] = tb[k](expr[s-1],expr[s+1])\n\t    table.remove(expr, s)\n\t    table.remove(expr, s)\n\t  end\n\tend\n  end\n  return expr[1]\nend\n\nprint(eval{expression:match(io.read())})<\/lang>\n\n==[[:Category:OCaml|OCaml]][[Category:OCaml]]==\n\n<lang ocaml>type expression =\n  | Const of float\n  | Sum  of expression * expression   (* e1 + e2 *)\n  | Diff of expression * expression   (* e1 - e2 *)\n  | Prod of expression * expression   (* e1 * e2 *)\n  | Quot of expression * expression   (* e1 \/ e2 *)\n\nlet rec eval = function\n  | Const c -> c\n  | Sum (f, g) -> eval f +. eval g\n  | Diff(f, g) -> eval f -. eval g\n  | Prod(f, g) -> eval f *. eval g\n  | Quot(f, g) -> eval f \/. eval g\n\nopen Genlex\n\nlet lexer = make_lexer [\"(\"; \")\"; \"+\"; \"-\"; \"*\"; \"\/\"]\n\nlet rec parse_expr = parser\n     [< e1 = parse_mult; e = parse_more_adds e1 >] -> e\n and parse_more_adds e1 = parser\n     [< 'Kwd \"+\"; e2 = parse_mult; e = parse_more_adds (Sum(e1, e2)) >] -> e\n   | [< 'Kwd \"-\"; e2 = parse_mult; e = parse_more_adds (Diff(e1, e2)) >] -> e\n   | [< >] -> e1\n and parse_mult = parser\n     [< e1 = parse_simple; e = parse_more_mults e1 >] -> e\n and parse_more_mults e1 = parser\n     [< 'Kwd \"*\"; e2 = parse_simple; e = parse_more_mults (Prod(e1, e2)) >] -> e\n   | [< 'Kwd \"\/\"; e2 = parse_simple; e = parse_more_mults (Quot(e1, e2)) >] -> e\n   | [< >] -> e1\n and parse_simple = parser\n   | [< 'Int i >] -> Const(float i)\n   | [< 'Float f >] -> Const f\n   | [< 'Kwd \"(\"; e = parse_expr; 'Kwd \")\" >] -> e\n\n\nlet parse_expression = parser [< e = parse_expr; _ = Stream.empty >] -> e\n\nlet read_expression s = parse_expression(lexer(Stream.of_string s))<\/lang>\n\nUsing the function <code>read_expression<\/code> in an interactive loop:\n\n<lang ocaml>let () =\n  while true do\n    print_string \"Expression: \";\n    let str = read_line() in\n    if str = \"q\" then exit 0;\n    let expr = read_expression str in\n    let res = eval expr in\n    Printf.printf \" = %g\\n%!\" res;\n  done<\/lang>\n\nCompile with:\n ocamlopt -pp camlp4o arith_eval.ml -o arith_eval.opt\n\n==[[:Category:Oz|Oz]][[Category:Oz]]==\nWe can create a simple, but slow parser using logic programming. \nEvery procedure reads the input characters from <code>X0<\/code> and returns the remaining characters in <code>X<\/code>. The AST is returned as the regular return value.\n\nThe <code>Do<\/code> procedure automatically threads the input state through a sequence of procedure calls.\n\n<lang oz>declare\n\n  fun {Expr X0 ?X}\n     choice\n        [L _ R] = {Do [Term &+ Expr] X0 ?X} in add(L R)\n     [] [L _ R] = {Do [Term &- Expr] X0 ?X} in sub(L R)\n     [] {Term X0 X}\n     end\n  end\n\n  fun {Term X0 ?X}\n     choice\n        [L _ R] = {Do [Factor &* Term] X0 ?X} in mul(L R)\n     [] [L _ R] = {Do [Factor &\/ Term] X0 ?X} in 'div'(L R)\n     [] {Factor X0 X}\n     end\n  end\n\n  fun {Factor X0 ?X}\n     choice {Parens Expr X0 X}\n     [] {Number X0 X}\n     end\n  end\n\n  fun {Number X0 X}\n     Ds = {Many1 Digit X0 X}\n  in\n     num(Ds)\n  end\n\n  fun {Digit X0 ?X}\n     D|!X = X0\n  in\n     D = choice &0 [] &1 [] &2 [] &3 [] &4 [] &5 [] &6 [] &7 [] &8 [] &9 end \n  end\n\n  fun {Many1 Rule X0 ?X}\n     choice [{Rule X0 X}]\n     [] X1 in {Rule X0 X1}|{Many1 Rule X1 X}\n     end\n  end\n\n  fun {Parens Rule X0 ?X}\n     [_ R _] = {Do [&( Rule &)] X0 X}\n  in\n     R\n  end\n\n  fun {Do Rules X0 ?X}\n     Res#Xn = {FoldL Rules\n               fun {$ Res#Xi Rule}\n                  if {Char.is Rule} then\n                     !Rule|X2 = Xi\n                  in\n                     (Rule|Res) # X2\n                  elseif {Procedure.is Rule} then\n                     X2 in\n                     ({Rule Xi X2}|Res) # X2\n                  end\n               end\n               nil#X0}\n  in\n     X = Xn\n     {Reverse Res}\n  end\n\n  %% Returns a singleton list if an AST was found or nil otherwise.\n  fun {Parse S}\n     {SearchOne fun {$} {Expr S nil} end}\n  end\n\n  fun {Eval X}\n     case X of\n        num(Ds)    then {String.toInt Ds}\n     [] add(L R)   then {Eval L} + {Eval R}\n     [] sub(L R)   then {Eval L} - {Eval R}\n     [] mul(L R)   then {Eval L} * {Eval R}\n     [] 'div'(L R) then {Eval L} div {Eval R}\n     end\n  end\n\n  [AST] = {Parse \"((11+15)*15)*2-(3)*4*1\"}\n\nin\n\n  {Inspector.configure widgetShowStrings true}\n  {Inspect AST}\n  {Inspect {Eval AST}}<\/lang>\n\nTo improve performance, the number of choice points should be limited, for example by reading numbers deterministically instead.\nFor real parsing with possible large input, it is however recommended to use [http:\/\/www.mozart-oz.org\/home\/doc\/gump\/node5.html Gump], Mozart's parser generator.\n\n==[[:Category:Pascal|Pascal]][[Category:Pascal]]==\nSee [[Arithmetic Evaluator\/Pascal]].\n\n==[[:Category:Perl|Perl]][[Category:Perl]]==\n<lang perl>sub ev\n# Evaluates an arithmetic expression like \"(1+3)*7\" and returns\n# its value.\n {my $exp = shift;\n  # Delete all meaningless characters. (Scientific notation,\n  # infinity, and not-a-number aren't supported.)\n  $exp =~ tr {0-9.+-\/*()} {}cd;\n  return ev_ast(astize($exp));}\n\n {my $balanced_paren_regex;\n  $balanced_paren_regex = qr\n     {\\( ( [^()]+ | (??{$balanced_paren_regex}) )+ \\)}x;\n  # ??{ ... } interpolates lazily (only when necessary),\n  # permitting recursion to arbitrary depths.\n  \n  sub astize\n  # Constructs an abstract syntax tree by recursively\n  # transforming textual arithmetic expressions into array\n  # references of the form [operator, left oprand, right oprand].\n   {my $exp = shift;\n    # If $exp is just a number, return it as-is.\n    $exp =~ \/[^0-9.]\/ or return $exp;\n    # If parentheses surround the entire expression, get rid of\n    # them.\n    $exp = substr($exp, 1, -1)\n        while $exp =~ \/\\A($balanced_paren_regex)\\z\/;\n    # Replace stuff in parentheses with placeholders.\n    my @paren_contents;\n    $exp =~ s {($balanced_paren_regex)}\n              {push(@paren_contents, $1);\n               \"[p$#paren_contents]\"}eg;\n    # Scan for operators in order of increasing precedence,\n    # preferring the rightmost.\n    $exp =~ m{(.+) ([+-]) (.+)}x or\n        $exp =~ m{(.+) ([*\/]) (.+)}x or\n        # The expression must've been malformed somehow.\n        # (Note that unary minus isn't supported.)\n        die \"Eh?: [$exp]\\n\";\n    my ($op, $lo, $ro) = ($2, $1, $3);\n    # Restore the parenthetical expressions.\n    s {\\[p(\\d+)\\]} {($paren_contents[$1])}eg\n        foreach $lo, $ro;\n    # And recurse.\n    return [$op, astize($lo), astize($ro)];}}\n\n {my %ops =\n     ('+' => sub {$_[0] + $_[1]},\n      '-' => sub {$_[0] - $_[1]},\n      '*' => sub {$_[0] * $_[1]},\n      '\/' => sub {$_[0] \/ $_[1]});\n  \n  sub ev_ast\n  # Evaluates an abstract syntax tree of the form returned by\n  # &astize.\n   {my $ast = shift;\n    # If $ast is just a number, return it as-is.\n    ref $ast or return $ast;\n    # Otherwise, recurse.\n    my ($op, @operands) = @$ast;\n    $_ = ev_ast($_) foreach @operands;\n    return $ops{$op}->(@operands);}}<\/lang>\n\n==[[:Category:Perl 6|Perl 6]][[Category:Perl 6]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Rakudo]] version #22 \"Thousand Oaks\"[[SMW::on]]<\/div>\n\n<lang perl6>sub ev (Str $s --> Num) {\n\n    grammar expr {\n        token TOP { ^ <sum> $ }\n        token sum { <product> (('+' || '-') <product>)* }\n        token product { <factor> (('*' || '\/') <factor>)* }\n        token factor { <unary_minus>? [ <parens> || <literal> ] }\n        token unary_minus { '-' }\n        token parens { '(' <sum> ')' }\n        token literal { \\d+ ['.' \\d+]? || '.' \\d+ }\n    }\n    \n    my sub minus ($b) { $b ?? -1 !! +1 }\n\n    my sub sum ($x) {\n        [+] product($x<product>), map\n            { minus($^y[0] eq '-') * product $^y<product> },\n            |($x[0] or [])\n    }\n    \n    my sub product ($x) {\n        [*] factor($x<factor>), map\n            { factor($^y<factor>) ** minus($^y[0] eq '\/') },\n            |($x[0] or [])\n    }\n    \n    my sub factor ($x) {\n        minus($x<unary_minus>) * ($x<parens>\n          ?? sum $x<parens><sum>\n          !! $x<literal>)\n    }\n\n    expr.parse([~] split \/\\s+\/, $s);\n    $\/ or fail 'No parse.';\n    sum $\/<sum>;\n\n}<\/lang>\n\nTesting:\n\n<lang perl6>say ev '5';                                    #   5\nsay ev '1 + 2 - 3 * 4 \/ 5';                    #   0.6\nsay ev '1 + 5*3.4 - .5  -4 \/ -2 * (3+4) -6';   #  25.5\nsay ev '((11+15)*15)* 2 + (3) * -4 *1';        # 768<\/lang>\n\n==[[:Category:PicoLisp|PicoLisp]][[Category:PicoLisp]]==\nThe built-in function 'str' splits a string into a list of lexical tokens\n(numbers and transient symbols). From that, a recursive descendent parser can\nbuild an expression tree, resulting in directly executable Lisp code.\n<lang PicoLisp>(de ast (Str)\n   (let *L (str Str \"\")\n      (aggregate) ) )\n\n(de aggregate ()\n   (let X (product)\n      (while (member (car *L) '(\"+\" \"-\"))\n         (setq X (list (intern (pop '*L)) X (product))) )\n      X ) )\n\n(de product ()\n   (let X (term)\n      (while (member (car *L) '(\"*\" \"\/\"))\n         (setq X (list (intern (pop '*L)) X (term))) )\n      X ) )\n\n(de term ()\n   (let X (pop '*L)\n      (cond\n         ((num? X) X)\n         ((= \"+\" X) (term))\n         ((= \"-\" X) (list '- (term)))\n         ((= \"(\" X) (prog1 (aggregate) (pop '*L)))) ) ) )<\/lang>\nOutput:\n<lang PicoLisp>: (ast \"1+2+3*-4\/(1+2)\")\n-> (+ (+ 1 2) (\/ (* 3 (- 4)) (+ 1 2)))\n\n: (ast \"(1+2+3)*-4\/(1+2)\")\n-> (\/ (* (+ (+ 1 2) 3) (- 4)) (+ 1 2))<\/lang>\n\n==[[:Category:Pop11|Pop11]][[Category:Pop11]]==\n\n<lang pop11>\/* Scanner routines *\/\n\/* Uncomment the following to parse data from standard input\n\nvars itemrep;\nincharitem(charin) -> itemrep;\n\n*\/\n\n;;; Current symbol\nvars sym;\n\ndefine get_sym();\n    itemrep() -> sym;\nenddefine;\n\ndefine expect(x);\n    lvars x;\n    if x \/= sym then\n        printf(x, 'Error, expected %p\\n');\n        mishap(sym, 1, 'Example parser error');\n    endif;\n    get_sym();\nenddefine;\n\nlconstant res_list = [( ) + * ];\n\nlconstant reserved = newproperty(\n  maplist(res_list, procedure(x); [^x ^(true)]; endprocedure),\n    20, false, \"perm\");\n\n\/*\n  Parser for arithmetic expressions\n*\/\n\/*\nexpr: term\n   | expr \"+\" term\n   | expr \"-\" term\n   ;\n*\/\n\ndefine do_expr() -> result;\n    lvars result = do_term(), op;\n    while sym = \"+\" or sym = \"-\" do\n        sym -> op;\n        get_sym();\n        [^op ^result ^(do_term())] -> result;\n    endwhile;\nenddefine;\n\n\/*\nterm: factor\n   | term \"*\" factor\n   | term \"\/\" factor\n   ;\n*\/\n\ndefine do_term() -> result;\n    lvars result = do_factor(), op;\n    while sym = \"*\" or sym = \"\/\" do\n        sym -> op;\n        get_sym();\n        [^op ^result ^(do_factor())] -> result;\n    endwhile;\nenddefine;\n\n\/*\nfactor: word\n   | constant\n   | \"(\" expr \")\"\n   ;\n*\/\n\ndefine do_factor() -> result;\n    if sym = \"(\" then\n        get_sym();\n        do_expr() -> result;\n        expect(\")\");\n    elseif isinteger(sym) or isbiginteger(sym) then\n        sym -> result;\n        get_sym();\n    else\n        if reserved(sym) then\n            printf(sym, 'unexpected symbol %p\\n');\n            mishap(sym, 1, 'Example parser syntax error');\n        endif;\n        sym -> result;\n        get_sym();\n    endif;\nenddefine;\n\n\/* Expression evaluator, returns false on error (currently only\n   division by 0 *\/\n\ndefine arith_eval(expr);\n    lvars op, arg1, arg2;\n    if not(expr) then\n        return(expr);\n    endif;\n    if isinteger(expr) or isbiginteger(expr) then\n        return(expr);\n    endif;\n    expr(1) -> op;\n    arith_eval(expr(2)) -> arg1;\n    arith_eval(expr(3)) -> arg2;\n    if not(arg1) or not(arg2) then\n        return(false);\n    endif;\n    if op = \"+\" then\n        return(arg1 + arg2);\n    elseif op = \"-\" then\n        return(arg1 - arg2);\n    elseif op = \"*\" then\n        return(arg1 * arg2);\n    elseif op = \"\/\" then\n        if arg2 = 0 then\n            return(false);\n        else\n            return(arg1 div arg2);\n        endif;\n    else\n        printf('Internal error\\n');\n        return(false);\n    endif;\nenddefine;\n\n\/* Given list, create item repeater.  Input list is stored in a\n   closure are traversed when new item is requested. *\/\n\ndefine listitemrep(lst);\n    procedure();\n        lvars item;\n        if lst = [] then\n            termin;\n        else\n            front(lst) -> item;\n            back(lst) -> lst;\n            item;\n         endif;\n     endprocedure;\nenddefine;\n\n\/* Initialise scanner *\/\n\nlistitemrep([(3 + 50) * 7 - 100 \/ 10]) -> itemrep;\n\nget_sym();\n\n;;; Test it\narith_eval(do_expr()) =><\/lang>\n\n==[[:Category:Prolog|Prolog]][[Category:Prolog]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[SWI Prolog]][[SMW::on]]<\/div>\n<lang prolog>% Lexer\n numeric(X) :- 48 =< X, X =< 57.\n not_numeric(X) :- 48 > X ; X > 57.\n \n lex1([], []).\n lex1([40|Xs], ['('|Ys]) :- lex1(Xs, Ys).\n lex1([41|Xs], [')'|Ys]) :- lex1(Xs, Ys).\n lex1([43|Xs], ['+'|Ys]) :- lex1(Xs, Ys).\n lex1([45|Xs], ['-'|Ys]) :- lex1(Xs, Ys).\n lex1([42|Xs], ['*'|Ys]) :- lex1(Xs, Ys).\n lex1([47|Xs], ['\/'|Ys]) :- lex1(Xs, Ys).\n lex1([X|Xs], [N|Ys]) :- numeric(X), N is X - 48, lex1(Xs, Ys).\n \n lex2([], []).\n lex2([X], [X]).\n lex2([Xa,Xb|Xs], [Xa|Ys]) :- atom(Xa), lex2([Xb|Xs], Ys).\n lex2([Xa,Xb|Xs], [Xa|Ys]) :- number(Xa), atom(Xb), lex2([Xb|Xs], Ys).\n lex2([Xa,Xb|Xs], [Y|Ys]) :- number(Xa), number(Xb), N is Xa * 10 + Xb, lex2([N|Xs], [Y|Ys]).\n \n % Parser\n oper(1, *, X, Y, X * Y). oper(1, \/, X, Y, X \/ Y).\n oper(2, +, X, Y, X + Y). oper(2, -, X, Y, X - Y).\n \n num(D) --> [D], {number(D)}.\n \n expr(0, Z) --> num(Z).\n expr(0, Z) --> {Z = (X)}, ['('], expr(2, X), [')'].\n \n expr(N, Z) --> {succ(N0, N)}, {oper(N, Op, X, Y, Z)}, expr(N0, X), [Op], expr(N, Y).\n expr(N, Z) --> {succ(N0, N)}, expr(N0, Z).\n \n parse(Tokens, Expr) :- expr(2, Expr, Tokens, []).\n \n \n % Evaluator\n evaluate(E, E) :- number(E).\n evaluate(A + B, E) :- evaluate(A, Ae), evaluate(B, Be), E is Ae + Be.\n evaluate(A - B, E) :- evaluate(A, Ae), evaluate(B, Be), E is Ae - Be.\n evaluate(A * B, E) :- evaluate(A, Ae), evaluate(B, Be), E is Ae * Be.\n evaluate(A \/ B, E) :- evaluate(A, Ae), evaluate(B, Be), E is Ae \/ Be.\n \n % Solution\n calculator(String, Value) :-\n    lex1(String, Tokens1),\n    lex2(Tokens1, Tokens2),\n    parse(Tokens2, Expression),\n    evaluate(Expression, Value).\n \n % Example use\n % calculator(\"(3+50)*7-9\", X).<\/lang>\n\n==[[:Category:Python|Python]][[Category:Python]]==\nThere are python modules, such as Ply, which facilitate the implementation of parsers.  This example, however, uses only standard Python with the parser having two stacks, one for operators, one for operands. \n<br>A subsequent example uses Pythons' ast module to generate the abstract syntax tree.\n\n<lang python>import operator\n\nclass AstNode(object):\n   def __init__( self, opr, left, right ):\n      self.opr = opr\n      self.l = left\n      self.r = right\n\n   def eval(self):\n      return self.opr(self.l.eval(), self.r.eval())\n\nclass LeafNode(object):\n   def __init__( self, valStrg ):\n      self.v = int(valStrg)\n\n   def eval(self):\n      return self.v\n\nclass Yaccer(object):\n   def __init__(self):\n      self.operstak = []\n      self.nodestak =[]\n      self.__dict__.update(self.state1)\n\n   def v1( self, valStrg ):\n      # Value String\n      self.nodestak.append( LeafNode(valStrg))\n      self.__dict__.update(self.state2)\n      #print 'push', valStrg\n\n   def o2( self, operchar ):\n      # Operator character or open paren in state1\n      def openParen(a,b):\n         return 0\t\t# function should not be called\n\n      opDict= { '+': ( operator.add, 2, 2 ),\n         '-': (operator.sub, 2, 2 ),\n         '*': (operator.mul, 3, 3 ),\n         '\/': (operator.div, 3, 3 ),\n         '^': ( pow,         4, 5 ),  # right associative exponentiation for grins\n         '(': ( openParen,   0, 8 )\n         }\n      operPrecidence = opDict[operchar][2]\n      self.redeuce(operPrecidence)\n\n      self.operstak.append(opDict[operchar])\n      self.__dict__.update(self.state1)\n      # print 'pushop', operchar\n\n   def syntaxErr(self, char ):\n      # Open Parenthesis \n      print 'parse error - near operator \"%s\"' %char\n\n   def pc2( self,operchar ):\n      # Close Parenthesis\n      # reduce node until matching open paren found \n      self.redeuce( 1 )\n      if len(self.operstak)>0:\n         self.operstak.pop()\t\t# pop off open parenthesis\n      else:\n         print 'Error - no open parenthesis matches close parens.'\n      self.__dict__.update(self.state2)\n\n   def end(self):\n      self.redeuce(0)\n      return self.nodestak.pop()\n\n   def redeuce(self, precidence):\n      while len(self.operstak)>0:\n         tailOper = self.operstak[-1]\n         if tailOper[1] < precidence: break\n\n         tailOper = self.operstak.pop()\n         vrgt = self.nodestak.pop()\n         vlft= self.nodestak.pop()\n         self.nodestak.append( AstNode(tailOper[0], vlft, vrgt))\n         # print 'reduce'\n\n   state1 = { 'v': v1, 'o':syntaxErr, 'po':o2, 'pc':syntaxErr }\n   state2 = { 'v': syntaxErr, 'o':o2, 'po':syntaxErr, 'pc':pc2 }\n\n\ndef Lex( exprssn, p ):\n   bgn = None\n   cp = -1\n   for c in exprssn:\n      cp += 1\n      if c in '+-\/*^()':         # throw in exponentiation (^)for grins\n         if bgn is not None:\n            p.v(p, exprssn[bgn:cp])\n            bgn = None\n         if c=='(': p.po(p, c)\n         elif c==')':p.pc(p, c)\n         else: p.o(p, c)\n      elif c in ' \\t':\n         if bgn is not None:\n            p.v(p, exprssn[bgn:cp])\n            bgn = None\n      elif c in '0123456789':\n         if bgn is None:\n            bgn = cp\n      else:\n         print 'Invalid character in expression'\n         if bgn is not None:\n            p.v(p, exprssn[bgn:cp])\n            bgn = None\n         \n   if bgn is not None:\n      p.v(p, exprssn[bgn:cp+1])\n      bgn = None\n   return p.end()\n\n\nexpr = raw_input(\"Expression:\")\nastTree = Lex( expr, Yaccer())\nprint expr, '=',astTree.eval()<\/lang>\n\n===ast standard library module===\nPython comes with its own [http:\/\/docs.python.org\/3.1\/library\/ast.html#module-ast ast] module as part of its standard libraries. The module compiles Python source into an AST tree that can in turn be compiled to bytecode then executed.\n<lang python>>>> import ast\n>>> \n>>> expr=\"2 * (3 -1) + 2 * 5\"\n>>> node = ast.parse(expr, mode='eval')\n>>> print(ast.dump(node).replace(',', ',\\n'))\nExpression(body=BinOp(left=BinOp(left=Num(n=2),\n op=Mult(),\n right=BinOp(left=Num(n=3),\n op=Sub(),\n right=Num(n=1))),\n op=Add(),\n right=BinOp(left=Num(n=2),\n op=Mult(),\n right=Num(n=5))))\n>>> code_object = compile(node, filename='<string>', mode='eval')\n>>> eval(code_object)\n14\n>>> # lets modify the AST by changing the 5 to a 6\n>>> node.body.right.right.n\n5\n>>> node.body.right.right.n = 6\n>>> code_object = compile(node, filename='<string>', mode='eval')\n>>> eval(code_object)\n16<\/lang>\n\n==[[:Category:Ruby|Ruby]][[Category:Ruby]]==\nFunction to convert infix arithmetic expression to binary tree. The resulting tree knows how to print and evaluate itself. Assumes expression is well-formed (matched parens, all operators have 2 operands). Algorithm: http:\/\/www.seas.gwu.edu\/~csci131\/fall96\/exp_to_tree.html\n<lang ruby>$op_priority = {\"+\" => 0, \"-\" => 0, \"*\" => 1, \"\/\" => 1}\n$op_function = {\n  \"+\" => lambda {|x, y| x + y},\n  \"-\" => lambda {|x, y| x - y},\n  \"*\" => lambda {|x, y| x * y},\n  \"\/\" => lambda {|x, y| x \/ y}}\n\nclass TreeNode\n  attr_accessor :info, :left, :right\n\n  def initialize(info)\n    @info = info\n  end\n\n  def leaf?\n    @left.nil? and @right.nil?\n  end\n\n  def to_s(order)\n    if leaf?\n      @info\n    else\n      left_s, right_s = @left.to_s(order), @right.to_s(order)\n\n      strs = case order\n             when :prefix then [@info, left_s, right_s]\n             when :infix then [left_s, @info, right_s]\n             when :postfix then [left_s, right_s, @info]\n             else []\n             end\n      \n      \"(\" + strs.join(\" \") + \")\"\n    end\n  end\n\n  def eval\n    if !leaf? and operator?(@info)\n      $op_function[@info].call(@left.eval, @right.eval)\n    else\n      @info.to_f\n    end\n  end\nend\n\ndef tokenize(exp)\n  exp\n    .gsub('(', ' ( ')\n    .gsub(')', ' ) ')\n    .split(' ')\nend\n\ndef operator?(token)\n  $op_priority.has_key?(token)\nend\n\ndef pop_connect_push(op_stack, node_stack)\n  temp = op_stack.pop\n  temp.right = node_stack.pop\n  temp.left = node_stack.pop\n  node_stack.push(temp)\nend\n\ndef infix_exp_to_tree(exp)\n  tokens = tokenize(exp)\n  op_stack, node_stack = [], []\n\n  tokens.each do |token|\n    if operator?(token)\n      # clear stack of higher priority operators\n      until (op_stack.empty? or\n             op_stack.last.info == \"(\" or\n             $op_priority[op_stack.last.info] < $op_priority[token])\n        pop_connect_push(op_stack, node_stack)\n      end\n\n      op_stack.push(TreeNode.new(token))\n    elsif token == \"(\"\n      op_stack.push(TreeNode.new(token))\n    elsif token == \")\"\n      while op_stack.last.info != \"(\"\n        pop_connect_push(op_stack, node_stack)\n      end\n\n      # throw away the '('\n      op_stack.pop\n    else\n      node_stack.push(TreeNode.new(token))\n    end\n  end\n\n  until op_stack.empty?\n    pop_connect_push(op_stack, node_stack)\n  end\n\n  node_stack.last\nend<\/lang>\nTesting:\n<lang ruby>exp = \"1 + 2 - 3 * (4 \/ 6)\"\nputs(\"Original: \" + exp)\n\ntree = infix_exp_to_tree(exp)\nputs(\"Prefix: \" + tree.to_s(:prefix))\nputs(\"Infix: \" + tree.to_s(:infix))\nputs(\"Postfix: \" + tree.to_s(:postfix))\nputs(\"Result: \" + tree.eval.to_s)<\/lang>\nOutput:\n<pre>Original: 1 + 2 - 3 * (4 \/ 6)\nPrefix: (- (+ 1 2) (* 3 (\/ 4 6)))\nInfix: ((1 + 2) - (3 * (4 \/ 6)))\nPostfix: ((1 2 +) (3 (4 6 \/) *) -)\nResult: 1.0<\/pre>\n\n==[[:Category:Scala|Scala]][[Category:Scala]]==\nThis code shows a bit of Scala's parser classes. The error handling of parser errors\nis practically non-existent, to avoid obscuring the code.\n\n<lang scala>\npackage org.rosetta.arithmetic_evaluator.scala\n\nobject ArithmeticParser extends scala.util.parsing.combinator.RegexParsers {\n\n  def readExpression(input: String) : Option[()=>Int] = {\n    parseAll(expr, input) match {\n      case Success(result, _) =>\n        Some(result)\n      case other =>\n        println(other)\n        None\n    }\n  }\n\n  private def expr : Parser[()=>Int] = {\n    (term<~\"+\")~expr ^^ { case l~r => () => l() + r() } |\n    (term<~\"-\")~expr ^^ { case l~r => () => l() - r() } |\n    term\n  }\n\n  private def term : Parser[()=>Int] = {\n    (factor<~\"*\")~term ^^ { case l~r => () => l() * r() } |\n    (factor<~\"\/\")~term ^^ { case l~r => () => l() \/ r() } |\n    factor\n  }\n\n  private def factor : Parser[()=>Int] = {\n    \"(\"~>expr<~\")\" |\n    \"\\\\d+\".r ^^ { x => () => x.toInt } |\n    failure(\"Expected a value\")\n  }\n}\n\nobject Main {\n  def main(args: Array[String]) {\n    println(\"\"\"Please input the expressions. Type \"q\" to quit.\"\"\")\n    var input: String = \"\"\n\n    do {\n      input = readLine(\"> \")\n      if (input != \"q\") {\n        ArithmeticParser.readExpression(input).foreach(f => println(f()))\n      }\n    } while (input != \"q\")\n  }\n}\n<\/lang>\n\nExample:\n\n<pre>\nC:\\Workset>scala org.rosetta.arithmetic_evaluator.scala.ArithmeticEvaluator\nPlease input the expressions. Type \"q\" to quit.\n> 2+3*2\n8\n> (1+3)*7\n28\n> 1+a\n[1.3] failure: Expected a number\n\n1+a\n  ^\n> 2 + 2\n4\n> q\n<\/pre>\n\nThis example was made rather more complex by the requirement of generating an AST tree. With a Scala distribution there are many examples of arithmetic parsers, as small as half a dozen lines.\n\n==[[:Category:Tcl|Tcl]][[Category:Tcl]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Tcl]] version 8.5[[SMW::on]]<\/div>\nThe code below delivers the AST for an expression in a form that it can be immediately eval-led, using Tcl's prefix operators.\n<lang Tcl>namespace import tcl::mathop::*\n\nproc ast str {\n    # produce abstract syntax tree for an expression\n    regsub -all {[-+*\/()]} $str { & } str ;# \"tokenizer\"\n    s $str\n}\nproc s {args} {\n    # parse \"(a + b) * c + d\" to \"+ [* [+ a b] c] d\"\n    if {[llength $args] == 1} {set args [lindex $args 0]}\n    if [regexp {[()]} $args] {\n        eval s [string map {( \"\\[s \" ) \\]} $args]\n    } elseif {\"*\" in $args} {\n\ts [s_group $args *]\n    } elseif {\"\/\" in $args} {\n\ts [s_group $args \/]\n    } elseif {\"+\" in $args} {\n        s [s_group $args +]\n    } elseif {\"-\" in $args} {\n        s [s_group $args -]\n    } else {\n        string map {\\{ \\[ \\} \\]} [join $args]\n    }\n}\nproc s_group {list op} {\n    # turn \".. a op b ..\" to \".. {op a b} ..\"\n    set pos [lsearch -exact $list $op]\n    set p_1 [- $pos 1]\n    set p1  [+ $pos 1]\n    lreplace $list $p_1 $p1 \\\n                  [list $op [lindex $list $p_1] [lindex $list $p1]]\n}\n#-- Test suite\nforeach test [split {\n    ast 2-2\n    ast 1-2-3\n    ast (1-2)-3\n    ast 1-(2-3)\n    ast (1+2)*3\n    ast (1+2)\/3-4*5\n    ast ((1+2)\/3-4)*5\n} \\n] {\n    puts \"$test ..... [eval $test] ..... [eval [eval $test]]\"\n}<\/lang>\nOutput:<pre>\n    ast 2-2 ..... - 2 2 ..... 0\n    ast 1-2-3 ..... - [- 1 2] 3 ..... -4\n    ast (1-2)-3 ..... - [- 1 2] 3 ..... -4\n    ast 1-(2-3) ..... - 1 [- 2 3] ..... 2\n    ast (1+2)*3 ..... * [+ 1 2] 3 ..... 9\n    ast (1+2)\/3-4*5 ..... - [\/ [+ 1 2] 3] [* 4 5] ..... -19\n    ast ((1+2)\/3-4)*5 ..... * [- [\/ [+ 1 2] 3] 4] 5 ..... -15\n<\/pre>\n\n==[[:Category:TXR|TXR]][[Category:TXR]]==\n\nUse TXR text pattern matching to parse expression to a Lisp AST, then evaluate with <code>eval<\/code>:\n\n<lang txr>@(next :args)\n@(define space)@\/ *\/@(end)\n@(define mulop (nod))@\\\n   @(local op)@\\\n   @(space)@\\\n   @(cases)@\\\n     @{op \/[*]\/}@(bind nod @(intern op *user-package*))@\\\n   @(or)@\\\n     @{op \/\\\/\/}@(bind (nod) @(list 'trunc))@\\\n   @(end)@\\\n   @(space)@\\\n@(end)\n@(define addop (nod))@\\\n   @(local op)@(space)@{op \/[+\\-]\/}@(space)@\\\n   @(bind nod @(intern op *user-package*))@\\\n@(end)\n@(define number (nod))@\\\n  @(local n)@(space)@{n \/[0-9]+\/}@(space)@\\\n  @(bind nod @(int-str n 10))@\\\n@(end)\n@(define factor (nod))@(cases)(@(expr nod))@(or)@(number nod)@(end)@(end)\n@(define term (nod))@\\\n  @(local op nod1 nod2)@\\\n  @(cases)@\\\n    @(factor nod1)@\\\n    @(cases)@(mulop op)@(term nod2)@(bind nod (op nod1 nod2))@\\\n    @(or)@(bind nod nod1)@\\\n    @(end)@\\\n  @(or)@\\\n    @(addop op)@(factor nod1)@\\\n    @(bind nod (op nod1))@\\\n  @(end)@\\\n@(end)\n@(define expr (nod))@\\\n  @(local op nod1 nod2)@\\\n  @(term nod1)@\\\n  @(cases)@(addop op)@(expr nod2)@(bind nod (op nod1 nod2))@\\\n  @(or)@(bind nod nod1)@\\\n  @(end)@\\\n@(end)\n@(cases)\n@  {source (expr e)}\n@  (output)\nsource: @source\nAST:    @(format nil \"~s\" e)\nvalue:  @(eval e nil)\n@  (end)\n@(or)\n@  (maybe)@(expr e)@(end)@bad\n@  (output)\nerroneous suffix \"@bad\"\n@  (end)\n@(end)<\/lang>\n\nRun:\n\n<pre>$  txr expr-ast.txr '3 + 3\/4 * (2 + 2) + (4*4)'\nsource: 3 + 3\/4 * (2 + 2) + (4*4)\nAST:    (+ 3 (+ (trunc 3 (* 4 (+ 2 2))) (* 4 4)))\nvalue:  19<\/pre>\n\n\n[[Category:gnuplot\/Omit]]\n\n==[[:Category:Ursala|Ursala]][[Category:Ursala]]==\nwith no error checking other than removal of spaces\n<lang Ursala>#import std\n#import nat\n#import flo\n\nlex = ~=' '*~F+ rlc both -=digits    # separate into tokens\n\nparse = # build a tree\n\n--<';'>; @iNX ~&l->rh ^\/~&lt cases~&lhh\\~&lhPNVrC {\n   '*\/': ^|C\/~&hNV associate '*\/',\n   '+-': ^|C\/~&hNV associate '*\/+-',\n   ');': @r ~&htitBPC+ associate '*\/+-'}\n\nassociate \"ops\" = ~&tihdh2B-=\"ops\"-> ~&thd2tth2hNCCVttt2C\n\ntraverse = *^ ~&v?\\%ep ^H\\~&vhthPX '+-*\/'-$<plus,minus,times,div>@dh\n\nevaluate = traverse+ parse+ lex<\/lang>\n\ntest program:\n<lang Ursala>#cast %eL\n\ntest = evaluate*t\n\n-[\n1+1\n4\/5\n2-1\n3*7\n3+4+5\n9-2-4\n7\/3\/2\n4+2*3\n5*2-1\n5-3*2\n(1+1)*(2+3)\n(2-4)\/(3+5*(8-1))]-<\/lang>\noutput:\n<pre>\n<\n   2.000000e+00,\n   8.000000e-01,\n   1.000000e+00,\n   2.100000e+01,\n   1.200000e+01,\n   3.000000e+00,\n   1.166667e+00,\n   1.000000e+01,\n   9.000000e+00,\n   -1.000000e+00,\n   1.000000e+01,\n   -5.263158e-02><\/pre>"}]}}}}