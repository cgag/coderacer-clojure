{"query":{"pages":{"2688":{"pageid":2688,"ns":0,"title":"Arithmetic\/Complex","revisions":[{"*":"<div class=\"infobox\" style=\"width: 2in\">[[File:Rcode-button-task-crushed.png|64px|left|alt=Task|link=Category:Solutions by Programming Task]]'''Arithmetic\/Complex'''<br\/>\nYou are encouraged to [[Rosetta Code:Solve a Task|solve this task]] according to the task description, using any language you may know.[[Category:Programming Tasks]][[Category:Arithmetic operations]]<\/div>\nA '''[[wp:Complex number|complex number]]''' is a number which can be written as \"<math>a + b \\times i<\/math>\" (sometimes shown as \"<math>b + a \\times i<\/math>\") where a and b are real numbers and [[wp:Imaginary_unit|<math>i<\/math> is the square root of -1]]. Typically, complex numbers are represented as a pair of real numbers called the \"imaginary part\" and \"real part\", where the imaginary part is the number to be multiplied by <math>i<\/math>.\n\n* Show addition, multiplication, negation, and inversion of complex numbers in separate functions. (Subtraction and division operations can be made with pairs of these operations.) Print the results for each operation tested.\n* ''Optional:'' Show complex conjugation. By definition, the [[wp:complex conjugate|complex conjugate]] of <math>a + bi<\/math> is <math>a - bi<\/math>.\n\nSome languages have complex number libraries available. If your language does, show the operations. If your language does not, also show the definition of this type.\n\n==[[:Category:Ada|Ada]][[Category:Ada]]==\n<lang ada>with Ada.Numerics.Generic_Complex_Types;\nwith Ada.Text_IO.Complex_IO;\n\nprocedure Complex_Operations is\n   -- Ada provides a pre-defined generic package for complex types\n   -- That package contains definitions for composition,\n   -- negation, addition, subtraction, multiplication, division,\n   -- conjugation, exponentiation, and absolute value, as well as\n   -- basic comparison operations.\n   -- Ada provides a second pre-defined package for sin, cos, tan, cot,\n   -- arcsin, arccos, arctan, arccot, and the hyperbolic versions of \n   -- those trigonometric functions.\n   \n   -- The package Ada.Numerics.Generic_Complex_Types requires definition\n   -- with the real type to be used in the complex type definition.\n   \n   package Complex_Types is new Ada.Numerics.Generic_Complex_Types (Long_Float);\n   use Complex_Types;\n   package Complex_IO is new Ada.Text_IO.Complex_IO (Complex_Types);\n   use Complex_IO;\n   use Ada.Text_IO;\n   \n   A : Complex := Compose_From_Cartesian (Re => 1.0, Im => 1.0);\n   B : Complex := Compose_From_Polar (Modulus => 1.0, Argument => 3.14159);\n   C : Complex;\n  \nbegin\n   -- Addition\n   C := A + B;\n   Put(\"A + B = \"); Put(C);\n   New_Line;\n   -- Multiplication\n   C := A * B;\n   Put(\"A * B = \"); Put(C);\n   New_Line;\n   -- Inversion\n   C := 1.0 \/ A;\n   Put(\"1.0 \/ A = \"); Put(C);\n   New_Line;\n   -- Negation\n   C := -A;\n   Put(\"-A = \"); Put(C);\n   New_Line;\n   -- Conjugation\n   C := Conjugate (C);\nend Complex_Operations;<\/lang>\n\n==[[:Category:ALGOL 68|ALGOL 68]][[Category:ALGOL 68]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[ALGOL 68]] version Revision 1 - no extensions to language used[[SMW::on]]<\/div>\n\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[ALGOL 68G]] version Any - tested with release [http:\/\/sourceforge.net\/projects\/algol68\/files\/algol68g\/algol68g-1.18.0\/algol68g-1.18.0-9h.tiny.el5.centos.fc11.i386.rpm\/download 1.18.0-9h.tiny][[SMW::on]]<\/div>\n\n<lang algol68>main:(\n  FORMAT compl fmt = $g(-7,5)\"\u22a5\"g(-7,5)$;\n  \n  PROC compl operations = VOID: (\n    LONG COMPL a = 1.0 \u22a5 1.0;\n    LONG COMPL b = 3.14159 \u22a5 1.2;\n  \n    LONG COMPL c;\n  \n    printf(($x\"a=\"f(compl fmt)l$,a));\n    printf(($x\"b=\"f(compl fmt)l$,b));\n  \n    # addition #\n    c := a + b;\n    printf(($x\"a+b=\"f(compl fmt)l$,c));\n    # multiplication #\n    c := a * b;\n    printf(($x\"a*b=\"f(compl fmt)l$,c));\n    # inversion #\n    c := 1.0 \/ a;\n    printf(($x\"1\/c=\"f(compl fmt)l$,c));\n    # negation #\n    c := -a;\n    printf(($x\"-a=\"f(compl fmt)l$,c))\n  ); \n  compl operations\n)<\/lang>\nOutput:<pre>\na=1.00000\u22a51.00000\nb=3.14159\u22a51.20000\na+b=4.14159\u22a52.20000\na*b=1.94159\u22a54.34159\n1\/c=0.50000\u22a5-.50000\n-a=-1.0000\u22a5-1.0000\n<\/pre>\n==[[:Category:APL|APL]][[Category:APL]]==\n<lang>\n   x\u21901j1                \u235dassignment\n   y\u21905.25j1.5\n   x+y                  \u235daddition\n6.25J2.5\n   x\u00d7y                  \u235dmultiplication\n3.75J6.75\n    \u2339x                  \u235dinversion\n0.5j_0.5\n    -x                  \u235dnegation\n\u00af1J\u00af1\n<\/lang>\n\n==[[:Category:AutoHotkey|AutoHotkey]][[Category:AutoHotkey]]==\ncontributed by Laszlo on the ahk [http:\/\/www.autohotkey.com\/forum\/post-276431.html#276431 forum]\n<lang AutoHotkey>Cset(C,1,1)\nMsgBox % Cstr(C)  ; 1 + i*1\nCneg(C,C)\nMsgBox % Cstr(C)  ; -1 - i*1\nCadd(C,C,C)\nMsgBox % Cstr(C)  ; -2 - i*2\nCinv(D,C)\nMsgBox % Cstr(D)  ; -0.25 + 0.25*i\nCmul(C,C,D)\nMsgBox % Cstr(C)  ; 1 + i*0\n\nCset(ByRef C, re, im) {\n   VarSetCapacity(C,16)\n   NumPut(re,C,0,\"double\")\n   NumPut(im,C,8,\"double\")\n}\nCre(ByRef C) {\n   Return NumGet(C,0,\"double\")\n}\nCim(ByRef C) {\n   Return NumGet(C,8,\"double\")\n}\nCstr(ByRef C) {\n   Return Cre(C) ((i:=Cim(C))<0 ? \" - i*\" . -i : \" + i*\" . i)\n}\nCadd(ByRef C, ByRef A, ByRef B) {\n   VarSetCapacity(C,16)\n   NumPut(Cre(A)+Cre(B),C,0,\"double\")\n   NumPut(Cim(A)+Cim(B),C,8,\"double\")\n}\nCmul(ByRef C, ByRef A, ByRef B) {\n   VarSetCapacity(C,16)\n   t := Cre(A)*Cim(B)+Cim(A)*Cre(B)\n   NumPut(Cre(A)*Cre(B)-Cim(A)*Cim(B),C,0,\"double\")\n   NumPut(t,C,8,\"double\") ; A or B can be C!\n}\nCneg(ByRef C, ByRef A) {\n   VarSetCapacity(C,16)\n   NumPut(-Cre(A),C,0,\"double\")\n   NumPut(-Cim(A),C,8,\"double\")\n}\nCinv(ByRef C, ByRef A) {\n   VarSetCapacity(C,16)\n   d := Cre(A)**2 + Cim(A)**2\n   NumPut( Cre(A)\/d,C,0,\"double\")\n   NumPut(-Cim(A)\/d,C,8,\"double\")\n}<\/lang> \n\n==[[:Category:BASIC|BASIC]][[Category:BASIC]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[QuickBasic]] version 4.5[[SMW::on]]<\/div>\n<lang qbasic>TYPE complex\n        real AS DOUBLE\n        imag AS DOUBLE\nEND TYPE\nDECLARE SUB add (a AS complex, b AS complex, c AS complex)\nDECLARE SUB mult (a AS complex, b AS complex, c AS complex)\nDECLARE SUB inv (a AS complex, b AS complex)\nDECLARE SUB neg (a AS complex, b AS complex)\nCLS\nDIM x AS complex\nDIM y AS complex\nDIM z AS complex\nx.real = 1\nx.imag = 1\ny.real = 2\ny.imag = 2\nCALL add(x, y, z)\nPRINT z.real; \"+\"; z.imag; \"i\"\nCALL mult(x, y, z)\nPRINT z.real; \"+\"; z.imag; \"i\"\nCALL inv(x, z)\nPRINT z.real; \"+\"; z.imag; \"i\"\nCALL neg(x, z)\nPRINT z.real; \"+\"; z.imag; \"i\"\n\n\nSUB add (a AS complex, b AS complex, c AS complex)\n        c.real = a.real + b.real\n        c.imag = a.imag + b.imag\nEND SUB\n\nSUB inv (a AS complex, b AS complex)\n        denom = a.real ^ 2 + a.imag ^ 2\n        b.real = a.real \/ denom\n        b.imag = -a.imag \/ denom\nEND SUB\n\nSUB mult (a AS complex, b AS complex, c AS complex)\n        c.real = a.real * b.real - a.imag * b.imag\n        c.imag = a.real * b.imag + a.imag * b.real\nEND SUB\n\nSUB neg (a AS complex, b AS complex)\n        b.real = -a.real\n        b.imag = -a.imag\nEND SUB<\/lang>\nOutput:\n<pre> 3 + 3 i\n 0 + 4 i\n .5 +-.5 i\n-1 +-1 i<\/pre>\n\n==[[:Category:BBC BASIC|BBC BASIC]][[Category:BBC BASIC]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[BBC BASIC for Windows]][[SMW::on]]<\/div>\n<lang bbcbasic>      DIM Complex{r, i}\n      \n      DIM a{} = Complex{} : a.r = 1.0 : a.i = 1.0\n      DIM b{} = Complex{} : b.r = PI# : b.i = 1.2\n      DIM o{} = Complex{}\n      \n      PROCcomplexadd(o{}, a{}, b{})\n      PRINT \"Result of addition is \" FNcomplexshow(o{})\n      PROCcomplexmul(o{}, a{}, b{})\n      PRINT \"Result of multiplication is \" ; FNcomplexshow(o{})\n      PROCcomplexneg(o{}, a{})\n      PRINT \"Result of negation is \" ; FNcomplexshow(o{})\n      PROCcomplexinv(o{}, a{})\n      PRINT \"Result of inversion is \" ; FNcomplexshow(o{})\n      END\n      \n      DEF PROCcomplexadd(dst{}, one{}, two{})\n      dst.r = one.r + two.r\n      dst.i = one.i + two.i\n      ENDPROC\n      \n      DEF PROCcomplexmul(dst{}, one{}, two{})\n      dst.r = one.r*two.r - one.i*two.i\n      dst.i = one.i*two.r + one.r*two.i\n      ENDPROC\n      \n      DEF PROCcomplexneg(dst{}, src{})\n      dst.r = -src.r\n      dst.i = -src.i\n      ENDPROC\n      \n      DEF PROCcomplexinv(dst{}, src{})\n      LOCAL denom : denom = src.r^2 + src.i^ 2\n      dst.r = src.r \/ denom\n      dst.i = -src.i \/ denom\n      ENDPROC\n      \n      DEF FNcomplexshow(src{})\n      IF src.i >= 0 THEN = STR$(src.r) + \" + \" +STR$(src.i) + \"i\"\n      = STR$(src.r) + \" - \" + STR$(-src.i) + \"i\"<\/lang>\nOutput:\n<pre>Result of addition is 4.14159265 + 2.2i\nResult of multiplication is 1.94159265 + 4.34159265i\nResult of negation is -1 - 1i\nResult of inversion is 0.5 - 0.5i<\/pre>\n\n==[[:Category:C|C]][[Category:C]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[C99]][[SMW::on]]<\/div>\nThe more recent [[C99]] standard has built-in complex number primitive types, which can be declared with float, double, or long double precision. To use these types and their associated library functions, you must include the <complex.h> header. (Note: this is a ''different'' header than the <complex> templates that are defined by [[C++]].) [http:\/\/www.opengroup.org\/onlinepubs\/009695399\/basedefs\/complex.h.html] [http:\/\/publib.boulder.ibm.com\/infocenter\/pseries\/v5r3\/index.jsp?topic=\/com.ibm.vacpp7a.doc\/language\/ref\/clrc03complex_types.htm]\n<lang c>#include <complex.h>\n#include <stdio.h>\n\nvoid cprint(double complex c)\n{\n  printf(\"%f%+fI\", creal(c), cimag(c));\n}\nvoid complex_operations() {\n  double complex a = 1.0 + 1.0I;\n  double complex b = 3.14159 + 1.2I;\n\n  double complex c;\n\n  printf(\"\\na=\"); cprint(a);\n  printf(\"\\nb=\"); cprint(b);\n\n  \/\/ addition\n  c = a + b;\n  printf(\"\\na+b=\"); cprint(c);\n  \/\/ multiplication\n  c = a * b;\n  printf(\"\\na*b=\"); cprint(c);\n  \/\/ inversion\n  c = 1.0 \/ a;\n  printf(\"\\n1\/c=\"); cprint(c);\n  \/\/ negation\n  c = -a;\n  printf(\"\\n-a=\"); cprint(c);\n  \/\/ conjugate\n  c = conj(a);\n  printf(\"\\nconj a=\"); cprint(c); printf(\"\\n\");\n}<\/lang>\n\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[C89]][[SMW::on]]<\/div>\nUser-defined type:\n<lang c>typedef struct{\n        double real;\n        double imag;\n} Complex;\n\nComplex add(Complex a, Complex b){\n        Complex ans;\n        ans.real = a.real + b.real;\n        ans.imag = a.imag + b.imag;\n        return ans;\n}\n\nComplex mult(Complex a, Complex b){\n        Complex ans;\n        ans.real = a.real * b.real - a.imag * b.imag;\n        ans.imag = a.real * b.imag + a.imag * b.real;\n        return ans;\n}\n\n\/* it's arguable that things could be better handled if either\n   a.real or a.imag is +\/-inf, but that's much work *\/\nComplex inv(Complex a){\n        Complex ans;\n        double denom = a.real * a.real + a.imag * a.imag;\n        ans.real =  a.real \/ denom;\n        ans.imag = -a.imag \/ denom;\n        return ans;\n}\n\nComplex neg(Complex a){\n        Complex ans;\n        ans.real = -a.real;\n        ans.imag = -a.imag;\n        return ans;\n}\n\nComplex conj(Complex a){\n        Complex ans;\n        ans.real =  a.real;\n        ans.imag = -a.imag;\n        return ans;\n}\n\nvoid put(Complex c)\n{ \n        printf(\"%lf%+lfI\", c.real, c.imag);\n} \n\nvoid complex_ops(void)\n{ \n  Complex a = { 1.0,     1.0 };\n  Complex b = { 3.14159, 1.2 };\n  \n  printf(\"\\na=\");   put(a);\n  printf(\"\\nb=\");   put(b);\n  printf(\"\\na+b=\"); put(add(a,b));\n  printf(\"\\na*b=\"); put(mult(a,b));\n  printf(\"\\n1\/a=\"); put(inv(a));\n  printf(\"\\n-a=\");  put(neg(a));\n  printf(\"\\nconj a=\");  put(conj(a));  printf(\"\\n\");\n}<\/lang>\n\n==[[:Category:C++|C++]][[Category:C++]]==\n<lang cpp>#include <iostream>\n#include <complex>\nusing std::complex;\n\nvoid complex_operations() {\n  complex<double> a(1.0, 1.0);\n  complex<double> b(3.14159, 1.25);\n\n  \/\/ addition\n  std::cout << a + b << std::endl;\n  \/\/ multiplication\n  std::cout << a * b << std::endl;\n  \/\/ inversion\n  std::cout << 1.0 \/ a << std::endl;\n  \/\/ negation\n  std::cout << -a << std::endl;\n  \/\/ conjugate\n  std::cout << std::conj(a) << std::endl;\n}<\/lang>\n\n==<span id=\"C sharp\">[[:Category:C sharp|C#]]<\/span>[[Category:C sharp]]==\n<lang csharp>using System;\n\npublic struct ComplexNumber\n{\n    public static readonly ComplexNumber i = new ComplexNumber(0.0, 1.0);\n    public static readonly ComplexNumber Zero = new ComplexNumber(0.0, 0.0);\n    \n    public double Re;\n    public double Im;\n\n    public ComplexNumber(double re)\n    {\n        this.Re = re;\n        this.Im = 0;\n    }\n\n    public ComplexNumber(double re, double im)\n    {\n        this.Re = re;\n        this.Im = im;\n    }\n\n    public static ComplexNumber operator *(ComplexNumber n1, ComplexNumber n2)\n    {\n        return new ComplexNumber(n1.Re * n2.Re - n1.Im * n2.Im,\n            n1.Im * n2.Re + n1.Re * n2.Im);\n    }\n\n    public static ComplexNumber operator *(double n1, ComplexNumber n2)\n    {\n        return new ComplexNumber(n1 * n2.Re, n1 * n2.Im);\n    }\n\n    public static ComplexNumber operator \/(ComplexNumber n1, ComplexNumber n2)\n    {\n        double n2Norm = n2.Re * n2.Re + n2.Im * n2.Im;\n        return new ComplexNumber((n1.Re * n2.Re + n1.Im * n2.Im) \/ n2Norm,\n            (n1.Im * n2.Re - n1.Re * n2.Im) \/ n2Norm);\n    }\n\n    public static ComplexNumber operator \/(ComplexNumber n1, double n2)\n    {\n        return new ComplexNumber(n1.Re \/ n2, n1.Im \/ n2);\n    }\n\n    public static ComplexNumber operator +(ComplexNumber n1, ComplexNumber n2)\n    {\n        return new ComplexNumber(n1.Re + n2.Re, n1.Im + n2.Im);\n    }\n\n    public static ComplexNumber operator -(ComplexNumber n1, ComplexNumber n2)\n    {\n        return new ComplexNumber(n1.Re - n2.Re, n1.Im - n2.Im);\n    }\n\n    public static ComplexNumber operator -(ComplexNumber n)\n    {\n        return new ComplexNumber(-n.Re, -n.Im);\n    }\n\n    public static implicit operator ComplexNumber(double n)\n    {\n        return new ComplexNumber(n, 0.0);\n    }\n\n    public static explicit operator double(ComplexNumber n)\n    {\n        return n.Re;\n    }\n\n    public static bool operator ==(ComplexNumber n1, ComplexNumber n2)\n    {\n        return n1.Re == n2.Re && n1.Im == n2.Im;\n    }\n\n    public static bool operator !=(ComplexNumber n1, ComplexNumber n2)\n    {\n        return n1.Re != n2.Re || n1.Im != n2.Im;\n    }\n\n    public override bool Equals(object obj)\n    {\n        return this == (ComplexNumber)obj;\n    }\n\n    public override int GetHashCode()\n    {\n        return Re.GetHashCode() ^ Im.GetHashCode();\n    }\n\n    public override string ToString()\n    {\n        return String.Format(\"{0}+{1}*i\", Re, Im);\n    }\n}\n\npublic static class ComplexMath\n{\n    public static double Abs(ComplexNumber a)\n    {\n        return Math.Sqrt(Norm(a));\n    }\n\n    public static double Norm(ComplexNumber a)\n    {\n        return a.Re * a.Re + a.Im * a.Im;\n    }\n\n    public static double Arg(ComplexNumber a)\n    {\n        return Math.Atan2(a.Im, a.Re);\n    }\n\n    public static ComplexNumber Inverse(ComplexNumber a)\n    {\n        double norm = Norm(a);\n        return new ComplexNumber(a.Re \/ norm, -a.Im \/ norm);\n    }\n\n    public static ComplexNumber Conjugate(ComplexNumber a)\n    {\n        return new ComplexNumber(a.Re, -a.Im);\n\n    }\n\n    public static ComplexNumber Exp(ComplexNumber a)\n    {\n        double e = Math.Exp(a.Re);\n        return new ComplexNumber(e * Math.Cos(a.Im), e * Math.Sin(a.Im));\n    }\n\n    public static ComplexNumber Log(ComplexNumber a)\n    {\n\n        return new ComplexNumber(0.5 * Math.Log(Norm(a)), Arg(a));\n    }\n\n    public static ComplexNumber Power(ComplexNumber a, ComplexNumber power)\n    {\n        return Exp(power * Log(a));\n    }\n\n    public static ComplexNumber Power(ComplexNumber a, int power)\n    {\n        bool inverse = false;\n        if (power < 0)\n        {\n            inverse = true; power = -power;\n        }\n\n        ComplexNumber result = 1.0;\n        ComplexNumber multiplier = a;\n        while (power > 0)\n        {\n            if ((power & 1) != 0) result *= multiplier;\n            multiplier *= multiplier;\n            power >>= 1;\n        }\n\n        if (inverse)\n            return Inverse(result);\n        else\n            return result;\n    }\n\n    public static ComplexNumber Sqrt(ComplexNumber a)\n    {\n        return Exp(0.5 * Log(a));\n    }\n\n    public static ComplexNumber Sin(ComplexNumber a)\n    {\n        return Sinh(ComplexNumber.i * a) \/ ComplexNumber.i;\n    }\n\n    public static ComplexNumber Cos(ComplexNumber a)\n    {\n        return Cosh(ComplexNumber.i * a);\n    }\n\n    public static ComplexNumber Sinh(ComplexNumber a)\n    {\n        return 0.5 * (Exp(a) - Exp(-a));\n    }\n\n    public static ComplexNumber Cosh(ComplexNumber a)\n    {\n        return 0.5 * (Exp(a) + Exp(-a));\n    }\n\n}\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        \/\/ usage\n        ComplexNumber i = 2;\n        ComplexNumber j = new ComplexNumber(1, -2);\n        Console.WriteLine(i * j);\n        Console.WriteLine(ComplexMath.Power(j, 2));\n        Console.WriteLine((double)ComplexMath.Sin(i) + \" vs \" + Math.Sin(2));\n        Console.WriteLine(ComplexMath.Power(j, 0) == 1.0);\n    }\n}<\/lang>\n\n==[[:Category:CoffeeScript|CoffeeScript]][[Category:CoffeeScript]]==\n<lang coffeescript>\n# create an immutable Complex type\nclass Complex\n  constructor: (@r=0, @i=0) ->\n    @magnitude = @r*@r + @i*@i\n\n  plus: (c2) ->\n    new Complex(\n      @r + c2.r,\n      @i + c2.i\n    )\n\n  times: (c2) ->\n    new Complex(\n      @r*c2.r - @i*c2.i,\n      @r*c2.i + @i*c2.r\n    )\n\n  negation: ->\n    new Complex(\n      -1 * @r,\n      -1 * @i\n    )\n\n  inverse: ->\n    throw Error \"no inverse\" if @magnitude is 0\n    new Complex(\n      @r \/ @magnitude,\n      -1 * @i \/ @magnitude\n    )\n\n  toString: ->\n    return \"#{@r}\" if @i == 0\n    return \"#{@i}i\" if @r == 0\n    if @i > 0\n      \"#{@r} + #{@i}i\"\n    else\n      \"#{@r} - #{-1 * @i}i\"\n      \n# test\ndo ->\n  a = new Complex(5, 3)\n  b = new Complex(4, -3)\n  \n  sum = a.plus b\n  console.log \"(#{a}) + (#{b}) = #{sum}\"\n  \n  product = a.times b\n  console.log \"(#{a}) * (#{b}) = #{product}\"\n  \n  negation = b.negation()\n  console.log \"-1 * (#{b}) = #{negation}\"\n  \n  diff = a.plus negation\n  console.log \"(#{a}) - (#{b}) = #{diff}\"\n  \n  inverse = b.inverse()\n  console.log \"1 \/ (#{b}) = #{inverse}\"\n  \n  quotient = product.times inverse\n  console.log \"(#{product}) \/ (#{b}) = #{quotient}\"\n<\/lang>\n\noutput\n<lang>\n> coffee complex.coffee \n(5 + 3i) + (4 - 3i) = 9\n(5 + 3i) * (4 - 3i) = 29 - 3i\n-1 * (4 - 3i) = -4 + 3i\n(5 + 3i) - (4 - 3i) = 1 + 6i\n1 \/ (4 - 3i) = 0.16 + 0.12i\n(29 - 3i) \/ (4 - 3i) = 5 + 3i\n<\/lang>\n\n==[[:Category:Common Lisp|Common Lisp]][[Category:Common Lisp]]==\n\nComplex numbers are a built-in numeric type in Common Lisp. The literal syntax for a complex number is <tt>#C(<var>real<\/var> <var>imaginary<\/var>)<\/tt>. The components of a complex number may be integers, ratios, or floating-point. Arithmetic operations automatically return complex (or real) numbers when appropriate:\n\n<lang lisp>> (sqrt -1)\n#C(0.0 1.0)\n\n> (expt #c(0 1) 2)\n-1<\/lang>\n\nHere are some arithmetic operations on complex numbers:\n\n<lang lisp>> (+ #c(0 1) #c(1 0))\n#C(1 1)\n\n> (* #c(1 1) 2)\n#C(2 2)\n\n> (* #c(1 1) #c(0 2))\n#C(-2 2)\n\n> (- #c(1 1))\n#C(-1 -1)\n\n> (\/ #c(0 2))\n#C(0 -1\/2)\n\n> (conjugate #c(1 1))\n#C(1 -1)<\/lang>\n\nComplex numbers can be constructed from real and imaginary parts using the <tt>complex<\/tt> function, and taken apart using the <tt>realpart<\/tt> and <tt>imagpart<\/tt> functions.\n\n<lang lisp>> (complex 64 (\/ 3 4))\n#C(64 3\/4)\n\n> (realpart #c(5 5))\n5\n\n> (imagpart (complex 0 pi))\n3.141592653589793d0<\/lang>\n\n==[[:Category:D|D]][[Category:D]]==\nBuilt-in complex numbers are now deprecated in D, to simplify the language.\n<lang d>import std.stdio, std.complex;\n\nvoid main() {\n    auto x = complex(1, 1); \/\/ complex of doubles on default\n    auto y = complex(3.14159, 1.2);\n     \n    writeln(x + y);   \/\/ addition  \n    writeln(x * y);   \/\/ multiplication\n    writeln(1.0 \/ x); \/\/ inversion\n    writeln(-x);      \/\/ negation\n}<\/lang>\nOutput:\n<pre>4.14159+2.2i\n1.94159+4.34159i\n0.5-0.5i\n-1-1i<\/pre>\n\n==[[:Category:Euphoria|Euphoria]][[Category:Euphoria]]==\n<lang euphoria>constant REAL = 1, IMAG = 2\ntype complex(sequence s)\n    return length(s) = 2 and atom(s[REAL]) and atom(s[IMAG])\nend type\n\nfunction add(complex a, complex b)\n    return a + b\nend function\n\nfunction mult(complex a, complex b)\n    return {a[REAL] * b[REAL] - a[IMAG] * b[IMAG],\n        a[REAL] * b[IMAG] + a[IMAG] * b[REAL]}\nend function\n\nfunction inv(complex a)\n    atom denom\n    denom = a[REAL] * a[REAL] + a[IMAG] * a[IMAG]\n    return {a[REAL] \/ denom, -a[IMAG] \/ denom}\nend function\n\nfunction neg(complex a)\n    return -a\nend function\n\nfunction scomplex(complex a)\n    sequence s\n    if a[REAL] != 0 then\n        s = sprintf(\"%g\",a)\n    else\n        s = {}\n    end if\n    \n    if a[IMAG] != 0 then\n        if a[IMAG] = 1 then\n            s &= \"+i\"\n        elsif a[IMAG] = -1 then\n            s &= \"-i\"\n        else\n            s &= sprintf(\"%+gi\",a[IMAG])\n        end if\n    end if\n    \n    if length(s) = 0 then\n        return \"0\"\n    else\n        return s\n    end if\nend function\n\ncomplex a, b\na = { 1.0,     1.0 }\nb = { 3.14159, 1.2 }\nprintf(1,\"a = %s\\n\",{scomplex(a)})\nprintf(1,\"b = %s\\n\",{scomplex(b)})\nprintf(1,\"a+b = %s\\n\",{scomplex(add(a,b))})\nprintf(1,\"a*b = %s\\n\",{scomplex(mult(a,b))})\nprintf(1,\"1\/a = %s\\n\",{scomplex(inv(a))})\nprintf(1,\"-a = %s\\n\",{scomplex(neg(a))})<\/lang>\n\nOutput:\n<pre>a = 1+i\nb = 3.14159+1.2i\na+b = 4.14159+2.2i\na*b = 1.94159+4.34159i\n1\/a = 0.5-0.5i\n-a = -1-i<\/pre>\n\n==<span id=\"F Sharp\">[[:Category:F Sharp|F#]]<\/span>[[Category:F Sharp]]==\nEntered into an interactive session to show the results:\n<lang fsharp>\n> open Microsoft.FSharp.Math;;\n\n> let a = complex 1.0 1.0;;\nval a : complex = 1r+1i\n\n> let b = complex 3.14159 1.25;;\nval b : complex = 3.14159r+1.25i\n\n> a + b;;\nval it : Complex = 4.14159r+2.25i {Conjugate = 4.14159r-2.25i;\n                                   ImaginaryPart = 2.25;\n                                   Magnitude = 4.713307515;\n                                   Phase = 0.497661247;\n                                   RealPart = 4.14159;\n                                   i = 2.25;\n                                   r = 4.14159;}\n\n> a * b;;\nval it : Complex = 1.89159r+4.39159i {Conjugate = 1.89159r-4.39159i;\n                                      ImaginaryPart = 4.39159;\n                                      Magnitude = 4.781649868;\n                                      Phase = 1.164082262;\n                                      RealPart = 1.89159;\n                                      i = 4.39159;\n                                      r = 1.89159;}\n\n> a \/ b;;\nval it : Complex =\n  0.384145932435901r+0.165463215905043i\n    {Conjugate = 0.384145932435901r-0.165463215905043i;\n     ImaginaryPart = 0.1654632159;\n     Magnitude = 0.418265673;\n     Phase = 0.4067140652;\n     RealPart = 0.3841459324;\n     i = 0.1654632159;\n     r = 0.3841459324;}\n\n> -a;;\nval it : complex = -1r-1i {Conjugate = -1r+1i;\n                           ImaginaryPart = -1.0;\n                           Magnitude = 1.414213562;\n                           Phase = -2.35619449;\n                           RealPart = -1.0;\n                           i = -1.0;\n                           r = -1.0;}\n<\/lang>\n\n==[[:Category:Factor|Factor]][[Category:Factor]]==\n<lang factor>USING: combinators kernel math math.functions prettyprint ;\n\nC{ 1 2 } C{ 0.9 -2.78 } {\n    [ + . ]             ! addition\n    [ - . ]             ! subtraction\n    [ * . ]             ! multiplication\n    [ \/ . ]             ! division\n    [ ^ . ]             ! power\n} 2cleave\n\nC{ 1 2 } {\n    [ neg . ]           ! negation\n    [ 1 swap \/ . ]      ! multiplicative inverse\n    [ conjugate . ]     ! complex conjugate\n    [ sin . ]           ! sine\n    [ log . ]           ! natural logarithm\n    [ sqrt . ]          ! square root\n} cleave<\/lang>\n\n==[[:Category:Forth|Forth]][[Category:Forth]]==\n<div class=\"examplemeta libheader\">'''Library:''' [[SMW::off]][[:Category:Forth Scientific Library|Forth Scientific Library]][[Category:Forth Scientific Library]][[SMW::on]]<\/div>\nThere is no standard syntax or mechanism for complex numbers. The FSL provides several implementations suitable for different uses. This example uses the existing floating point stack, but other libraries define a separate complex stack and\/or a fixed-point implementation suitable for microcontrollers and DSPs.\n\n<lang forth>include complex.seq\n\n: ZNEGATE ( r i -- -r -i ) fswap fnegate fswap fnegate ;\n\nzvariable x\nzvariable y\n1e 1e   x z!\npi 1.2e y z!\n\nx z@ y z@ z+ z.\nx z@ y z@ z* z.\n1+0i x z@ z\/ z.\nx z@ znegate z.<\/lang>\n\n==[[:Category:Fortran|Fortran]][[Category:Fortran]]==\nIn ANSI FORTRAN 66 or later, COMPLEX is a built-in data type with full access to intrinsic arithmetic operations. Putting each native operation in a function is horribly inefficient, so I will simply demonstrate the operations. This example shows usage for Fortran 90 or later:\n<lang fortran>program cdemo\n    complex :: a = (5,3), b = (0.5, 6.0)      ! complex initializer\n    complex :: absum, abprod, aneg, ainv\n    \n    absum  = a + b\n    abprod = a * b\n    aneg   = -a\n    ainv   = 1.0 \/ a\nend program cdemo<\/lang>\n\nAnd, although you did not ask, here are demonstrations of some other common complex number operations\n<lang fortran>program cdemo2\n    complex :: a = (5,3), b = (0.5, 6)        ! complex initializer\n    real, parameter :: pi = 3.141592653589793 ! The constant \"pi\"\n    complex, parameter :: i = (0, 1)          ! the imaginary unit \"i\" (sqrt(-1))\n    complex :: abdiff, abquot, abpow, aconj, p2cart, newc\n    real :: areal, aimag, anorm, rho = 10, theta = pi \/ 3.0, x = 2.3, y = 3.0\n    integer, parameter :: n = 50\n    integer :: j\n    complex, dimension(0:n-1) :: unit_circle\n    \n    abdiff = a - b\n    abquot = a \/ b\n    abpow  = a ** b\n    areal = real(a)               ! Real part\n    aimag = imag(a)               ! Imaginary part\n    newc = cmplx(x,y)             ! Creating a complex on the fly from two reals intrinsically\n                                  !   (initializer only works in declarations)\n    newc = x + y*i                ! Creating a complex on the fly from two reals arithmetically\n    anorm = abs(a)                ! Complex norm (or \"modulus\" or \"absolute value\")\n                                  !   (use CABS before Fortran 90)\n    aconj = conjg(a)              ! Complex conjugate (same as real(a) - i*imag(a))\n    p2cart = rho * exp(i * theta) ! Euler's polar complex notation to cartesian complex notation\n                                  !   conversion (use CEXP before Fortran 90)\n \n    ! The following creates an array of N evenly spaced points around the complex unit circle\n    ! useful for FFT calculations, among other things\n    unit_circle = exp(2*i*pi\/n * (\/ (j, j=0, n-1) \/) ) \nend program cdemo2<\/lang>\n==[[:Category:GAP|GAP]][[Category:GAP]]==\n<lang gap># GAP knows gaussian integers, gaussian rationals (i.e. Q[i]), and cyclotomic fields. Here are some examples.\n# E(n) is an nth primitive root of 1\ni := Sqrt(-1);\n# E(4)\n(3 + 2*i)*(5 - 7*i);\n# 29-11*E(4)\n1\/i;\n# -E(4)\nSqrt(-3);\n# E(3)-E(3)^2\n\ni in GaussianIntegers;\n# true\ni\/2 in GaussianIntegers;\n# false\ni\/2 in GaussianRationals;\n# true\nSqrt(-3) in Cyclotomics;\n# true<\/lang>\n\n==[[:Category:Go|Go]][[Category:Go]]==\nGo has complex numbers built in, with the complex conjugate in the standard library.\n<lang go>package main\n\nimport (\n    \"fmt\"\n    \"math\/cmplx\"\n)\n\nfunc main() {\n    a := 1 + 1i\n    b := 3.14159 + 1.25i\n    fmt.Println(\"a:      \", a)\n    fmt.Println(\"b:      \", b)\n    fmt.Println(\"a + b:  \", a+b)\n    fmt.Println(\"a * b:  \", a*b)\n    fmt.Println(\"-a:     \", -a)\n    fmt.Println(\"1 \/ a:  \", 1\/a)\n    fmt.Println(\"a\u0305:      \", cmplx.Conj(a))\n}<\/lang>\nOutput:\n<pre>\na:       (1+1i)\nb:       (3.14159+1.25i)\na + b:   (4.14159+2.25i)\na * b:   (1.8915899999999999+4.39159i)\n-a:      (-1-1i)\n1 \/ a:   (0.5-0.5i)\na\u0305:       (1-1i)\n<\/pre>\n\n==[[:Category:Groovy|Groovy]][[Category:Groovy]]==\nGroovy does not provide any built-in facility for complex arithmetic. However, it does support arithmetic operator overloading. Thus it is not too hard to build a fairly robust, complete, and intuitive complex number class, such as the following:\n<lang groovy>class Complex {\n    final Number real, imag\n    \n    static final Complex I = [0,1] as Complex\n    \n    Complex(Number real) { this(real, 0) }\n    \n    Complex(real, imag) { this.real = real; this.imag = imag }\n    \n    Complex plus (Complex c) { [real + c.real, imag + c.imag] as Complex }\n    \n    Complex plus (Number n) { [real + n, imag] as Complex }\n    \n    Complex minus (Complex c) { [real - c.real, imag - c.imag] as Complex }\n    \n    Complex minus (Number n) { [real - n, imag] as Complex }\n    \n    Complex multiply (Complex c) { [real*c.real - imag*c.imag , imag*c.real + real*c.imag] as Complex }\n    \n    Complex multiply (Number n) { [real*n , imag*n] as Complex }\n    \n    Complex div (Complex c) { this * c.recip() }\n    \n    Complex div (Number n) { this * (1\/n) }\n    \n    Complex negative () { [-real, -imag] as Complex }\n    \n    \/** the complex conjugate of this complex number.\n      * Overloads the bitwise complement (~) operator. *\/\n    Complex bitwiseNegate () { [real, -imag] as Complex }\n    \n    \/** the magnitude of this complex number. *\/\n   \/\/ could also use Math.sqrt( (this * (~this)).real )\n    Number abs () { Math.sqrt( real*real + imag*imag ) }\n    \n    \/** the complex reciprocal of this complex number. *\/\n    Complex recip() { (~this) \/ ((this * (~this)).real) }\n    \n    \/** derived angle &#x03B8; (theta) for polar form.\n      * Normalized to 0 &#x2264; &#x03B8; < 2&#x03C0;. *\/\n    Number getTheta() {\n        def theta = Math.atan2(imag,real)\n        theta = theta < 0 ? theta + 2 * Math.PI : theta\n    }\n    \n    \/** derived magnitude &#x03C1; (rho) for polar form. *\/\n    Number getRho() { this.abs() }\n    \n    \/** Runs Euler's polar-to-Cartesian complex conversion,\n      * converting [&#x03C1;, &#x03B8;] inputs into a [real, imag]-based complex number *\/\n    static Complex fromPolar(Number rho, Number theta) {\n        [rho * Math.cos(theta), rho * Math.sin(theta)] as Complex\n    }\n    \n    \/** Creates new complex with same magnitude &#x03C1;, but different angle &#x03B8; *\/\n    Complex withTheta(Number theta) { fromPolar(this.rho, theta) }\n    \n    \/** Creates new complex with same angle &#x03B8;, but different magnitude &#x03C1; *\/\n    Complex withRho(Number rho) { fromPolar(rho, this.theta) }\n    \n    static Complex exp(Complex c) { fromPolar(Math.exp(c.real), c.imag) }\n    \n    static Complex log(Complex c) { [Math.log(c.rho), c.theta] as Complex }\n    \n    Complex power(Complex c) {\n        this == 0 && c != 0  \\\n                ?  [0] as Complex  \\\n                :  c == 1  \\\n                        ?  this  \\\n                        :  exp( log(this) * c )\n    }\n    \n    Complex power(Number n) { this ** ([n, 0] as Complex) }\n    \n    boolean equals(other) {\n        other != null && (other instanceof Complex \\\n                                ? [real, imag] == [other.real, other.imag] \\\n                                : other instanceof Number && [real, imag] == [other, 0])\n    }\n    \n    int hashCode() { [real, imag].hashCode() }\n    \n    String toString() {\n        def realPart = \"${real}\"\n        def imagPart = imag.abs() == 1 ? \"i\" : \"${imag.abs()}i\"\n        real == 0 && imag == 0 \\\n                ? \"0\" \\\n                : real == 0 \\\n                        ? (imag > 0 ? '' : \"-\")  + imagPart \\\n                        : imag == 0 \\\n                                ? realPart \\\n                                : realPart + (imag > 0 ? \" + \" : \" - \")  + imagPart\n    }\n}<\/lang>\nJavadoc on the polar-related methods uses the following Greek alphabet encoded entities: &amp;#x03C1;: &#x03C1; (rho), &amp;#x03B8;: &#x03B8; (theta), and &amp;#x03C0;: &#x03C0; (pi).\n\nTest Program (patterned after the [[#Fortran|Fortran]] example):\n<lang groovy>def tol = 0.000000001  \/\/ tolerance: acceptable \"wrongness\" to account for rounding error\n\nprintln 'Demo 1: functionality as requested'\ndef a = [5,3] as Complex\nprintln 'a == ' + a\ndef b = [0.5,6] as Complex\nprintln 'b == ' + b\n\nprintln \"a + b == (${a}) + (${b}) == \" + (a + b)\nprintln \"a * b == (${a}) * (${b}) == \" + (a * b)\nassert a + (-a) == 0\nprintln \"-a == -(${a}) == \" + (-a)\nassert (a * a.recip() - 1).abs() < tol\nprintln \"1\/a == (${a}).recip() == \" + (a.recip())\nprintln()\n\nprintln 'Demo 2: other functionality not requested, but important for completeness'\nprintln \"a - b == (${a}) - (${b}) == \" + (a - b)\nprintln \"a \/ b == (${a}) \/ (${b}) == \" + (a \/ b)\nprintln \"a ** b == (${a}) ** (${b}) == \" + (a ** b)\nprintln 'a.real == ' + a.real\nprintln 'a.imag == ' + a.imag\nprintln 'a.rho == ' + a.rho\nprintln 'a.theta == ' + a.theta\nprintln '|a| == ' + a.abs()\nprintln 'a_bar == ' + ~a\n\ndef rho = 10\ndef piOverTheta = 3\ndef theta = Math.PI \/ piOverTheta\ndef fromPolar1 = Complex.fromPolar(rho, theta)          \/\/ direct polar-to-cartesian conversion\ndef fromPolar2 = Complex.exp(Complex.I * theta) * rho     \/\/ Euler's equation\nprintln \"rho*cos(theta) +  rho*i*sin(theta) == ${rho}*cos(pi\/${piOverTheta}) +  ${rho}*i*sin(pi\/${piOverTheta}) == \" + fromPolar1\nprintln \"rho * exp(i * theta) == ${rho} * exp(i * pi\/${piOverTheta}) == \" + fromPolar2\nassert (fromPolar1 - fromPolar2).abs() < tol\nprintln()<\/lang>\n\nOutput:\n<pre>Demo 1: functionality as requested\na == 5 + 3i\nb == 0.5 + 6i\na + b == (5 + 3i) + (0.5 + 6i) == 5.5 + 9i\na * b == (5 + 3i) * (0.5 + 6i) == -15.5 + 31.5i\n-a == -(5 + 3i) == -5 - 3i\n1\/a == (5 + 3i).recip() == 0.1470588235 - 0.0882352941i\n\nDemo 2: other functionality not requested, but important for completeness\na - b == (5 + 3i) - (0.5 + 6i) == 4.5 - 3i\na \/ b == (5 + 3i) \/ (0.5 + 6i) == 0.56551724145 - 0.78620689665i\na ** b == (5 + 3i) ** (0.5 + 6i) == -0.013750112198456855 - 0.09332524760169053i\na.real == 5\na.imag == 3\na.rho == 5.830951894845301\na.theta == 0.5404195002705842\n|a| == 5.830951894845301\na_bar == 5 - 3i\nrho*cos(theta) +  rho*i*sin(theta) == 10*cos(pi\/3) +  10*i*sin(pi\/3) == 5.000000000000001 + 8.660254037844386i\nrho * exp(i * theta) == 10 * exp(i * pi\/3) == 5.000000000000001 + 8.660254037844386i<\/pre>\n\nA Groovy equivalent to the \"unit circle\" part of the Fortran demo is shown in the [[Roots_of_unity#Groovy|Roots of unity]] task.\n\n==[[:Category:Haskell|Haskell]][[Category:Haskell]]==\n\nComplex numbers are parameterized in their base type, so you can\nhave ''Complex Integer'' for the Gaussian Integers, ''Complex Float'', ''Complex Double'', etc. The operations are just the usual overloaded numeric operations.\n\n<lang haskell>import Data.Complex\n\nmain = do\n  let a = 1.0 :+ 2.0    -- complex number 1+2i\n  let b = 4             -- complex number 4+0i\n  -- 'b' is inferred to be complex because it's used in \n  -- arithmetic with 'a' below.\n  putStrLn $ \"Add:      \" ++ show (a + b)\n  putStrLn $ \"Subtract: \" ++ show (a - b)\n  putStrLn $ \"Multiply: \" ++ show (a * b)\n  putStrLn $ \"Divide:   \" ++ show (a \/ b)\n  putStrLn $ \"Negate:   \" ++ show (-a)\n  putStrLn $ \"Inverse:  \" ++ show (recip a)\n  putStrLn $ \"Conjugate:\" ++ show (conjugate a)<\/lang>\n\nOutput:\n\n<lang haskell>*Main> main\nAdd:      5.0 :+ 2.0\nSubtract: (-3.0) :+ 2.0\nMultiply: 4.0 :+ 8.0\nDivide:   0.25 :+ 0.5\nNegate:   (-1.0) :+ (-2.0)\nInverse:  0.2 :+ (-0.4)\nConjugate:1.0 :+ (-2.0)<\/lang>\n\n==[[:Category:IDL|IDL]][[Category:IDL]]==\n\n<tt>complex<\/tt> (and <tt>dcomplex<\/tt> for double-precision) is a built-in data type in IDL:\n\n<lang idl>x=complex(1,1)\n y=complex(!pi,1.2)\n print,x+y\n(      4.14159,      2.20000)\n print,x*y\n(      1.94159,     4.34159)\n print,-x\n(     -1.00000,     -1.00000)\n print,1\/x\n(     0.500000,    -0.500000)<\/lang>\n\n==[[:Category:Icon|Icon]][[Category:Icon]] and [[:Category:Unicon|Unicon]][[Category:Unicon]]==\nIcon doesn't provide native support for complex numbers.  Support is included in the IPL.\n<lang Icon>procedure main()\n\nSetupComplex()\na := complex(1,2)   \nb := complex(3,4)\n\nc := complex(&pi,1.5)\nd := complex(1)\ne := complex(,1)\n\nevery v := !\"abcde\" do write(v,\" := \",cpxstr(variable(v)))\n\nwrite(\"a+b := \", cpxstr(cpxadd(a,b)))\nwrite(\"a-b := \", cpxstr(cpxsub(a,b)))\nwrite(\"a*b := \", cpxstr(cpxmul(a,b)))\nwrite(\"a\/b := \", cpxstr(cpxdiv(a,b)))\nwrite(\"neg(a) := \", cpxstr(cpxneg(a)))\nwrite(\"inv(a) := \", cpxstr(cpxinv(a)))\nwrite(\"conj(a) := \", cpxstr(cpxconj(a)))\nwrite(\"abs(a) := \", cpxabs(a))\nwrite(\"neg(1) := \", cpxstr(cpxneg(1)))\nend<\/lang>\nIcon doesn't allow for operator overloading but procedures can be overloaded as was done here to allow 'complex' to behave more robustly.\n\n<div class=\"examplemeta libheader\">'''Library:''' [[SMW::off]][[:Category:Icon Programming Library|Icon Programming Library]][[Category:Icon Programming Library]][[SMW::on]]<\/div>  \n[http:\/\/www.cs.arizona.edu\/icon\/library\/src\/procs\/complex.icn provides complex number support] supplemented by the code below.\n<lang Icon>\nlink complex                            # for complex number support\n\nprocedure SetupComplex()                #: used to setup safe complex\nCOMPLEX()\t\t\t\t#  replace complex record constructor\t\nSetupComplex := 1                       #  never call here again\nreturn\nend\n\nprocedure COMPLEX(rpart,ipart)          #: new safe record constructor and coercion\ninitial complex :=: COMPLEX             # get in front of record constructor\nreturn if \/ipart & (type(rpart) == \"complex\") \n   then rpart                           #                  already complex\n   else COMPLEX( real(\\rpart | 0.0), real(\\ipart|0) )    # create a new complex number\nend        \n\nprocedure cpxneg(z)                     #: negate z\n   z := complex(z)                      # coerce\n   return complex( -z.rpart, -z.ipart)\nend\n\nprocedure cpxinv(z)                     #: inverse of z\n   local denom\n   z := complex(z)                      # coerce\n\n   denom := z.rpart ^ 2 + z.ipart ^ 2\n   return complex(z.rpart \/ denom, z.ipart \/ denom)\nend<\/lang>\nTo take full advantage of the overloaded 'complex' procedure, the other cpxxxx procedures would need to be rewritten or overloaded.\n\nSample output:\n<pre>#complexdemo.exe\n\na := (1.0+2.0i)\nb := (3.0+4.0i)\nc := (3.141592653589793+1.5i)\nd := (1.0+0.0i)\ne := (0.0+1.0i)\na+b := (4.0+6.0i)\na-b := (-2.0-2.0i)\na*b := (-5.0+10.0i)\na\/b := (0.44+0.08i)\nneg(a) := (-1.0-2.0i)\ninv(a) := (0.2+0.4i)\nconj(a) := (1.0-2.0i)\nabs(a) := 2.23606797749979\nneg(1) := (-1.0+0.0i)<\/pre>\n\n{| class=\"messagebox\" style=\"text-align: center; background-color: lightgray; clear: both;\"\n| <div style=\"text-align:center\">This example is '''in need of improvement:'''<\/div>\n<blockquote>This could be better implemented as an object i n Unicon. Note, however, that  Unicon doesn't allow for operator overloading at the current time.<\/blockquote> \n|}[[Category:Unicon examples needing attention]][[Category:Examples needing attention]]\n\n==[[:Category:J|J]][[Category:J]]==\nComplex numbers are a native numeric data type in J. Although the examples shown here are performed on scalars, all numeric operations naturally apply to arrays of complex numbers.\n<lang j>   x=: 1j1\n   y=: 3.14159j1.2\n   x+y\n4.14159j2.2\n   x*y\n1.94159j4.34159\n   %x\n0.5j_0.5\n   -x\n_1j_1<\/lang>\n\n==[[:Category:Java|Java]][[Category:Java]]==\n<lang java>public class Complex{\n   public final double real;\n   public final double imag;\n\n   public Complex(){this(0,0)}\/\/default values to 0...force of habit\n   public Complex(double r, double i){real = r; imag = i;}\n\n   public Complex add(Complex b){\n      return new Complex(this.real + b.real, this.imag + b.imag);\n   }\n\n   public Complex mult(Complex b){\n      \/\/FOIL of (a+bi)(c+di) with i*i = -1\n      return new Complex(this.real * b.real - this.imag * b.imag, this.real * b.imag + this.imag * b.real);\n   }\n\n   public Complex inv(){\n      \/\/1\/(a+bi) * (a-bi)\/(a-bi) = 1\/(a+bi) but it's more workable\n      double denom = real * real + imag * imag;\n      return new Complex(real\/denom,-imag\/denom);\n   }\n\n   public Complex neg(){\n      return new Complex(-real, -imag);\n   }\n\n   public Complex conj(){\n      return new Complex(real, -imag);\n   }\n\n   public String toString(){ \/\/override Object's toString\n      return real + \" + \" + imag + \" * i\";\n   }\n\n   public static void main(String[] args){\n      Complex a = new Complex(Math.PI, -5) \/\/just some numbers\n      Complex b = new Complex(-1, 2.5);\n      System.out.println(a.neg());\n      System.out.println(a.add(b));\n      System.out.println(a.inv());\n      System.out.println(a.mult(b));\n      System.out.println(a.conj());\n   }\n}<\/lang>\n\n==[[:Category:JavaScript|JavaScript]][[Category:JavaScript]]==\n<lang javascript>function Complex(r, i) {\n\tthis.r = r;\n\tthis.i = i;\n}\n\nComplex.add = function() {\n\tvar num = arguments[0];\n\t\n\tfor(var i = 1, ilim = arguments.length; i < ilim; i += 1){\n\t\tnum.r += arguments[i].r;\n\t\tnum.i += arguments[i].i;\n\t}\n\t\n\treturn num;\n}\n\nComplex.multiply = function() {\n\tvar num = arguments[0];\n\t\n\tfor(var i = 1, ilim = arguments.length; i < ilim; i += 1){\n\t\tnum.r = (num.r * arguments[i].r) - (num.i * arguments[i].i);\n\t\tnum.i = (num.i * arguments[i].r) - (num.r * arguments[i].i);\n\t}\n\t\n\treturn num;\n}\n\nComplex.negate = function (z) {\n\treturn new Complex(-1*z.r, -1*z.i);\n}\n\nComplex.invert = function(z) {\n\tvar denom = Math.pow(z.r,2) + Math.pow(z.i,2);\n\treturn new Complex(z.r\/denom, -1*z.i\/denom);\n}\n\nComplex.conjugate = function(z) {\n\treturn new Complex(z.r, -1*z.i);\n}\n\n\/\/ BONUSES!\n\n\nComplex.prototype.toString = function() {\n\treturn this.r === 0 && this.i === 0\n          ? \"0\"\n          : (this.r !== 0 ? this.r : \"\") \n          + ((this.r !== 0 || this.i < 0) && this.i !== 0 \n              ? (this.i > 0 ? \"+\" : \"-\") \n              : \"\" ) + ( this.i !== 0 ? Math.abs(this.i) + \"i\" : \"\" ); \n}\n\nComplex.prototype.getMod = function() {\n\treturn Math.sqrt( Math.pow(this.r,2) , Math.pow(this.i,2) )\n}<\/lang>\n\n==[[:Category:Liberty BASIC|Liberty BASIC]][[Category:Liberty BASIC]]==\n<lang lb>mainwin 50 10\n\nprint \" Adding\",\ncall cprint cadd$(   complex$( 1, 1), complex$( 3.14159265, 1.2))\nprint \" Multiplying\",\ncall cprint cmulti$( complex$( 1, 1), complex$( 3.14159265, 1.2))\nprint \" Inverting\",\ncall cprint cinv$(   complex$( 1, 1))\nprint \" Negating\",\ncall cprint cneg$(   complex$( 1, 1))\n\nend\n\nsub cprint cx$\n    print \"( \"; word$( cx$, 1); \" + i *\"; word$( cx$, 2); \")\"\nend sub\n\nfunction complex$( a , bj )\n''complex number string-object constructor\n  complex$ = str$( a ) ; \" \" ; str$( bj )\nend function\n\nfunction cadd$( a$ , b$ )\n  ar = val( word$( a$ , 1 ) )\n  ai = val( word$( a$ , 2 ) )\n  br = val( word$( b$ , 1 ) )\n  bi = val( word$( b$ , 2 ) )\n  cadd$ = complex$( ar + br , ai + bi )\nend function\n\nfunction cmulti$( a$ , b$ )\n  ar = val( word$( a$ , 1 ) )\n  ai = val( word$( a$ , 2 ) )\n  br = val( word$( b$ , 1 ) )\n  bi = val( word$( b$ , 2 ) )\n  cmulti$ = complex$( ar * br - ai * bi _\n                    , ar * bi + ai * br )\nend function\n\nfunction cneg$( a$)\n  ar = val( word$( a$ , 1 ) )\n  ai = val( word$( a$ , 2 ) )\n  cneg$ =complex$( 0 -ar, 0 -ai)\nend function\n\nfunction cinv$( a$)\n  ar = val( word$( a$ , 1 ) )\n  ai = val( word$( a$ , 2 ) )\n  D =ar^2 +ai^2\n  cinv$ =complex$( ar \/D , 0 -ai \/D )\nend function<\/lang>\n\n==[[:Category:Lua|Lua]][[Category:Lua]]==\n<lang lua>\n\n--defines addition, subtraction, negation, multiplication, division, conjugation, norms, and a conversion to strgs.\ncomplex = setmetatable({\n__add = function(u, v) return complex(u.real + v.real, u.imag + v.imag) end,\n__sub = function(u, v) return complex(u.real - v.real, u.imag - v.imag) end,\n__mul = function(u, v) return complex(u.real * v.real - u.imag * v.imag, u.real * v.imag + u.imag * v.real) end,\n__div = function(u, v) return u * complex(v.real \/ v.norm, -v.imag \/ v.norm) end,\n__unm = function(u) return complex(-u.real, -u.imag) end,\n__concat = function(u, v)\n    if type(u) == \"table\" then return u.real .. \" + \" .. u.imag .. \"i\" .. v\n\telseif type(u) == \"string\" or type(u) == \"number\" then return u .. v.real .. \" + \" .. v.imag .. \"i\"\n\tend end,\n__index = function(u, index)\n  local operations = {\n    norm = function(u) return u.real ^ 2 + u.imag ^ 2 end,\n    conj = function(u) return complex(u.real, -u.imag) end,\n  }\n  return operations[index] and operations[index](u)\nend,\n__newindex = function() error() end\n}, {\n__call = function(z, realpart, imagpart) return setmetatable({real = realpart, imag = imagpart}, complex) end\n} )\n\nlocal i, j = complex(2, 3), complex(1, 1)\n\nprint(i .. \" + \" .. j .. \" = \" .. (i+j))\nprint(i .. \" - \" .. j .. \" = \" .. (i-j))\nprint(i .. \" * \" .. j .. \" = \" .. (i*j))\nprint(i .. \" \/ \" .. j .. \" = \" .. (i\/j))\nprint(\"|\" .. i .. \"| = \" .. math.sqrt(i.norm))\nprint(i .. \"* = \" .. i.conj)\n<\/lang>\n\n==[[:Category:Maple|Maple]][[Category:Maple]]==\n\nMaple has <code>I<\/code> (the square root of -1) built-in. Thus:\n\n<lang maple>x := 1+I;\ny := Pi+I*1.2;<\/lang>\n\nBy itself, it will perform mathematical operations symbolically, i.e. it will not try to perform computational evaluation unless specifically asked to do so. Thus:\n\n<lang maple>x*y;\n    ==> (1 + I) (Pi + 1.2 I)\nsimplify(x*y);\n    ==> 1.941592654 + 4.341592654 I<\/lang>\n\nOther than that, the task merely asks for\n\n<lang maple>x+y;\nx*y;\n-x;\n1\/x;<\/lang>\n\n==[[:Category:Mathematica|Mathematica]][[Category:Mathematica]]==\nMathematica has fully implemented support for complex numbers throughout the software. Addition, subtraction, division, multiplications and powering need no further syntax than for real numbers:\n<lang Mathematica>x=1+2I\ny=3+4I\n\nx+y  =>  4 + 6 I\nx-y  =>  -2 - 2 I\ny x  =>  -5 + 10 I\ny\/x  => 11\/5 - (2 I)\/5\nx^3  =>  -11 - 2 I\ny^4  =>  -527 - 336 I\nx^y  =>  (1 + 2 I)^(3 + 4 I)    \nN[x^y]  =>  0.12901 + 0.0339241 I<\/lang>\nPowering to a complex power can in general not be written shorter, so Mathematica leaves it unevaluated if the numbers are exact. An approximation can be acquired using the function N.\nHowever Mathematica goes much further, basically all functions can handle complex numbers to arbitrary precision, including (but not limited to!):\n<lang Mathematica>Exp  Log\nSin  Cos  Tan  Csc  Sec  Cot\nArcSin  ArcCos  ArcTan  ArcCsc  ArcSec  ArcCot\nSinh  Cosh  Tanh  Csch  Sech  Coth\nArcSinh  ArcCosh  ArcTanh  ArcCsch  ArcSech  ArcCoth\nSinc\nHaversine  InverseHaversine \nFactorial  Gamma  PolyGamma  LogGamma\nErf  BarnesG  Hyperfactorial  Zeta  ProductLog  RamanujanTauL<\/lang>\nand many many more. The documentation states:\n\n''Mathematica has fundamental support for both explicit complex numbers and symbolic complex variables. All applicable mathematical functions support arbitrary-precision evaluation for complex values of all parameters, and symbolic operations automatically treat complex variables with full generality.''\n\n==[[:Category:MATLAB|MATLAB]][[Category:MATLAB]]==\nComplex numbers are a primitive data type in MATLAB. All the typical complex operations can be performed. There are two keywords that specify a number as complex: \"i\" and \"j\".\n\n<lang MATLAB>>> a = 1+i\n\na =\n\n  1.000000000000000 + 1.000000000000000i\n\n>> b = 3+7i\n\nb =\n\n  3.000000000000000 + 7.000000000000000i\n\n>> a+b\n\nans =\n\n  4.000000000000000 + 8.000000000000000i\n\n>> a-b\n\nans =\n\n -2.000000000000000 - 6.000000000000000i\n\n>> a*b\n\nans =\n\n -4.000000000000000 +10.000000000000000i\n\n>> a\/b\n\nans =\n\n  0.172413793103448 - 0.068965517241379i\n\n>> -a\n\nans =\n\n -1.000000000000000 - 1.000000000000000i\n\n>> a'\n\nans =\n\n  1.000000000000000 - 1.000000000000000i\n\n>> a^b\n\nans =\n\n  0.000808197112874 - 0.011556516327187i\n\n>> norm(a)\n\nans =\n\n   1.414213562373095<\/lang>\n\n==[[:Category:Modula-2|Modula-2]][[Category:Modula-2]]==\n<lang modula2>MODULE complex;\n\nIMPORT  InOut;\n\nTYPE    Complex         = RECORD   R, Im    : REAL    END;\n\nVAR     z               : ARRAY [0..3] OF Complex;\n\nPROCEDURE ShowComplex (str  : ARRAY OF CHAR;  p  : Complex);\n\nBEGIN\n  InOut.WriteString (str);              InOut.WriteString (\" = \");\n  InOut.WriteReal (p.R, 6, 2);\n  IF  p.Im >= 0.0  THEN  InOut.WriteString (\" + \")  ELSE  InOut.WriteString (\" - \")  END;\n  InOut.WriteReal (ABS (p.Im), 6, 2);   InOut.WriteString (\" i \");\n  InOut.WriteLn;                        InOut.WriteBf\nEND ShowComplex;\n\nPROCEDURE AddComplex (x1, x2 : Complex; VAR x3  : Complex);\n\nBEGIN\n  x3.R  := x1.R  + x2.R;\n  x3.Im := x1.Im + x2.Im\nEND AddComplex;\n\nPROCEDURE SubComplex (x1, x2 : Complex; VAR x3  : Complex);\n\nBEGIN\n  x3.R := x1.R - x2.R;\n  x3.Im := x1.Im - x2.Im\nEND SubComplex;\n\nPROCEDURE MulComplex (x1, x2  : Complex; VAR x3  : Complex);\n\nBEGIN\n  x3.R := x1.R * x2.R - x1.Im * x2.Im;\n  x3.Im := x1.R * x2.Im + x1.Im * x2.R\nEND MulComplex;\n\nPROCEDURE InvComplex (x1 : Complex; VAR x2  : Complex);\n\nBEGIN\n  x2.R := x1.R \/ (x1.R * x1.R + x1.Im * x1.Im);\n  x2.Im := -1.0 * x1.Im \/ (x1.R * x1.R + x1.Im * x1.Im)\nEND InvComplex;\n\nPROCEDURE NegComplex (x1 : Complex; VAR x2  : Complex);\n\nBEGIN\n  x2.R := - x1.R;       x2.Im := - x1.Im\nEND NegComplex;\n\nBEGIN\n  InOut.WriteString (\"Enter two complex numbers : \");\n  InOut.WriteBf;\n  InOut.ReadReal (z[0].R);              InOut.ReadReal (z[0].Im);\n  InOut.ReadReal (z[1].R);              InOut.ReadReal (z[1].Im);\n  ShowComplex (\"z1\", z[0]);             ShowComplex (\"z2\", z[1]);\n  InOut.WriteLn;\n  AddComplex (z[0], z[1], z[2]);        ShowComplex (\"z1 + z2\", z[2]);\n  SubComplex (z[0], z[1], z[2]);        ShowComplex (\"z1 - z2\", z[2]);\n  MulComplex (z[0], z[1], z[2]);        ShowComplex (\"z1 * z2\", z[2]);\n  InvComplex (z[0], z[2]);              ShowComplex (\"1  \/ z1\", z[2]);\n  NegComplex (z[0], z[2]);              ShowComplex (\"   - z1\", z[2]);\n  InOut.WriteLn\nEND complex.<\/lang>Output :<pre>Enter two complex numbers : 5 3 0.5 6\nz1 =   5.00 +   3.00 i\nz2 =   0.50 +   6.00 i\n\nz1 + z2 =   5.50 +   9.00 i\nz1 - z2 =   4.50 -   3.00 i\nz1 * z2 = -15.50 +  31.50 i\n1  \/ z1 =   0.15 -   0.09 i\n   - z1 =  -5.00 -   3.00 i<\/pre>\n\n\n==[[:Category:OCaml|OCaml]][[Category:OCaml]]==\nThe [http:\/\/caml.inria.fr\/pub\/docs\/manual-ocaml\/libref\/Complex.html Complex] module from the standard library provides the functionality of complex numbers:\n<lang ocaml>open Complex\n\nlet print_complex z =\n  Printf.printf \"%f + %f i\\n\" z.re z.im\n\nlet () =\n  let a = { re = 1.0; im = 1.0 }\n  and b = { re = 3.14159; im = 1.25 } in\n  print_complex (add a b);\n  print_complex (mul a b);\n  print_complex (inv a);\n  print_complex (neg a);\n  print_complex (conj a)<\/lang>\n\nUsing [http:\/\/forge.ocamlcore.org\/projects\/pa-do\/ Delimited Overloading], the syntax can be made closer to the usual one:\n<lang ocaml>let () =\n  Complex.(\n    let print txt z = Printf.printf \"%s = %s\\n\" txt (to_string z) in\n    let a = 1 + I\n    and b = 3 + 7I in\n    print \"a + b\" (a + b);\n    print \"a - b\" (a - b);\n    print \"a * b\" (a * b);\n    print \"a \/ b\" (a \/ b);\n    print \"-a\" (- a);\n    print \"conj a\" (conj a);\n    print \"a^b\" (a**b);\n    Printf.printf \"norm a = %g\\n\" (float(abs a));\n  )<\/lang>\n\n==[[:Category:Octave|Octave]][[Category:Octave]]==\nGNU Octave handles naturally complex numbers:\n<lang octave>z1 = 1.5 + 3i;\nz2 = 1.5 + 1.5i;\ndisp(z1 + z2);    % 3.0 + 4.5i\ndisp(z1 - z2);    % 0.0 + 1.5i\ndisp(z1 * z2);    % -2.25 + 6.75i\ndisp(z1 \/ z2);    % 1.5 + 0.5i\ndisp(-z1);        % -1.5 - 3i\ndisp(z1');        % 1.5 - 3i\ndisp(abs(z1));    % 3.3541 = sqrt(z1*z1')\ndisp(z1 ^ z2);    % -1.10248 - 0.38306i\ndisp( exp(z1) );  % -4.43684 + 0.63246i\ndisp( imag(z1) ); % 3\ndisp( real(z2) ); % 1.5\n%...<\/lang>\n\n==[[:Category:PARI\/GP|PARI\/GP]][[Category:PARI\/GP]]==\nTo use, type, e.g., inv(3 + 7*I).\n<lang parigp>add(a,b)=a+b;\nmult(a,b)=a*b;\nneg(a)=-a;\ninv(a)=1\/a;<\/lang>\n\n==[[:Category:Pascal|Pascal]][[Category:Pascal]]==\n<lang pascal>program showcomplex(output);\n\ntype\n complex = record\n            re,im: real\n           end;\n\nvar\n z1, z2, zr: complex;\n\nprocedure set(var result: complex; re, im: real);\n begin\n  result.re := re;\n  result.im := im\n end;\n\nprocedure print(a: complex);\n begin\n  write('(', a.re , ',', a.im, ')')\n end;\n\nprocedure add(var result: complex; a, b: complex);\n begin\n  result.re := a.re + b.re;\n  result.im := a.im + b.im;\n end;\n\nprocedure neg(var result: complex; a: complex);\n begin\n  result.re := -a.re;\n  result.im := -a.im\n end;\n\nprocedure mult(var result: complex; a, b: complex);\n begin\n  result.re := a.re*b.re - a.im*b.im;\n  result.im := a.re*b.im + a.im*b.re\n end;\n\nprocedure inv(var result: complex; a: complex);\n var\n  anorm: real;\n begin\n  anorm := a.re*a.re + a.im*a.im;\n  result.re := a.re\/anorm;\n  result.im := -a.im\/anorm\n end;\n\nbegin\n set(z1, 3, 4);\n set(z2, 5, 6);\n\n neg(zr, z1);\n print(zr); { prints (-3,-4) }\n writeln;\n\n add(zr, z1, z2);\n print(zr); { prints (8,10) }\n writeln;\n\n inv(zr, z1);\n print(zr); { prints (0.12,-0.16) }\n writeln;\n\n mul(zr, z1, z2);\n print(zr); { prints (-9,38) }\n writeln\nend.<\/lang>\n\nFreePascal has a complex units. Example of usage:\n<lang Pascal>Program ComplexDemo;\n\nuses\n  ucomplex;\n\nvar\n  a, b, absum, abprod, aneg, ainv, acong: complex;\n\nfunction complex(const re, im: real): ucomplex.complex; overload;\n  begin\n    complex.re := re;\n    complex.im := im;\n  end;\n\nbegin\n  a      := complex(5, 3);\n  b      := complex(0.5, 6.0);\n  absum  := a + b;\n  writeln ('(5 + i3) + (0.5 + i6.0): ', absum.re:3:1, ' + i', absum.im:3:1);\n  abprod := a * b;\n  writeln ('(5 + i3) * (0.5 + i6.0): ', abprod.re:5:1, ' + i', abprod.im:4:1);\n  aneg   := -a;\n  writeln ('-(5 + i3): ', aneg.re:3:1, ' + i', aneg.im:3:1);\n  ainv   := 1.0 \/ a;\n  writeln ('1\/(5 + i3): ', ainv.re:3:1, ' + i', ainv.im:3:1);\n  acong  := cong(a);\n  writeln ('conj(5 + i3): ', acong.re:3:1, ' + i', acong.im:3:1);\nend.\n<\/lang>\n\n==[[:Category:Perl|Perl]][[Category:Perl]]==\nThe <code>Math::Complex<\/code> module implements complex arithmetic.\n<lang perl>use Math::Complex;\nmy $a = 1 + 1*i;\nmy $b = 3.14159 + 1.25*i;\n\nprint \"$_\\n\" foreach\n    $a + $b,    # addition\n    $a * $b,    # multiplication\n    -$a,        # negation\n    1 \/ $a,     # multiplicative inverse\n    ~$a;        # complex conjugate<\/lang>\n\n==[[:Category:Perl 6|Perl 6]][[Category:Perl 6]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Rakudo]] version #22 \"Thousand Oaks\"[[SMW::on]]<\/div>\n\n<lang perl6>my $a = 1 + i;\nmy $b = pi + 1.25i;\n\n.say for $a + $b, $a * $b, -$a, 1 \/ $a, $a.conj;\n.say for $a.abs, $a.sqrt, $a.re, $a.im;<\/lang>\nOutput (precision varies with different implementations):\n<pre>\n4.1415926535897931+2.25i\n1.8915926535897931+4.3915926535897931i\n-1-1i\n0.5-0.5i\n1-1i\n1.4142135623730951\n1.0986841134678098+0.45508986056222733i\n1\n1\n<\/pre>\n\n==[[:Category:PL\/I|PL\/I]][[Category:PL\/I]]==\n<lang PL\/I>\n\/* PL\/I complex numbers may be integer or floating-point.  *\/\n\/* In this example, the variables are floating-pint.       *\/\n\/* For integer variables, change 'float' to 'fixed binary' *\/\n\ndeclare (a, b) complex float;\na = 2+5i;\nb = 7-6i;\n\nput skip list (a+b);\nput skip list (a - b);\nput skip list (a*b);\nput skip list (a\/b);\nput skip list (a**b);\nput skip list (1\/a);\nput skip list (conjg(a)); \/* gives the conjugate of 'a'. *\/\n\n\/* Functions exist for extracting the real and imaginary parts *\/\n\/* of a complex number. *\/\n\n\/* As well, trigonometric functions may be used with complex  *\/\n\/* numbers, such as SIN, COS, TAN, ATAN, and so on.           *\/\n<\/lang>\n\n==[[:Category:PicoLisp|PicoLisp]][[Category:PicoLisp]]==\n<lang PicoLisp>(load \"@lib\/math.l\")\n\n(de addComplex (A B)\n   (cons\n      (+ (car A) (car B))        # Real\n      (+ (cdr A) (cdr B)) ) )    # Imag\n\n(de mulComplex (A B)\n   (cons\n      (-\n         (*\/ (car A) (car B) 1.0)\n         (*\/ (cdr A) (cdr B) 1.0) )\n      (+\n         (*\/ (car A) (cdr B) 1.0)\n         (*\/ (cdr A) (car B) 1.0) ) ) )\n\n(de invComplex (A)\n   (let Denom\n      (+\n         (*\/ (car A) (car A) 1.0)\n         (*\/ (cdr A) (cdr A) 1.0) )\n      (cons\n         (*\/ (car A) 1.0 Denom)\n         (- (*\/ (cdr A) 1.0 Denom)) ) ) )\n\n(de negComplex (A)\n   (cons (- (car A)) (- (cdr A))) )\n\n(de fmtComplex (A)\n   (pack\n      (round (car A) (dec *Scl))\n      (and (gt0 (cdr A)) \"+\")\n      (round (cdr A) (dec *Scl))\n      \"i\" ) )\n\n(let (A (1.0 . 1.0)  B (cons pi 1.2))\n   (prinl \"A = \" (fmtComplex A))\n   (prinl \"B = \" (fmtComplex B))\n   (prinl \"A+B = \" (fmtComplex (addComplex A B)))\n   (prinl \"A*B = \" (fmtComplex (mulComplex A B)))\n   (prinl \"1\/A = \" (fmtComplex (invComplex A)))\n   (prinl \"-A = \" (fmtComplex (negComplex A))) )<\/lang>\nOutput:\n<pre>A = 1.00000+1.00000i\nB = 3.14159+1.20000i\nA+B = 4.14159+2.20000i\nA*B = 1.94159+4.34159i\n1\/A = 0.50000-0.50000i\n-A = -1.00000-1.00000i<\/pre>\n\n==[[:Category:Pop11|Pop11]][[Category:Pop11]]==\n\nComplex numbers are a built-in data type in Pop11.  Real and\nimaginary part of complex numbers can be floating point or\nexact (integer or rational) value (both part must be of the same\ntype).  Operations on floating point complex numbers always produce\ncomplex numbers.  Operations on exact complex numbers give\nreal result (integer or rational) if imaginary part of the result\nis 0.  The '+:' and '-:' operators create complex numbers:\n'1 -: 3' is '1 - 3i' in mathematical notation.\n\n<lang pop11>lvars a = 1.0 +: 1.0, b = 2.0 +: 5.0 ;\na+b =>\na*b =>\n1\/a =>\na-b =>\na-a =>\na\/b =>\na\/a =>\n\n;;; The same, but using exact values\n1 +: 1 -> a;\n2 +: 5 -> b;\na+b =>\na*b =>\n1\/a =>\na-b =>\na-a =>\na\/b =>\na\/a =><\/lang>\n==[[:Category:PostScript|PostScript]][[Category:PostScript]]==\nComplex numbers can be represented as 2 element vectors ( arrays ). Thus, a+bi can be written as [a b] in PostScript.\n<lang>\n%Adding two complex numbers\n\/addcomp{\n\/x exch def\n\/y exch def\n\/z [0 0] def\nz 0 x 0 get y 0 get add put \nz 1 x 1 get y 1 get add put\nz pstack\n}def \n\n%Subtracting one complex number from another\n\/subcomp{\n\/x exch def\n\/y exch def\n\/z [0 0] def\nz 0 x 0 get y 0 get sub put \nz 1 x 1 get y 1 get sub put\nz pstack\n}def\n\n%Multiplying two complex numbers\n\/mulcomp{\n\/x exch def\n\/y exch def\n\/z [0 0] def\nz 0 x 0 get y 0 get mul x 1 get y 1 get mul sub  put \nz 1 x 1 get y 0 get mul x 0 get y 1 get mul add put\nz pstack\n}def\n\n%Negating a complex number\n\/negcomp{\n\/x exch def\n\/z [0 0] def\nz 0 x 0 get neg put\nz 1 x 1 get neg put\nz pstack\n}def\n\n%Inverting a complex number\n\/invcomp{\n\/x exch def\n\/z [0 0] def\nz 0 x 0 get x 0 get 2 exp x 1 get 2 exp add div put\nz 0 x 1 get neg x 0 get 2 exp x 1 get 2 exp add div put\nz pstack\n}def\n\n<\/lang>\n\n==[[:Category:PureBasic|PureBasic]][[Category:PureBasic]]==\n<lang PureBasic>Structure Complex\n  real.d\n  imag.d\nEndStructure\n\nProcedure Add_Complex(*A.Complex, *B.Complex) \n  Protected *R.Complex=AllocateMemory(SizeOf(Complex))\n  If *R\n    *R\\real=*A\\real+*B\\real\n    *R\\imag=*A\\imag+*B\\imag\n  EndIf\n  ProcedureReturn *R\nEndProcedure\n\nProcedure Inv_Complex(*A.Complex)\n  Protected *R.Complex=AllocateMemory(SizeOf(Complex)), denom.d\n  If *R\n    denom  = *A\\real * *A\\real + *A\\imag * *A\\imag\n    *R\\real= *A\\real \/ denom\n    *R\\imag=-*A\\imag \/ denom\n  EndIf\n  ProcedureReturn *R\nEndProcedure\n\nProcedure Mul_Complex(*A.Complex, *B.Complex)\n  Protected *R.Complex=AllocateMemory(SizeOf(Complex))\n  If *R\n    *R\\real=*A\\real * *B\\real - *A\\imag * *B\\imag\n    *R\\imag=*A\\real * *B\\imag + *A\\imag * *B\\real\n  EndIf\n  ProcedureReturn *R\nEndProcedure\n\nProcedure Neg_Complex(*A.Complex)\n  Protected *R.Complex=AllocateMemory(SizeOf(Complex))\n  If *R\n    *R\\real=-*A\\real\n    *R\\imag=-*A\\imag\n  EndIf\n  ProcedureReturn *R\nEndProcedure\n\nProcedure ShowAndFree(Header$, *Complex.Complex)\n  If *Complex\n    Protected.d i=*Complex\\imag, r=*Complex\\real \n    Print(LSet(Header$,7))\n    Print(\"= \"+StrD(r,3))\n    If i>=0:  Print(\" + \")\n    Else:     Print(\" - \")\n    EndIf\n    PrintN(StrD(Abs(i),3)+\"i\")\n    FreeMemory(*Complex)\n  EndIf\nEndProcedure\n\nIf OpenConsole()\n  Define.Complex a, b, *c\n  a\\real=1.0: a\\imag=1.0\n  b\\real=#PI: b\\imag=1.2\n  *c=Add_Complex(a,b):  ShowAndFree(\"a+b\",    *c)\n  *c=Mul_Complex(a,b):  ShowAndFree(\"a*b\",    *c)\n  *c=Inv_Complex(a):    ShowAndFree(\"Inv(a)\", *c)\n  *c=Neg_Complex(a):    ShowAndFree(\"-a\",     *c)\n  Print(#CRLF$+\"Press ENTER to exit\"):Input()\nEndIf<\/lang>\n\n==[[:Category:Python|Python]][[Category:Python]]==\n\n<lang python>>>> z1 = 1.5 + 3j\n>>> z2 = 1.5 + 1.5j\n>>> z1 + z2\n(3+4.5j)\n>>> z1 - z2\n1.5j\n>>> z1 * z2\n(-2.25+6.75j)\n>>> z1 \/ z2\n(1.5+0.5j)\n>>> - z1\n(-1.5-3j)\n>>> z1.conjugate()\n(1.5-3j)\n>>> abs(z1)\n3.3541019662496847\n>>> z1 ** z2\n(-1.1024829553277784-0.38306415117199333j)\n>>> z1.real\n1.5\n>>> z1.imag\n3.0\n>>> <\/lang>\n\n==[[:Category:R|R]][[Category:R]]==\n<div class=\"examplemeta translation\">'''Translation of''': [[Arithmetic\/Complex#Octave|Octave]]<\/div>\n\n<lang R>z1 <- 1.5 + 3i\nz2 <- 1.5 + 1.5i\nprint(z1 + z2)   #  3+4.5i                    \nprint(z1 - z2)   #  0+1.5i               \nprint(z1 * z2)   #  -2.25+6.75i          \nprint(z1 \/ z2)   #  1.5+0.5i             \nprint(-z1)       #  -1.5-3i              \nprint(Conj(z1))  #  1.5-3i               \nprint(abs(z1))   #  3.354102             \nprint(z1^z2)     #  -1.102483-0.383064i  \nprint(exp(z1))   #  -4.436839+0.632456i  \nprint(Re(z1))    #  1.5                  \nprint(Im(z1))    #  3<\/lang>\n\n==[[:Category:REXX|REXX]][[Category:REXX]]==\nThe REXX language has no complex type numbers, but some complex arithmetic subroutines can easily be written.\n<lang rexx>\/*REXX program to show how to support math functions for complex numbers*\/\n\nx='(5,3i)'\ny='(.5,6j)'\n\nsum  = Cadd(x,y);    say '      addition:   ' x \" + \" y ' = ' sum\ndif  = Csub(x,y);    say '    subtration:   ' x \" + \" y ' = ' dif\nprod = Cmul(x,y);    say 'multiplication:   ' x \" * \" y ' = ' prod\nquot = Cdiv(x,y);    say '      division:   ' x \" \u00f7 \" y ' = ' quot\ninv  = Cinv(x);      say '       inverse:   ' x \"             = \" inv\ncnjX = Ccnj(x);      say '  conjugate of:   ' x \"             = \" cnjX\nnegX = Cneg(x);      say '   negation of:   ' x \"             = \" negX\nexit\n\/*\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500one\u2500liners\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500*\/\nCcnj: procedure;arg a ',' b,c ',' d;call Cg;r1=a;r2=-b;return Cr()\nCadd: procedure;arg a ',' b,c ',' d;call Cg;r1=a+c;r2=b+d;return Cr()\nCsub: procedure;arg a ',' b,c ',' d;call Cg;r1=a-c;r2=b-d;return Cr()\nCmul: procedure;arg a ',' b,c ',' d;call Cg;r1=a*c-b*d; r2=b*c+a*d;return Cr()\nCdiv: procedure;arg a ',' b,c ',' d;call Cg;_=c*c+d*d;r1=(a*c+b*d)\/_;r2=(b*c-a*d)\/_;return Cr()\nCg:   a=Cdej(a); b=Cdej(b); c=Cdej(c); d=Cdej(d); return\nCr:   _='['r1; if r2\\=0 then _=_','r2\"j\"; return _']'\nCdej: return word(translate(arg(1),,'{[(JI)]}') 0,1)\nCneg: return Cmul(arg(1),-1)\nCinv: return Cdiv(1,arg(1))<\/lang>\n'''output'''\n<pre style=\"overflow:scroll\">\n      addition:    (5,3i)  +  (.5,6j)  =  [5.5,9j]\n    subtration:    (5,3i)  +  (.5,6j)  =  [4.5,-3j]\nmultiplication:    (5,3i)  *  (.5,6j)  =  [-15.5,31.5j]\n      division:    (5,3i)  \u00f7  (.5,6j)  =  [0.565517241,-0.786206897j]\n       inverse:    (5,3i)              =  [0.147058824,-0.0882352941j]\n  conjugate of:    (5,3i)              =  [5,-3j]\n   negation of:    (5,3i)              =  [-5,-3j]\n<\/pre>\n\n==[[:Category:RLaB|RLaB]][[Category:RLaB]]==\n\n<lang RLaB>\n>> x = sqrt(-1)\n                        0 + 1i\n>> y = 10 + 5i\n                       10 + 5i\n>> z = 5*x-y\n                      -10 + 0i\n>> isreal(z)\n  1\n<\/lang>\n\n==[[:Category:Ruby|Ruby]][[Category:Ruby]]==\n<lang ruby>require 'complex'  # With Ruby 1.9, this line is optional.\n\n# Two ways to write complex numbers:\na = Complex(1, 1)       # 1. call Kernel#Complex\ni = Complex::I          # 2. use Complex::I\nb = 3.14159 + 1.25 * i\n\n# Operations:\nputs a + b              # addition\nputs a * b              # multiplication\nputs -a                 # negation\nputs 1.quo a            # multiplicative inverse\nputs a.conjugate        # complex conjugate\nputs a.conj             # alias for complex conjugate<\/lang>\n\n''Notes:''\n* Ruby 1.8 must <code>require 'complex'<\/code>. Ruby 1.9 moves complex numbers to core, so <code>require 'complex'<\/code> only defines a few deprecated methods.\n* Ruby 1.9 deprecates Numeric#im; code like <code>a = 1 + 1.im<\/code> or <code>b = 3.14159 + 1.25.im<\/code> would call the deprecated method.\n* All of these operations are safe with other numeric types. For example, <code>42.conjugate<\/code> returns 42.\n\n<lang ruby># Other ways to find the multiplicative inverse:\nputs 1.quo a            # always works\nputs 1.0 \/ a            # works, but forces floating-point math\nputs 1 \/ a              # might truncate to integer<\/lang>\n\n==[[:Category:Scala|Scala]][[Category:Scala]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Scala]] version 2.8[[SMW::on]]<\/div>\nScala doesn't come with a Complex library, but one can be made:\n\n<lang scala>package org.rosettacode\n\npackage object ArithmeticComplex {\n  val i = Complex(0, 1)\n  \n  implicit def fromDouble(d: Double) = Complex(d)\n  implicit def fromInt(i: Int) = Complex(i.toDouble)\n}  \n\npackage ArithmeticComplex {\n  case class Complex(real: Double = 0.0, imag: Double = 0.0) {\n    def this(s: String) = \n      this(\"[\\\\d.]+(?!i)\".r findFirstIn s getOrElse \"0\" toDouble, \n           \"[\\\\d.]+(?=i)\".r findFirstIn s getOrElse \"0\" toDouble)\n    \n    def +(b: Complex) = Complex(real + b.real, imag + b.imag)\n    def -(b: Complex) = Complex(real - b.real, imag - b.imag)\n    def *(b: Complex) = Complex(real * b.real - imag * b.imag, real * b.imag + imag * b.real)\n    def inverse = {\n      val denom = real * real + imag * imag\n      Complex(real \/ denom, -imag \/ denom)\n    }\n    def \/(b: Complex) = this * b.inverse\n    def unary_- = Complex(-real, -imag)\n    lazy val abs = math.hypot(real, imag)\n    override def toString = real + \" + \" + imag + \"i\"\n    \n    def i = { require(imag == 0.0); Complex(imag = real) }\n  }\n  \n  object Complex {\n    def apply(s: String) = new Complex(s)\n    def fromPolar(rho:Double, theta:Double) = Complex(rho*math.cos(theta), rho*math.sin(theta))\n  }\n}<\/lang>\n\nUsage example:\n\n<lang scala>scala> import org.rosettacode.ArithmeticComplex._\nimport org.rosettacode.ArithmeticComplex._\n\nscala> 1 + i\nres0: org.rosettacode.ArithmeticComplex.Complex = 1.0 + 1.0i\n\nscala> 1 + 2 * i\nres1: org.rosettacode.ArithmeticComplex.Complex = 1.0 + 2.0i\n\nscala> 2 + 1.i\nres2: org.rosettacode.ArithmeticComplex.Complex = 2.0 + 1.0i\n\nscala> res0 + res1\nres3: org.rosettacode.ArithmeticComplex.Complex = 2.0 + 3.0i\n\nscala> res1 * res2\nres4: org.rosettacode.ArithmeticComplex.Complex = 0.0 + 5.0i\n\nscala> res2 \/ res0\nres5: org.rosettacode.ArithmeticComplex.Complex = 1.5 + -0.5i\n\nscala> res1.inverse\nres6: org.rosettacode.ArithmeticComplex.Complex = 0.2 + -0.4i\n\nscala> -res6\nres7: org.rosettacode.ArithmeticComplex.Complex = -0.2 + 0.4i\n<\/lang>\n\n==[[:Category:Scheme|Scheme]][[Category:Scheme]]==\nScheme implementations are not required to support complex numbers, but if they do, they are required to support complex number literals in one of the following standard formats[http:\/\/people.csail.mit.edu\/jaffer\/r4rs_9.html#SEC67]:\n* rectangular coordinates: <code>''real''+''imag''i<\/code> (or <code>''real''-''imag''i<\/code>), where ''real'' is the real part and ''imag'' is the imaginary part. For a pure-imaginary number, the real part may be omitted but the sign of the imaginary part is mandatory (even if it is \"+\"): <code>+''imag''i<\/code> (or <code>-''imag''i<\/code>). If the imaginary part is 1 or -1, the imaginary part can be omitted, leaving only the  <code>+i<\/code> or <code>-i<\/code> at the end.\n* polar coordinates: <code>''r''@''theta''<\/code>, where ''r'' is the absolute value (magnitude) and ''theta'' is the angle\n<lang scheme>(define a 1+i)\n(define b 3.14159+1.25i)\n\n(define c (+ a b))\n(define c (* a b))\n(define c (\/ 1 a))\n(define c (- a))<\/lang>\n\n==[[:Category:Seed7|Seed7]][[Category:Seed7]]==\n\n<lang seed7>$ include \"seed7_05.s7i\";\n  include \"float.s7i\";\n  include \"complex.s7i\";\n\nconst proc: main is func\n  local\n    var complex: a is complex(1.0, 1.0);\n    var complex: b is complex(3.14159, 1.2);\n  begin\n    writeln(\"a=\" <& a digits 5);\n    writeln(\"b=\" <& b digits 5);\n    # addition\n    writeln(\"a+b=\" <& a + b digits 5);\n    # multiplication\n    writeln(\"a*b=\" <& a * b digits 5);\n    # inversion\n    writeln(\"1\/a=\" <& complex(1.0) \/ a digits 5);\n    # negation\n    writeln(\"-a=\" <& -a digits 5);\n  end func;<\/lang>\n\n==[[:Category:Slate|Slate]][[Category:Slate]]==\n\n<lang slate>[| a b |\n  a: 1 + 1 i.\n  b: Pi + 1.2 i.\n  print: a + b.\n  print: a * b.\n  print: a \/ b.\n  print: a reciprocal.\n  print: a conjugated.\n  print: a abs.\n  print: a negated.\n].<\/lang>\n\n==[[:Category:Smalltalk|Smalltalk]][[Category:Smalltalk]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[GNU Smalltalk]][[SMW::on]]<\/div>\n<lang smalltalk>PackageLoader fileInPackage: 'Complex'.\n|a b|\na := 1 + 1 i.\nb := 3.14159 + 1.2 i.\n(a + b) displayNl.\n(a * b) displayNl.\n(a \/ b) displayNl.\na reciprocal displayNl.\na conjugate displayNl.\na abs displayNl.\na real displayNl.\na imaginary displayNl.\na negated displayNl.<\/lang>\n\n==[[:Category:SNOBOL4|SNOBOL4]][[Category:SNOBOL4]]==\n\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Macro Spitbol]][[SMW::on]]<\/div>\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Snobol4+]][[SMW::on]]<\/div>\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[CSnobol]][[SMW::on]]<\/div>\n\n<lang SNOBOL4>*       # Define complex datatype\n        data('complex(r,i)')\n\n*       # Addition\n        define('addx(x1,x2)a,b,c,d') :(addx_end)\naddx    a = r(x1); b = i(x1); c = r(x2); d = i(x2)\n        addx = complex(a + c, b + d) :(return)\naddx_end       \n\n*       # Multiplication\n        define('multx(x1,x2)a,b,c,d') :(multx_end)\nmultx   a = r(x1); b = i(x1); c = r(x2); d = i(x2)\n        multx = complex(a * c - b * d, b * c + a * d) :(return)\nmultx_end\n\n*       # Negation\n        define('negx(x)') :(negx_end)\nnegx    negx = complex(-r(x), -i(x)) :(return)\nnegx_end\n\n*       # Inverse\n        define('invx(x)d') :(invx_end)\ninvx    d = (r(x) * r(x)) + (i(x) * i(x))\n        invx = complex(1.0 * r(x) \/ d, 1.0 * -i(x) \/ d) :(return)\ninvx_end\n\n*       # Print compex number: a+bi \/ a-bi\n        define('printx(x)sign') :(printx_end)\nprintx  sign = ge(i(x),0) '+'\n        printx = r(x) sign i(x) 'i' :(return)\nprintx_end        \n        \n*       # Test and display        \n        a = complex(1,1)\n        b = complex(3.14159, 1.2)\n        output = printx( addx(a,b) )\n        output = printx( multx(a,b) )\n        output = printx( negx(a) ) ', ' printx( negx(b) )\n        output = printx( invx(a) ) ', ' printx( invx(b) )\nend<\/lang>\n\nOutput:\n<pre>4.14159+2.2i\n1.94159+4.34159i\n-1-1i, -3.14159-1.2i\n0.5-0.5i, 0.277781125-0.106104663i<\/pre>\n\n==[[:Category:Standard ML|Standard ML]][[Category:Standard ML]]==\n<lang Standard ML>\n(* Signature for complex numbers *)\nsignature COMPLEX = sig\n type num\n \n val complex : real * real -> num\n \n val negative : num -> num\n val plus : num -> num -> num\n val minus : num -> num -> num\n val times : num -> num -> num\n val invert : num -> num\n val print_number : num -> unit\nend;\n\n(* Actual implementation *)\nstructure Complex :> COMPLEX = struct\n  type num = real * real\n  \n  fun complex (a, b) = (a, b)\n  \n  fun negative (a, b) = (Real.~a, Real.~b)\n  fun plus (a1, b1) (a2, b2) = (Real.+ (a1, a2), Real.+(b1, b2))\n  fun minus i1 i2 = plus i1 (negative i2)\n  fun times (a1, b1) (a2, b2)= (Real.*(a1, a2) - Real.*(b1, b2), Real.*(a1, b2) + Real.*(a2, b1))\n  fun invert (a, b) =\n    let\n      val denom = a * a + b * b\n    in\n      (a \/ denom, ~b \/ denom)\n    end\n  \n  fun print_number (a, b) =\n    print (Real.toString(a) ^ \" + \" ^ Real.toString(b) ^ \"i\\n\")\nend;\n\nval i1 = Complex.complex(1.0,2.0); (* 1 + 2i *)\nval i2 = Complex.complex(3.0,4.0); (* 3 + 4i *)\n\nComplex.print_number(Complex.negative(i1)); (* -1 - 2i *)\nComplex.print_number(Complex.plus i1 i2); (* 4 + 6i *)\nComplex.print_number(Complex.minus i2 i1); (* 2 + 2i *)\nComplex.print_number(Complex.times i1 i2); (* -5 + 10i *)\nComplex.print_number(Complex.invert i1); (* 1\/5 - 2i\/5 *)\n<\/lang>\n\n==[[:Category:Tcl|Tcl]][[Category:Tcl]]==\n<div class=\"examplemeta libheader\">'''Library:''' [[SMW::off]][[:Category:Tcllib|Tcllib]][[Category:Tcllib]][[SMW::on]] <small>('''Package:''' math::complexnumbers)<\/small><\/div>\n<lang tcl>package require math::complexnumbers\nnamespace import math::complexnumbers::*\n\nset a [complex 1 1]\nset b [complex 3.14159 1.2]\nputs [tostring [+ $a $b]] ;# ==> 4.14159+2.2i\nputs [tostring [* $a $b]] ;# ==> 1.94159+4.34159i\nputs [tostring [pow $a [complex -1 0]]] ;# ==> 0.5-0.4999999999999999i\nputs [tostring [- $a]] ;# ==> -1.0-i<\/lang>\n\n==[[:Category:TI-83 BASIC|TI-83 BASIC]][[Category:TI-83 BASIC]]==\n\nTI-83 BASIC has built in complex number support; the normal arithmetic operators + - * \/ are used.\n\nThe method complex numbers are displayed can be chosen in the \"MODE\" menu.<br \/>\nReal: Does not show complex numbers, gives an error if a number is imaginary.<br \/>\na+bi: The classic display for imaginary numbers with the real and imaginary components<br \/>\nre^\u0398i: Displays imaginary numbers in Polar Coordinates.\n\n==[[:Category:TI-89 BASIC|TI-89 BASIC]][[Category:TI-89 BASIC]]==\n\nTI-89 BASIC has built-in complex number support; the normal arithmetic operators + - * \/ are used. \n\n:Character set note: the symbol for the imaginary unit is not the normal \"i\" but a different character (Unicode: U+F02F \"<span style=\"font-family: 'TI Uni';\">\uf02f<\/span>\" (private use area); this character should display with the \"TI Uni\" font). Also, U+3013 EN DASH \u201c<span style=\"font-family: 'TI Uni';\">\u2013<\/span>\u201d, displayed on the TI as a superscript minus, is used for the minus sign on numbers, distinct from ASCII \"-\" used for subtraction.\n\nThe choice of examples here is <div class=\"examplemeta translation\">'''Translation of''': [[Arithmetic\/Complex#Common Lisp|Common Lisp]]<\/div>. \n\n<pre style=\"font-family: 'TI Uni';\">\u25a0 \u221a(\u20131)                    \uf02f\n\u25a0 \uf02f^2                     \u20141\n\u25a0 \uf02f + 1                1 + \uf02f\n\u25a0 (1+\uf02f) * 2          2 + 2*\uf02f\n\u25a0 (1+\uf02f) (2\uf02f)        \u20142 + 2*\uf02f\n\u25a0 \u2014(1+\uf02f)              \u20141 - \uf02f\n\u25a0 1\/(2\uf02f)              \u20141 - \uf02f\n\u25a0 real(1 + 2\uf02f)             1\n\u25a0 imag(1 + 2\uf02f)             2<\/pre>\n\nComplex numbers can also be entered and displayed in polar form. (This example shows input in polar form while the complex display mode is rectangular and the angle mode is radians).\n\n<pre style=\"font-family: 'TI Uni';\">\u25a0 (1\u2220\u03c0\/4)\n           \u221a(2)\/2 + \u221a(2)\/2*\uf02f<\/pre>\n\nNote that the parentheses around \u2220 notation are required. It has a related use in vectors: (1\u2220\u03c0\/4) is a complex number, [1,\u2220\u03c0\/4] is a vector in two dimensions in polar notation, and [(1\u2220\u03c0\/4)] is a complex number in a vector.\n\n==[[:Category:Ursala|Ursala]][[Category:Ursala]]==\n\nComplex numbers are a primitive type that can be parsed in\nfixed or exponential formats, with either i or j notation as shown.\nThe usual complex arithmetic and transcendental functions are callable\nusing the syntax libname..funcname or a recognizable truncation (e.g.,\nc..add or ..csin). Real operands are promoted to complex.\n\n<lang Ursala>u = 3.785e+00-1.969e+00i\nv = 9.545e-01-3.305e+00j\n\n#cast %jL\n\nexamples = \n\n<\n   complex..add (u,v),\n   complex..mul (u,v),\n   complex..sub (0.,u),\n   complex..div (1.,v)><\/lang>\noutput:\n<pre><\n   4.740e+00-5.274e+00j,\n   -2.895e+00-1.439e+01j,\n   3.785e+00-1.969e+00j,\n   8.066e-02+2.793e-01j><\/pre>\n\n[[Category:M4\/Omit]]"}]}}},"query-continue":{"revisions":{"rvstartid":136255}}}