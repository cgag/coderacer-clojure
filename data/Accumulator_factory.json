{"query-continue":{"search":{"gsroffset":1},"revisions":{"rvstartid":137424}},"query":{"pages":{"5255":{"pageid":5255,"ns":0,"title":"Accumulator factory","revisions":[{"*":"<div class=\"infobox\" style=\"width: 2in\">[[File:Rcode-button-task-crushed.png|64px|left|alt=Task|link=Category:Solutions by Programming Task]]'''Accumulator factory'''<br\/>\nYou are encouraged to [[Rosetta Code:Solve a Task|solve this task]] according to the task description, using any language you may know.[[Category:Programming Tasks]][[Category:Solutions by Programming Task]]<\/div>\nA problem posed by [[wp:Paul Graham|Paul Graham]] is that of creating a function that takes a single (numeric) argument and which returns another function that is an accumulator. The returned accumulator function in turn also takes a single numeric argument, and returns the sum of all the numeric values passed in so far to that accumulator (including the initial value passed when the accumulator was created).\n\nThe detailed rules are at http:\/\/paulgraham.com\/accgensub.html and are reproduced here for simplicity (with additions in <small>''small italic text''<\/small>).\n:Before you submit an example, make sure the function\n\n:# Takes a number n and returns a function (lets call it g), that takes a number i, and returns n incremented by the accumulation of i from every call of function g(i).<br><small>Although these exact function and parameter names need not be used<\/small>\n:# Works for any numeric type-- i.e. can take both ints and floats and returns functions that can take both ints and floats. (It is not enough simply to convert all input to floats. An accumulator that has only seen integers must return integers.) <small>''(i.e., if the language doesn't allow for numeric polymorphism, you have to use overloading or something like that)''<\/small>\n:# Generates functions that return the sum of every number ever passed to them, not just the most recent. <small>''(This requires a piece of state to hold the accumulated value, which in turn means that pure functional languages can't be used for this task.)''<\/small>\n:# Returns a real function, meaning something that you can use wherever you could use a function you had defined in the ordinary way in the text of your program. <small>''(Follow your language's conventions here.)''<\/small>\n:# Doesn't store the accumulated value or the returned functions in a way that could cause them to be inadvertently modified by other code. <small>''(No global variables or other such things.)''<\/small>\n: E.g. if after the example, you added the following code (in a made-up language) <small>''where the factory function is called foo''<\/small>:\n:: <lang pseudocode>x = foo(1); \nx(5); \nfoo(3);\nprint x(2.3);<\/lang>\n: It should print <tt>8.3<\/tt>. <small>''(There is no need to print the form of the accumulator function returned by <tt>foo(3)<\/tt>; it's not part of the task at all.)''<\/small>\nThe purpose of this task is to create a function that implements the described rules. It need not handle any special error cases not described above. The simplest way to implement the task as described is typically to use a [[Closures|closure]], providing the language supports them.\n\nWhere it is not possible to hold exactly to the constraints above, describe the deviations.\n[[Category:MUMPS\/Omit]]\n\n==[[:Category:ABAP|ABAP]][[Category:ABAP]]==\nABAP, unfortunately, has no first order functions, nor does its OO paradigm implement method overloading. One potential solution to this problem is to use classes to maintain the state, with the import\/export parameters being defined as type 'any', so that the resultant type is calculated dynamically.\n\nAnother possible solution would be to use the languages in-built JavaScript processing capabilities to dynamically construct a JS source at run-time, which implements the JS Accumulator factory.\n=== Object Oriented Solution ===\n<lang ABAP>report z_accumulator\nclass acc definition.\n  public section.\n    methods:\n      call importing iv_i type any default 0 exporting ev_r type any,\n      constructor importing iv_d type f.\n  private section.\n    data a_sum type f.\nendclass.\n\nclass acc implementation.\n  method call.\n      add iv_i to a_sum.\n      ev_r = a_sum.\n  endmethod.\n\nstart-of-selection.\n\ndata: cl_acc type ref to acc,\n      lv_ret2 type f,\n      lv_ret1 type i.\n\ncreate object cl_acc exporting iv_d = 1.\ncl_acc->call( exporting iv_i = 5 ).\ncl_acc->call( exporting iv_i = '2.3' importing ev_r = lv_ret2 ).\ncl_acc->call( exporting iv_i = 2 importing ev_r = lv_ret1 ).\nwrite : \/ lv_ret2 decimals 2 exponent 0 left-justified, \/ lv_ret1 left-justified.<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>\n 8.30\n10\n<\/pre>\n=== JavaScript Solution ===\n<lang ABAP>data: lv_source type string,\n      cl_processor type ref to cl_java_script,\n      lv_ret type string.\n\ncl_processor = cl_java_script=>create( ).\nconcatenate\n'function acc(sum) { '\n'  return function(n) { '\n'   return sum += n;'\n'  }; '\n' }; '\n' var x = acc(1); '\n' x(5);'\n' var ret = acc(3).toString();'\n' ret = ret + x(2.3);'\n into lv_source.\nlv_ret = cl_processor->evaluate( lv_source ).\n\nif cl_processor->last_condition_code <> cl_java_script=>cc_ok.\n  write cl_processor->last_error_message.\nelse.\n  write lv_ret.\n  write \/ 'Done'.\nendif.<\/lang>\n\n<pre>#function (n) {#    return sum += n;#}#8.3<\/pre>\n\n==[[:Category:ActionScript|ActionScript]][[Category:ActionScript]]==\nClosures work the same in ActionScript  as in JavaScript. ActionScript will transparently convert integers to reals if the function is given a real argument, but the typeof operator must be used to ensure the function isn't sent invalid arguments, such as strings (which would silently convert the accumulated number to a string without throwing an error).\n<div class=\"examplemeta translation\">'''Translation of''': [[Accumulator factory#Javascript|Javascript]]<\/div>\n<lang ActionScript>\/\/Throw an error if a non-number argument is used. (typeof evaluates to\n\/\/ \"number\" for both integers and reals)\nfunction checkType(obj:Object):void {\n    if(typeof obj != \"number\")\n\tthrow new ArgumentError(\"Expected integer or float argument. Recieved \" + typeof obj);\n}\nfunction accumulator(sum:Object):Function {\n    checkType(sum);\n    return function(n:Object):Object {checkType(n); return sum += n};\n}\nvar acc:Function=accumulator(2);\ntrace(acc(10));\ntrace(acc(4));\ntrace(acc(\"123\")); \/\/This causes an ArgumentError to be thrown.<\/lang>\n\n==[[:Category:Ada|Ada]][[Category:Ada]]==\n<lang Ada>with Accumulator;\nwith Ada.Text_IO; use Ada.Text_IO;\n\nprocedure Example is\n   package A is new Accumulator;\n   package B is new Accumulator;\nbegin\n   Put_Line (Integer'Image (A.The_Function (5)));\n   Put_Line (Integer'Image (B.The_Function (3)));\n   Put_Line (Float'Image (A.The_Function (2.3)));\nend;<\/lang>\n\n<lang Ada>generic package Accumulator is\n\n--  This Ada generic package represents an accumulator factory.\n--  The required function is provided as The_Function.\n--  The first call to The_Function sets the initial value.\n--  (Marius Amado-Alves)\n\n   function The_Function (X : Integer) return Integer;\n   function The_Function (X : Integer) return Float;\n   function The_Function (X : Float) return Float;\nend;<\/lang>\n\n<lang Ada>package body Accumulator is\n\n--  The accumulator lives through three states. It is in Virgin_State\n--  before any use of The_Function. It changes to Integer_State or\n--  Float_State, according to the input type used. The accumulation is\n--  memorized in variable I or F, according to the state. Float_State,\n--  once reached, is never left. A Float output on an Integer_State is\n--  simply a conversion, sans effect on state. (Marius Amado-Alves)\n\n   type State_T is (Virgin_State, Integer_State, Float_State);\n   State : State_T := Virgin_State;\n   I : Integer;\n   F : Float;\n\n   function The_Function (X : Float) return Float is\n   begin\n      case State is\n         when Virgin_State =>\n            State := Float_State;\n            F := X;\n            return F;\n         when Integer_State =>\n            State := Float_State;\n            F := Float (I) + X;\n            return F;\n         when Float_State =>\n            F := F + X;\n            return F;\n      end case;\n   end;\n\n   function The_Function (X : Integer) return Float is\n   begin\n      case State is\n         when Virgin_State =>\n            State := Integer_State;\n            I := X;\n            return Float (I);\n         when Integer_State =>\n            I := I + X;\n            return Float (I);\n         when Float_State =>\n            F := F + Float (X);\n            return F;\n      end case;\n   end;\n\n   function The_Function (X : Integer) return Integer is\n   begin\n      case State is\n         when Virgin_State =>\n            State := Integer_State;\n            I := X;\n            return I;\n         when Integer_State =>\n            I := I + X;\n            return I;\n         when Float_State =>\n            F := F + Float (X);\n            return Integer (F);\n      end case;\n   end;\n\nend;<\/lang>\n\n==[[:Category:Aikido|Aikido]][[Category:Aikido]]==\n<div class=\"examplemeta translation\">'''Translation of''': [[Accumulator factory#Javascript|Javascript]]<\/div>\n<lang aikido>function accumulator (sum:real) {\n    return function(n:real) { return sum += n }\n}\n\nvar x = accumulator(1)\nx(5)\nprintln (accumulator)\nprintln (x(2.3))<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n accumulator\n 8.3\n\n==[[:Category:ALGOL 68|ALGOL 68]][[Category:ALGOL 68]]==\n<div class=\"examplemeta translation\">'''Translation of''': [[Accumulator factory#aikido|aikido]]<\/div>\n\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[ELLA ALGOL 68]] version Any (with appropriate job cards) - tested with release [http:\/\/sourceforge.net\/projects\/algol68\/files\/algol68toc\/algol68toc-1.8.8d\/algol68toc-1.8-8d.fc9.i386.rpm\/download 1.8-8d][[SMW::on]]<\/div>\nNote: Standard ALGOL 68's scoping rules forbids exporting a '''procedure''' (or '''format''') out of it's scope (closure).  Hence this specimen will run on [[ELLA ALGOL 68]], but is non-standard.  For a discussion of first-class functions in ALGOL 68 consult [http:\/\/www.cs.ru.nl\/~kees\/home\/papers\/psi96.pdf \"The Making of Algol 68\"] - [[wp:Cornelis_H.A._Koster|C.H.A. Koster]] (1993). \n<lang algol68>MODE NUMBER =  UNION(INT,REAL,COMPL);\n\nPROC plus = (NUMBER in a, in b)NUMBER: (\n    CASE in a IN\n        (INT a):   CASE in b IN (INT b): a+b, (REAL b): a+b, (COMPL b): a+b ESAC,\n        (REAL a):  CASE in b IN (INT b): a+b, (REAL b): a+b, (COMPL b): a+b ESAC,\n        (COMPL a): CASE in b IN (INT b): a+b, (REAL b): a+b, (COMPL b): a+b ESAC\n    ESAC\n);\n\nmain: (\n\n# now override the + and +:= OPerators #\n  OP + = (NUMBER a, b)NUMBER: plus(a,b);\n\n  OP +:= = (REF NUMBER lhs, NUMBER rhs)NUMBER:\n      lhs := lhs + rhs;\n\n  PROC accumulator  = (REF NUMBER sum)PROC(NUMBER)NUMBER:\n      (NUMBER n)NUMBER:  \n          sum +:= n;\n   \n  PROC (NUMBER)NUMBER x = accumulator(LOC NUMBER := 1);\n  x(5);\n  print((\"x:\",x(2.3), new line));\n\n  PROC (NUMBER)NUMBER y = accumulator(LOC NUMBER := 100);\n  y(500);\n  print((\"y:\",y(230), new line));\n\n  print((\"x:\",x(0), new line))\n\n)<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>\nx: +.830000000000000e +1\ny:        +830\nx: +.830000000000000e +1\n<\/pre>\n\n==[[:Category:Argile|Argile]][[Category:Argile]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Argile]] version 1.1.1[[SMW::on]]<\/div>\n<lang Argile>use std, array\n\nlet A = accumulator 42\nprint(A 0)\nprint(A 1)\nprint(A 10)\nprint(A 100)\n\nlet B = accumulator 4.2\nprint(B 0)\nprint(B 1)\nprint(B 10.0)\nprint(B 100.4)\n\n~A ; ~B\n(: use dbg; check mem leak :)\n\n(: accumulator call :)\n=: <accumulator a> <num x> := -> (a.t)\n   call ((a.func) as function(any)(a.t)->(a.t)) with (a.data) ((Cgen x) as a.t)\n\n(: accumulator constructors :)\n.: accumulator <int x> :. -> int accumulator\n   (val (int accumulator) A).init(x)\n   (A as Accumulator).func = ( .:<int& accu, int x>:. ->int {accu += x; accu} )\n   A\n\n.: accumulator <real x> :. -> real accumulator\n   (val (real accumulator) A).init(x)\n   (A as Accumulator).func = ( .:<real&accu,real x>:. ->real{accu += x; accu} )\n   A\n\n=: <accumulator& a>.init <num x> :=\n   a = new (Accumulator)\n   a.data = (new array of 1 a.t)\n   *(a.data as (a.t*)) = Cgen x\n\n(: accumulator destructor :)\n.: del Accumulator <Accumulator a>:.\n   free a.data\n   free a\n=: ~ <accumulator a> := {del Accumulator a}\n\n(: accumulator type :)\nclass Accumulator\n  function\tfunc\n  any\t\tdata\n\n=: [<type t=(int)>] accumulator := -> type\n   Accumulator.prefix\n   Accumulator.suffix\n\nautocast accumulator<->Accumulator<\/lang>\n\n==[[:Category:Brat|Brat]][[Category:Brat]]==\n<lang brat>accumulator = { sum |\n  { n | sum = sum + n }\n}\n\nx = accumulator 1\nx 5\naccumulator 3 #Does not affect x\np x 2.3 #Prints 8.3 (1 + 5 + 2.3)<\/lang>\n\n==[[:Category:C|C]][[Category:C]]==\nDeviation: Not in standard C, but several compilers include the typeof operator as an extension which can be used like a typedef. Functions must be defined outside of the main program body and they retain the same type throughout their life. C11 is supposed to give us some Type-generic macro expressions.\n\n<lang C>#include <stdio.h>\n\/\/~ Take a number n and return a function that takes a number i\n#define ACCUMULATOR(name,n) __typeof__(n) name (__typeof__(n) i) { \\\n    static __typeof__(n) _n=n; LOGIC; }\n\/\/~ have it return n incremented by the accumulation of i\n#define LOGIC return _n+=i\nACCUMULATOR(x,1.0)\nACCUMULATOR(y,3)\nACCUMULATOR(z,'a')\n#undef LOGIC\nint main (void) {\n    printf (\"%f\\n\", x(5));   \/* 6.000000 *\/\n    printf (\"%f\\n\", x(2.3)); \/* 8.300000 *\/\n    printf (\"%i\\n\", y(5.0)); \/* 8 *\/\n    printf (\"%i\\n\", y(3.3)); \/* 11 *\/\n    printf (\"%c\\n\", z(5));   \/* f *\/\n    return 0;\n}<\/lang>\n\n==[[:Category:C++|C++]][[Category:C++]]==\nDeviation: The return type is wrong when the accumulator is called with an integer argument after is has been called with a float argument.\n<lang cpp>#include <iostream>\n\nclass Acc\n{\npublic:\n    Acc(int init)\n        : _type(intType)\n        , _intVal(init)\n    {}\n\n    Acc(float init)\n        : _type(floatType)\n        , _floatVal(init)\n    {}\n\n    int operator()(int x)\n    {\n        if( _type == intType )\n        {\n            _intVal += x;\n            return _intVal;\n        }\n        else\n        {\n            _floatVal += x;\n            return static_cast<int>(_floatVal);\n        }\n    }\n\n    float operator()(float x)\n    {\n        if( _type == intType )\n        {\n            _floatVal = _intVal + x;\n            _type = floatType;\n            return _floatVal;\n        }\n        else\n        {\n            _floatVal += x;\n            return _floatVal;\n        }\n    }\nprivate:\n    enum {floatType, intType} _type;\n    float _floatVal;\n    int _intVal;\n};\n\nint main()\n{\n    Acc a(1);\n    a(5);\n    Acc(3);\n    std::cout << a(2.3f);\n    return 0;\n}<\/lang>\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[C++11]][[SMW::on]]<\/div>\nThe following is similar to the above, using lambda functions from C++11. Note that we declared the lambda <code>mutable<\/code>, which allows us to modify variables that were captured by value. This feature allows us to maintain mutable state, which is essential for an accumulator.\n\nIt suffers from the same deviation as the former, where the return type is wrong when the accumulator is called with a float argument after is has been called with an integer argument.\n<lang cpp>#include <iostream>\n#include <functional>\n\ntemplate <typename T>\nstd::function<T(T)> makeAccumulator(T sum) {\n\treturn [=](T increment) mutable {\n\t\treturn sum += increment;\n\t};\n}\n\nint main() {\n\tauto acc = makeAccumulator<float>(1);\n\tacc(5);\n\tmakeAccumulator(3);\n\tstd::cout << acc(2.3) << std::endl;\n\treturn 0;\n}<\/lang>\n\n==<span id=\"C sharp\">[[:Category:C sharp|C#]]<\/span>[[Category:C sharp]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[C sharp]] version 4.0[[SMW::on]]<\/div>\n<lang csharp>using System;\n\nclass Program\n{\n    static Func<dynamic, dynamic> Foo(dynamic n)\n    {\n        return i => n += i;\n    }\n\n    static void Main(string[] args)\n    {\n        var x = Foo(1);\n        x(5);\n        Foo(3);\n        Console.WriteLine(x(2.3));\n    }\n}<\/lang>\n\n==[[:Category:Clay|Clay]][[Category:Clay]]==\nTo my knowledge Clay does not admit of an elegant solution to this problem, although it should be stated that I am still exploring the language. But a clean solution mirroring that for other static languages is quite simple (one in which the operative numeric type is constrained by the original call to acc):\n<lang Clay>acc(n) {\n    return (m) => {\n        n = n + m;\n        return n;\n    };\n}\n\nmain() {\n    var x = acc(1.0);\n    x(5);\n    acc(3);\n    println(x(2.3)); \/\/ Prints \u201c8.300000000000001\u201d.\n}<\/lang>\nAlthough statically typed, due to Clay\u2019s everywhere-genericity this has the advantage of working out of the box for any type that defines addition:\n<lang Clay>    var y = acc(Vector[Char](\"Hello\"));\n    println(y(\" World!\")); \/\/ Prints \"Hello World!\u201d.<\/lang>\nBut you could constrain the function to numeric types were you so inclined:\n<lang Clay>[N | Numeric?(N)] acc(n: N) {\n    return (m) => {\n        n = n + m;\n        return n;\n    };\n}<\/lang>\nOne could go crazy with tagged unions and runtime dispatching to rig something up that adhered more closely to the problem\u2019s specification. But I know of no easier way to \u201cchange types\u201d in the fashion necessary.\n\n==[[:Category:Clojure|Clojure]][[Category:Clojure]]==\nThe ''atom'' function creates an atomically updatable identity holding a value. The ''swap!'' function atomically updates the atom's value, returning the new value. The function returned from an ''accum'' call satisfies all the requirements.\n<lang clojure>(defn accum [n]\n  (let [acc (atom n)]\n    (fn [m] (swap! acc + m))))<\/lang>\nSimilarly, a ''ref'' could be used.\n<lang clojure>(defn accum [n]\n  (let [acc (ref n)]\n    #(dosync (alter acc + %))))<\/lang>\n\n==[[:Category:CoffeeScript|CoffeeScript]][[Category:CoffeeScript]]==\n<lang coffeescript>accumulator = (sum) ->\n  (n) -> sum += n\n  \nf = accumulator(1)\nconsole.log f(5)\nconsole.log f(2.3)<\/lang>\n\n==[[:Category:Common Lisp|Common Lisp]][[Category:Common Lisp]]==\n<lang lisp>(defun accumulator (sum)\n  (lambda (n)\n    (setf sum (+ sum n))))<\/lang>\nExample usage:\n<lang lisp>(defvar x (accumulator 1))\n(funcall x 5)\n(accumulator 3)\n(funcall x 2.3)<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>\nX\n6\n#<CLOSURE :LAMBDA (N) (SETF SUM (+ SUM N))>\n8.3\n<\/pre>\n\n==[[:Category:D|D]][[Category:D]]==\n\n<lang d>void main() {\n    auto x = acc(1);\n    x(5);\n    acc(3);\n    writeln(x(2.3));\n}\n\nauto acc(U = real, T)(T initvalue) { \/\/ U is type of the accumulator\n    auto accum = cast(U)initvalue ;\n    return (U n) { return accum += n ; } ;\n}<\/lang>\n\n==[[:Category:E|E]][[Category:E]]==\n<lang e>def foo(var x) {\n  return fn y { x += y }\n}<\/lang>\n\n==[[:Category:Elena|Elena]][[Category:Elena]]==\n<lang elena>#define std'dictionary'*.\n#define sys'dynamics'*.\n\n#symbol NewAccumulator : aValue =\n    __group(aValue, aNumber => ((self~egroup @ 0) set &content:(aNumber + self))).\n\n#symbol Program =>\n[\n    #var x := NewAccumulator::1.\n\n    x eval:5.\n                                    \n    NewAccumulator::3.\n    \n    'program'Output << x eval:2.3r.\n].<\/lang>\n\n==[[:Category:Factor|Factor]][[Category:Factor]]==\n<lang factor>:: accumulator ( n! -- quot ) [ n + dup n! ] ;\n\n1 accumulator\n[ 5 swap call drop ]\n[ drop 3 accumulator drop ]\n[ 2.3 swap call ] tri .<\/lang>\n\n==[[:Category:Fantom|Fantom]][[Category:Fantom]]==\nThe accumulator function is a little unwieldy using multiple ifs to maintain the type of 'sum' until forced to change.  Again, a result of the three concrete Num types, Int, Float and Decimal, all being separated in the API.\n<lang fantom>class AccumulatorFactory\n{\n  static |Num -> Num| accumulator (Num sum)\n  {\n    return |Num a -> Num| \n    { \/\/ switch on type of sum\n      if (sum is Int)\n      { \/\/ and then type of a\n        if (a is Int)\n          return sum = sum->plus(a)\n        else if (a is Float)\n          return sum = sum->plusFloat(a)\n        else\n          return sum = sum->plusDecimal(a)\n      }\n      else if (sum is Float)\n      {\n        if (a is Int)\n          return sum = sum->plusInt(a)\n        else if (a is Float)\n          return sum = sum->plus(a)\n        else\n          return sum = sum->plusDecimal(a)\n      }\n      else \/\/ if (sum is Decimal)\n      {\n        if (a is Int)\n          return sum = sum->plusInt(a)\n        else if (a is Float)\n          return sum = sum->plusFloat(a)\n        else\n          return sum = sum->plus(a)\n      }\n    }\n  } \n\n  public static Void main () \n  {\n    x := accumulator (3.1)\n    y := accumulator (3f)\n    echo (x(5))              \/\/ the Decimal sum combines with an Int\n    echo (x(2))\n    echo (y(5.1))            \/\/ the Float sum combines with a Decimal\n\n    x = accumulator (1)\n    x (5)\n    accumulator (3)\n    echo (x(2.3))          \/\/ the Int sum is now a Decimal\n  }\n}<\/lang>\n\n==[[:Category:Forth|Forth]][[Category:Forth]]==\nForth is untyped; this works on integers.\n<lang forth>: accumulator\n  create ( n -- ) ,\n  does> ( n -- acc+n ) tuck +! @ ;\n\n0 accumulator foo\n\n1 foo .  \\ 1\n2 foo .  \\ 3\n3 foo .  \\ 6<\/lang>\n\n==<span id=\"F Sharp\">[[:Category:F Sharp|F#]]<\/span>[[Category:F Sharp]]==\nA statically typed version is not possible, but it is quite easy to write dynamically typed functions in F#:\n<lang fsharp>\/\/ dynamically typed add\nlet add (x: obj) (y: obj) =\n  match x, y with\n  | (:? int as m), (:? int as n) -> box(m+n)\n  | (:? int as n), (:? float as x)\n  | (:? float as x), (:? int as n) -> box(x + float n)\n  | (:? float as x), (:? float as y) -> box(x + y)\n  | _ -> failwith \"Run-time type error\"\n\nlet acc init =\n  let state = ref (box init)\n  fun y ->\n    state := add !state (box y)\n    !state\n\ndo \n  let x : obj -> obj = acc 1\n  printfn \"%A\" (x 5) \/\/ prints \"6\"\n  acc 3 |> ignore\n  printfn \"%A\" (x 2.3) \/\/ prints \"8.3\"<\/lang>\n\n==[[:Category:GAP|GAP]][[Category:GAP]]==\n<lang gap>accu := function(n)\n  local f, v;\n  v := n;\n  f := function(a)\n    v := v + a;\n    return v;\n  end;\n  return f;\nend;\n\na := accu(0);\n# function( a ) ... end\nb := accu(100);\n# function( a ) ... end\na(6);\n# 6\nb(6);\n# 106\na(1);\n# 7\nb(1);\n# 107\n# These functions also accept other types, as long as addition is meaningful\nb(1\/FLOAT_INT(3))\n# 107.333\na(2\/3);\n# 23\/3\na([1, 2, 3]);\n# [ 26\/3, 29\/3, 32\/3 ]<\/lang>\n\n==[[:Category:Go|Go]][[Category:Go]]==\nSmall deviation on condition 2. The task specifies to handle all numeric types, and only int and float64 are shown here.  The technique would extend to all types just as easily, but Go has lots of numeric types and the program would be big.\n<lang go>package main\n\nimport \"fmt\"\n\nfunc accumulator(sum interface{}) func(interface{}) interface{} {\n    return func(nv interface{}) interface{} {\n        switch s := sum.(type) {\n        case int:\n            switch n := nv.(type) {\n            case int:\n                sum = s + n\n            case float64:\n                sum = float64(s) + n\n            }\n        case float64:\n            switch n := nv.(type) {\n            case int:\n                sum = s + float64(n)\n            case float64:\n                sum = s + n\n            }\n        default:\n            sum = nv\n        }\n        return sum\n    }\n}\n\nfunc main() {\n    x := accumulator(1)\n    x(5)\n    accumulator(3)\n    fmt.Println(x(2.3))\n}<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>8.3<\/pre>\n\n==[[:Category:Groovy|Groovy]][[Category:Groovy]]==\nSolution:\n<lang groovy>def accumulator = { Number n ->\n    def value = n;\n    { it = 0 -> value += it}\n}<\/lang>\nTest:\n<lang groovy>def x = accumulator(1)\n\nprintln x()\nassert x() instanceof Integer\n\nprintln x(5)\nassert x() instanceof Integer\n\ndef y = accumulator(3)\nprintln y()\nassert y() instanceof Integer\n\nprintln x(2.3)\nassert x() instanceof BigDecimal\n\nprintln y(10)\nassert y() instanceof Integer\n\nprintln y(200L)\nassert y() instanceof Long\n\nprintln y(2.25D)\nassert y() instanceof Double<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>1\n6\n3\n8.3\n13\n213\n215.25<\/pre>\n\n==[[:Category:Haskell|Haskell]][[Category:Haskell]]==\n<div class=\"examplemeta translation\">'''Translation of''': [[Accumulator factory#Ruby|Ruby]]<\/div>\n<lang haskell>import Control.Monad.ST\nimport Data.STRef\n\naccumulator :: (Num a) => a -> ST s (a -> ST s a)\naccumulator sum0 = do\n  sum <- newSTRef sum0\n  return $ \\n -> do\n    modifySTRef sum (+ n)\n    readSTRef sum\n\nmain :: IO ()\nmain = print foo\n    where foo = runST $ do\n                  x <- accumulator 1\n                  x 5\n                  accumulator 3\n                  x 2.3<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>8.3<\/pre>\n\n==[[:Category:Icon|Icon]][[Category:Icon]] and [[:Category:Unicon|Unicon]][[Category:Unicon]]==\nAt first glance you might expect the example below to run under Icon; however, as the co-expression calling sequence is Unicon specific.\n\nStrictly speaking, <tt>genAcc(n)<\/tt> returns a <i>co-expression<\/i>, not a function.  However, the invocation syntax here is indistinguishable from calling a function.\n<lang Unicon>procedure main()\n    a := genAcc(3)\n    b := genAcc(5)\n    \n    write(\"        \" ,center(\"a\",5),  \" \", center(\"b\", 5))\n    write(\"genAcc: \", right(a(4),5),  \" \", right(b(4), 5))\n    write(\"genAcc: \", right(a(2),5),  \" \", right(b(3),5))\n    write(\"genAcc: \", right(a(4.5),5),\" \", right(b(1.3),5))\nend\n\nprocedure genAcc(n)   # The generator factory\n    return makeProc { while i := (n@&source)[1] do n +:= i }\nend\n\nprocedure makeProc(A) # A Programmer-Defined Control Operation\n    return (@A[1],A[1])\nend<\/lang>\nThis example produces the output:\n<pre>\n          a     b  \ngenAcc:     7     9\ngenAcc:     9    12\ngenAcc:  13.5  13.3\n<\/pre>\nTo adapt the above for use in Icon, the function-syntax for activating co-expressions (e.g. <tt>a(4)<\/tt>) available in Unicon would have to be replaced with the <i>activation<\/i> operator (e.g. <tt>[4]@a<\/tt>).  The use of a list as the value passed through activation is to retain compatibility with the Unicon approach.\n\n==[[:Category:J|J]][[Category:J]]==\nSee http:\/\/www.jsoftware.com\/jwiki\/Guides\/Lexical_Closure, including the [[j:Guides\/Lexical%20Closure#dissent|dissent]] section.\n<lang J>oleg=:1 :0\n  a=. cocreate''\n  n__a=: m\n  a&(4 : 'n__x=: n__x + y')\n)<\/lang>\nExample use: \n<lang j>   F=: 10 oleg\n   F 11\n21\n   F 12\n33\n   F 11\n44<\/lang>\n\n==[[:Category:Java|Java]][[Category:Java]]==\nJava has no first-class functions; the standard syntactic workaround is to use a standard method name. Java uses objects to maintain state.\n<lang java>public class Accumulator {\n    private double sum;\n    public Accumulator(double sum0) {\n        sum = sum0;\n    }\n    public double call(double n) {\n        return sum += n;\n    }\n\n    public static void main(String[] args) {\n        Accumulator x = new Accumulator(1);\n        x.call(5);\n        System.out.println(new Accumulator(3));\n        System.out.println(x.call(2.3));\n    }\n}<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>Accumulator@42e816\n8.3<\/pre>\nTo do a full version that sums with integers as long as possible before switching to double-precision floats requires a little more work and the use of the <code>Number<\/code> class...\n\n;Optimized\nJava has no first-class functions, but with minor syntaxical sugar it does (and yes, this will work in Java 6 and up).  \n<lang java>import com.google.common.base.Function;\n\npublic class AccumulatorFactory {\n\tprivate static Function<Double, Double> accumulator(final Double elem) {\n\t\treturn new Function<Double, Double>() {\n\t\t\tDouble sum = elem;\n\t\t\t@Override public Double apply(Double val) {\n\t\t\t\treturn sum += val;\n\t\t\t}\n\t\t};\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tFunction<Double, Double> x = accumulator(1d);\n\t\tx.apply(5d);\n\t\tSystem.out.println(accumulator(3d));\t\t\n\t\tSystem.out.println(x.apply(2.3));\n\t}\n}<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>AccumulatorFactory$1@e86da0\n8.3<\/pre>\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Java]] version 5.0[[SMW::on]]<\/div>\n<lang java5>public class Accumulator {\n    private Long sumA; \/\/ non-null if we're working in the integer domain\n    private double sumB;\n    public Accumulator(Number sum0) {\n\tif (sum0 instanceof Double) {\n\t    sumB = sum0.doubleValue();\n\t} else {\n\t    sumA = sum0.longValue();\n\t}\n    }\n    public Number call(Number n) {\n        if (sumA != null) {\n\t    if (n instanceof Double) {\n\t\tsumB = n.doubleValue() + sumA;\n\t\tsumA = null;\n\t\treturn sumB;\n\t    }\n            return sumA += n.longValue();\n        }\n        return sumB += n.doubleValue();\n    }\n \n    public static void main(String[] args) {\n        Accumulator x = new Accumulator(1);\n        x.call(5);\n        Accumulator y = new Accumulator(3);\n        System.out.println(y+\" has value \"+y.call(0));\n        System.out.println(x.call(2.3));\n    }\n}<\/lang>\nProducing this sample output:\n<pre>\nAccumulator@6100ab23 has value 3\n8.3\n<\/pre>\n\n==[[:Category:JavaScript|JavaScript]][[Category:JavaScript]]==\n<lang javascript>function accumulator(sum) {\n    return function(n) {\n        return sum += n;\n    }\n}\nvar x = accumulator(1);\nx(5);\ndocument.write(accumulator(3).toString() + '<br>');\ndocument.write(x(2.3));<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>function (n) { return sum += n; }\n8.3<\/pre>\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[JavaScript 1.8]][[SMW::on]]<\/div>\n<lang javascript>function accumulator(sum) function(n) sum += n;\nvar x = accumulator(1);\nx(5);\nconsole.log(accumulator(3).toSource());\nconsole.log(x(2.3));<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>(function (n) sum += n)\n8.3<\/pre>\n\n==[[:Category:Lua|Lua]][[Category:Lua]]==\nA simple implementation:\n<lang Lua>function acc(init)\n  init = init or 0\n  return function(delta)\n    init = init + (delta or 0)\n    return init\n  end\nend<\/lang>\nAn expanded example of similar but more complex functionality:\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Lua]] version 5.1[[SMW::on]]<\/div>\n<lang lua>do\n    local accSum = 0;               -- accumulator factory 'upvalue'\n    function acc(v)                 -- the accumulator factory\n        accSum = accSum + (v or 0)  -- increment factory sum\n        \n        local closuredSum = accSum;               -- new 'upvalue' at each factory call\n        return function (w)                       -- the produced accumulator function\n            closuredSum = closuredSum + (w or 0)  -- increment product 'upvalue'\n            return closuredSum                    -- return 'upvalue'\n        end, accSum                               -- end of product closure\n        \n    end--acc\nend--end of factory closure<\/lang>\nUsage example:\n<lang lua>x = acc(1)                 -- x stores the product with initial value = 1\nx(5)                       -- add 5 to x's sum\nacc(3)                     -- add 3 to factory's sum\nprint (x(2.3))  --> 8.3    -- add 2.3 to x's sum then print the result\ny = acc()                  -- create new function with factory's sum as initial value\nprint (y())     --> 4      -- print the accumulated value inside the product y<\/lang>\n\n==[[:Category:Mathematica|Mathematica]][[Category:Mathematica]]==\n<lang Mathematica>accFactory[initial_] := \n  Module[{total = initial},\n    Function[x, total += x]\n  ]\nx=accFactory[1];\nx[5.0];\naccFactory[3];\nx[2.3]<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>8.3<\/pre>\n\n==[[:Category:Objeck|Objeck]][[Category:Objeck]]==\nUses objects instead of first class functions.\n<lang objeck>bundle Default {\n  class Accumulator {\n    @sum : Float;\n      \n    New(sum : Float) {\n      @sum := sum;\n    }\n      \n    method : public : Call(n : Float) ~ Float {\n      @sum += n;\n      return @sum;\n    }\n      \n    function : Main(args : String[]) ~ Nil {\n      x := Accumulator->New(1.0);\n      x->Call(5.0  );\n      x->Call(2.3)->PrintLine();\n    }\n  }\n}<\/lang>\n\n==[[:Category:Objective-C|Objective-C]][[Category:Objective-C]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Mac OS X]] version 10.6+[[SMW::on]]<\/div>\n<lang objc>#import <Foundation\/Foundation.h>\n\ntypedef double (^Accumulator)(double);\n\nAccumulator accumulator_factory(double initial) {\n    __block double sum = initial;\n    Accumulator acc = ^(double n){\n        return sum += n;\n    };\n    return [[acc copy] autorelease];\n}\n\nint main (int argc, const char * argv[]) {\n    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];\n\n    Accumulator x = accumulator_factory(1);\n    x(5);\n    accumulator_factory(3);\n    NSLog(@\"%f\", x(2.3));\n\t\n    [pool drain];\n    return 0;\n}<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>8.300000<\/pre>\n\n==[[:Category:OCaml|OCaml]][[Category:OCaml]]==\n<div class=\"examplemeta translation\">'''Translation of''': [[Accumulator factory#Ruby|Ruby]]<\/div>\nDeviations: An accumulator instance can take ''either'' integers ''or'' floats, but not both mixed (due to lack of runtime polymorphism).\n<lang ocaml>let accumulator sum0 =\n  let sum = ref sum0 in\n  fun n ->\n    sum := !sum +. n;\n    !sum;;\n\nlet _ =\n  let x = accumulator 1.0 in\n  ignore (x 5.0);\n  let _ = accumulator 3.0 in\n  Printf.printf \"%g\\n\" (x 2.3)\n;;<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>8.3<\/pre>\n\n==[[:Category:Octave|Octave]][[Category:Octave]]==\n\n<lang octave># not a function file:\n1;\nfunction fun = foo(init)\n  currentSum = init;\n  fun = @(add) currentSum = currentSum + add; currentSum;\nendfunction\n\nx = foo(1);\nx(5); \nfoo(3);\ndisp(x(2.3));<\/lang>\n\n==[[:Category:Oz|Oz]][[Category:Oz]]==\nA bit unwieldy because the '+' operator does not allow mixed type operands. The implementation is thread-safe (atomic Exchange operation).\n<lang oz>declare\n  fun {Acc Init}\n     State = {NewCell Init}\n  in\n     fun {$ X}\n        OldState\n     in\n        {Exchange State OldState} = {Sum OldState X}\n     end\n  end\n\n  fun {Sum A B}\n     if {All [A B] Int.is} then A+B\n     else {ToFloat A}+{ToFloat B}\n     end\n  end\n\n  fun {ToFloat X}\n     if {Float.is X} then X\n     elseif {Int.is X} then {Int.toFloat X}\n     end\n  end\n\n  X = {Acc 1}\nin\n  {X 5 _}\n  {Acc 3 _}\n  {Show {X 2.3}}<\/lang>\n\n==[[:Category:Perl|Perl]][[Category:Perl]]==\n<div class=\"examplemeta translation\">'''Translation of''': [[Accumulator factory#Ruby|Ruby]]<\/div>\n<lang perl>sub accumulator {\n  my $sum = shift;\n  sub { $sum += shift }\n}\n\nmy $x = accumulator(1);\n$x->(5);\nprint accumulator(3), \"\\n\";\nprint $x->(2.3), \"\\n\";<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>CODE(0x91131f0)\n8.3<\/pre>\n\n==[[:Category:Perl 6|Perl 6]][[Category:Perl 6]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Rakudo]] version #23 \"Lisbon\"[[SMW::on]]<\/div>\n<lang perl6>sub accum ($n is copy) { sub { $n += $^x } }<\/lang>\nExample use:\n<lang perl6>my $a = accum 5;\n$a(4.5);\nsay $a(.5);   # Prints \"10\".<\/lang>\nYou can also use the \"&\" sigil to create a function that behaves syntactically like any other function (i.e. no sigil nor parentheses needed to call it):\n<lang perl6>my &b = accum 5;\nsay b 3;   # Prints \"8\".<\/lang>\n\n==[[:Category:PHP|PHP]][[Category:PHP]]==\n<lang PHP><?php\nfunction accumulator($start){\n return create_function('$x','static $v='.$start.';return $v+=$x;');\n}\n$acc = accumulator(5);\necho $acc(5), \"\\n\"; \/\/prints 10\necho $acc(10), \"\\n\"; \/\/prints 20\n?><\/lang>\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[PHP]] version 5.3+[[SMW::on]]<\/div>\n<lang php><?php\nfunction accumulator($sum){\n return function ($x) use (&$sum) { return $sum += $x; };\n}\n$acc = accumulator(5);\necho $acc(5), \"\\n\"; \/\/prints 10\necho $acc(10), \"\\n\"; \/\/prints 20\n?><\/lang>\n\n==[[:Category:PicoLisp|PicoLisp]][[Category:PicoLisp]]==\n<lang PicoLisp>(de accumulator (Sum)\n   (curry (Sum) (N)\n      (inc 'Sum N) ) )\n\n(def 'a (accumulator 7))\n(a 1)  # Output: -> 8\n(a 2)  # Output: -> 10\n(a -5)  # Output: -> 5<\/lang>\n\n==[[:Category:PostScript|PostScript]][[Category:PostScript]]==\n<lang PostScript>\/mk-acc  {             % accumulator generator\n  {0 add 0 0 2 index put}\n  7 array copy\n  dup 0 4 -1 roll put\n  dup dup 2 exch put\n  cvx\n}  def\n\n% Examples (= is a printing command in PostScript):\n\/a 1 mk-acc def        % create accumulator #1, name it a\n5 a =                  % add 5 to 1, print it\n10 mk-acc              % create accumulator #2, leave it anonymous on the stack\n2.71 a =               % add 2.71 to 6, print it\ndup 3.14 exch exec =   % add 3.14 to 10, print it\ndup 100 exch exec =    % add 100 to 13.14, print it\n12 a =                 % add 12 to 8.71, print it\n                       % accumulator #2 is still available on the stack<\/lang>\n\n==[[:Category:Prolog|Prolog]][[Category:Prolog]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[SWI Prolog]][[SMW::on]]<\/div>\nUses the module '''lambda''' written by  '''Ulrich Neumerkel'''.\n<lang Prolog>:- use_module(library(lambda)).\n\ndefine_g(N, G) :-\n\tput_attr(V, user, N),\n\tG = V +\\X^Y^(get_attr(V, user, N1),\n\t\t  Y is X + N1,\n\t\t  put_attr(V, user, Y)).\n\naccumulator :-\n\tdefine_g(1, G),\n\tformat('Code of g : ~w~n', [G]),\n\tcall(G, 5, S),\n\twriteln(S),\n\tcall(G, 2.3, R1),\n\twriteln(R1).<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>8 ?- accumulator.\nCode of g : _G275+\\_G285^_G288^ (get_attr(_G275,user,_G296),_G288 is _G285+_G296,put_attr(_G275,user,_G288))\n6\n8.3\ntrue.<\/pre>\n\n==[[:Category:Python|Python]][[Category:Python]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Python]] version 2.x\/3.x[[SMW::on]]<\/div>\n<lang python>>>> def accumulator(sum):\n  def f(n):\n    f.sum += n\n    return f.sum\n  f.sum = sum\n  return f\n\n>>> x = accumulator(1)\n>>> x(5)\n6\n>>> x(2.3)\n8.3000000000000007\n>>> x = accumulator(1)\n>>> x(5)\n6\n>>> x(2.3)\n8.3000000000000007\n>>> x2 = accumulator(3)\n>>> x2(5)\n8\n>>> x2(3.3)\n11.300000000000001\n>>> x(0)\n8.3000000000000007\n>>> x2(0)\n11.300000000000001<\/lang>\n<div class=\"examplemeta translation\">'''Translation of''': [[Accumulator factory#Ruby|Ruby]]<\/div>\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Python]] version 3.x[[SMW::on]]<\/div>\n<lang python>def accumulator(sum):\n  def f(n):\n    nonlocal sum\n    sum += n\n    return sum\n  return f\n\nx = accumulator(1)\nx(5)\nprint(accumulator(3))\nprint(x(2.3))<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre><function f at 0xb7c2d0ac>\n8.3<\/pre>\n\n==[[:Category:R|R]][[Category:R]]==\n<lang R>accumulatorFactory <- function(init) {\n  currentSum <- init\n  function(add) {\n    currentSum <<- currentSum + add\n    currentSum\n  }\n}<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>\n> f <- accumulatorFactory(1)\n> f(5)\n[1] 6\n> f(2.3)\n[1] 8.3\n<\/pre>\n\n==[[:Category:Racket|Racket]][[Category:Racket]]==\n<lang scheme>#lang racket\n\n(define (accumulator n)\n    (lambda (i)\n      (set! n (+ n i))\n      n))<\/lang>\n\n==[[:Category:REBOL|REBOL]][[Category:REBOL]]==\n<lang rebol>make-acc-gen: func [start-val] [\n    use [state] [\n        state: start-val\n        func [value] [\n            state: state + value\n        ]\n    ]\n]<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>>> x: make-acc-gen 1\n>> x 5\n== 6\n>> make-acc-gen 3\n>> print x 2.3\n8.3<\/pre>\n\n==[[:Category:Retro|Retro]][[Category:Retro]]==\nRetro only supports integers.\n<lang Retro>  : acc here swap , [ &+! &@ bi ] curry ;\n\n  ( create an accumulator function )\n  1 acc\n\n  ( and give it a name )\n  constant x\n\n  ( add values to it and display the results )\n  5 x do putn\n  2 x do putn<\/lang>\n\n==[[:Category:Ruby|Ruby]][[Category:Ruby]]==\nRuby has methods and blocks. These are both real functions, but not with the same syntax. Our accumulator factory is a method that returns a block (in a Proc object). So, <tt>x = accumulator(1)<\/tt> is valid, but <tt>x(5)<\/tt> is an error: the syntax must be <tt>x.call(5)<\/tt> or <tt>x[5]<\/tt> (with square brackets). Ruby 1.9 also allows <tt>x.(5)<\/tt> (with an extra dot).\n<lang ruby>def accumulator(sum)\n  lambda {|n| sum += n}\nend\n\n# mixing Integer and Float\nx = accumulator(1)\nx.call(5)\np accumulator(3)  # add some output to show what it returns\nputs x.call(2.3)  # prints 8.3\n\n# mixing Rational and Complex\nrequire 'rational'\nrequire 'complex'\ny = accumulator(Rational(2, 3))\ny.call(Rational(1, 2))\nputs y.call(4)\nputs y.call(Complex(0, 1))\nputs y.call(Complex.polar(6, 5 * Math::PI \/ 4))\nputs x.call(0)    # again prints 8.3\n\n# using other things that have a + method\nt = accumulator(Time.utc(1999, 8, 7, 6, 5))\nputs t.call(4)    # prints 1999-08-07 06:05:04 UTC\n\nrequire 'matrix'\nm = accumulator(Matrix[[1, 2], [3, 4]])\nputs m.call(Matrix[[5, 6], [7, 8]])\nputs t.call(-12 * 60 * 60)  # subtracts 12 hours\nputs y.call(1e200)\nputs x.call(0)    # again prints 8.3<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n{| class=\"wikitable\"\n! Output from Ruby 1.8.6\n! Output from Ruby 1.9.2\n|-\n| <pre>#<Proc:0x0000000207ba7f30@\/tmp\/accumulator.rb:2>\n8.3\n31\/6\n31\/6+1i\n0.924025979547381-3.24264068711928i\n8.3\nSat Aug 07 06:05:04 UTC 1999\nMatrix[[6, 8], [10, 12]]\nFri Aug 06 18:05:04 UTC 1999\n1.0e+200-3.24264068711928i\n8.3<\/pre>\n| <pre>#<Proc:0x000002060d1788@\/tmp\/accumulator.rb:2 (lambda)>\n8.3\n31\/6\n31\/6+1i\n0.9240259795473813-3.2426406871192848i\n8.3\n1999-08-07 06:05:04 UTC\nMatrix[[6, 8], [10, 12]]\n1999-08-06 18:05:04 UTC\n1.0e+200-3.2426406871192848i\n8.3<\/pre>\n|}\n\n==[[:Category:Scala|Scala]][[Category:Scala]]==\nThe type of a function can't change in Scala, and there is no \"numeric\" type that is a supertype of all such types. So, if the accumulator is declared as integer, it can only receive and return integers, and so on.\n<lang scala>def AccumulatorFactory[N](n: N)(implicit num: Numeric[N]) = {\n  import num._\n  var acc = n\n  (inc: N) => {\n    acc = acc + inc\n    acc\n  }\n}<\/lang>\n<div>\n;Sample<nowiki>:<\/nowiki><\/div>\n<pre>\nscala> val x = AccumulatorFactory(1.0)\nx: (Double) => Double = <function1>\n\nscala> x(5.0)\nres7: Double = 6.0\n\nscala> AccumulatorFactory(3.0)\nres8: (Double) => Double = <function1>\n\nscala> println(x(2.3))\n8.3\n<\/pre>\n\n==[[:Category:Scheme|Scheme]][[Category:Scheme]]==\n<div class=\"examplemeta translation\">'''Translation of''': [[Accumulator factory#Ruby|Ruby]]<\/div>\n<lang scheme>(define (accumulator sum)\n  (lambda (n)\n    (set! sum (+ sum n))\n    sum))\n\n;; or:\n\n(define ((accumulator sum) n)\n  (set! sum (+ sum n))\n  sum)\n\n(define x (accumulator 1))\n(x 5)\n(display (accumulator 3)) (newline)\n(display (x 2.3)) (newline)<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>#<procedure>\n8.3<\/pre>\n\n==[[:Category:Smalltalk|Smalltalk]][[Category:Smalltalk]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[GNU Smalltalk]][[SMW::on]]<\/div>\n<lang smalltalk>Object subclass: AccumulatorFactory [\n  AccumulatorFactory class >> new: aNumber [\n    |r sum|\n    sum := aNumber.\n    r := [ :a |\n           sum := sum +  a.\n           sum\n         ].\n    ^r\n  ]\n]\n\n|x y|\nx := AccumulatorFactory new: 1.\nx value: 5.\ny := AccumulatorFactory new: 3.\n(x value: 2.3) displayNl.\n\"x inspect.\"\n\"de-comment the previous line to show that x is a block closure\"<\/lang>\n\n==[[:Category:Standard ML|Standard ML]][[Category:Standard ML]]==\n<div class=\"examplemeta translation\">'''Translation of''': [[Accumulator factory#OCaml|OCaml]]<\/div>\nDeviations: An accumulator instance can take ''either'' integers ''or'' reals, but not both mixed (due to lack of runtime polymorphism).\n<lang sml>fun accumulator (sum0:real) : real -> real = let\n  val sum = ref sum0\n  in\n    fn n => (\n      sum := !sum + n;\n      !sum)\n  end;\n\nlet\n  val x = accumulator 1.0\n  val _ = x 5.0\n  val _ = accumulator 3.0\nin\n  print (Real.toString (x 2.3) ^ \"\\n\")\nend;<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>8.3<\/pre>\n\n==[[:Category:Tcl|Tcl]][[Category:Tcl]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Tcl]] version 8.6[[SMW::on]]<\/div>\nThis uses nested [[wp:coroutine|coroutine]]s to manage the state, which for the outer coroutine is a counter used to generate unique instances of the inner coroutine, and for the inner coroutine it is the actual accumulator variable. Note that Tcl commands (including coroutines) are ''never'' nameless, but it is trivial to synthesize a name for them. It's possible to guarantee uniqueness of names, but just using a simple sequence generator gets 90% of the effect for 10% of the effort.\n<lang tcl>package require Tcl 8.6\n\n# make the creation of coroutines without procedures simpler\nproc coro {name arguments body args} {\n    coroutine $name apply [list $arguments $body] {*}$args\n}\n# Wrap the feeding of values in and out of a generator\nproc coloop {var body} {\n    set val [info coroutine]\n    upvar 1 $var v\n    while 1 {\n\tset v [yield $val]\n        if {$v eq \"stop\"} break\n\tset val [uplevel 1 $body]\n    }\n}\n\n# The outer coroutine is the accumulator factory\n# The inner coroutine is the particular accumulator\ncoro accumulator {} {\n    coloop n {\n\tcoro accumulator.[incr counter] n {\n\t    coloop i {\n\t\tset n [expr {$n + $i}]\n\t    }\n\t} $n\n    }\n}<\/lang>\nSample usage (extra characters over Paul's example to show more clearly what is going on):\n<lang tcl>% set x [accumulator 1]\n::accumulator.1\n% $x 5\n6\n% accumulator 3\n::accumulator.2\n% puts \">>[$x 2.3]<<\"\n>>8.3<<<\/lang>\n\n==[[:Category:Unicon|Unicon]][[Category:Unicon]]==\nStrictly speaking, <tt>genAcc(n)<\/tt> returns a <i>co-expression<\/i>, not a function.  However, the invocation syntax here is indistinguishable from calling a function.\n<lang Unicon>procedure main()\n    a := genAcc(3)\n    b := genAcc(5)\n    \n    write(\"        \" ,center(\"a\",5),  \" \", center(\"b\", 5))\n    write(\"genAcc: \", right(a(4),5),  \" \", right(b(4), 5))\n    write(\"genAcc: \", right(a(2),5),  \" \", right(b(3),5))\n    write(\"genAcc: \", right(a(4.5),5),\" \", right(b(1.3),5))\nend\n\nprocedure genAcc(n)   # The generator factory\n    return makeProc { while i := (n@&source)[1] do n +:= i }\nend\n\nprocedure makeProc(A) # A Programmer-Defined Control Operation\n    return (@A[1],A[1])\nend<\/lang>\nNote: The co-expression calling sequence used is Unicon specific.\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>\n          a     b  \ngenAcc:     7     9\ngenAcc:     9    12\ngenAcc:  13.5  13.3\n<\/pre>\n\n==[[:Category:UNIX Shell|UNIX Shell]][[Category:UNIX Shell]]==\nDeviation from task: The accumulator factory returns a ''global function'', which stores the sum in a ''global variable''. Other code can modify the function or the variable, perhaps by accident.\n\nThe shell is a bad choice for this task. This example plays tricks with <tt>eval<\/tt>. The difficulty with <tt>eval<\/tt> is to put the quotation marks \" and dollar signs <tt>$<\/tt> in the correct place, and escape them with the correct number of backslashes \\. One missing (or one extra) backslash can ruin the entire program.\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[pdksh]][[SMW::on]]<\/div>\n<lang bash>#!\/bin\/sh\naccumulator() {\n\t# Define a global function named $1\n\t# with a global variable named ${1}_sum.\n\teval \"${1}_sum=\\$2\"\n\teval \"$1() {\n\t\t${1}_sum=\\$(echo \\\"(\\$${1}_sum) + (\\$2)\\\" | bc)\n\t\teval \\\"\\$1=\\\\\\$${1}_sum\\\"  # Provide the current sum.\n\t}\"\n}\n\naccumulator x 1\nx r 5\naccumulator y 3\nx r 2.3\necho $r\ny r -3000\necho $r<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>$ sh accumulator.sh\n8.3\n-2997<\/pre>\n\n===[[:Category:es|es]][[Category:es]]===\nA better shell for this task is ''es'', because it has lexical variables and closures. <code>@ i {code}<\/code> is a lambda with parameter ''i'', and <code>fn accumulator n {code}<\/code> is sugar for <code>fn-accumulator = @ n {code}<\/code>.\n<lang es>fn accumulator n {\n\tresult @ i {\n\t\tn = `{echo $n + $i | bc}\n\t\tresult $n\n\t}\n}\n\nfn-x = <={accumulator 1}\nx 5\nfn-y = <={accumulator 3}\necho <={x 2.3}\necho <={y -3000}<\/lang>\n\n==[[:Category:VBScript|VBScript]][[Category:VBScript]]==\nI'm not entirely convinced that this is actually doing what is asked. A VBScript guru I'm not. The answer's right, though.\n;Implementation\n<lang vb>class accumulator\n\tdim A\n\tpublic default function acc(x)\n\t\tA = A + x\n\t\tacc = A\n\tend function\n\tpublic property get accum\n\t\taccum = A\n\tend property\nend class<\/lang>\n;Invocation\n<lang vb>dim a\nset a = new accumulator\nx = a( 1 )\na 5\ndim b\nset b = new accumulator\nb 3\nwscript.echo a(2.3)<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>\n8.3\n<\/pre>\n\n==[[:Category:Yorick|Yorick]][[Category:Yorick]]==\nYorick cannot dynamically create new functions. Instead, the accum function can be called in two ways: directly, in which case its first argument is numerical; or through a closure, where its first argument is implicitly an object and the second is the user-provided argument. This example uses closures and group objects, which require Yorick 2.2 or later.\n<lang yorick>func accum(data, n) {\n   if(!is_obj(data))\n      return closure(accum, save(total=data));\n   save, data, total=data.total + n;\n   return data.total;\n}<\/lang>\nExample of use (interactive session):\n<pre>> x = accum(1)\n> x(5)\n6\n> y = accum(3)\n> x(2.3)\n8.3\n> y(2.3)\n5.3<\/pre>\n\n[[Category:Scratch\/Omit]]\n[[Category:C\/Omit]] \n[[Category:ML\/I\/Omit]]"}]}}}}