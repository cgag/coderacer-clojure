{"query":{"pages":{"9632":{"pageid":9632,"ns":0,"title":"Anagrams\/Deranged anagrams","revisions":[{"*":"<div class=\"infobox\" style=\"width: 2in\">[[File:Rcode-button-task-crushed.png|64px|left|alt=Task|link=Category:Solutions by Programming Task]]'''Anagrams\/Deranged anagrams'''<br\/>\nYou are encouraged to [[Rosetta Code:Solve a Task|solve this task]] according to the task description, using any language you may know.[[Category:Programming Tasks]][[Category:Solutions by Programming Task]]<\/div>\nTwo or more words are said to be [[Anagrams|anagrams]] if they have the same characters, but in a different order. By analogy with [[Permutations\/Derangements|derangements]] we define a deranged anagram as two words with the same characters, but in which the same character does ''not'' appear in the same position in both words.\n\nThe task is to use the word list at http:\/\/www.puzzlers.org\/pub\/wordlists\/unixdict.txt to find and ''show'' the longest deranged anagram. \n\n;Cf.\n* [[Permutations\/Derangements]]\n* [[Best shuffle]]\n\n==[[:Category:Ada|Ada]][[Category:Ada]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Ada 2005]][[SMW::on]]<\/div>\n<lang Ada>with Ada.Text_IO; use Ada.Text_IO;\nwith Ada.Containers.Generic_Array_Sort;\nwith Ada.Containers.Indefinite_Vectors;\nprocedure Danagrams is\n   package StringVector is new Ada.Containers.Indefinite_Vectors\n      (Positive, String);\n   procedure StrSort is new Ada.Containers.Generic_Array_Sort\n      (Index_Type => Positive,\n      Element_Type => Character,\n      Array_Type => String);\n   function Derange (s1 : String; s2 : String) return Boolean is begin\n      for i in s1'Range loop\n         if (s1 (i) = s2 (i)) then return False; end if;\n      end loop;\n      return True;\n   end Derange;\n   File : File_Type;\n   len, foundlen : Positive := 1;\n   Vect, SVect : StringVector.Vector;\n   index, p1, p2 : StringVector.Extended_Index := 0;\nbegin\n   Open (File, In_File, \"unixdict.txt\");\n   while not End_Of_File (File) loop\n      declare str : String := Get_Line (File);\n      begin\n         len := str'Length;\n         if len > foundlen then\n            Vect.Append (str);\n            StrSort (str);\n            index := 0;\n            loop --  Loop through anagrams by index in vector of sorted strings\n               index := SVect.Find_Index (str, index + 1);\n               exit when index = StringVector.No_Index;\n               if Derange (Vect.Last_Element, Vect.Element (index)) then\n                     p1 := Vect.Last_Index; p2 := index;\n                     foundlen := len;\n               end if;\n            end loop;\n            SVect.Append (str);\n         end if;\n      end;\n   end loop;\n   Close (File);\n   Put_Line (Vect.Element (p1) & \" \" & Vect.Element (p2));\nend Danagrams;<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>intoxicate excitation<\/pre>\n\n==[[:Category:Bracmat|Bracmat]][[Category:Bracmat]]==\nThe file is read into a single string, <code>wordList<\/code>. Then, in a while loop, each line is read and, in a nested loop, atomised into single letters. The letters are added together to create a sorted list that is the letter sum, the 'anagram fingerprint', of the word. To make sure that even single letter words create a sum of at least two terms, the sum is initialised with the empty string rather than zero. (Otherwise the words <i>a<\/i> and <i>aaa<\/i> later on would get the same fingerprint, the factors <code>1<\/code> and <code>3<\/code> being factored out.)\n\nFor the word <i>bizarre<\/i> the letter sum is <code>(+a+b+e+2*r+z+i)<\/code>. The letter sum, with the word as the exponent (<code>(+a+b+e+2*r+z+i)^bizarre<\/code>) is prepended to a list <code>unsorted<\/code>. Somewhat later the word <i>brazier<\/i> also is prepended to the <code>unsorted<\/code> list. This word happens to have the same letter sum as <i>bizarre<\/i>, so these two words must be anagrams of each other. The program brings these two elements together by merge sorting the <code>unsorted<\/code> list, using Bracmat's Computer Algebra powers to normalise sums and products by sorting and combining like terms or factors. During the sort, all elements in the the <code>unsorted<\/code> list are multiplied together, combining factors with the same letter sums by adding their exponents together. So at some stage during sorting, the two elements <code>(+a+b+e+2*r+z+i)^bizarre<\/code> and <code>(+a+b+e+2*r+z+i)^brazier<\/code> are brought together in a product <code>(+a+b+e+2*r+z+i)^bizarre*(+a+b+e+2*r+z+i)^brazier<\/code> which immediately is transformed to the single factor <code>(+a+b+e+2*r+z+i)^(bizarre+brazier)<\/code>. In the product of all elements the anagrams are to be found in the exponents consisting of a sum of at least two terms. To find the longest deranged anagrams, we traverse the product list to find all exponents with multiple words, check that the length of the first word is at least as long as the length of the longest deranged anagram up to now, and check each pair of words for being deranged. If a pair of deranged anagrams is found with more letters than previously found deranged anagrams, the earlier finds are forgotten. If the new anagrams are the same length, however, they are added to the output.\n\nThe Bracmat solution to the similar task [[Anagrams|anagrams]] skips the explicit merge sort and instead prepends new factors directly to the product one by one. Bracmat shuffles each new factor into place to keep the growing product normalized before continuing with the next word from the list. The result is exactly the same, but the running time becomes much longer.  \n<lang bracmat>  get$(\"unixdict.txt\",STR):?wordList\n& 1:?product\n& :?unsorted\n&   whl\n  ' ( @(!wordList:(%?word:?letterString) \\n ?wordList)\n    & :?letterSum\n    &   whl\n      ' ( @(!letterString:%?letter ?letterString)\n        &   (!letter:~#|str$(N !letter))+!letterSum\n          : ?letterSum\n        )\n    & !letterSum^!word !unsorted:?unsorted\n    )\n& ( mergeSort\n  =   newL L first second\n    .   !arg:?L\n      &   whl\n        ' ( !L:% %\n          & :?newL\n          &   whl\n            ' ( !L:%?first %?second ?L\n              & !first*!second !newL:?newL\n              )\n          & !L !newL:?L\n          )\n      & !L\n  )\n& mergeSort$!unsorted:?product\n& 0:?maxLength:?oldMaxLength\n& :?derangedAnagrams\n& ( deranged\n  =   nextLetter Atail Btail\n    .   !arg\n      : ( (.)\n        |   ( @(?:%@?nextLetter ?Atail)\n            . @(?:(%@:~!nextLetter) ?Btail)\n            )\n          & deranged$(!Atail.!Btail)\n        )\n  )\n& (   !product\n    :   ?\n      *   ?\n        ^ ( %+%\n          : @(%:? ([~<!maxLength:[?maxLength))+?\n          :   ?\n            + %@?anagramA\n            + ?\n            + %@?anagramB\n            + ( ?\n              & deranged$(!anagramA.!anagramB)\n              &     (!anagramA.!anagramB)\n                    (   !maxLength:>!oldMaxLength:?oldMaxLength\n                      & \n                    | !derangedAnagrams\n                    )\n                : ?derangedAnagrams\n              & ~\n              )\n          )\n      * ?\n  | out$!derangedAnagrams\n  );<\/lang>\nOutput:\n<pre>excitation.intoxicate<\/pre>\n\n==[[:Category:C|C]][[Category:C]]==\n<lang C>#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys\/types.h>\n#include <fcntl.h>\n#include <sys\/stat.h>\n\ntypedef struct { char *key, *word; } wtuple;\n\nint deranged(char *s1, char *s2)\n{\n\twhile (*s1 != '\\0')\n\t\tif (*(s1++) == *(s2++)) return 0;\n\n\treturn 1;\n}\n\nint cmp_tuple(const void *a, const void *b)\n{\n\tconst wtuple *x = a, *y = b;\n\tint l1 = strlen(x->key), l2 = strlen(y->key);\n\treturn l1 > l2 ? -1 : l1 < l2 ? 1 :strcmp(x->key, y->key);\n}\n\n\/* sort letters in a string *\/\nvoid char_sort(char *ptr, int len)\n{\n\tint i, j;\n\tchar tmp;\n\t\/* bubble sort, O(n) shmoen *\/\n\tfor (i = 0; i < len; i++)\n\t\tfor (j = i + 1; j < len; j++)\n\t\t\tif (ptr[i] > ptr[j]) {\n\t\t\t\ttmp = ptr[i]; ptr[i] = ptr[j]; ptr[j] = tmp;\n\t\t\t}\n}\n\nint main()\n{\n\tint i, j, k, n_words = 0;\n\tchar *words, *keys;\n\tstruct stat st;\n\twtuple *t;\n\n\tint fd = open(\"unixdict.txt\", O_RDONLY);\n\tfstat(fd, &st);\n\n\twords = malloc(st.st_size);\n\tread(fd, words, st.st_size);\n\tclose(fd);\n\n\tkeys = malloc(st.st_size);\n\tmemcpy(keys, words, st.st_size);\n\n\t\/* count words, change all new line to null, and sort each key *\/\n\tfor (i = j = 0; i < st.st_size; i++) {\n\t\tif (words[i] != '\\n') continue;\n\t\tn_words ++;\n\t\twords[i] = keys[i] = '\\0';\n\t\tchar_sort(keys + j, i - j);\n\t\tj = i;\n\t}\n\n\t\/* make key-word tuples *\/\n\tt = malloc(sizeof(wtuple) * n_words);\n\tfor (j = k = i = 0; i < st.st_size; i++) {\n\t\tif (words[i] != '\\0') continue;\n\t\tt[j].key  = keys  + k;\n\t\tt[j].word = words + k;\n\t\tk = ++i;\n\t\tj++;\n\t}\n\n\t\/* sort t by key length \/ key order *\/\n\tqsort(t, n_words, sizeof(wtuple), cmp_tuple);\n\tfor (i = 0, j = 0; j < n_words; j++) {\n\t\tif (strcmp(t[i].key, t[j].key)) i = j;\n\t\telse if (deranged(t[i].word, t[j].word)) break;\n\t}\n\n\tprintf(\"longest derangement: %s %s\\n\", t[i].word, t[j].word);\n\treturn 0;\n}<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>\nlongest derangement: excitation intoxicate\n<\/pre>\n\n==[[:Category:CoffeeScript|CoffeeScript]][[Category:CoffeeScript]]==\nThis example was tested with node.js.\n<lang coffeescript>http = require 'http'\n\nis_derangement = (word1, word2) ->\n  for c, i in word1\n    return false if c == word2[i]\n  true\n\nshow_longest_derangement = (word_lst) ->\n  anagrams = {}\n  max_len = 0\n  \n  for word in word_lst\n    continue if word.length < max_len\n    key = word.split('').sort().join('')\n    if anagrams[key]\n      for prior in anagrams[key]\n        if is_derangement(prior, word)\n          max_len = word.length\n          result = [prior, word]\n    else\n      anagrams[key] = []\n    anagrams[key].push word\n    \n  console.log \"Longest derangement: #{result.join ' '}\"\n\nget_word_list = (process) ->\n  options =\n    host: \"www.puzzlers.org\"\n    path: \"\/pub\/wordlists\/unixdict.txt\"\n  \n  req = http.request options, (res) ->\n    s = ''\n    res.on 'data', (chunk) ->\n      s += chunk\n    res.on 'end', ->\n      process s.split '\\n'\n  req.end()\n  \nget_word_list show_longest_derangement<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>\n> coffee anagrams.coffee \nLongest derangement: excitation intoxicate\n<\/pre>\n\n==[[:Category:Common Lisp|Common Lisp]][[Category:Common Lisp]]==\n<lang lisp>(defun read-words (file)\n  (with-open-file (stream file)\n    (loop with w = \"\" while w collect (setf w (read-line stream nil)))))\n \n(defun deranged (a b)\n  (loop for ac across a for bc across b always (char\/= ac bc)))\n\n(defun longest-deranged (file)\n  (let ((h (make-hash-table :test #'equal))\n\t(wordlist (sort (read-words file)\n\t\t\t#'(lambda (x y) (> (length x) (length y))))))\n    (loop for w in wordlist do\n\t  (let* ((ws (sort (copy-seq w) #'char<))\n\t\t (l (gethash ws h)))\n\t    (loop for w1 in l do\n\t\t  (if (deranged w w1)\n\t\t    (return-from longest-deranged (list w w1))))\n\t    (setf (gethash ws h) (cons w l))))))\n\n(format t \"~{~A~%~^~}\" (longest-deranged \"unixdict.txt\"))<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>intoxicate\nexcitation<\/pre>\n\n==[[:Category:D|D]][[Category:D]]==\n<lang d>import std.stdio, std.file, std.string, std.algorithm, std.range;\n\nauto findAnagrams(Range)(Range words) \/*pure nothrow*\/ {\n    string[][const ubyte[]] anagrams; \/\/ assume input is ASCII\n    foreach (w; words)\n        anagrams[(cast(ubyte[])w).sort().release().idup] ~= w.idup;\n    return anagrams.byValue.filter!q{ a.length > 1 }().array();\n}\n\nconst(string)[2][] findDeranged(in string[] words) \/*pure nothrow*\/ {\n    typeof(return) result;\n    foreach (i, w1; words)\n        foreach (w2; words[i+1 .. $])\n            if (zip(w1, w2).all!q{ a[0] != a[1] }())\n                result ~= [w1, w2];\n    return result;\n}\n\nauto largestDerangedAna(string[][] anagrams) \/*nothrow*\/ {\n    anagrams.schwartzSort!(a => -a[0].length)();\n    return anagrams.map!findDeranged().filter!q{ a.length }();\n}\n\nvoid main() {\n    \/\/auto words = readText(\"unixdict.txt\").splitter();\n    auto words = std.array.splitter(readText(\"unixdict.txt\"));\n    writeln(\"Longest deranged anagrams:\");\n    auto der = largestDerangedAna(findAnagrams(words));\n    if (!der.empty)\n        writeln(der.front);\n}<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>Longest deranged anagrams:\n[[\"excitation\", \"intoxicate\"]]<\/pre>\n===Faster version===\n<lang d>import std.stdio, std.file, std.string, std.algorithm,\n       std.typecons, std.range;\n\nauto findDeranged(in string[] words) \/*pure nothrow*\/ {\n    Tuple!(const string, const string)[] result;\n    foreach (i, w1; words)\n        foreach (w2; words[i+1 .. $])\n            if (!zip(w1, w2).canFind!q{ a[0] == a[1] }())\n                result ~= tuple(w1, w2);\n    return result;\n}\n\nvoid main() {\n    Appender!(string[])[30] wclasses;\n    foreach (word; std.algorithm.splitter(readText(\"unixdict.txt\")))\n        wclasses[$ - word.length].put(word);\n    auto r = filter!q{ a.length }(map!q{ a.data }(wclasses[]));\n    writeln(\"Longest deranged anagrams:\");\n    foreach (words; r) {\n        string[][const ubyte[]] anags; \/\/ assume input is ASCII\n        foreach (w; words)\n            anags[(cast(ubyte[])w).sort().release().idup] ~= w.idup;\n        const anas = anags.values.filter!q{ a.length > 1 }().array();\n        auto pairs = anas.map!findDeranged().filter!q{ a.length }();\n        if (!pairs.empty) {\n            writefln(\"  %s, %s\", pairs.front[0].tupleof);\n            break;\n        }\n    }\n}<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>Longest deranged anagrams:\n  excitation, intoxicate<\/pre>\n\n==[[:Category:GAP|GAP]][[Category:GAP]]==\nUsing function [[Anagrams#GAP|Anagrams]].\n<lang gap>IsDeranged := function(a, b)\n\tlocal i, n;\n\tfor i in [1 .. Size(a)] do\n\t\tif a[i] = b[i] then\n\t\t\treturn false;\n\t\tfi;\n\tod;\n\treturn true;\nend;\n\n# This solution will find all deranged pairs of any length.\nDeranged := function(name)\n\tlocal sol, ana, u, v;\n\tsol := [ ];\n\tana := Anagrams(name);\n\tfor u in ana do\n\t\tfor v in Combinations(u, 2) do\n\t\t\tif IsDeranged(v[1], v[2]) then\n\t\t\t\tAdd(sol, v);\n\t\t\tfi;\n\t\tod;\n\tod;\n\treturn sol;\nend;\n\n# Now we find all deranged pairs of maximum length\na := Deranged(\"unixdict.txt\");;\nn := Maximum(List(a, x -> Size(x[1])));\nFiltered(a, x -> Size(x[1]) = n);\n# [ [ \"excitation\", \"intoxicate\" ] ]<\/lang>\n\n==[[:Category:Go|Go]][[Category:Go]]==\n<lang go>package main\nimport (\n\t\"fmt\"\n\t\"io\/ioutil\"\n\t\"strings\"\n\t\"sort\"\n)\n\nfunc deranged(a, b string) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range(a) {\n\t\tif a[i] == b[i] { return false }\n\t}\n\treturn true\n}\n\nfunc main() {\n\t\/* read the whole thing in. how big can it be? *\/\n\tbuf, _ := ioutil.ReadFile(\"unixdict.txt\")\n\twords := strings.Split(string(buf), \"\\n\")\n\n\tm := make(map[string] []string)\n\tbest_len, w1, w2 := 0, \"\", \"\"\n\n\tfor _, w := range(words) {\n\t\t\/\/ don't bother: too short to beat current record\n\t\tif len(w) <= best_len { continue }\n\n\t\t\/\/ save strings in map, with sorted string as key\n\t\tletters := strings.Split(w, \"\")\n\t\tsort.Strings(letters)\n\t\tk := strings.Join(letters, \"\")\n\n\t\tif _, ok := m[k]; !ok {\n\t\t\tm[k] = []string { w }\n\t\t\tcontinue\n\t\t}\n\n\t\tfor _, c := range(m[k]) {\n\t\t\tif deranged(w, c) {\n\t\t\t\tbest_len, w1, w2 = len(w), c, w\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tm[k] = append(m[k], w)\n\t}\n\n\tfmt.Println(w1, w2, \": Length\", best_len)\n}<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>\nexcitation intoxicate : Length 10\n<\/pre>\n\n==[[:Category:Haskell|Haskell]][[Category:Haskell]]==\nIf the longest deranged anagram includes three or more words we'll only print two of them.  We also correctly handle duplicate words in the input.\n<lang haskell>import Control.Arrow\nimport Data.List\nimport Data.Ord\nimport qualified Data.Map as M\nimport qualified Data.Set as S\n\n-- Group lists of words based on their \"signatures\".  A signature is a sorted\n-- list of characters.  Handle duplicate input words by storing them in sets.\ngroupBySig = map (sort &&& S.singleton)\n\n-- Convert groups to lists of equivalent words.\nequivs = map (S.toList . snd) . M.toList . M.fromListWith S.union\n\n-- Indicate whether the pair of words differ in all character positions.\nisDerangement (a, b) = and $ zipWith (\/=) a b\n\n-- Return all pairs of elements, ignoring order.\npairs = concat . unfoldr step\n  where step (x:xs) = Just (map ((,) x) xs, xs)\n        step []     = Nothing\n\n-- Return all anagram pairs in the input string.\nanagrams = concatMap pairs . equivs . groupBySig\n\n-- Return the pair of words making the longest deranged anagram.\nmaxDerangedAnagram = maxByLen . filter isDerangement . anagrams\n  where maxByLen [] = Nothing\n        maxByLen xs = Just $ maximumBy (comparing (length . fst)) xs\n\nmain :: IO ()\nmain = do\n  input <- getContents\n  case maxDerangedAnagram $ words input of\n    Nothing     -> putStrLn \"No deranged anagrams were found.\"\n    Just (a, b) -> putStrLn $ \"Longest deranged anagrams: \" ++ a ++ \" and \" ++ b<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>\nLongest deranged anagrams: excitation and intoxicate\n<\/pre>\n\n==[[:Category:Icon|Icon]][[Category:Icon]] and [[:Category:Unicon|Unicon]][[Category:Unicon]]==\nThis solution (which works in both languages) does a strict interpretation of the problem and ignores the fact that there may be multiple derangements that are the same length (including ignoring multiple derangements arising from the same set of words that are all anagrams).  \n<lang unicon>link strings     # for csort() procedure\n\nprocedure main()\n    anagrams := table()                     # build lists of anagrams\n    every *(word := !&input) > 1 do {\n        canon := csort(word)\n        \/anagrams[canon] := []\n        put(anagrams[canon], word)\n        }\n\n    longest := 1                            # find a longest derangement\n    every *(aList := !anagrams) > 1 do     \n        if derangement := derange(aList) then \n            if longest <:= *derangement[1] then long := derangement\n\n    every writes((!\\long||\" \")|\"\\n\")        # show longest\nend\n\nprocedure derange(aList)    # Return a single derangement from this list\n    while aWord := get(aList) do return noMatch(aWord, !aList)\nend\n\nprocedure noMatch(s1,s2)    # Produce pair only if s1,s2 are deranged.\n    every i := 1 to *s1 do if s1[i] == s2[i] then fail\n    return [s1,s2]\nend<\/lang>\n<div>\n;Sample run<nowiki>:<\/nowiki><\/div>\n<pre>->dra <unixdict.txt\nexcitation intoxicate \n-><\/pre>\n\n==[[:Category:J|J]][[Category:J]]==\nThis assumes that [http:\/\/www.puzzlers.org\/pub\/wordlists\/unixdict.txt unixdict.txt] has been saved in the current directory.\n<lang j>   #words=: <;._2 ] 1!:1 <'unixdict.txt'\n25104\n   #anagrams=: (#~ 1 < #@>) (<\/.~ \/:~&>) words\n1303\n   #maybederanged=: (#~ (1 -.@e. #@~.\"1)@|:@:>&>) anagrams\n432\n   #longest=: (#~ [: (= >.\/) #@>@{.@>) maybederanged\n1\n   longest\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502\n\u2502\u2502excitation\u2502intoxicate\u2502\u2502\n\u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518<\/lang>\nNote that anagram sets with more than two members might, hypothetically, have made things more complicated.  By lucky coincidence, this was not an issue.  We could have taken advantage of that coincidence to achieve slight further simplifications.  Perhaps <code>maybederanged=: (#~ (-: ~.\"1)@|:@:>&>) anagrams<\/code>\n\nIn other words, if we had had to consider whether <code>ascertain\/cartesian\/sectarian<\/code> contained a deranged pair, we would have had to break it out into the three pairs it contains.  However, since 'excitation' is a longer word than 'ascertain', we know that this triple cannot contain the longest deranged anagram pair.  And since there are no anagrams longer than 'excitation' which involve more than a single pair, we know that we can ignore this issue entirely.\n\n==[[:Category:Java|Java]][[Category:Java]]==\n<div class=\"examplemeta translation\">'''Translation of''': [[Anagrams\/Deranged anagrams#D|D]]<\/div>\n<lang java>import java.io.*;\nimport java.util.*;\n\npublic class DerangedAnagrams {\n     \n    public static void main(String[] args) throws IOException {\n        String[][] anagrams = findAnagrams(readLines(\"unixdict.txt\"));\n        String[] res = null;\n        for (String[] ana : anagrams) {\n            int j = ana[0].length() - 1;\n            while (j >= 0 && ana[0].charAt(j) != ana[1].charAt(j)) {\n                j--;\n            }\n            if (j == -1) {\n                res = ana;\n                break;\n            }\n        }\n        System.out.printf(\"result: %s %s\\n\", res[0], res[1]);\n    }\n\n    static String[][] findAnagrams(String[] words) {\n        Map<String, ArrayList<String>> map = new LinkedHashMap<String, ArrayList<String>>();\n        for (String w : words) {\n            char[] srt = w.toCharArray();\n            Arrays.sort(srt);\n            String key = String.valueOf(srt);\n            if (map.containsKey(key)) {\n                map.get(key).add(w);\n            } else {\n                ArrayList<String> v = new ArrayList<String>();\n                v.add(w);\n                map.put(key, v);\n            }\n        }\n        List<String[]> pairs = new ArrayList<String[]>();\n        for (List<String> v : map.values()) {\n            if (v.size() > 1) {\n                String[] wrds = v.toArray(new String[]{});\n                for (int i = 0; i < wrds.length - 1; i++) {\n                    pairs.add(new String[]{wrds[i], wrds[i + 1]});\n                }\n            }\n        }\n        return pairs.toArray(new String[][]{});\n    }\n\n    static public String[] readLines(String fn) throws IOException {\n        BufferedReader br = new BufferedReader(new FileReader(fn));\n        List<String> lines = new ArrayList<String>();\n        String line = null;\n        while ((line = br.readLine()) != null) \n            lines.add(line.trim());\n        br.close();\n        Collections.sort(lines, new Comparator<String>() {\n            public int compare(String a, String b) {\n                return b.length() - a.length();\n            }\n        });\n        return lines.toArray(new String[]{});\n    }\n}<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>result: excitation intoxicate<\/pre>\n\n==[[:Category:JavaScript|JavaScript]][[Category:JavaScript]]==\n{| class=\"messagebox\" style=\"text-align: center; background-color: #ffc8c8; clear: both;\"\n| This example does not show the output mentioned in the task description '''on this page''' (or a page linked to from here).  Please ensure that it meets all task requirements and remove this message. <br><small>Note that phrases in task descriptions such as ''\"print and display\"'' and ''\"print and show\"'' for example, indicate that (reasonable length) output be a part of a language's solution.<\/small>\n|}[[Category:JavaScript examples needing attention]][[Category:Examples needing attention]]\nWord file is saved locally because browser won't fetch it cross-site.  Tested on Gecko.\n<lang javascript><html><head><title>Intoxication<\/title><\/head>\n<body><pre id='x'><\/pre>\n<script type=\"application\/javascript\">\n\nfunction show(t) {\n\tvar l = document.createTextNode(t + '\\n');\n\tdocument.getElementById('x').appendChild(l);\n}\n\n\/\/ get words; be ware of cross-site restrictions on XMLHttpRequest\nvar words = null;\nvar req = new XMLHttpRequest();\nreq.open('GET', 'file:\/\/\/tmp\/unixdict.txt', false);\nreq.send(null);\nwords = req.responseText.split('\\n');\n\nvar idx = {};\nfor (var i = 0; i < words.length; i++) {\n\tvar t = words[i].split('').sort().join('');\n\tif (idx[t]) idx[t].push(words[i]);\n\telse\t    idx[t] = [words[i]];\n}\n\nvar best = '';\nvar best_pair;\nfor (var i in idx) {\n\tif (i.length <= best.length) continue;\n\tif (idx[i].length == 1) continue;\n\n\tvar a = idx[i], got = null;\n\tfor (var j = 0, l1 = a[j]; j < a.length && !got; j++) {\n\t\tfor (var k = j + 1, l2 = a[k]; k < a.length && !got; k++)\n\t\t\tfor (var m = 0; m < l1.length || !(got = [l2]); m++)\n\t\t\t\tif (l1[m] == l2[m]) break;\n\t\tif (got) got.push(l1);\n\t}\n\n\tif (got) {\n\t\tbest_pair = got;\n\t\tbest = got[0];\n\t}\n}\n\nshow(best_pair);\n<\/script><\/body><\/html><\/lang>\n\n==[[:Category:K|K]][[Category:K]]==\n<lang K>   \/ anagram clusters\n   a:{x g@&1<#:'g:={x@<x}'x}@0:\"unixdict.txt\";\n \n   \/ derangements in these clusters\n   b@&c=|\/c:{#x[0]}'b:a@&{0=+\/\/{x=y}':x}'a\n(\"excitation\"\n \"intoxicate\")<\/lang>\n\n==[[:Category:OCaml|OCaml]][[Category:OCaml]]==\n<lang ocaml>let sort_chars s =\n  let r = String.copy s in\n  for i = 0 to (String.length r) - 2 do\n    for j = i + 1 to (String.length r) - 1 do\n      if r.[i] > r.[j] then begin\n        let tmp = r.[i] in\n        r.[i] <- r.[j];\n        r.[j] <- tmp;\n      end\n    done\n  done;\n  (r)\n\nlet deranged (s1, s2) =\n  let len1 = String.length s1\n  and len2 = String.length s2 in\n  if len1 <> len2 then false else\n  try\n    for i = 0 to pred len1 do\n      if s1.[i] = s2.[i] then raise Exit\n    done;\n    true\n  with Exit -> false\n\nlet pairs_of_list lst =\n  let rec aux acc = function\n    | [] -> acc\n    | x::xs ->\n        aux (List.fold_left (fun acc y -> (x,y)::acc) acc xs) xs\n  in\n  aux [] lst\n\nlet () =\n  let h = Hashtbl.create 3571 in\n  let ic = open_in \"unixdict.txt\" in\n  try while true do\n    let word = input_line ic in\n    let key = sort_chars word in\n    let l =\n      try Hashtbl.find h key\n      with Not_found -> [] \n    in\n    Hashtbl.add h key (word::l);\n  done with End_of_file ->\n    close_in ic;\n    let lst =\n      Hashtbl.fold (fun _ lw acc ->\n        if List.length lw < 2 then acc else lw::acc) h []\n    in\n    let lst =\n      List.fold_left (fun acc anagrams ->\n        let pairs = pairs_of_list anagrams in\n        (List.filter deranged pairs) @ acc\n      ) [] lst\n    in\n    let res, _ =\n      List.fold_left (fun (res, n) (w1, w2) ->\n        let len = String.length w1 in\n        match Pervasives.compare len n with\n        | 0 -> ((w1, w2)::res, n)\n        | 1 -> ([w1, w2], len)\n        | _ -> (res, n)\n      ) ([], 0) lst\n    in\n    List.iter (fun (w1, w2) -> Printf.printf \"%s, %s\\n\" w1 w2) res<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>$ ocaml deranged_anagram.ml\nintoxicate, excitation<\/pre>\n\n==[[:Category:Perl|Perl]][[Category:Perl]]==\n<lang Perl>sub deranged {                          # only anagrams ever get here\n        my @a = split('', shift);       # split word into letters\n        my @b = split('', shift);\n        for (0 .. $#a) {\n                $a[$_] eq $b[$_] and return;\n        }\n        return 1\n}\n\nsub find_deranged {     \n        for my $i ( 0 .. $#_ ) {\n                for my $j ( $i+1 .. $#_ ) {\n                        next unless deranged $_[$i], $_[$j];\n\n                        print \"length \", length($_[$i]), \": $_[$i] => $_[$j]\\n\";\n                        return 1;\n                }\n        }\n}\n\nmy %letter_list;\nopen my $in, 'unixdict.txt';\n\nlocal $\/ = undef;\n\nfor (split(' ', <$in>)) {\n        # store anagrams in hash table by letters they contain\n        push @{ $letter_list{ join('', sort split('', $_)) } }, $_\n}\n\nfor (   sort { length($b) <=> length($a) }      # sort by length, descending\n        grep { @{ $letter_list{$_} } > 1 }      # take only ones with anagrams\n        keys %letter_list               )\n{\n        # if we find a pair, they are the longested due to the sort before\n        last if find_deranged(@{ $letter_list{$_} });\n}<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>\nlength 10: excitation => intoxicate\n<\/pre>\n\n==[[:Category:PicoLisp|PicoLisp]][[Category:PicoLisp]]==\n<lang PicoLisp>(let Words NIL\n   (in \"unixdict.txt\"\n      (while (line)\n         (let (Word @  Key (pack (sort (copy @))))\n            (if (idx 'Words Key T)\n               (push (car @) Word)\n               (set Key (list Word)) ) ) ) )\n   (maxi '((X) (length (car X)))\n      (extract\n         '((Key)\n            (pick\n               '((Lst)\n                  (and\n                     (find\n                        '((L) (not (find = L Lst)))\n                        (val Key) )\n                     (cons (pack @) (pack Lst)) ) )\n               (val Key) ) )\n         (idx 'Words) ) ) )<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>-> (\"excitation\" . \"intoxicate\")<\/pre>\n\n==[[:Category:Perl 6|Perl 6]][[Category:Perl 6]]==\nNote that, to make runtime manageable, we have created a subset file:\n<lang bash>grep '^[ie]' unixdict.txt > dict.ie<\/lang>\n<lang perl6>my %anagram = slurp('dict.ie').words.map({[.comb]}).classify({ .sort.join });\n\nfor %anagram.values.sort({ -@($_[0]) }) -> @aset {\n    for     0   ..^ @aset.end -> $i {\n        for $i ^..  @aset.end -> $j {\n            if none(  @aset[$i].list Zeq @aset[$j].list ) {\n                say \"{@aset[$i].join}   {@aset[$j].join}\";\n                exit;\n            }\n        }\n    }\n}<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>excitation   intoxicate<\/pre>\n\n==[[:Category:Prolog|Prolog]][[Category:Prolog]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[SWI Prolog]][[SMW::on]]<\/div>\n<lang Prolog>longest_deranged_anagram :-\n\thttp_open('http:\/\/www.puzzlers.org\/pub\/wordlists\/unixdict.txt',In,[]),\n\tread_file(In, [], Out),\n\tclose(In),\n\tmsort(Out, MOut),\n\tgroup_pairs_by_key(MOut, GPL),\n\tmap_list_to_pairs(compute_len, GPL, NGPL),\n\tpredsort(my_compare, NGPL, GPLSort),\n\tsearch_derangement(GPLSort).\n\n\n% order tuples to have longest words first\nmy_compare(R, N1-(K1-E1), N2-(K2-E2)) :-\n\t(   N1 < N2 -> R = > ; N1 > N2 -> R = <;\n\tlength(E1, L1),\n\tlength(E2, L2),\n\t(   L1 < L2 -> R = <; L1 > L2 -> R = >; compare(R, K1, K2))).\n\n\ncompute_len(_-[H|_], Len) :-\n\tlength(H, Len).\n\n\n% check derangement of anagrams\nderangement([], []).\nderangement([H1|T1], [H2 | T2]) :-\n\tH1 \\= H2,\n\tderangement(T1, T2).\n\n\nsearch_derangement([_-(_-L) | T]) :-\n\tlength(L, 1), !,\n\tsearch_derangement(T).\n\n\nsearch_derangement([_-(_-L) | T]) :-\n\t(   search(L) -> true; search_derangement(T)).\n\nsearch([]) :- fail.\nsearch([H | T]) :-\n\t(   search_one(H, T) -> true; search(T)).\n\n\nsearch_one(Word, L) :-\n\tinclude(derangement(Word), L, [H|_]),\n\tatom_codes(W, Word),\n\tatom_codes(W1, H),\n\tformat('Longest deranged anagrams : ~w ~w ~n', [W, W1]).\n\n\nread_file(In, L, L1) :-\n\tread_line_to_codes(In, W),\n\t(   W == end_of_file ->\n\t       L1 = L\n\t       ;\n\t       msort(W, W1),\n\t       atom_codes(A, W1),\n\t       read_file(In, [A-W | L], L1)).<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre> ?- longest_deranged_anagram.\nLongest deranged anagrams : excitation intoxicate \ntrue.\n<\/pre>\n\n==[[:Category:PureBasic|PureBasic]][[Category:PureBasic]]==\n<lang PureBasic>Structure anagram\n  word.s\n  letters.s\nEndStructure\n \nStructure  wordList\n  List words.anagram()\nEndStructure\n \n#True = 1\n#False = 0\n \nProcedure.s sortLetters(*word.Character, wordLength)\n  ;returns a string with the letters of a word sorted\n  Protected Dim letters.c(wordLength)\n  Protected *letAdr = @letters()\n  CopyMemoryString(*word, @*letAdr)\n  SortArray(letters(), #PB_Sort_Ascending, 0, wordLength - 1)\n  ProcedureReturn PeekS(@letters(), wordLength)\nEndProcedure\n \n;Compare a list of anagrams for derangement.\nProcedure isDeranged(List anagram.s()) \n  ;If a pair of deranged anagrams is found return #True\n  ;and and modify the list to include the pair of deranged anagrams.\n  Protected i, length, word.s, *ptrAnagram, isDeranged\n  Protected NewList deranged.s()\n  FirstElement(anagram())\n  length = Len(anagram())\n  Repeat \n    word = anagram()\n    *ptrAnagram = @anagram()\n    \n    While NextElement(anagram())\n      isDeranged = #True\n      For i = 1 To length\n        If Mid(word, i, 1) = Mid(anagram(), i, 1)\n          isDeranged = #False\n          Break ;exit for\/next\n        EndIf \n      Next \n      \n      If isDeranged\n        AddElement(deranged())\n        deranged() = anagram()\n        AddElement(deranged())\n        deranged() = word\n        CopyList(deranged(), anagram())\n        ProcedureReturn #True ;deranged anagram found\n      EndIf \n    Wend\n    ChangeCurrentElement(anagram(), *ptrAnagram)\n  Until Not NextElement(anagram())\n  \n  ProcedureReturn #False ;deranged anagram not found\nEndProcedure\n \nIf OpenConsole()\n  ;word file is assumed to be in the same directory\n  If Not ReadFile(0,\"unixdict.txt\"): End: EndIf \n  \n  Define maxWordSize = 0, word.s, length\n  Dim wordlists.wordList(maxWordSize)\n  \n  ;Read word file and create separate lists of anagrams and their original\n  ;words by length.\n  While Not Eof(0)\n    word = ReadString(0)\n    length = Len(word)\n    If length > maxWordSize\n      maxWordSize = length\n      Redim wordlists.wordList(maxWordSize)\n    EndIf \n    AddElement(wordlists(length)\\words())\n    wordlists(length)\\words()\\word = word\n    wordlists(length)\\words()\\letters = sortLetters(@word, length)\n  Wend\n  CloseFile(0)\n  \n  Define offset = OffsetOf(anagram\\letters), option = #PB_Sort_Ascending\n  Define sortType = #PB_Sort_String\n  Define letters.s, foundDeranged\n  NewList anagram.s()\n  ;start search from largest to smallest\n  For length = maxWordSize To 2 Step -1\n    \n    If FirstElement(wordlists(length)\\words()) ;only examine lists with words\n      ;sort words to place anagrams next to each other\n      SortStructuredList(wordlists(length)\\words(), option, offset, sortType)\n      \n      With wordlists(length)\\words()\n        letters = \\letters\n        AddElement(anagram()): anagram() = \\word\n        \n        ;Compose sets of anagrams and check for derangement with remaining\n        ;words in current list.\n        While NextElement(wordlists(length)\\words())\n          ;Check for end of a set of anagrams?\n          If letters <> \\letters\n            \n            ;if more than one word in a set of anagrams check for derangement\n            If ListSize(anagram()) > 1\n              If isDeranged(anagram())\n                foundDeranged = #True ;found deranged anagrams, stop processing\n                Break 2 ;exit while\/wend and for\/next\n              EndIf \n            EndIf \n            \n            letters = \\letters ;setup for next set of anagrams\n            ClearList(anagram())\n          EndIf \n          \n          AddElement(anagram()): anagram() = \\word\n        Wend\n      EndWith\n      \n    EndIf \n    \n    ClearList(anagram())\n  Next   \n  \n  ;report results\n  If foundDeranged\n    Print(\"Largest 'Deranged' anagrams found are of length \")\n    PrintN(Str(length) + \":\" + #CRLF$)\n    ForEach anagram()\n      PrintN(\"  \" + anagram())\n    Next \n  Else\n    PrintN(\"No 'Deranged' anagrams were found.\" + #CRLF$)\n  EndIf \n  \n  Print(#CRLF$ + #CRLF$ + \"Press ENTER to exit\"): Input()\n  CloseConsole()\nEndIf<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>Largest 'Deranged' anagrams found are of length 10:\n\n  intoxicate\n  excitation<\/pre>\n\n==[[:Category:Python|Python]][[Category:Python]]==\n<lang python>import urllib.request\nfrom collections import defaultdict\nfrom itertools import combinations\n\ndef getwords(url='http:\/\/www.puzzlers.org\/pub\/wordlists\/unixdict.txt'):\n    return list(set(urllib.request.urlopen(url).read().decode().split()))\n\ndef find_anagrams(words):\n    anagram = defaultdict(list) # map sorted chars to anagrams\n    for word in words:\n        anagram[tuple(sorted(word))].append( word )\n    return dict((key, words) for key, words in anagram.items()\n                if len(words) > 1)\n\ndef is_deranged(words):\n    'returns pairs of words that have no character in the same position'\n    return [ (word1, word2)\n             for word1,word2 in combinations(words, 2)\n             if all(ch1 != ch2 for ch1, ch2 in zip(word1, word2)) ]\n\ndef largest_deranged_ana(anagrams):\n    ordered_anagrams = sorted(anagrams.items(),\n                              key=lambda x:(-len(x[0]), x[0]))\n    for _, words in ordered_anagrams:\n        deranged_pairs = is_deranged(words)\n        if deranged_pairs:\n            return deranged_pairs\n    return []\n\nif __name__ == '__main__':\n    words = getwords('http:\/\/www.puzzlers.org\/pub\/wordlists\/unixdict.txt')\n    print(\"Word count:\", len(words))\n\n    anagrams = find_anagrams(words)\n    print(\"Anagram count:\", len(anagrams),\"\\n\")\n\n    print(\"Longest anagrams with no characters in the same position:\")\n    print('  ' + '\\n  '.join(', '.join(pairs)\n                             for pairs in largest_deranged_ana(anagrams)))<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>Word count: 25104\nAnagram count: 1303 \n\nLongest anagrams with no characters in the same position:\n  excitation, intoxicate<\/pre>\n===Faster Version===\n<div class=\"examplemeta translation\">'''Translation of''': [[Anagrams\/Deranged anagrams#D|D]]<\/div>\n<lang python>from itertools import izip, ifilter\nfrom collections import defaultdict\n\ndef find_deranged(words):\n    result = []\n    for i, w1 in enumerate(words):\n        for w2 in words[i+1:]:\n            if all(a != b for a,b in izip(w1, w2)):\n                result.append((w1, w2))\n    return result\n\ndef main():\n    wclasses = [[] for _ in xrange(30)]\n    for word in open(\"unixdict.txt\").read().split():\n        wclasses[-len(word)].append(word)\n    print \"Longest deranged anagrams:\"\n    for words in ifilter(None, wclasses):\n        anags = defaultdict(list)\n        for w in words:\n            anags[\"\".join(sorted(w))].append(w)\n        anas = (find_deranged(a) for a in anags.itervalues() if len(a)>1)\n        pairs = filter(None, anas)\n        if pairs:\n            print \"  %s, %s\" % (pairs[0][0])\n            break\n\nmain()<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>Longest deranged anagrams:\n  excitation, intoxicate<\/pre>\n\n==[[:Category:R|R]][[Category:R]]==\n<lang R>puzzlers.dict <- readLines(\"http:\/\/www.puzzlers.org\/pub\/wordlists\/unixdict.txt\")\n\nlongest.deranged.anagram <- function(dict=puzzlers.dict) {\n  anagram.groups <- function(word.group) {\n    sorted <- sapply(lapply(strsplit(word.group,\"\"),sort),paste, collapse=\"\")\n    grouped <- tapply(word.group, sorted, force, simplify=FALSE)\n    grouped <- grouped[sapply(grouped, length) > 1]\n    grouped[order(-nchar(names(grouped)))]\n  }\n  \n  derangements <- function(anagram.group) {\n    pairs <- expand.grid(a = anagram.group, b = anagram.group,\n                         stringsAsFactors=FALSE)\n    pairs <- subset(pairs, a < b)\n    deranged <- with(pairs, mapply(function(a,b) all(a!=b),\n                                   strsplit(a,\"\"), strsplit(b,\"\")))\n    pairs[which(deranged),]\n  }\n\n  for (anagram.group in anagram.groups(dict)) {\n    if (nrow(d <- derangements(anagram.group)) > 0) {\n      return(d[1,])\n    }\n  }\n}<\/lang>\n\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n\n<lang R>> longest.deranged.anagram()\n           a          b\n3 excitation intoxicate<\/lang>\n\n==[[:Category:Ruby|Ruby]][[Category:Ruby]]==\n<lang ruby>require 'open-uri'\nanagram = nil\nopen('http:\/\/www.puzzlers.org\/pub\/wordlists\/unixdict.txt') do |f|\n  anagram = f.read.split.group_by {|s| s.each_char.sort}\nend\n\ndef deranged?(a, b)\n  a.chars.zip(b.chars).all? {|char_a, char_b| char_a != char_b}\nend\n\ndef remove_non_derangements(val)\n  list = val.dup\n  for i in 0 ... list.length\n    j = i + 1\n    while j < list.length \n      if deranged?(list[i], list[j])\n        j += 1\n      else\n        list.delete_at(j)\n      end\n    end\n  end\n  list\nend\n\nmax_word_length = anagram.each_value .\n                          select {|list| list.length > 1} .\n                          map {|list| list[0].length} .\n                          max\n\nderangements = []\n\nuntil derangements.length > 1\n  puts \"looking for deranged anagrams with word length #{max_word_length}\"\n\n  anagram.each_value .\n          select {|list| list.length > 1 and list[0].length == max_word_length} .\n          each do |list|\n            derangements = remove_non_derangements(list)\n            break if derangements.length > 1\n          end\n\n  max_word_length -= 1\nend\n\nputs \"derangement with longest word length: #{derangements}\"<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>looking for deranged anagrams with word length 12\nlooking for deranged anagrams with word length 11\nlooking for deranged anagrams with word length 10\nderangement with longest word length: [\"excitation\", \"intoxicate\"]<\/pre>\n==[[:Category:Run BASIC|Run BASIC]][[Category:Run BASIC]]==\n<lang runbasic>a$ = httpGet$(\"http:\/\/www.puzzlers.org\/pub\/wordlists\/unixdict.txt\")\ndim theWord$(30000)\ndim ssWord$(30000)\n\nc10$ = chr$(10)\ni = 1\nwhile instr(a$,c10$,i) <> 0\n  j     = instr(a$,c10$,i)\n  ln    = j - i\n  again = 1\n  sWord$ = mid$(a$,i,j-i)\n  n = n + 1\n theWord$(n) = sWord$\n\n while again = 1\n   again  = 0\n   for kk = 1 to len(sWord$) - 1\n   if mid$(sWord$,kk,1) > mid$(sWord$,kk +1,1) then\n     sWord$ = left$(sWord$,kk-1);mid$(sWord$,kk+1,1);mid$(sWord$,kk,1);mid$(sWord$,kk+2)\n     again  = 1\n   end if\n   next kk\n wend\n ssWord$(n) = sWord$\n i = j + 1\nwend\n\nfor i = 1 to n\n  if len(theWord$(i)) > maxLen then\n    for j = 1 to n\n      if ssWord$(i) = ssWord$(j) and i <> j then\n        cnt = 0\n\tfor k = 1 to len(theWord$(i))\n\t  if mid$(theWord$(i),k,1) = mid$(theWord$(j),k,1) then cnt = cnt + 1\n\tnext k\n\tif cnt = 0 then \n\t  maxLen = len(theWord$(i))\n\t  maxPtrI = i\n\t  maxPtrJ = j\n\tend if\n      end if\n    next j\n  end if\nnext i\n\nprint maxLen;\" \";theWord$(maxPtrI);\" => \";theWord$(maxPtrJ)\nend<\/lang>Output:<pre>10 excitation => intoxicate<\/pre>\n\n==[[:Category:Scala|Scala]][[Category:Scala]]==\n<lang scala>object DerangedAnagrams {\n\n  \/** Returns a map of anagrams keyed by the sorted characters *\/ \n  def groupAnagrams(words: Iterable[String]): Map[String, Set[String]] =\n    words.foldLeft (Map[String, Set[String]]()) { (map, word) =>\n      val sorted = word.sorted\n      val entry = map.getOrElse(sorted, Set.empty)\n      map + (sorted -> (entry + word))\n    }\n    \n  \/* Returns true if the pair of strings has no positions with the same\n   * characters *\/\n  def isDeranged(ss: (String, String)): Boolean = \n    ss._1 zip ss._2 forall { case (c1, c2) => c1 != c2 }\n    \n  \/* Returns pairwise combination of all Strings in the argument Iterable *\/\n  def pairWords(as: Iterable[String]): Iterable[(String, String)] =\n    if (as.size < 2) Seq() else (as.tail map (as.head -> _)) ++ pairWords(as.tail)\n    \n  \/* Returns the contents of the argument URL as an Iterable[String], each\n   * String is one line in the file *\/\n  def readLines(url: String): Iterable[String] = \n    io.Source.fromURL(url).getLines().toIterable\n    \n  val wordsURL = \"http:\/\/www.puzzlers.org\/pub\/wordlists\/unixdict.txt\"\n    \n  def main(args: Array[String]): Unit = {\n    val anagramMap = groupAnagrams(readLines(wordsURL))\n    val derangedPairs = anagramMap.values flatMap (pairWords) filter (isDeranged)\n    val (w1, w2) = derangedPairs maxBy (pair => pair._1.length)\n    println(\"Longest deranged pair: \"+w1+\" and \"+w2)\n  }   \n\n}<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>Longest deranged pair: excitation and intoxicate<\/pre>\n\n==[[:Category:Tcl|Tcl]][[Category:Tcl]]==\n<lang tcl>package require Tcl 8.5\npackage require http\n\n# Fetch the words\nset t [http::geturl \"http:\/\/www.puzzlers.org\/pub\/wordlists\/unixdict.txt\"]\nset wordlist [split [http::data $t] \\n]\nhttp::cleanup $t\n\n# Group by characters in word\nforeach word $wordlist {\n    dict lappend w [lsort [split $word \"\"]] [split $word \"\"]\n}\n\n# Deranged test\nproc deranged? {l1 l2} {\n    foreach c1 $l1 c2 $l2 {\n\tif {$c1 eq $c2} {return 0}\n    }\n    return 1\n}\n\n# Get a deranged pair from an anagram set, if one exists\nproc getDeranged {words} {\n    foreach l1 [lrange $words 0 end-1] {\n\tforeach l2 [lrange $words 1 end] {\n\t    if {[deranged? $l1 $l2]} {\n\t\treturn [list $l1 $l2 1]\n\t    }\n\t}\n    }\n    return {{} {} 0}\n}\n\n# Find the max-length deranged anagram\nset count 0\nset candidates {}\nset max 0\ndict for {k words} $w {\n    incr count [expr {[llength $words] > 1}]\n    if {[llength $k] > $max && [lassign [getDeranged $words] l1 l2]} {\n\tset max [llength $l1]\n\tlappend candidates [join $l1 \"\"],[join $l2 \"\"]\n    }\n}\n\n# Print out what we found\nputs \"[llength $wordlist] words\"\nputs \"[dict size $w] potential anagram-groups\"\nputs \"$count real anagram-groups\"\nforeach pair $candidates {\n    puts \"considered candidate pairing: $pair\"\n}\nputs \"MAXIMAL DERANGED ANAGRAM: LENGTH $max\\n\\t[lindex $candidates end]\"<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>\n25105 words\n23567 potential anagram-groups\n1303 real anagram-groups\nconsidered candidate pairing: abc,cab\nconsidered candidate pairing: abed,bade\nconsidered candidate pairing: abort,bator\nconsidered candidate pairing: afresh,shafer\nconsidered candidate pairing: alberto,latrobe\nconsidered candidate pairing: american,cinerama\nconsidered candidate pairing: ancestral,lancaster\nconsidered candidate pairing: excitation,intoxicate\nMAXIMAL DERANGED ANAGRAM: LENGTH 10\n\texcitation,intoxicate\n<\/pre>\n\n==[[:Category:TUSCRIPT|TUSCRIPT]][[Category:TUSCRIPT]]==\n<lang tuscript>$$ MODE TUSCRIPT,{}\nrequestdata = REQUEST (\"http:\/\/www.puzzlers.org\/pub\/wordlists\/unixdict.txt\")\n\nDICT anagramm CREATE 99999\n\nCOMPILE\n LOOP word=requestdata\n  -> ? : any character\n  charsInWord=STRINGS (word,\" ? \")\n  charString =ALPHA_SORT (charsInWord)\n\n  DICT anagramm LOOKUP charString,num,freq,wordalt,wlalt\n  IF (num==0) THEN\n   WL=SIZE (charString)\n   DICT anagramm APPEND\/QUIET\/COUNT charString,num,freq,word,wl;\" \"\n  ELSE\n   DICT anagramm APPEND\/QUIET\/COUNT charString,num,freq,word,\"\";\" \"\n  ENDIF\n ENDLOOP\n\nDICT anagramm UNLOAD charString,all,freq,anagrams,wl\n\nindex        =DIGIT_INDEX (wl)\nreverseIndex =REVERSE (index)\nwl           =INDEX_SORT (wl,reverseIndex)\nfreq         =INDEX_SORT (freq,reverseIndex)\nanagrams     =INDEX_SORT (anagrams,reverseIndex)\ncharString   =INDEX_SORT (charString,reverseIndex)\n\nLOOP fr=freq,a=anagrams,w=wl\n IF (fr==1) cycle\n asplit=SPLIT (a,\": :\")\n a1=SELECT (asplit,1,arest)\n a1split=STRINGS (a1,\" ? \")\n LOOP r=arest\n  rsplit=STRINGS (r,\" ? \")\n   LOOP v1=a1split,v2=rsplit\n    IF (v1==v2) EXIT,EXIT\n   ENDLOOP\n    PRINT \"Largest deranged anagram (length: \",w,\"):\"\n    PRINT a\n   STOP\n ENDLOOP\nENDLOOP\nENDCOMPILE<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>\nLargest deranged anagram (length: 10):\nexcitation intoxicate\n<\/pre>\n\n==[[:Category:Ursala|Ursala]][[Category:Ursala]]==\nThis solution assumes the file <code>unixdict.txt<\/code> is passed to the compiler as a command line parameter.\n<lang Ursala>#import std\n\nanagrams = |=tK33lrDSL2SL ~=&& ==+ ~~ -<&\n\nderanged = filter not zip; any ==\n\n#cast %sW\n\nmain = leql$^&l deranged anagrams unixdict_dot_txt<\/lang>\nThe <code>anagrams<\/code> function is a little slow as defined above, but can be sped up by at least two orders of magnitude by grouping the words into classes of equal length, and sorting each word once in advance instead of each time a comparison is made as shown below.\n<lang Ursala>anagrams = @NSiXSlK2rSS *= ^(-<&,~&)*; |=rSStFtK33lrDSL2SL ~=@br&& ==@bl<\/lang>\nWe can speed it up by about another factor of 5 by starting from the group of longest words and stopping as soon as a deranged anagram is found instead of generating all anagrams.\n<lang Ursala>#import std\n\nlongest_deranged_anagram = \n\n@NSiXSlK2rSS leql-<x&h; @NiX ~&lZrB->l ^\\~&rt @rh -+\n   ~&a^& ~&plrEkZ?ah\/~&ah ~&fatPR,\n   ^(-<&,~&)*; |=rSStFtK33lrDSL2SL ~=@br&& ==@bl+-\n\n#cast %sW\n\nmain = longest_deranged_anagram unixdict_dot_txt<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>\n('excitation','intoxicate')\n<\/pre>"}]}}},"query-continue":{"revisions":{"rvstartid":135230}}}