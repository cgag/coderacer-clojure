{"query-continue":{"search":{"gsroffset":1},"revisions":{"rvstartid":135094}},"query":{"pages":{"4938":{"pageid":4938,"ns":0,"title":"24 game","revisions":[{"*":"<div class=\"infobox\" style=\"width: 2in\">[[File:Rcode-button-task-crushed.png|64px|left|alt=Task|link=Category:Solutions by Programming Task]]'''24 game'''<br\/>\nYou are encouraged to [[Rosetta Code:Solve a Task|solve this task]] according to the task description, using any language you may know.[[Category:Programming Tasks]][[Category:Solutions by Programming Task]]<\/div>\nThe [[wp:24 Game|24 Game]] tests one's mental arithmetic. \n\nWrite a program that [[task feature::Rosetta Code:randomness|randomly]] chooses and [[task feature::Rosetta Code:user output|displays]] four digits, each from one to nine, with repetitions allowed. The program should prompt for the player to enter an equation using ''just'' those, and ''all'' of those four digits. The program should ''check'' then [[task feature::Rosetta Code:parsing|evaluate the expression]]. The goal is for the player to [[task feature::Rosetta Code:user input|enter]] an expression that evaluates to '''24'''.\n* Only multiplication, division, addition, and subtraction operators\/functions are allowed.\n* Division should use floating point or rational arithmetic, etc, to preserve remainders.\n* Brackets are allowed, if using an infix expression evaluator.\n* Forming multiple digit numbers from the supplied digits is ''disallowed''. (So an answer of 12+12 when given 1, 2, 2, and 1 is wrong).\n* The order of the digits when given does not have to be preserved.\n\nNote:\n* The type of expression evaluator used is not mandated. An [[wp:Reverse Polish notation|RPN]] evaluator is equally acceptable for example.\n* The task is not for the program to generate the expression, or test whether an expression is even possible.\n\nC.f: [[24 game Player]]\n\n'''Reference'''\n# [http:\/\/www.bbc.co.uk\/dna\/h2g2\/A933121 The 24 Game] on h2g2.\n\n==[[:Category:ABAP|ABAP]][[Category:ABAP]]==\nSee [[24 game\/ABAP]]\n\n==[[:Category:Ada|Ada]][[Category:Ada]]==\ngame24.adb:\n<lang Ada>with Ada.Text_IO;\nwith Ada.Numerics.Discrete_Random;\nprocedure Game_24 is\n   subtype Operation is Character;\n   type Op_Array is array (Positive range <>) of Operation;\n   type Digit is range 1 .. 9;\n   type Digit_Array is array (Positive range <>) of Digit;\n   package Digit_IO is new Ada.Text_IO.Integer_IO (Digit);\n   package Random_Digit is new Ada.Numerics.Discrete_Random (Digit);\n   Digit_Generator : Random_Digit.Generator;\n   Given_Digits : array (1 .. 4) of Digit;\nbegin\n   Ada.Text_IO.Put_Line (\"24 Game\");\n   Ada.Text_IO.Put_Line (\"Generating 4 digits...\");\n   Random_Digit.Reset (Digit_Generator);\n   for I in Given_Digits'Range loop\n      Given_Digits (I) := Random_Digit.Random (Digit_Generator);\n   end loop;\n   Ada.Text_IO.Put (\"Your Digits:\");\n   for I in Given_Digits'Range loop\n      Digit_IO.Put (Given_Digits (I));\n   end loop;\n   Ada.Text_IO.New_Line;\n   Ada.Text_IO.Put (\"Enter your Expression: \");\n   declare\n      Value : Integer;\n      Input_Operations : Op_Array (1 .. 3);\n      Input_Digits : Digit_Array (1 .. 4);\n      Unused_Digits : array (Given_Digits'Range) of Boolean :=\n        (others => True);\n   begin\n      -- get input\n      for I in 1 .. 4 loop\n         Digit_IO.Get (Input_Digits (I));\n         exit when I = 4;\n         Ada.Text_IO.Get (Input_Operations (I));\n      end loop;\n      -- check input\n      for I in Input_Digits'Range loop\n         declare\n            Found : Boolean := False;\n         begin\n            for J in Given_Digits'Range loop\n               if Unused_Digits (J) and then\n                 Given_Digits (J) = Input_Digits (I) then\n                  Unused_Digits (J) := False;\n                  Found := True;\n                  exit;\n               end if;\n            end loop;\n            if not Found then\n               Ada.Text_IO.Put_Line (\"Illegal Number used:\" &\n                                     Digit'Image (Input_Digits (I)));\n               return;\n            end if;\n         end;\n      end loop;\n      -- check value\n      Value := Integer (Input_Digits (Input_Digits'First));\n      for I in Input_Operations'Range loop\n         case Input_Operations (I) is\n            when '+' =>\n               Value := Value + Integer (Input_Digits (I + 1));\n            when '-' =>\n               Value := Value - Integer (Input_Digits (I + 1));\n            when '*' =>\n               Value := Value * Integer (Input_Digits (I + 1));\n            when '\/' =>\n               Value := Value \/ Integer (Input_Digits (I + 1));\n            when others =>\n               Ada.Text_IO.Put_Line (\"Illegal Op used:\" &\n                                     Input_Operations (I));\n               return;\n         end case;\n      end loop;\n      if Value \/= 24 then\n         Ada.Text_IO.Put_Line (\"Value\" & Integer'Image (Value) &\n                               \" is not 24!\");\n      else\n         Ada.Text_IO.Put_Line (\"You won!\");\n      end if;\n   end;\nend Game_24;<\/lang>\n\nOutput:\n<pre>24 Game\nGenerating 4 digits...\nYour Digits: 4 9 5 5\nEnter your Expression: 4*5+9-5\nYou won!<\/pre>\n<pre>24 Game\nGenerating 4 digits...\nYour Digits: 4 1 9 7\nEnter your Expression: 4*9-7+1\nValue 30 is not 24!<\/pre>\n\n==[[:Category:Argile|Argile]][[Category:Argile]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Argile]] version 1.0.0[[SMW::on]]<\/div>\n<lang Argile>use std, array, list\n\ndo\n  generate random digits\n  show random digits\n  let result = parse expression (get input line)\n  if result != ERROR\n    if some digits are unused\n      print \"Wrong ! (you didn't use all digits)\" ; failure++\n    else if result == 24.0\n      print \"Correct !\" ; success++\n    else\n      print \"Wrong ! (you got \"result\")\" ; failure++\n while play again ?\nprint \"success:\"success\" failure:\"failure\" total:\"(success+failure) as int\n\nlet success = 0, failure = 0.\n\n.: generate random digits :.\n   our nat seed = 0xc6f31 (: default seed when \/dev\/urandom doesn't exist :)\n   let urandom = fopen \"\/dev\/urandom\" \"r\"\n   if  urandom isn't nil\n     fread &seed size of seed 1 urandom\n     fclose urandom\n   Cfunc srandom seed\n   seed = (Cfunc random) as nat\n   for each (val int d) from 0 to 3\n     digits[d] = '1' + (seed % 9)\n     seed \/= 9\n\nlet digits be an array of 4 byte\n\n.: show random digits :.\n   print \"Enter an expression that equates to 24 using only all these digits:\"\n   printf \"%c , %c , %c , %c\\n\"(digits[0])(digits[1])(digits[2])(digits[3])\n   printf \"24 = \"\n\n.: some digits are unused :. -> bool\n   for each (val int d) from 0 to 3\n     return true if digits[d] != '\\0'\n   false\n\n.: get input line :. -> text\n   our array of 64 byte line\n   Cfunc fgets (line) (size of line) (stdin)\n   let int i\n   for (i = 0) (line[i] != 0) (i++)\n     line[i] = '\\0' if (line[i] == '\\n')\n   line as text\n\n.: play again ? :. -> bool\n   while true\n     printf \"Play again ? (y\/n) \" ; Cfunc fflush stdout\n     let answer = get input line\n     switch answer[0]\n       case 'n' {return false}\n       case 'y' {return true }\n       default  {continue    }\n   false\n\n=: ERROR := -> real {-32202.0}\n\n.: parse expression <text expr> :. -> real\n   let x = 0.0, x_is_set = false, op = ' '.\n   let stack be a list of State ; class State {byte op; real x}\n   for (stack = nil) (*expr != 0) (expr++)\n     switch *expr\n       case '+' ; case '-' ; case '*' ; case '\/'\n         error \"bad syntax\" if not x_is_set\n\t op = *expr\n       case '1' ; case '2' ; case '3' ; case '4' ; case '5'\n       case '6' ; case '7' ; case '8' ; case '9'\n\t error \"missing operator\" if (x_is_set and op == ' ')\n\t error \"unavailable digit\" unless consume digit expr[0]\n\t do operation with (expr[0] - '0') as real\n       case (Cgen \"'('\")\n\t error \"missing operator\" if (op == ' ' but x_is_set)\n\t (new list (new State) (code of del State())) << stack\n\t op = ' ' ; x_is_set = false (: start fresh state :)\n       case (Cgen \"')'\")\n         error \"mismatched parenthesis\" if stack is nil\n\t error \"wrong syntax\" if not x_is_set\n\t let y = x\n\t x = stack.data.x ; op = stack.data.op\n\t delete pop stack\n\t do operation with y\n       default {error \"disallowed character\"}\n\n       .:new State          :. -> State {let s=new(State); s.x=x; s.op=op; s}\n       .:del State <State s>:.          {               free s              }\n       .:do operation with <real y>:.\n  \t switch op\n\t   case '+' {x += y}\n\t   case '-' {x -= y}\n\t   case '*' {x *= y}\n\t   case '\/' {x \/= y}\n\t   default  {x  = y; x_is_set = true}\n         op = ' '\n   =:error<text msg>:= ->real {eprint \"Error: \"msg\" at [\"expr\"]\";return ERROR}\n   .:consume digit <byte b>:. -> bool\n     for each (val int d) from 0 to 3\n       if digits[d] == b\n         digits[d] = '\\0'\n       \t return true\n     false\n\n   if stack isn't nil\n     delete all stack\n     error \"unclosed parenthesis\"\n   return x\n<\/lang>\ncompile with:\narc 24_game.arg -o 24_game.c && gcc 24_game.c -o 24_game \/usr\/lib\/libargrt.a\n\n==[[:Category:AutoHotkey|AutoHotkey]][[Category:AutoHotkey]]==\n<lang autohotkey>AutoExecute: \n    Title := \"24 Game\" \n    Gui, -MinimizeBox \n    Gui, Add, Text, w230 vPuzzle \n    Gui, Add, Edit, wp vAnswer \n    Gui, Add, Button, w70, &Generate \n    Gui, Add, Button, x+10 wp Default, &Submit \n    Gui, Add, Button, x+10 wp, E&xit \n\n\nButtonGenerate: ; new set of numbers \n    Loop, 4 \n        Random, r%A_Index%, 1, 9 \n    Puzzle = %r1%, %r2%, %r3%, and %r4% \n    GuiControl,, Puzzle, The numbers are:  %Puzzle%  - Good luck! \n    GuiControl,, Answer ; empty the edit box \n    ControlFocus, Edit1 \n    Gui, -Disabled \n    Gui, Show,, %Title% \nReturn ; end of auto execute section \n\n\nButtonSubmit: ; check solution \n    Gui, Submit, NoHide \n    Gui, +Disabled \n\n    ; check numbers used \n    RegExMatch(Answer, \"(\\d)\\D+(\\d)\\D+(\\d)\\D+(\\d)\", $) \n    ListPuzzle := r1 \",\" r2 \",\" r3 \",\" r4 \n    ListAnswer := $1 \",\" $2 \",\" $3 \",\" $4 \n    Sort, ListPuzzle, D, \n    Sort, ListAnswer, D, \n    If Not ListPuzzle = ListAnswer { \n        MsgBox, 48, Error - %Title%, Numbers used!`n%Answer% \n        Goto, TryAgain \n    } \n\n    ; check operators used \n    StringReplace, $, $, +,, All \n    StringReplace, $, $, -,, All \n    StringReplace, $, $, *,, All \n    StringReplace, $, $, \/,, All \n    StringReplace, $, $, (,, All \n    StringReplace, $, $, ),, All \n    Loop, 9 \n        StringReplace, $, $, %A_Index%,, All \n    If StrLen($) > 0 \n    Or InStr(Answer, \"**\") \n    Or InStr(Answer, \"\/\/\") \n    Or InStr(Answer, \"++\") \n    Or InStr(Answer, \"--\") { \n        MsgBox, 48, Error - %Title%, Operators used!`n%Answer% \n        Goto, TryAgain \n    } \n\n    ; check result \n    Result := Eval(Answer) \n    If Not Result = 24 { \n        MsgBox, 48, Error - %Title%, Result incorrect!`n%Result% \n        Goto, TryAgain \n    } \n\n    ; if we are sill here \n    MsgBox, 4, %Title%, Correct solution! Play again? \n    IfMsgBox, Yes \n        Gosub, ButtonGenerate \n    Else \n        ExitApp \nReturn \n\n\nTryAgain: ; alternative ending of routine ButtonSubmit \n    ControlFocus, Edit1 \n    Gui, -Disabled \n    Gui, Show \nReturn \n\n\nGuiClose: \nGuiEscape: \nButtonExit: \n    ExitApp \nReturn \n\n\n;--------------------------------------------------------------------------- \nEval(Expr) { ; evaluate expression using separate AHK process \n;--------------------------------------------------------------------------- \n    ; credit for this function goes to AutoHotkey forum member Laszlo \n    ; http:\/\/www.autohotkey.com\/forum\/topic9578.html \n    ;----------------------------------------------------------------------- \n    static File := \"24$Temp.ahk\" \n\n    ; delete old temporary file, and write new \n    FileDelete, %File% \n    FileContent := \"#NoTrayIcon`r`n\" \n                .  \"FileDelete, \" File \"`r`n\" \n                .  \"FileAppend, `% \" Expr \", \" File \"`r`n\" \n    FileAppend, %FileContent%, %File% \n\n    ; run AHK to execute temp script, evaluate expression \n    RunWait, %A_AhkPath% %File% \n\n    ; get result \n    FileRead, Result, %File% \n    FileDelete, %File% \n    Return, Result \n}<\/lang>\n\n==[[:Category:BBC BASIC|BBC BASIC]][[Category:BBC BASIC]]==\n<lang bbcbasic>      REM Choose four random digits (1-9) with repetitions allowed:\n      DIM digits%(4), check%(4)\n      FOR choice% = 1 TO 4\n        digits%(choice%) = RND(9)\n      NEXT choice%\n      \n      REM Prompt the player:\n      PRINT \"Enter an equation (using all of, and only, the single digits \";\n      FOR index% = 1 TO 4\n        PRINT ; digits%(index%) ;\n        IF index%<>4 PRINT \" \" ;\n      NEXT\n      PRINT \")\"\n      PRINT \"which evaluates to exactly 24.  Only multiplication (*), division (\/),\"\n      PRINT \"addition (+) & subtraction (-) operations and parentheses are allowed:\"\n      INPUT \"24 = \" equation$\n      \n      REPEAT\n        \n        REM Check that the correct digits are used:\n        check%() = 0\n        FOR char% = 1 TO LEN(equation$)\n          digit% = INSTR(\"0123456789\", MID$(equation$, char%, 1)) - 1\n          IF digit% >= 0 THEN\n            FOR index% = 1 TO 4\n              IF digit% = digits%(index%) THEN\n                IF NOT check%(index%) check%(index%) = TRUE : EXIT FOR\n              ENDIF\n            NEXT index%\n            IF index% > 4 THEN\n              PRINT \"Sorry, you used the illegal digit \"; digit%\n              EXIT REPEAT\n            ENDIF\n          ENDIF\n        NEXT char%\n        \n        FOR index% = 1 TO 4\n          IF NOT check%(index%) THEN\n            PRINT \"Sorry, you failed to use the digit \" ; digits%(index%)\n            EXIT REPEAT\n          ENDIF\n        NEXT index%\n        \n        REM Check that no pairs of digits are used:\n        FOR pair% = 11 TO 99\n          IF INSTR(equation$, STR$(pair%)) THEN\n            PRINT \"Sorry, you may not use a pair of digits \"; pair%\n            EXIT REPEAT\n          ENDIF\n        NEXT pair%\n        \n        REM Check whether the equation evaluates to 24:\n        ON ERROR LOCAL PRINT \"Sorry, there was an error in the equation\" : EXIT REPEAT\n        result = EVAL(equation$)\n        RESTORE ERROR\n        IF result = 24 THEN\n          PRINT \"Congratulations, you succeeded in the task!\"\n        ELSE\n          PRINT \"Sorry, your equation evaluated to \" ; result \" rather than 24!\"\n        ENDIF\n        \n      UNTIL TRUE\n      \n      INPUT '\"Play again\", answer$\n      IF LEFT$(answer$,1) = \"y\" OR LEFT$(answer$,1) = \"Y\" THEN CLS : RUN\n      QUIT<\/lang>\n\n==[[:Category:Bracmat|Bracmat]][[Category:Bracmat]]==\n\n<lang Bracmat>  ( 24-game\n  =     m-w m-z 4numbers answer expr numbers\n      , seed get-random convertBinaryMinusToUnary\n      , convertDivisionToMultiplication isExpresssion reciprocal\n    .   (seed=.!arg:(~0:~\/#?m-w.~0:~\/#?m-z))\n      & seed$!arg\n      & ( get-random\n        =   \n          .   36969*mod$(!m-z.65536)+div$(!m-z.65536):?m-z\n            & 18000*mod$(!m-w.65536)+div$(!m-w.65536):?m-w\n            & mod$(!m-z*65536+!m-w.9)+1\n        )\n      & ( convertBinaryMinusToUnary\n        =   a z\n          .     @(!arg:%?a \"-\" ?z)\n              & str$(!a \"+-1*\" convertBinaryMinusToUnary$!z)\n            | !arg\n        )\n      & (reciprocal=.!arg^-1)\n      & ( convertDivisionToMultiplication\n        =   a z\n          .     @(!arg:?a \"\/\" ?z)\n              & str$(!a \"*reciprocal$\" convertDivisionToMultiplication$!z)\n            | !arg\n        )\n      & ( isExpresssion\n        =   A Z expr\n          .   @( !arg\n               :   ?A\n                   (\"+\"|\"-\"|\"*\"|\"\/\")\n                   ( ?Z\n                   & isExpresssion$!A\n                   & isExpresssion$!Z\n                   )\n               )\n            |   !numbers:?A !arg ?Z\n              & !A !Z:?numbers\n            |   ( @(!arg:\"(\" ?expr \")\")\n                | @(!arg:(\" \"|\\t) ?expr)\n                | @(!arg:?expr (\" \"|\\t))\n                )\n              & isExpresssion$!expr\n        )\n      &   out\n        $ \"Enter an expression that evaluates to 24 by combining the following numbers.\"\n      & out$\"You may only use the operators + - * \/\"\n      & out$\"Parentheses and spaces are allowed.\"\n      &   whl\n        ' (   get-random$() get-random$() get-random$() get-random$\n            : ?4numbers\n          & out$!4numbers\n          &   whl\n            ' ( get'(,STR):?expr:~\n              & !4numbers:?numbers\n              & ~(isExpresssion$!expr&!numbers:)\n              &   out\n                $ ( str\n                  $ ( \"[\"\n                      !expr\n                      \"] is not a valid expression. Try another expression.\"\n                    )\n                  )\n              )\n          & !expr:~\n          & convertBinaryMinusToUnary$!expr:?expr\n          & convertDivisionToMultiplication$!expr:?expr\n          & get$(!expr,MEM):?answer\n          & out$(str$(!expr \" = \" !answer))\n          &   !answer\n            : ( 24&out$Right!\n              | #&out$Wrong!\n              )\n          & out$\"Try another one:\"\n          )\n      & out$bye\n  )\n& 24-game$(13.14)\n& ;<\/lang>\n<pre>Enter an expression that evaluates to 24 by combining the following numbers.\nYou may only use the operators + - * \/\nParentheses and spaces are allowed.\n4 2 2 7\n4*7 - 2-2\n4*7 +-1* 2+-1*2 = 24\nRight!\nTry another one:\n4 7 9 8\n((4) *(8 - (9- 7))\n[((4) *(8 - (9- 7))] is not a valid expression. Try another expression.\n((4) *(8 - (9- 7)))\n((4) *(8 +-1* (9+-1* 7))) = 24\nRight!\nTry another one:\n9 5 8 5\n5 * 5 - (9 - 8)\n5 * 5 +-1* (9 +-1* 8) = 24\nRight!\nTry another one:\n5 9 7 8\n5*8 - 9 - 7\n5*8 +-1* 9 +-1* 7 = 24\nRight!\nTry another one:\n7 8 6 2\n8 * ((7 - 6) + 2)\n8 * ((7 +-1* 6) + 2) = 24\nRight!\nTry another one:\n8 6 8 1\n8 * (1 + 8 - 6)\n8 * (1 + 8 +-1* 6) = 24\nRight!\nTry another one:\n8 2 2 4\n8 * (2 + 4)\/2\n8 * (2 + 4)*reciprocal$2 = 24\nRight!\nTry another one:\n8 4 6 7\n\nbye<\/pre>\n\n==[[:Category:C|C]][[Category:C]]==\nSimple recursive descent parser.  It doesn't have a real lexer, because all tokens are single character (digits, operators and parens).  Code is a little too long.\n<lang C>#include <stdio.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <ucontext.h>\n\nucontext_t ctx;\nchar *msg;\n\nenum { OP_NONE = 0, OP_NUM, OP_ADD, OP_SUB, OP_MUL, OP_DIV };\n\ntypedef struct expr_t *expr, expr_t;\nstruct expr_t {\n\tint op, val, used;\n\texpr left, right;\n};\n\n#define N_DIGITS 4\nexpr_t digits[N_DIGITS];\n\nvoid gen_digits()\n{\n\tint i;\n\tfor (i = 0; i < N_DIGITS; i++)\n\t\tdigits[i].val = 1 + rand() % 9;\n}\n\n#define MAX_INPUT 64\nchar str[MAX_INPUT];\nint pos;\n\n#define POOL_SIZE 8\nexpr_t pool[POOL_SIZE];\nint pool_ptr;\n\nvoid reset()\n{\n\tint i;\n\tmsg = 0;\n\tpool_ptr = pos = 0;\n\tfor (i = 0; i < POOL_SIZE; i++) {\n\t\tpool[i].op = OP_NONE;\n\t\tpool[i].left = pool[i].right = 0;\n\t}\n\tfor (i = 0; i < N_DIGITS; i++)\n\t\tdigits[i].used = 0;\n}\n\n\/* longish jumpish back to input cycle *\/\nvoid bail(char *s)\n{\n\tmsg = s;\n\tsetcontext(&ctx);\n}\n\nexpr new_expr()\n{\n\tif (pool_ptr < POOL_SIZE)\n\t\treturn pool + pool_ptr++;\n\treturn 0;\n}\n\n\/* check next input char *\/\nint next_tok()\n{\n\twhile (isspace(str[pos])) pos++;\n\treturn str[pos];\n}\n\n\/* move input pointer forward *\/\nint take()\n{\n\tif (str[pos] != '\\0') return ++pos;\n\treturn 0;\n}\n\n\/* BNF(ish)\nexpr = term { (\"+\")|(\"-\") term }\nterm = fact { (\"*\")|(\"\/\") expr }\nfact =\tnumber\n\t| '(' expr ')'\n*\/\n\nexpr get_fact();\nexpr get_term();\nexpr get_expr();\n\nexpr get_expr()\n{\n\tint c;\n\texpr l, r, ret;\n\tif (!(ret = get_term())) bail(\"Expected term\");\n\twhile ((c = next_tok()) == '+' || c == '-') {\n\t\tif (!take()) bail(\"Unexpected end of input\");\n\t\tif (!(r = get_term())) bail(\"Expected term\");\n\n\t\tl = ret;\n\t\tret = new_expr();\n\t\tret->op = (c == '+') ? OP_ADD : OP_SUB;\n\t\tret->left = l;\n\t\tret->right = r;\n\t}\n\treturn ret;\n}\n\nexpr get_term()\n{\n\tint c;\n\texpr l, r, ret;\n\tret = get_fact();\n\twhile((c = next_tok()) == '*' || c == '\/') {\n\t\tif (!take()) bail(\"Unexpected end of input\");\n\n\t\tr = get_fact();\n\t\tl = ret;\n\t\tret = new_expr();\n\t\tret->op = (c == '*') ? OP_MUL : OP_DIV;\n\t\tret->left = l;\n\t\tret->right = r;\n\t}\n\treturn ret;\n}\n\nexpr get_digit()\n{\n\tint i, c = next_tok();\n\texpr ret;\n\tif (c >= '0' && c <= '9') {\n\t\ttake();\n\t\tret = new_expr();\n\t\tret->op = OP_NUM;\n\t\tret->val = c - '0';\n\t\tfor (i = 0; i < N_DIGITS; i++)\n\t\t\tif (digits[i].val == ret->val && !digits[i].used) {\n\t\t\t\tdigits[i].used = 1;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\tbail(\"Invalid digit\");\n\t}\n\treturn 0;\n}\n\nexpr get_fact()\n{\n\tint c;\n\texpr l = get_digit();\n\tif (l) return l;\n\tif ((c = next_tok()) == '(') {\n\t\ttake();\n\t\tl = get_expr();\n\t\tif (next_tok() != ')') bail(\"Unbalanced parens\");\n\t\ttake();\n\t\treturn l;\n\t}\n\treturn 0;\n}\n\nexpr parse()\n{\n\tint i;\n\texpr ret = get_expr();\n\tif (next_tok() != '\\0')\n\t\tbail(\"Trailing garbage\");\n\tfor (i = 0; i < N_DIGITS; i++)\n\t\tif (!digits[i].used)\n\t\t\tbail(\"Not all digits are used\");\n\treturn ret;\n}\n\ntypedef struct frac_t frac_t, *frac;\nstruct frac_t { int denom, num; };\n\nint gcd(int m, int n)\n{\n\tint t;\n\twhile (m) {\n\t\tt = m; m = n % m; n = t;\n\t}\n\treturn n;\n}\n\n\/* evaluate expression tree.  result in fraction form *\/\nvoid eval_tree(expr e, frac res)\n{\n\tfrac_t l, r;\n\tint t;\n\tif (e->op == OP_NUM) {\n\t\tres->num = e->val;\n\t\tres->denom = 1;\n\t\treturn;\n\t}\n\n\teval_tree(e->left, &l);\n\teval_tree(e->right, &r);\n\n\tswitch(e->op) {\n\tcase OP_ADD:\n\t\tres->num = l.num * r.denom + l.denom * r.num;\n\t\tres->denom = l.denom * r.denom;\n\t\tbreak;\n\tcase OP_SUB:\n\t\tres->num = l.num * r.denom - l.denom * r.num;\n\t\tres->denom = l.denom * r.denom;\n\t\tbreak;\n\tcase OP_MUL:\n\t\tres->num = l.num * r.num;\n\t\tres->denom = l.denom * r.denom;\n\t\tbreak;\n\tcase OP_DIV:\n\t\tres->num = l.num * r.denom;\n\t\tres->denom = l.denom * r.num;\n\t\tbreak;\n\t}\n\tif ((t = gcd(res->denom, res->num))) {\n\t\tres->denom \/= t;\n\t\tres->num \/= t;\n\t}\n}\n\nvoid get_input()\n{\n\tint i;\nreinput:\n\treset();\n\tprintf(\"\\nAvailable digits are:\");\n\tfor (i = 0; i < N_DIGITS; i++) \n\t\tprintf(\" %d\", digits[i].val);\n\tprintf(\". Type an expression and I'll check it for you, or make new numbers.\\n\"\n\t\t\"Your choice? [Expr\/n\/q] \");\n\n\twhile (1) {\n\t\tfor (i = 0; i < MAX_INPUT; i++) str[i] = '\\n';\n\t\tfgets(str, MAX_INPUT, stdin);\n\t\tif (*str == '\\0') goto reinput;\n\t\tif (str[MAX_INPUT - 1] != '\\n')\n\t\t\tbail(\"string too long\");\n\n\t\tfor (i = 0; i < MAX_INPUT; i++)\n\t\t\tif (str[i] == '\\n') str[i] = '\\0';\n\t\tif (str[0] == 'q') {\n\t\t\tprintf(\"Bye\\n\");\n\t\t\texit(0);\n\t\t}\n\t\tif (str[0] == 'n') {\n\t\t\tgen_digits();\n\t\t\tgoto reinput;\n\t\t}\n\t\treturn;\n\t}\n}\n\nint main()\n{\n\tfrac_t f;\n\tsrand(time(0));\n\n\tgen_digits();\n\twhile(1) {\n\t\tget_input();\n\t\tgetcontext(&ctx); \/* if parse error, jump back here with err msg set *\/\n\t\tif (msg) {\n\t\t\t\/* after error jump; announce, reset, redo *\/\n\t\t\tprintf(\"%s at '%.*s'\\n\", msg, pos, str);\n\t\t\tcontinue;\n\t\t}\n\n\t\teval_tree(parse(), &f);\n\n\t\tif (f.denom == 0) bail(\"Divide by zero\");\n\t\tif (f.denom == 1 && f.num == 24)\n\t\t\tprintf(\"You got 24.  Very good.\\n\");\n\t\telse {\n\t\t\tif (f.denom == 1)\n\t\t\t\tprintf(\"Eval to: %d, \", f.num);\n\t\t\telse\n\t\t\t\tprintf(\"Eval to: %d\/%d, \", f.num, f.denom);\n\t\t\tprintf(\"no good.  Try again.\\n\");\n\t\t}\n\t}\n\treturn 0;\n}<\/lang>Output<pre>Available digits are: 5 2 3 9. Type an expression and I'll check it for you, or make new numbers.\nYour choice? [Expr\/n\/q] 5*2*3\/9\nEval to: 10\/3, no good.  Try again.\n\nAvailable digits are: 5 2 3 9. Type an expression and I'll check it for you, or make new numbers.\nYour choice? [Expr\/n\/q] (5*(2+3)-9\nUnbalanced parens at '(5*(2+3)-9'\n\nAvailable digits are: 5 2 3 9. Type an expression and I'll check it for you, or make new numbers.\nYour choice? [Expr\/n\/q] 3*9-(5-2)\nYou got 24.  Very good.\n\nAvailable digits are: 5 2 3 9. Type an expression and I'll check it for you, or make new numbers.\nYour choice? [Expr\/n\/q] n\n\nAvailable digits are: 4 4 4 7. Type an expression and I'll check it for you, or make new numbers.\nYour choice? [Expr\/n\/q] q\nBye<\/pre>\nSee [[24 game\/C]]\n\n==[[:Category:C++|C++]][[Category:C++]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[C++11]][[SMW::on]]<\/div>\n\nThis uses the C++11 standard to simplify several parts of the code. Input is given in RPN format.\n\n<lang cpp>#include <random>\n#include <iostream>\n#include <stack>\n#include <set>\n#include <string>\n#include <functional>\nusing namespace std;\n\nclass RPNParse\n{\npublic:\n  stack<double> stk;\n  multiset<int> digits;\n\n  void op(function<double(double,double)> f)\n  {\n    if(stk.size() < 2)\n      throw \"Improperly written expression\";\n    int b = stk.top(); stk.pop();\n    int a = stk.top(); stk.pop();\n    stk.push(f(a, b));\n  }\n\n  void parse(char c)\n  {\n    if(c >= '0' && c <= '9')\n    {\n      stk.push(c - '0');\n      digits.insert(c - '0');\n    }\n    else if(c == '+')\n      op([](double a, double b) {return a+b;});\n    else if(c == '-')\n      op([](double a, double b) {return a-b;});\n    else if(c == '*')\n      op([](double a, double b) {return a*b;});\n    else if(c == '\/')\n      op([](double a, double b) {return a\/b;});\n  }\n\n  void parse(string s)\n  {\n    for(int i = 0; i < s.size(); ++i)\n      parse(s[i]);\n  }\n\n  double getResult()\n  {\n    if(stk.size() != 1)\n      throw \"Improperly written expression\";\n    return stk.top();\n  }\n};\n\nint main()\n{\n  random_device seed;\n  mt19937 engine(seed());\n  uniform_int_distribution<> distribution(1, 9);\n  auto rnd = bind(distribution, engine);\n\n  multiset<int> digits;\n  cout << \"Make 24 with the digits: \";\n  for(int i = 0; i < 4; ++i)\n  {\n    int n = rnd();\n    cout << \" \" << n;\n    digits.insert(n);\n  }\n  cout << endl;\n\n  RPNParse parser;\n\n  try\n  {\n    string input;\n    getline(cin, input);\n    parser.parse(input);\n\n    if(digits != parser.digits)\n      cout << \"Error: Not using the given digits\" << endl;\n    else\n    {\n      double r = parser.getResult();\n      cout << \"Result: \" << r << endl;\n\n      if(r > 23.999 && r < 24.001)\n        cout << \"Good job!\" << endl;\n      else\n        cout << \"Try again.\" << endl;\n    }\n  }\n  catch(char* e)\n  {\n    cout << \"Error: \" << e << endl;\n  }\n  return 0;\n}<\/lang>\n\nSample output:\n<pre>\nMake 24 with the digits:  1 4 9 9\n9 9 + 4 * 1 +\nResult: 73\nTry again.\n\nMake 24 with the digits:  3 9 9 2\n9 9 + 3 2 * +\nResult: 24\nGood job!\n<\/pre>\n\n==<span id=\"C sharp\">[[:Category:C sharp|C#]]<\/span>[[Category:C sharp]]==\nSee [[24 game\/CSharp]]\n\n==[[:Category:Clojure|Clojure]][[Category:Clojure]]==\n<lang Clojure>\n(ns rosettacode.24game)\n\n(defn gen-new-game-nums [amount] (repeatedly amount #(inc ( rand-int 9))))\n\n(defn orderless-seq-eq? [seq1 seq2] (apply = (map frequencies (list seq1 seq2))))\n                                       \n(defn valid-input?\n  \"checks whether the expression is somewhat valid prefix notation\n (+ 1 2 3 4) (+ 3 (+ 4 5) 6)\n this is done by making sure the only contents of the list are numbers operators and brackets\n flatten gets rid of the brackets, so we just need to test for operators and integers after that\"\n  [user-input]\n  (if (re-find #\"^\\(([\\d-+\/*] )+\\d?\\)$\" (pr-str (flatten user-input)))\n    true\n    false))\n\n(defn game-numbers-and-user-input-same?\n  \"input form: (+ 1 2 (+ 3 4))\ntests to see if the numbers the user entered are the same as the ones given to them by the game\"\n  [game-nums user-input]\n  (orderless-seq-eq? game-nums (filter integer? (flatten  user-input))))\n\n(defn win [] (println \"you won the game!\\n\"))\n(defn lose [] (println \"you guessed wrong, or your input was not in prefix notation. eg: '(+ 1 2 3 4)'\\n\"))\n(defn game-start [goal game-numbers] (do\n                                       (println \"Your numbers are \" game-numbers)\n                                       (println \"Your goal is \" goal)\n                                       (println \"Use the numbers and +*-\/ to reach your goal\\n\")\n                                       (println \"'q' to Quit\\n\")))\n\n(defn play-game\n  \"typing in 'q' quits.\n   to play use (play-game) (play-game 24) or (play-game 24 '(1 2 3 4)\"\n  ([] (play-game 24))\n  ([goal] (play-game goal (gen-new-game-nums 4)))\n  ([goal game-numbers]\n     (game-start goal game-numbers)\n     (let [input  (read-line)\n           input-as-code (read-string input)]\n       (if (and (valid-input? input-as-code)\n                (game-numbers-and-user-input-same? game-numbers input-as-code)\n                (try (= goal (eval input-as-code)) (catch Exception e (do (lose) (play-game goal game-numbers)))))\n         (win)\n         (when (not (= input \"q\"))\n           (do (lose) (recur goal game-numbers)))))))\n<\/lang>\n\n==[[:Category:CoffeeScript|CoffeeScript]][[Category:CoffeeScript]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[node.js]][[SMW::on]]<\/div>\n<lang coffeescript>tty = require 'tty'\ntty.setRawMode true\n\nbuffer  = \"\"\nnumbers = []\n\nfor n in [0...4]\n    numbers.push Math.max 1, Math.floor(Math.random() * 9)\n    \nconsole.log \"You can use the numbers: #{numbers.join ' '}\"\n\nprocess.stdin.on 'keypress', (char, key) ->\n\n    # accept operator\n    if char and isNaN(char) and \/[()*\\\/+-]\/.test(char) and buffer.substr(-1) isnt char\n        buffer += char\n        process.stdout.write char\n    # accept number\n    else if !isNaN(+char) and (buffer == '' or isNaN(buffer.substr -1))\n        buffer += char\n        process.stdout.write char\n    \n    # check then evaluate expression\n    if key?.name is 'enter'\n        result = calculate()\n        process.stdout.write '\\n'\n        if result and result is 24\n            console.log \" = 24! congratulations.\"\n        else\n            console.log \"#{result}. nope.\"\n        process.exit 0\n    \n    # quit\n    if key?.name is 'escape' or (key?.name == 'c' and key.ctrl)\n        process.exit 0\n\ncalculate = () ->\n\n    if \/[^\\d\\s()+*\\\/-]\/.test buffer\n        console.log \"invalid characters\"\n        process.exit 1\n    \n    used = buffer.match(\/\\d\/g)\n    if used?.length != 4 or used.sort().join() != numbers.sort().join()\n        console.log \"you must use the 4 numbers provided\"\n        process.exit 1\n    \n    res = try eval buffer catch e\n    return res or 'invalid expression'\n\n    \n# begin taking input\nprocess.stdin.resume()\n<\/lang>\n\n==[[:Category:Common Lisp|Common Lisp]][[Category:Common Lisp]]==\n<lang lisp>(define-condition choose-digits () ())\n(define-condition bad-equation (error) ())\n\n(defun 24-game ()\n  (let (chosen-digits)\n    (labels ((prompt ()\n               (format t \"Chosen digits: ~{~D~^, ~}~%~\n                          Enter expression (or `bye' to quit, `!' to choose new digits): \"\n                       chosen-digits)\n               (read))\n             (lose () (error 'bad-equation))\n             (choose () (setf chosen-digits (loop repeat 4 collecting (random 10))))\n             (check (e)\n               (typecase e\n                 ((eql bye) (return-from 24-game))\n                 ((eql !) (signal 'choose-digits))\n                 (atom (lose))\n                 (cons (check-sub (car e) (check-sub (cdr e) chosen-digits)) e)))\n             (check-sub (sub allowed-digits)\n               (typecase sub\n                 ((member nil + - * \/) allowed-digits)\n                 (integer\n                  (if (member sub allowed-digits)\n                      (remove sub allowed-digits :count 1)\n                      (lose)))\n                 (cons (check-sub (car sub) (check-sub (cdr sub) allowed-digits)))\n                 (t (lose))))\n             (win ()\n               (format t \"You win.~%\")\n               (return-from 24-game)))\n      (choose)\n      (loop\n       (handler-case\n           (if (= 24 (eval (check (prompt)))) (win) (lose))\n         (error () (format t \"Bad equation, try again.~%\"))\n         (choose-digits () (choose)))))))<\/lang>\n\n'''Verbose Implementation'''\n\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[clisp]] version 2.47[[SMW::on]]<\/div>\n<lang lisp>\n(defconstant +ops+ '(* \/ + -))\n\n(defun expr-numbers (e &optional acc)\n  \"Return all the numbers in argument positions in the expression.\"\n  (cond\n   ((numberp e) (cons e acc))\n   ((consp e)\n    (append (apply #'append\n                   (mapcar #'expr-numbers (cdr e)))\n            acc))))\n\n(defun expr-well-formed-p (e)\n  \"Return non-nil if the given expression is well-formed.\"\n  (cond\n   ((numberp e) t)\n   ((consp e)\n    (and (member (car e) +ops+)\n         (every #'expr-well-formed-p (cdr e))))\n   (t nil)))\n\n(defun expr-valid-p (e available-digits)\n  \"Return non-nil if the expression is well-formed and uses exactly\nthe digits specified.\"\n  (and (expr-well-formed-p e)\n       (equalp (sort (copy-seq available-digits) #'<)\n               (sort (expr-numbers e) #'<))))\n\n(defun expr-get (&optional using)\n  (emit \"Enter lisp form~@[ using the digit~P ~{~D~^ ~}~]: \"\n        (when using\n          (length using)) using)\n  (let (*read-eval*)\n    (read)))\n\n(defun digits ()\n  (sort (loop repeat 4 collect (1+ (random 9))) #'<))\n\n(defun emit (fmt &rest args)\n  (format t \"~&~?\" fmt args))\n\n(defun prompt (digits)\n  (emit \"Using only these operators:~%~%~\n           ~2T~{~A~^ ~}~%~%~\n         And exactly these numbers \\(no repetition\\):~%~%~\n           ~2T~{~D~^ ~}~%~%~\n         ~A\"\n        +ops+ digits (secondary-prompt)))\n\n(defun secondary-prompt ()\n  (fill-to 50 \"Enter a lisp form which evaluates to ~\n               the integer 24, or \\\"!\\\" to get fresh ~\n               digits, or \\\"q\\\" to abort.\"))\n\n(defun fill-to (n fmt &rest args)\n  \"Poor-man's text filling mechanism.\"\n  (loop with s = (format nil \"~?\" fmt args)\n        for c across s\n        and i from 0\n        and j = 0 then (1+ j) ; since-last-newline ctr\n\n        when (char= c #\\Newline)\n        do (setq j 0)\n\n        else when (and (not (zerop j))\n                       (zerop (mod j n)))\n        do (loop for k from i below (length s)\n                 when (char= #\\Space (schar s k))\n                 do (progn\n                      (setf (schar s k) #\\Newline\n                            j 0)\n                      (loop-finish)))\n        finally (return s)))\n\n(defun 24-game ()\n  (loop with playing-p = t\n        and initial-digits = (digits)\n\n        for attempts from 0\n        and digits = initial-digits then (digits)\n\n        while playing-p\n\n        do (loop for e = (expr-get (unless (zerop attempts)\n                                     digits))\n                 do\n                 (case e\n                   (! (loop-finish))\n                   (Q (setq playing-p nil)\n                      (loop-finish))\n                   (R (emit \"Current digits: ~S\" digits))\n                   (t\n                    (if (expr-valid-p e digits)\n                        (let ((v (eval e)))\n                          (if (eql v 24)\n                              (progn\n                                (emit \"~%~%---> A winner is you! <---~%~%\")\n                                (setq playing-p nil)\n                                (loop-finish))\n                            (emit \"Sorry, the form you entered ~\n                                   computes to ~S, not 24.~%~%\"\n                                  v)))\n                      (emit \"Sorry, the form you entered did not ~\n                             compute.~%~%\")))))\n        initially (prompt initial-digits)))<\/lang>\n\nExample Usage:\n\n<pre>CL-USER 97 > (24-game)\nUsing only these operators:\n\n  * \/ + -\n\nAnd exactly these numbers (no repetition):\n\n  3 7 7 9\n\nEnter a lisp form which evaluates to the integer 24,\nor \"!\" to get fresh digits, or \"q\" to abort.\nEnter lisp form: (eval (read-from-string \"(\/ 1 0)\"))\nSorry, the form you entered did not compute.\n\nEnter lisp form: !\nEnter lisp form using the digits 4 5 7 8: !\nEnter lisp form using the digits 1 2 4 5: (* 4 (* 5 (- 2 1)))\nSorry, the form you entered computes to 20, not 24.\n\nEnter lisp form using the digits 1 2 4 5: (* 4 (+ 5 (- 2 1)))\n\n\n---> A winner is you! <---\n\nNIL<\/pre>\n==[[:Category:D|D]][[Category:D]]==\n<lang d>import std.stdio, std.random, std.math, std.algorithm, std.range,\n       std.typetuple;\n\nvoid main() {\n    void op(char c)() {\n        if (stack.length < 2)\n            throw new Exception(\"Wrong expression.\");\n        stack[$ - 2] = mixin(\"stack[$ - 2]\" ~ c ~ \"stack[$ - 1]\");\n        stack.popBack();\n    }\n\n    const problem = iota(4).map!(_ => uniform(1, 10))().array();\n    writeln(\"Make 24 with the digits: \", problem);\n\n    double[] stack;\n    int[] digits;\n    foreach (const char c; readln())\n        switch (c) {\n            case ' ', '\\t', '\\n': break;\n            case '1': .. case '9':\n                stack ~= c - '0';\n                digits ~= c - '0';\n                break;\n            foreach (o; TypeTuple!('+', '-', '*', '\/')) {\n                case o: op!o(); break;\n            }\n            break;\n            default: throw new Exception(\"Wrong char: \" ~ c);\n        }\n\n    if (!digits.sort().equal(problem.dup.sort()))\n        throw new Exception(\"Not using the given digits.\");\n    if (stack.length != 1)\n        throw new Exception(\"Wrong expression.\");\n    writeln(\"Result: \", stack[0]);\n    writeln(abs(stack[0] - 24) < 0.001 ? \"Good job!\" : \"Try again.\");\n}<\/lang>\nExample:\n<pre>Make 24 with the digits: [1, 8, 9, 8]\n8 1 - 9 + 8 +\nResult: 24\nGood job!<\/pre>\n\n==[[:Category:Erlang|Erlang]][[Category:Erlang]]==\n<lang Erlang>-module(g24).\n-import(random, [uniform\/1, seed\/3]).\n-import(string, [strip\/3]).\n-import(regexp, [match\/2]).\n-import(lists, [member\/2]).\n-compile(export_all).\n\n\neval(S) ->\n    {ok, Scanned,_} = erl_scan:string(S),\n    {ok, Parsed} = erl_parse:parse_exprs(Scanned),\n    {value, Value, _} = erl_eval:exprs(Parsed, []),\n    {ok, Value}.\n\ngen_number() ->\n    [ uniform(X) || X <-[9,9,9,9]].\n\nmain() ->\n    io:format(\"24 Game~n\"),\n    {A1,A2,A3} = now(),\n    seed(A1, A2, A3),\n    play().\n\nplay() ->\n    io:format(\"Generating 4 digits...~n\"),\n    Digts = gen_number(),\n    io:format(\"Your digits\\t~w~n\", [Digts]),\n    read_eval(Digts).\n\nread_eval(D) ->\n    Exp = strip(io:get_line(standard_io, 'Your expression: '),\n                both, $\\n),\n    case check_expr([X||X <- Exp,X \/= 32], D, 1) of\n        {ok} ->\n            try eval(Exp ++ \".\") of\n                {ok, V} ->\n                    if\n                        V == 24 ->\n                            {right, Exp};\n                        true  ->\n                            io:format(\"~w is not 24~n\", [V]),\n                            read_eval(D)\n                    end\n            catch\n                _:_ ->\n                    io:format(\"bad expression~n\"),\n                    read_eval(D)\n            end;\n        _  ->\n            io:format(\"bad expression~n\"),\n            read_eval(D)\n    end.\ncheck_expr([H|L], D, Isop) ->\n    %% io:format(\"checking ~w in ~w~n\", [H, D]),\n    case match([H], \"[()]\")  of\n        {match, _, _}->\n            check_expr(L, D, Isop);\n        _ ->\n            case Isop =:= 1 of\n            %% now we need a digit\n                true ->\n                    case member(H - 48, D) of\n                        true ->\n                            case match([H], \"[0-9]\") of\n                                {match, _,_} ->\n                                    check_expr(L, D--[H - 48], 0);\n                                _ ->\n                                    %% io:format(\"error1 ~w~n\", [H]),\n                                    {error}\n                             end;\n                        false ->\n                            %% io:format(\"error2 ~w~n\", [H]),\n                            {error}\n                    end;\n            %% now we need a Op\n                false ->\n                    case match([H], \"[*+-\/]\") of\n                        {match, _,_} ->\n                            check_expr(L, D , 1);\n                        _ ->\n                            %% io:format(\"error3 ~w~n\", [H]),\n                         {error}\n                    end\n            end\n    end;\n\ncheck_expr([], [], _) ->\n    {ok};\ncheck_expr([], _L, _) ->\n    {error}.\n<\/lang>\n\nExample:\n<pre>2>  g24:main().\n24 Game\nGenerating 4 digits...\nYour digits     [6,8,7,4]\nYour expression: 6 + 8 + 7 + 4\n25 is not 24\nYour expression: 4*6\nbad expression\nYour expression: (6-7-4)*8\n-40 is not 24\nYour expression: (6-(7-4))*8\n{right,\"(6-(7-4))*8\"}\n3><\/pre>\n\n==[[:Category:Falcon|Falcon]][[Category:Falcon]]==\n<lang falcon>load compiler\n\nfunction genRandomNumbers( amount )\n  rtn = []\n  for i in [ 0 : amount ]: rtn += random( 1, 9 )\n  return( rtn )\nend\n\nfunction getAnswer( exp )\n  ic = ICompiler()\n  ic.compileAll(exp)\n\n  return( ic.result )\nend\n\nfunction validInput( str )\n  for i in [ 0 : str.len() ]\n    if str[i] notin ' ()[]0123456789-+\/*'\n      > 'INVALID Character = ', str[i]\n      return( false )\n    end\n  end\n\n  return( true )\nend\n\nprintl('\nThe 24 Game\n\nGiven any four digits in the range 1 to 9, which may have repetitions,\nUsing just the +, -, *, and \/ operators; and the possible use of\nbrackets, (), show how to make an answer of 24.\n\nAn answer of \"q\" will quit the game.\nAn answer of \"!\" will generate a new set of four digits.\nOtherwise you are repeatedly asked for an expression until it evaluates to 24\n\nNote: you cannot form multiple digit numbers from the supplied digits,\nso an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.\n')\n\nnum = genRandomNumbers( 4 )\n\nwhile( true )\n\n  >>  \"Here are the numbers to choose from: \"\n  map({ a => print(a, \" \") }, num)\n  >\n\n  exp = input()\n\n  switch exp\n    case \"q\", \"Q\"\n      exit()\n\n    case \"!\"\n      > 'Generating new numbers list'\n      num = genRandomNumbers( 4 )\n\n    default\n      if not validInput( exp ): continue\n\n      answer = getAnswer( exp )\n\n      if answer == 24\n        > \"By George you GOT IT! Your expression equals 24\"\n      else\n        > \"Ahh Sorry, So Sorry your answer of \", answer, \" does not equal 24.\"\n      end\n  end\nend<\/lang>\n\n\n\n==[[:Category:Fortran|Fortran]][[Category:Fortran]]==\nIndicate operator precedence by parentheses; e.g. (3+(5*6))-9. No whitespace is admissible.\nThe program uses [[Insertion_sort#Fortran|Insertion_sort in Fortran]].\n<lang Fortran>program game_24\n  implicit none\n  real               :: vector(4), reals(11), result, a, b, c, d\n  integer            :: numbers(4), ascii(11), i\n  character(len=11)  :: expression\n  character          :: syntax(11)\n  ! patterns:\n  character, parameter :: one(11)   = (\/ '(','(','1','x','1',')','x','1',')','x','1' \/)\n  character, parameter :: two(11)   = (\/ '(','1','x','(','1','x','1',')',')','x','1' \/)\n  character, parameter :: three(11) = (\/ '1','x','(','(','1','x','1',')','x','1',')' \/)\n  character, parameter :: four(11)  = (\/ '1','x','(','1','x','(','1','x','1',')',')' \/)\n  character, parameter :: five(11)  = (\/ '(','1','x','1',')','x','(','1','x','1',')' \/)\n  \n  do\n    call random_number(vector)\n    numbers = 9 * vector + 1\n    write (*,*) 'Digits: ',numbers\n    write (*,'(a)',advance='no') 'Your expression: '\n    read (*,'(a11)') expression\n\n    forall (i=1:11) syntax(i) = expression(i:i)\n    ascii = iachar(syntax)\n    where (syntax >= '0' .and. syntax <= '9')\n      syntax = '1'  ! number\n    elsewhere (syntax == '+' .or. syntax == '-' .or. syntax == '*' .or. syntax == '\/')\n      syntax = 'x'  ! op\n    elsewhere (syntax \/= '(' .and. syntax \/= ')')\n      syntax = '-'  ! error\n    end where\n\n    reals = real(ascii-48)\n    if ( all(syntax == one) ) then\n      a = reals(3); b = reals(5); c = reals(8); d = reals(11)\n      call check_numbers(a,b,c,d)\n      result = op(op(op(a,4,b),7,c),10,d)\n    else if ( all(syntax == two) ) then\n      a = reals(2); b = reals(5); c = reals(7); d = reals(11)\n      call check_numbers(a,b,c,d)\n      result = op(op(a,3,op(b,6,c)),10,d)\n    else if ( all(syntax == three) ) then\n      a = reals(1); b = reals(5); c = reals(7); d = reals(10)\n      call check_numbers(a,b,c,d)\n      result = op(a,2,op(op(b,6,c),9,d))\n    else if ( all(syntax == four) ) then\n      a = reals(1); b = reals(4); c = reals(7); d = reals(9)\n      call check_numbers(a,b,c,d)\n      result = op(a,2,op(b,5,op(c,8,d)))\n    else if ( all(syntax == five) ) then\n      a = reals(2); b = reals(4); c = reals(8); d = reals(10)\n      call check_numbers(a,b,c,d)\n      result = op(op(a,3,b),6,op(c,9,d))\n    else\n      stop 'Input string: incorrect syntax.'\n    end if\n\n    if ( abs(result-24.0) < epsilon(1.0) ) then\n      write (*,*) 'You won!'\n    else\n      write (*,*) 'Your result (',result,') is incorrect!'\n    end if\n  \n    write (*,'(a)',advance='no') 'Another one? [y\/n] '\n    read (*,'(a1)') expression\n    if ( expression(1:1) == 'n' .or. expression(1:1) == 'N' ) then\n      stop\n    end if  \n  end do\n  \ncontains\n\n  pure real function op(x,c,y)\n    integer, intent(in) :: c\n    real, intent(in) :: x,y\n    select case ( char(ascii(c)) )\n      case ('+')\n        op = x+y\n      case ('-')\n        op = x-y\n      case ('*')\n        op = x*y\n      case ('\/')\n        op = x\/y\n    end select\n  end function op\n  \n  subroutine check_numbers(a,b,c,d)\n    real, intent(in) :: a,b,c,d\n    integer          :: test(4)\n    test = (\/ nint(a),nint(b),nint(c),nint(d) \/)\n    call Insertion_Sort(numbers)\n    call Insertion_Sort(test)\n    if ( any(test \/= numbers) ) then\n      stop 'You cheat ;-) (Incorrect numbers)'\n    end if\n  end subroutine check_numbers\n  \n  pure subroutine Insertion_Sort(a)\n    integer, intent(inout) :: a(:)\n    integer                :: temp, i, j\n    do i=2,size(a)\n      j = i-1\n      temp = a(i)\n      do while ( j>=1 .and. a(j)>temp )\n        a(j+1) = a(j)\n        j = j - 1\n      end do\n      a(j+1) = temp\n    end do\n  end subroutine Insertion_Sort\n\nend program game_24\n<\/lang>\n\n==[[:Category:GAP|GAP]][[Category:GAP]]==\n<lang gap># Solution in '''RPN'''\nPlay24 := function()\n\tlocal input, digits, line, c, chars, stack, stackptr, cur, p, q, ok, a, b, run;\n\tinput := InputTextUser();\n\trun := true;\n\twhile run do\n\t\tdigits := List([1 .. 4], n -> Random(1, 9));\n\t\twhile true do\n\t\t\tDisplay(digits);\n\t\t\tline := ReadLine(input);\n\t\t\tline := Chomp(line);\n\t\t\tif line = \"end\" then\n\t\t\t\trun := false;\n\t\t\t\tbreak;\n\t\t\telif line = \"next\" then\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tok := true;\n\t\t\t\tstack := [ ];\n\t\t\t\tstackptr := 0;\n\t\t\t\tchars := \"123456789+-*\/ \";\n\t\t\t\tcur := ShallowCopy(digits);\n\t\t\t\tfor c in line do\n\t\t\t\t\tif c = ' ' then\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfi;\n\t\t\t\t\tp := Position(chars, c);\n\t\t\t\t\tif p = fail then\n\t\t\t\t\t\tok := false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tfi;\n\t\t\t\t\tif p < 10 then\n\t\t\t\t\t\tq := Position(cur, p);\n\t\t\t\t\t\tif q = fail then\n\t\t\t\t\t\t\tok := false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tfi;\n\t\t\t\t\t\tUnbind(cur[q]);\n\t\t\t\t\t\tstackptr := stackptr + 1;\n\t\t\t\t\t\tstack[stackptr] := p;\n\t\t\t\t\telse\n\t\t\t\t\t\tif stackptr < 2 then\n\t\t\t\t\t\t\tok := false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tfi;\n\t\t\t\t\t\tb := stack[stackptr];\n\t\t\t\t\t\ta := stack[stackptr - 1];\n\t\t\t\t\t\tstackptr := stackptr - 1;\n\t\t\t\t\t\tif c = '+' then\n\t\t\t\t\t\t\ta := a + b;\n\t\t\t\t\t\telif c = '-' then\n\t\t\t\t\t\t\ta := a - b;\n\t\t\t\t\t\telif c = '*' then\n\t\t\t\t\t\t\ta := a * b;\n\t\t\t\t\t\telif c = '\/' then\n\t\t\t\t\t\t\tif b = 0 then\n\t\t\t\t\t\t\t\tok := false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tfi;\n\t\t\t\t\t\t\ta := a \/ b;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tok := false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tfi;\n\t\t\t\t\t\tstack[stackptr] := a;\n\t\t\t\t\tfi;\n\t\t\t\tod;\n\t\t\t\tif ok and stackptr = 1 and Size(cur) = 0 then\n\t\t\t\t\tif stack[1] = 24 then\n\t\t\t\t\t\tPrint(\"Good !\\n\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\telse\n\t\t\t\t\t\tPrint(\"Bad value: \", stack[1], \"\\n\");\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfi;\n\t\t\t\tfi;\n\t\t\t\tPrint(\"Invalid expression\\n\");\n\t\t\tfi;\n\t\tod;\n\tod;\n\tCloseStream(input);\nend;\n\n# example session\n# type \"end\" to quit the game, \"next\" to try another list of digits\ngap> Play24();\n[ 7, 6, 8, 5 ]\n86*75-\/\nGood !\n[ 5, 9, 2, 7 ]\nend\ngap><\/lang>\n\n==[[:Category:Go|Go]][[Category:Go]]==\nRPN solution.\n<lang go>package main\n\nimport (\n    \"fmt\"\n    \"math\"\n    \"math\/rand\"\n    \"time\"\n)\n\nfunc main() {\n    rand.Seed(time.Now().Unix())\n    n := make([]rune, 4)\n    for i := range n {\n        n[i] = rune(rand.Intn(9) + '1')\n    }\n    fmt.Printf(\"Your numbers: %c\\n\", n)\n    fmt.Print(\"Enter RPN: \")\n    var expr string\n    fmt.Scan(&expr)\n    if len(expr) != 7 {\n        fmt.Println(\"invalid. expression length must be 7.\" +\n            \" (4 numbers, 3 operators, no spaces)\")\n        return\n    }\n    stack := make([]float64, 0, 4)\n    for _, r := range expr {\n        if r >= '0' && r <= '9' {\n            if len(n) == 0 {\n                fmt.Println(\"too many numbers.\")\n                return\n            }\n            i := 0\n            for n[i] != r {\n                i++\n                if i == len(n) {\n                    fmt.Println(\"wrong numbers.\")\n                    return\n                }\n            }\n            n = append(n[:i], n[i+1:]...)\n            stack = append(stack, float64(r-'0'))\n            continue\n        }\n        if len(stack) < 2 {\n            fmt.Println(\"invalid expression syntax.\")\n            return\n        }\n        switch r {\n        case '+':\n            stack[len(stack)-2] += stack[len(stack)-1]\n        case '-':\n            stack[len(stack)-2] -= stack[len(stack)-1]\n        case '*':\n            stack[len(stack)-2] *= stack[len(stack)-1]\n        case '\/':\n            stack[len(stack)-2] \/= stack[len(stack)-1]\n        default:\n            fmt.Printf(\"%c invalid.\\n\", r)\n            return\n        }\n        stack = stack[:len(stack)-1]\n    }\n    if math.Abs(stack[0]-24) > 1e-6 {\n        fmt.Println(\"incorrect.\", stack[0], \"!= 24\")\n    } else {\n        fmt.Println(\"correct.\")\n    }\n}<\/lang>\nExample game:\n<pre>\nYour numbers: [5 8 1 3]\nEnter RPN: 83-5*1-\ncorrect.\n<\/pre>\n\n==[[:Category:Groovy|Groovy]][[Category:Groovy]]==\n<div class=\"examplemeta translation\">'''Translation of''': [[24 game#Ruby|Ruby]]<\/div>\nThis solution breaks strict adherence to the rules in only one way: any line that starts with the letter \"q\" causes the game to quit.\n<lang groovy>final random = new Random()\nfinal input = new Scanner(System.in)\n\n\ndef evaluate = { expr ->\n    if (expr == 'QUIT') {\n        return 'QUIT'\n    } else {\n        try { Eval.me(expr.replaceAll(\/(\\d)\/, '$1.0')) }\n        catch (e) { 'syntax error' }\n    }\n}\n\n\ndef readGuess = { digits ->\n    while (true) {\n        print \"Enter your guess using ${digits} (q to quit): \"\n        def expr = input.nextLine()\n        \n        switch (expr) {\n            case ~\/^[qQ].*\/:\n                return 'QUIT'\n\n            case ~\/.*[^\\d\\s\\+\\*\\\/\\(\\)-].*\/:\n                def badChars = expr.replaceAll(~\/[\\d\\s\\+\\*\\\/\\(\\)-]\/, '')\n                println \"invalid characters in input: ${(badChars as List) as Set}\"\n                break\n\n            case { (it.replaceAll(~\/\\D\/, '') as List).sort() != ([]+digits).sort() }:\n                println '''you didn't use the right digits'''\n                break\n\n            case ~\/.*\\d\\d.*\/:\n                println 'no multi-digit numbers allowed'\n                break\n\n            default:\n                return expr\n        }\n    }\n}\n\n\ndef digits = (1..4).collect { (random.nextInt(9) + 1) as String }\n\nwhile (true) {\n    def guess = readGuess(digits)\n    def result = evaluate(guess)\n    \n    switch (result) {\n        case 'QUIT':\n            println 'Awwww. Maybe next time?'\n            return\n            \n        case 24:\n            println 'Yes! You got it.'\n            return\n            \n        case 'syntax error':\n            println \"A ${result} was found in ${guess}\" \n            break\n            \n        default:\n            println \"Nope: ${guess} == ${result}, not 24\"\n            println 'One more try, then?'\n    }\n}<\/lang>\n\nSample Run:\n<pre>$ groovy TwentyFour.gsh\nEnter your guess using [4, 8, 3, 6] (q to quit): 4836\nno multi-digit numbers allowed\nEnter your guess using [4, 8, 3, 6] (q to quit): 4  ++ ++ 8\/ 3-6\nA syntax error was found in 4  ++ ++ 8\/ 3-6\nEnter your guess using [4, 8, 3, 6] (q to quit): btsjsb\ninvalid characters in input: [t, s, b, j]\nEnter your guess using [4, 8, 3, 6] (q to quit): 1+3+2+2\nyou didn't use the right digits\nEnter your guess using [4, 8, 3, 6] (q to quit): q\nAwwww. Maybe next time?\n\n$ groovy TwentyFour.gsh\nEnter your guess using [6, 3, 2, 6] (q to quit): 6+6+3+2\nNope: 6+6+3+2 == 17.0, not 24\nOne more try, then?\nEnter your guess using [6, 3, 2, 6] (q to quit): (6*3 - 6) * 2\nYes! You got it.<\/pre>\n\n==[[:Category:Haskell|Haskell]][[Category:Haskell]]==\n<lang Haskell>import Char\nimport Control.Monad.Error\nimport Data.List\nimport IO\nimport Maybe\nimport Random\n\nmain = do\n    hSetBuffering stdout NoBuffering\n    mapM_ putStrLn \n        [ \"THE 24 GAME\\n\"\n        , \"Given four digits in the range 1 to 9\"\n        , \"Use the +, -, *, and \/ operators in reverse polish notation\"\n        , \"To show how to make an answer of 24.\\n\"\n        ]\n    digits <- liftM (sort . take 4 . randomRs (1,9)) getStdGen :: IO [Int]\n    putStrLn (\"Your digits: \" ++ intercalate \" \" (map show digits))\n    guessLoop digits\n    where guessLoop digits =\n              putStr \"Your expression: \" >>\n              liftM (processGuess digits . words) getLine >>=\n              either (\\m -> putStrLn m >> guessLoop digits) putStrLn\n\nprocessGuess _      [] = Right \"\"\nprocessGuess digits xs | not $ matches = Left \"Wrong digits used\"\n    where matches = digits == (sort . map read $ filter (all isDigit) xs)\nprocessGuess digits xs = calc xs >>= check\n    where check 24 = Right \"Correct\"\n          check x  = Left (show (fromRational (x :: Rational)) ++ \" is wrong\")\n\n-- A Reverse Polish Notation calculator with full error handling\ncalc = result []\n    where result [n] [] = Right n\n          result _   [] = Left \"Too few operators\"\n          result ns  (x:xs) = simplify ns x >>= flip result xs\n\nsimplify (a:b:ns) s | isOp s = Right ((fromJust $ lookup s ops) b a : ns)\nsimplify _        s | isOp s = Left (\"Too few values before \" ++ s)\nsimplify ns       s | all isDigit s = Right (fromIntegral (read s) : ns)\nsimplify _        s = Left (\"Unrecognized symbol: \" ++ s)\n\nisOp v = elem v $ map fst ops\n\nops = [(\"+\",(+)), (\"-\",(-)), (\"*\",(*)), (\"\/\",(\/))]<\/lang>\n\n==[[:Category:HicEst|HicEst]][[Category:HicEst]]==\n<lang HicEst>DIMENSION digits(4), input_digits(100), difference(4)\nCHARACTER expression*100, prompt*100, answers='Wrong,Correct,', protocol='24 game.txt'\n\n1  digits = CEILING( RAN(9) )\n2  DLG(Edit=expression, Text=digits, TItle=prompt)\n\n   READ(Text=expression, ItemS=n) input_digits\n   IF(n == 4) THEN\n     ALIAS(input_digits,1,  input,4)\n     SORT(Vector=digits, Sorted=digits)\n     SORT(Vector=input, Sorted=input)\n     difference = ABS(digits - input)\n     IF( SUM(difference) == 0 ) THEN\n       EDIT(Text=expression, ScaNnot='123456789+-*\/ ()', GetPos=i, CoPyto=prompt)\n       IF( i > 0 ) THEN\n         prompt = TRIM(expression) \/\/ ': ' \/\/TRIM(prompt) \/\/ ' is an illegal character'\n       ELSE\n         prompt = TRIM(expression) \/\/ ': Syntax error'\n         result = XEQ(expression, *2) ! on error branch to label 2\n         EDIT(Text=answers, ITeM=(result==24)+1, Parse=answer)\n         WRITE(Text=prompt, Name) TRIM(expression)\/\/': ', answer, result\n       ENDIF\n     ELSE\n       WRITE(Text=prompt) TRIM(expression), ': You used ', input, ' instead ', digits\n     ENDIF\n   ELSE\n     prompt = TRIM(expression) \/\/ ': Instead 4 digits you used ' \/\/ n\n   ENDIF\n\n   OPEN(FIle=protocol, APPend)\n   WRITE(FIle=protocol, CLoSe=1) prompt\n\n   DLG(TItle=prompt, Button='>2:Try again', B='>1:New game', B='Quit')\n\nEND<\/lang>\n<lang HicEst>4 + 8 + 7 + 5: You used 4 5 7 8  instead 4 4 7 8\n4 + 8 + 7 + a: Instead 4 digits you used 3\n4 + 8 + 7 + a + 4: a is an illegal character\n4 + 8 + 7a + 4: a is an illegal character\n4 + 8 + 7 + 4:; answer=Wrong; result=23;\n4 * 7 - 8 + 4:; answer=Correct; result=24;<\/lang>\n\n==[[:Category:Icon|Icon]][[Category:Icon]] and [[:Category:Unicon|Unicon]][[Category:Unicon]]==\nThis plays the game of 24 using a simplified version of the code from the [[Arithmetic_evaluation#Icon_and_Unicon|Arithmetic evaluation]] task.\n<lang Icon>invocable all \nlink strings   # for csort, deletec\n\nprocedure main() \nhelp()  \nrepeat { \n   every (n := \"\") ||:= (1 to 4, string(1+?8))\n   writes(\"Your four digits are : \")\n   every writes(!n,\" \") \n   write()\n   \n   e := trim(read()) | fail\n   case e of {\n      \"q\"|\"quit\": return\n      \"?\"|\"help\": help()\n      default: {\n         e := deletec(e,' \\t')         # no whitespace\n         d := deletec(e,~&digits)      # just digits\n         if csort(n) ~== csort(d) then # and only the 4 given digits\n            write(\"Invalid repsonse.\") & next \n\n         if e ? (ans := eval(E()), pos(0)) then # parse and evaluate\n            if ans = 24 then write(\"Congratulations you win!\") \n            else write(\"Your answer was \",ans,\". Try again.\")\n         else write(\"Invalid expression.\")\n         }\n      }\n   }\nend\n\nprocedure eval(X)    #: return the evaluated AST\n   if type(X) == \"list\" then {\n      x := eval(get(X))\n      while x := get(X)(real(x), real(eval(get(X) | stop(\"Malformed expression.\"))))\n   }\n   return \\x | X\nend\n\nprocedure E()    #: expression\n   put(lex := [],T())\n   while put(lex,tab(any('+-*\/'))) do\n      put(lex,T())  \n   suspend if *lex = 1 then lex[1] else lex     # strip useless []  \nend   \n \nprocedure T()                   #: Term\n   suspend 2(=\"(\", E(), =\")\") | # parenthesized subexpression, or ...\n       tab(any(&digits))        # just a value\nend\n\nprocedure help()\nreturn write(\n   \"Welcome to 24\\n\\n\",\n   \"Combine the 4 given digits to make 24 using only + - * \/ and ( ).\\n \",\n   \"All operations have equal precedence and are evaluated left to right.\\n\",\n   \"Combining (concatenating) digits is not allowed.\\n\",\n   \"Enter 'help', 'quit', or an expression.\\n\")  \nend<\/lang>\n\n<div class=\"examplemeta libheader\">'''Library:''' [[SMW::off]][[:Category:Icon Programming Library|Icon Programming Library]][[Category:Icon Programming Library]][[SMW::on]]<\/div>\n[http:\/\/www.cs.arizona.edu\/icon\/library\/src\/procs\/strings.icn strings.icn provides deletec and sortc] \n\nOutput:<pre>Welcome to 24\n\nThe object of the game is to combine the 4 given digits using only + - * \/ and ( ).\nAll operations have equal precedence and are evaluated left to right.\nCombining (concatenating) digits is not allowed.\nEnter 'help', 'quit', or an expression.\n\nYour four digits are : 8 1 7 2\n8*2+(7+1)\nCongratulations you win!\nYour four digits are : 4 2 7 6\n7*6+(4*2)\nYour answer was 50. Try again.\nYour four digits are : 7 7 8 8\n77-88\nInvalid expression.\nYour four digits are : 9 3 2 3\n9+3+2+3+\nMalformed expression.<\/pre>\n\n==[[:Category:J|J]][[Category:J]]==\n\n<lang J>require'misc'\ndeal=: 1 + ? bind 9 9 9 9\nrules=: smoutput bind 'see http:\/\/en.wikipedia.org\/wiki\/24_Game'\ninput=: prompt @ ('enter 24 expression using ', \":, ': '\"_)\n\nwellformed=: (' '<;._1@, \":@[) -:&(\/:~)  '(+-*%)' -.&;:~ ]\nis24=: 24 -: \". ::0:@]\n\nrespond=: (;:'no yes') {::~ wellformed * is24\n\ngame24=: (respond input)@deal@rules<\/lang>\n\nExample use:\n\n    '''<nowiki>game24 ''<\/nowiki>'''\n see <nowiki>http:\/\/en.wikipedia.org\/wiki\/24_Game<\/nowiki>\n enter 24 expression using 6 5 9 4: '''6+5+9+4'''\n yes\n    '''<nowiki>game24 ''<\/nowiki>'''\n see <nowiki>http:\/\/en.wikipedia.org\/wiki\/24_Game<\/nowiki>\n enter 24 expression using 3 3 3 3: '''3+3+3+3+3+3+3+3'''\n no\n\n==[[:Category:JavaScript|JavaScript]][[Category:JavaScript]]==\n<div class=\"examplemeta libheader\">'''Library:''' [[SMW::off]][[:Category:underscore.js|underscore.js]][[Category:underscore.js]][[SMW::on]]<\/div>\n\nThis is my first Rosetta Code, and I am a JS newbie. Works, but is not the best solution. Due to the eval, it is probably '''not safe'''.\n<lang javascript>String.prototype.replaceAll = function(patt,repl) { var that = this;\n              \t                                    that     = that.replace(patt,repl);\n\t\t\t\t\t\t    if (that.search(patt) != -1) {\n\t\t\t\t\t\t\tthat = that.replaceAll(patt,repl);\n\t\t\t\t\t\t    }\n\t\t\t\t\t\t    return that;\n\t\t\t\t\t\t  };\n\nfunction validChars(input) { var regInvalidChar = \/[^\\d\\+\\*\\\/\\s-\\(\\)]\/;\n                             return input.search(regInvalidChar) == -1;\n                           }\n\nfunction validNums(str, nums) {\n    var arr, l;\n    arr = str.replaceAll(\/[^\\d\\s]\/,\" \").replaceAll(\"  \",\" \").trim().split(\" \").sort();\n    l   = arr.length;\n\n    while(l--) { arr[l] = Number(arr[l]); }\n\n    return _.isEqual(arr,nums.sort());\n}\n\nfunction validEval(input) { try { eval(input); } catch (e) { return false; };\n\t\t\t    return true;\n\t\t\t  }\n\nvar input;\n\nwhile(true){ var numbers = [];\n             var i = 4;\n             while(i--) { numbers.push(Math.floor(Math.random()*8+1));\n                        }\n\n             input = prompt(\"Your numbers are:\\n\"\n                           + numbers.join(\" \")\n                           + \"\\nEnter expression. (use only + - * \/ and parens).\\n\"\n                           + \"'x' to exit.\"\n                           );\n\n             if (input === 'x') break;\n    \n               !validChars(input)                 ? alert(\"Invalid chars used, try again. Use only:\\n + - * \/ ( )\")\n             : !validNums(input,numbers)          ? alert(\"Wrong numbers used, try again.\")\n\t     : !validEval(input)                  ? alert(\"Could not evaluate input, try again.\")\n             : eval(input) != 24                  ? alert(\"Wrong answer:\" + eval(input) + \"\\nTry again.\")\n             : alert(input + \"== 24. Congrats!!\")\n             ;\n           }\n<\/lang>\n\n==[[:Category:Liberty BASIC|Liberty BASIC]][[Category:Liberty BASIC]]==\n<lang lb>dim d(4)\ndim chk(4)\nprint \"The 24 Game\"\nprint\nprint \"Given four digits and using just the +, -, *, and \/ operators; and the\"\nprint \"possible use of brackets, (), enter an expression that equates to 24.\"\n\ndo\n    d$=\"\"\n    for i = 1 to 4\n        d(i)=int(rnd(1)*9)+1    '1..9\n        chk(i)=d(i)\n        d$=d$;d(i)  'valid digits, to check with Instr\n    next\n\n    print\n    print \"These are your four digits: \";\n    for i = 1 to 4\n        print d(i);left$(\",\",i<>4);\n    next\n    print\n\n    Print \"Enter expression:\"\n    Input \"24 = \";expr$\n    'check expr$ for validity\n\n    'check right digits used\n    failed = 0\n    for i = 1 to len(expr$)\n        c$=mid$(expr$,i,1)\n        if instr(\"123456789\", c$)<>0 then 'digit\n            if instr(d$, c$)=0 then failed = 1: exit for\n            if i>1 and instr(\"123456789\", mid$(expr$,i-1,1))<>0 then failed = 2: exit for\n            for j =1 to 4\n                if chk(j)=val(c$) then chk(j)=0: exit for\n            next\n        end if\n    next\n    if failed=1 then\n        print \"Wrong digit (\";c$;\")\"\n        goto [fail]\n    end if\n\n    if failed=2 then\n        print \"Multiple digit numbers is disallowed.\"\n        goto [fail]\n    end if\n\n    'check all digits used\n    if chk(1)+ chk(2)+ chk(3)+ chk(4)<>0 then\n        print \"Not all digits used\"\n        goto [fail]\n    end if\n\n    'check valid operations\n    failed = 0\n    for i = 1 to len(expr$)\n        c$=mid$(expr$,i,1)\n        if instr(\"+-*\/()\"+d$, c$)=0 then failed = 1: exit for\n    next\n    if failed then\n        print \"Wrong operation (\";c$;\")\"\n        goto [fail]\n    end if\n    'some errors (like brackets) trapped by error handler\n    Err$=\"\"\n    res=evalWithErrCheck(expr$)\n    if Err$<>\"\" then\n        print \"Error in expression\"\n        goto [fail]\n    end if\n    if res = 24 then\n        print \"Correct!\"\n    else\n        print \"Wrong! (you got \";res ;\")\"\n    end if\n[fail]\n    Input \"Play again (y\/n)? \"; ans$\nloop while ans$=\"y\"\nend\n\nfunction evalWithErrCheck(expr$)\n    on error goto [handler]\n    evalWithErrCheck=eval(expr$)\n    exit function\n[handler]\nend function<\/lang>\n\n==[[:Category:Locomotive Basic|Locomotive Basic]][[Category:Locomotive Basic]]==\n\n<lang locobasic>10 CLS:RANDOMIZE TIME\n20 PRINT \"The 24 Game\"\n30 PRINT \"===========\":PRINT\n40 PRINT \"Enter an arithmetic expression\"\n50 PRINT \"that evaluates to 24,\"\n60 PRINT \"using only the provided digits\"\n70 PRINT \"and +, -, *, \/, (, ).\"\n80 PRINT \"(Just hit Return for new digits.)\"\n90 ' create new digits\n100 FOR i=1 TO 4:a(i)=INT(RND*9)+1:NEXT\n110 PRINT\n120 PRINT \"The digits are\";a(1);a(2);a(3);a(4)\n130 PRINT\n140 ' user enters solution\n150 INPUT \"Your solution\";s$\n160 IF s$=\"\" THEN PRINT \"Creating new digits...\":GOTO 100\n170 GOTO 300\n180 ' a little hack to create something like an EVAL function\n190 OPENOUT \"exp.bas\"\n200 PRINT #9,\"1000 x=\"s$\":return\"\n210 CLOSEOUT\n220 CHAIN MERGE \"exp\",240\n230 ' now evaluate the expression\n240 ON ERROR GOTO 530\n250 GOSUB 1000\n260 IF x=24 THEN PRINT \"Well done!\":END\n270 PRINT \"No, this evaluates to\"x:PRINT \"Please try again.\"\n280 GOTO 150\n290 ' check input for correctness\n300 FOR i=1 TO LEN(s$)\n310 q=ASC(MID$(s$,i,1))\n320 IF q=32 OR (q>39 AND q<44) OR q=45 OR (q>46 AND q<58) THEN NEXT\n330 IF i-1=LEN(s$) THEN 370\n340 PRINT \"Bad character in expression:\"CHR$(q)\n350 PRINT \"Try again\":GOTO 150\n360 ' new numbers in solution?\n370 FOR i=1 TO LEN(s$)-1\n380 q=ASC(MID$(s$,i,1)):p=ASC(MID$(s$,i+1,1))\n390 IF q>47 AND q<58 AND p>47 AND p<58 THEN PRINT \"No forming of new numbers, please!\":GOTO 150\n400 NEXT\n410 FOR i=1 TO 9:orig(i)=0:guess(i)=0:NEXT\n420 FOR i=1 TO 4:orig(a(i))=orig(a(i))+1:NEXT\n430 FOR i=1 TO LEN(s$)\n440 v$=MID$(s$,i,1)\n450 va=ASC(v$)-48\n460 IF va>0 AND va<10 THEN guess(va)=guess(va)+1\n470 NEXT\n480 FOR i=1 TO 9\n490 IF guess(i)<>orig(i) THEN PRINT \"Only use all the provided digits!\":GOTO 150\n500 NEXT\n510 GOTO 190\n520 ' syntax error, e.g. non-matching parentheses\n530 PRINT \"Error in expression, please try again.\"\n540 RESUME 150<\/lang>\n\nNote: The program needs a writable disk in the active disk drive.\n\n==[[:Category:Logo|Logo]][[Category:Logo]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[UCB_Logo]] version 5.5[[SMW::on]]<\/div>\n<lang logo>; useful constants\nmake \"false 1=0\nmake \"true  1=1\nmake \"lf char 10\nmake \"sp char 32\n\n; non-digits legal in expression\nmake \"operators (lput sp [+ - * \/ \\( \\)])\n\n; display help message\nto show_help :digits\n  type lf\n  print sentence quoted [Using only these digits:] :digits \n  print sentence quoted [and these operators:] [* \/ + -]\n  print quoted [\\(and parentheses as needed\\),]\n  print quoted [enter an arithmetic expression \n     which evaluates to exactly 24.]\n  type lf\n  print quoted [Enter \\\"!\\\" to get fresh numbers.]\n  print quoted [Enter \\\"q\\\" to quit.]\n  type lf\nend\n\nmake \"digits []\nmake \"done false\nuntil [done] [\n\n  if empty? digits [\n    make \"digits (map [(random 9) + 1] [1 2 3 4])\n  ]\n\n  (type \"Solution sp \"for sp digits \"? sp )\n  make \"expression readrawline\n\n  ifelse [expression = \"?] [\n\n    show_help digits\n\n  ] [ifelse [expression = \"q] [\n\n    print \"Bye!\n    make \"done true\n\n  ] [ifelse [expression = \"!] [\n\n    make \"digits []\n\n  ] [\n    make \"exprchars ` expression\n    make \"allowed (sentence digits operators)\n\n    ifelse (member? false (map [[c] member? c allowed] exprchars)) [\n      (print quoted [Illegal character in input.])\n    ] [\n      catch \"error [\n        make \"syntax_error true\n        make \"testval (run expression)\n        make \"syntax_error false\n      ]\n      ifelse syntax_error [\n        (print quoted [Invalid expression.])\n      ] [\n        ifelse (testval = 24) [\n          print quoted [You win!]\n          make \"done true\n        ] [\n          (print (sentence \n            quoted [Incorrect \\(got ] testval quoted [instead of 24\\).]))\n        ]\n      ]\n    ]\n  ]]]\n] \nbye<\/lang>\nSample output:\n<pre>\nSolution for 3 8 9 5? ?\n\nUsing only these digits: 3 8 9 5\nand these operators: * \/ + -\n(and parentheses as needed),\nenter an arithmetic expression which evaluates to exactly 24.\n\nEnter \"!\" to get fresh numbers.\nEnter \"q\" to quit.\n\nSolution for 3 8 9 5? !\nSolution for 9 2 8 5? 9+2+8+5\nYou win!\n<\/pre>\n\n==[[:Category:Lua|Lua]][[Category:Lua]]==\n<lang lua>\nlocal function help()\n\tprint [[\n The 24 Game\n\n Given any four digits in the range 1 to 9, which may have repetitions,\n Using just the +, -, *, and \/ operators; and the possible use of\n brackets, (), show how to make an answer of 24.\n\n An answer of \"q\" will quit the game.\n An answer of \"!\" will generate a new set of four digits.\n\n Note: you cannot form multiple digit numbers from the supplied digits,\n so an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.\n\n ]]\nend\n\nlocal function generate(n)\n\tresult = {}\n\tfor i=1,n do\n\t\tresult[i] = math.random(1,9)\n\tend\n\treturn result\nend\n\nlocal function check(answer, digits)\n\tlocal adig = {}\n\tlocal ddig = {}\n\tlocal index\n\tlocal lastWasDigit = false\n\tfor i=1,9 do adig[i] = 0 ddig[i] = 0 end\n\tallowed = {['(']=true,[')']=true,[' ']=true,['+']=true,['-']=true,['*']=true,['\/']=true,['\\t']=true,['1']=true,['2']=true,['3']=true,['4']=true,['5']=true,['6']=true,['7']=true,['8']=true,['9']=true}\n\tfor i=1,string.len(answer) do\n\t\tif not allowed[string.sub(answer,i,i)] then\n\t\t\treturn false\n\t\tend\n\t\tindex = string.byte(answer,i)-48\n\t\tif index > 0 and index < 10 then\n\t\t\tif lastWasDigit then\n\t\t\t\treturn false\n\t\t\tend\n\t\t\tlastWasDigit = true\n\t\t\tadig[index] = adig[index] + 1\n\t\telse\n\t\t\tlastWasDigit = false\n\t\tend\n\tend\n\tfor i,digit in next,digits do\n\t\tddig[digit] = ddig[digit]+1\n\tend\n\tfor i=1,9 do\n\t\tif adig[i] ~= ddig[i] then\n\t\t\treturn false\n\t\tend\n\tend\n\treturn loadstring('return '..answer)()\nend\n\nlocal function game24()\n\thelp()\n\tmath.randomseed(os.time())\n\tmath.random()\n\tlocal digits = generate(4)\n\tlocal trial = 0\n\tlocal answer = 0\n\tlocal ans = false\n\tio.write 'Your four digits:'\n\tfor i,digit in next,digits do\n\t\tio.write (' ' .. digit)\n\tend\n\tprint()\n\twhile ans ~= 24 do\n\t\ttrial = trial + 1\n\t\tio.write(\"Expression \"..trial..\": \")\n\t\tanswer = io.read()\n\t\tif string.lower(answer) == 'q' then\n\t\t\tbreak\n\t\tend\n\t\tif answer == '!' then\n\t\t\tdigits = generate(4)\n\t\t\tio.write (\"New digits:\")\n\t\t\tfor i,digit in next,digits do\n\t\t\t\tio.write (' ' .. digit)\n\t\t\tend\n\t\t\tprint()\n\t\telse\n\t\t\tans = check(answer,digits)\n\t\t\tif ans == false then\n\t\t\t\tprint ('The input '.. answer ..' was wonky!')\n\t\t\telse\n\t\t\t\tprint (' = '.. ans)\n\t\t\t\tif ans == 24 then\n\t\t\t\t\tprint (\"Thats right!\")\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\nend\ngame24()<\/lang>\n\nAlternately, using the <code>lpeg.re<\/code> module:\n\n<lang lua>function twentyfour()\n   print [[\n The 24 Game\n \n Given any four digits in the range 1 to 9, which may have repetitions,\n Using just the +, -, *, and \/ operators; and the possible use of\n brackets, (), show how to make an answer of 24.\n \n An answer of \"q\" will quit the game.\n An answer of \"!\" will generate a new set of four digits.\n \n Note: you cannot form multiple digit numbers from the supplied digits,\n so an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.\n \n ]]\n   expr = re.compile[[   --matches properly formatted infix expressions and returns all numerals as captures\n         expr <- (!.) \/ (<paren> \/ <number>) (<ws> <oper> <ws> <expr>)?\n         number <- {[0-9]}\n         ws <- \" \"*\n         oper <- [-+\/*]\n         paren <- \"(\" <ws> <expr> <ws> \")\"   ]]\n   local val_t = {math.random(9), math.random(9), math.random(9), math.random(9)}\n   table.sort(val_t)\n   print(\"the digits are \" .. table.concat(val_t, \", \"))\n   local ex = io.read()\n   a, b, c, d, e = expr:match(ex)\n   if a and b and c and d and not e then --if there is a fifth numeral the player is cheating\n      local digs = {a + 0, b + 0, c + 0, d + 0}\n      local flag = false -- (terrorism!)\n      table.sort(digs)\n      for i = 1, 4 do\n\t   flag = digs[i] ~= val_t[i] and not print\"Wrong digits!\" or flag\n      end\n      if not flag and loadstring(\"return \" .. ex)() == 24 then\n         print\"You win!\"\n      else\n         print\"You lose.\"\n      end\n   else print\"wat\" --expression could not be interpreted as arithmetic\n   end\nend\ntwentyfour()<\/lang>\n\n==[[:Category:Mathematica|Mathematica]][[Category:Mathematica]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Mathematica]] version 6[[SMW::on]]<\/div>\n\nSince Mathematica hasn't historically had good custom I\/O support (the command-line allowed ''all'' operations, not very good for UI-generation), I had to roll some custom GUI (with a text box), which requires Mathematica 6.\n\nMost of the job is already done by Mathematica (the expression conversion); in fact, it is ''too'' good&mdash;it automatically converts ex. 3\/4 to Times[3, Power[4, -1]], which we have to specifically test for so that real powers don't get through.\n\n<lang Mathematica>isLegal[n_List, x_String] := \n Quiet[Check[\n   With[{h = ToExpression[x, StandardForm, HoldForm]}, \n    If[Cases[Level[h, {2, \\[Infinity]}, Hold, Heads -> True], \n        Except[_Integer | Plus | _Plus | Times | _Times | Power | \n          Power[_, -1]]] === {} && \n      Sort[Level[h \/. Power[q_, -1] -> q, {-1}] \/. \n         q_Integer -> Abs[q]] === Sort[n], ReleaseHold[h]]], Null]]\nGrid[{{Button[\n    \"new numbers\", {a, b, c, d} = Table[RandomInteger[{1, 9}], {4}]], \n   InputField[Dynamic[x], String]}, {Dynamic[{a, b, c, d}], \n   Dynamic[Switch[isLegal[{a, b, c, d}, x], Null, \n     \"Sorry, that is invalid.\", 24, \"Congrats! That's 24!\", _, \n     \"Sorry, that makes \" <> ToString[ToExpression@x, InputForm] <> \n      \", not 24.\"]]}}]<\/lang>\n==[[:Category:MATLAB|MATLAB]][[Category:MATLAB]] \/ [[:Category:Octave|Octave]][[Category:Octave]]== \n\n<lang Matlab>  function twentyfour()\n  N = 4;\n  n = ceil(rand(1,N)*9);\n  printf('Generate a equation with the numbers %i, %i, %i, %i and +, -, *, \/, () operators ! \\n',n);\n  s = input(': ','s');\n  t = s;\n  for k = 1:N,\n    [x,t] = strtok(t,'+-*\/() \\t');\n     if length(x)~=1,\n       error('invalid sign %s\\n',x);\n     end; \n     y = x-'0';\n     if ~(0 < y & y < 10) \n       error('invalid sign %s\\n',x);\n     end;\n     z(1,k) = y;  \t\n  end; \n  if any(sort(z)-sort(n)) \n    error('numbers do not match.\\n');\t\n  end; \n\n  val =  eval(s);\n  if val==24,\n    fprintf('expression \"%s\" results in %i.\\n',s,val);\t\n  else\n    fprintf('expression \"%s\" does not result in 24 but %i.\\n',s,val);\n  end; \t<\/lang>\n\n\n==[[:Category:Modula-2|Modula-2]][[Category:Modula-2]]==\n<div class=\"examplemeta libheader\">'''Library:''' [[SMW::off]][[:Category:Ulm's Modula-2 Library|Ulm's Modula-2 Library]][[Category:Ulm's Modula-2 Library]][[SMW::on]]<\/div>\n<lang modula2>MODULE TwentyFour;\n\nFROM\tInOut\t\t\tIMPORT WriteString, WriteLn, Write, ReadString, WriteInt;\nFROM\tRandomGenerator IMPORT Random;\n\nTYPE\toperator_t \t\t= (add, sub, mul, div);\n\t\texpr_t\t\t\t= RECORD\n\t\t\t\t\t\t\toperand\t\t: ARRAY[0..3] OF CARDINAL;\n\t\t\t\t\t  \t\toperator \t: ARRAY[1..3] OF operator_t;\n\t\t\t\t\t\t  END;(*of RECORD*)\n\t\tnumbers_t\t\t= SET OF CHAR;\n\nVAR\t\texpr \t: expr_t;\n\t\tnumbers\t: numbers_t;\n(*******************************************************************createExpr*)\n(*analyse the input string                                                    *)\nPROCEDURE createExpr(s: ARRAY OF CHAR);\n\nVAR index, counter\t: INTEGER;\n\ttoken \t\t\t: CHAR;\n\ttemp_expr \t\t: expr_t;\n\toperand   \t\t: CARDINAL;\n\toperator\t\t: operator_t;\n\t\n\t(************************************nextToken*)\n\t(* returns the next CHAR that isn`t a space    *)\n\tPROCEDURE nextToken(): CHAR;\n\tBEGIN\n\t\tINC(index);\n\t\tWHILE (s[index] = ' ') DO\n\t\t\tINC(index);\n\t\tEND;(*of WHILE*)\n\t\tRETURN(s[index]);\n\tEND nextToken;\n\t(***********************************set_operand*)\n\t(* checks if the CHAR o inerhits a valid number*)\n\t(* and sets 'operand' to its value             *)\t\n\tPROCEDURE set_operand(o: CHAR);\n\tBEGIN\n\t\tCASE o OF\n\t\t\t'0'..'9':\tIF o IN numbers THEN\n\t\t\t\t\t\t\toperand := ORD(o)-48;\n\t\t\t\t\t\t\tnumbers := numbers - numbers_t{o};\n\t\t\t\t\t\tELSE\n\t\t\t\t\t\t\tWriteString(\"ERROR: '\");\n\t\t\t\t\t\t\tWrite(\t\t\t\t\to);\n\t\t\t\t\t\t\tWriteString(\t\t\t\t\"' isn`t a available number \");\n\t\t\t\t\t\t\tWriteLn;\n\t\t\t\t\t\t\tHALT;\n\t\t\t\t\t\tEND;(*of IF*)|\n\t\t\t0  : WriteString(\"ERROR: error in input \");\n\t\t\t\t\tWriteLn;\n\t\t\t\t\tHALT;\n\t\t\tELSE\n\t\t\t\tWriteString(\"ERROR: '\");\n\t\t\t\tWrite(\t\t\t\t\to);\n\t\t\t\tWriteString(\t\t\t\t\"' isn`t a number \");\n\t\t\t\tWriteLn;\n\t\t\t\tHALT;\n\t\tEND;(*of CASE*)\n\tEND set_operand;\n\t(**********************************set_operator*)\n\t(* checks if the CHAR o inerhits a valid       *)\n\t(* operator and sets 'operator' to its value   *)\n\tPROCEDURE set_operator(o: CHAR);\n\tBEGIN\n\t\tCASE o OF\n\t\t\t'+' : operator := add;|\n\t\t\t'-' : operator := sub;|\n\t\t\t'*' : operator := mul;|\n\t\t\t'\/' : operator := div;|\n\t\t\t0  : WriteString(\"ERROR: error in input \");\n\t\t\t\t\tWriteLn;\n\t\t\t\t\tHALT;\n\t\tELSE\n\t\t\tWriteString(\"ERROR: '\");\n\t\t\t\tWrite(\t\t\t\t\to);\n\t\t\t\tWriteString(\t\t\t\t\"' isn`t a operator \");\n\t\t\t\tWriteLn;\n\t\t\t\tHALT;\n\t\tEND;(*of CASE*)\n\tEND set_operator;\n\t(************************************************)\nBEGIN\n\tindex := -1;\n\t\n\ttoken := nextToken();\n\tset_operand(token);\n\texpr.operand[0] := operand;\n\t\n\ttoken := nextToken();\n\tset_operator(token);\n\texpr.operator[1] := operator;\n\t\n\t\n\ttoken := nextToken();\n\tset_operand(token);\n\texpr.operand[1] := operand;\n\t\n\ttoken := nextToken();\n\tset_operator(token);\n\texpr.operator[2] := operator;\n\t\n\ttoken := nextToken();\n\tset_operand(token);\n\texpr.operand[2] := operand;\n\t\n\ttoken := nextToken();\n\tset_operator(token);\n\texpr.operator[3] := operator;\n\t\n\ttoken := nextToken();\n\tset_operand(token);\n\texpr.operand[3] := operand;\nEND createExpr;\n\n(*****************************************************************evaluateExpr*)\n(* evaluate the expresion that was createt by 'createExpr'                    *)\n\nPROCEDURE evaluateExpr(VAR num: REAL);\n\nVAR\tindex\t: INTEGER;\nBEGIN\n\tWITH expr DO\n\t\tnum := VAL(REAL,operand[0]);\n\t\tFOR index := 1 TO 3 DO\n\t\t\tCASE operator[index] OF\n\t\t\t\tadd : num := num + VAL(REAL,operand[index]);|\n\t\t\t\tsub : num := num - VAL(REAL,operand[index]);|\n\t\t\t\tmul : num := num * VAL(REAL,operand[index]);|\n\t\t\t\tdiv : num := num \/ VAL(REAL,operand[index]);\n\t\t\tEND;(*of CASE*)\n\t\tEND;(*of FOR*)\n\tEND;(*of WIHT*)\nEND evaluateExpr;\n\n(**************************************************************generateNumbers*)\n(* generates the 4 random numbers ond write them                              *)\nPROCEDURE generateNumbers;\nVAR\tindex,ran : INTEGER;\nBEGIN\n\tnumbers := numbers_t{};\n\tran := Random(0,9);\n\tFOR index := 1 TO 4 DO\n\t\tWHILE (CHR(ran+48) IN numbers )DO\n\t\t\tran := Random(0,9);\n\t\tEND;(*of While*)\n\t\tWrite(CHR(ran+48));\n\t\tWriteLn;\n\t\tnumbers := numbers + numbers_t{CHR(ran+48)}\n\tEND;(*of FOR*)\nEND generateNumbers;\n(****************************************************************Main Programm*)\nVAR\tstr : ARRAY[0..255] OF CHAR;\n\tsum : REAL;\nBEGIN\n\tWriteString(\"Welcome to the 24 game in MODULA-2\");\n\tWriteLn;\n\tWriteString(\"Here are your numbers:\");\n\tWriteLn;\n\tgenerateNumbers;\n\tWriteString(\"Enter your equation(This implementation dosn`t support brackets yet): \");\n\tWriteLn;\n\tReadString(str);\n\tcreateExpr(str);\n\tevaluateExpr(sum);\n\tWriteLn;\n\tWriteString(\"Result:\");\n\tWriteLn;\n\tWriteInt(TRUNC(sum),0);\n\tWriteLn;\n\tCASE (TRUNC(sum) - 24) OF\n\t\t0 : WriteString(\"Perfect!\");|\n\t\t1 : WriteString(\"Almost perfect.\");\n\t\tELSE \n\t\t\tWriteString(\"You loose!\");\n\tEND;(*of CASE*)\n\tWriteLn;\nEND TwentyFour.<\/lang>\n\n==[[:Category:OCaml|OCaml]][[Category:OCaml]]==\n\nCompile with:\n ocamlopt -pp camlp4o g24.ml -o g24.opt\n\n<lang ocaml>type expression =\n  | Const of float\n  | Sum  of expression * expression   (* e1 + e2 *)\n  | Diff of expression * expression   (* e1 - e2 *)\n  | Prod of expression * expression   (* e1 * e2 *)\n  | Quot of expression * expression   (* e1 \/ e2 *)\n\nlet rec eval = function\n  | Const c -> c\n  | Sum (f, g) -> eval f +. eval g\n  | Diff(f, g) -> eval f -. eval g\n  | Prod(f, g) -> eval f *. eval g\n  | Quot(f, g) -> eval f \/. eval g\n\nlet rec extract acc = function\n  | Const c -> (c::acc)\n  | Sum (f, g) -> (extract acc f) @ (extract [] g)\n  | Diff(f, g) -> (extract acc f) @ (extract [] g)\n  | Prod(f, g) -> (extract acc f) @ (extract [] g)\n  | Quot(f, g) -> (extract acc f) @ (extract [] g)\n\nopen Genlex\n\nlet lexer = make_lexer [\"(\"; \")\"; \"+\"; \"-\"; \"*\"; \"\/\"]\n\nlet rec parse_expr = parser\n     [< e1 = parse_mult; e = parse_more_adds e1 >] -> e\n and parse_more_adds e1 = parser\n     [< 'Kwd \"+\"; e2 = parse_mult; e = parse_more_adds (Sum(e1, e2)) >] -> e\n   | [< 'Kwd \"-\"; e2 = parse_mult; e = parse_more_adds (Diff(e1, e2)) >] -> e\n   | [< >] -> e1\n and parse_mult = parser\n     [< e1 = parse_simple; e = parse_more_mults e1 >] -> e\n and parse_more_mults e1 = parser\n     [< 'Kwd \"*\"; e2 = parse_simple; e = parse_more_mults (Prod(e1, e2)) >] -> e\n   | [< 'Kwd \"\/\"; e2 = parse_simple; e = parse_more_mults (Quot(e1, e2)) >] -> e\n   | [< >] -> e1\n and parse_simple = parser\n   | [< 'Int i >] -> Const(float i)\n   | [< 'Float f >] -> Const f\n   | [< 'Kwd \"(\"; e = parse_expr; 'Kwd \")\" >] -> e\n\n\nlet parse_expression = parser [< e = parse_expr; _ = Stream.empty >] -> e\n\nlet read_expression s = parse_expression(lexer(Stream.of_string s))\n\n\nlet () =\n  Random.self_init();\n  print_endline \"\n  The 24 Game\n\n  Given any four digits in the range 1 to 9, which may have repetitions,\n  Using just the +, -, *, and \/ operators; and the possible use of\n  brackets, (), show how to make an answer of 24.\n\n  An answer of 'q' will quit the game.\n  An answer of '!' will generate a new set of four digits.\n  Otherwise you are repeatedly asked for an expression until it evaluates to 24\n\n  Note: you cannot form multiple digit numbers from the supplied digits,\n  so an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.\\n\";\n\n  let sort = List.sort compare in\n  let digits = ref [] in\n  let digit_set () =\n    let ar = Array.init 4 (fun _ -> 1 + Random.int 9) in\n    digits := Array.to_list(Array.map float_of_int ar);\n    print_string \"The four digits: \";\n    List.iter (Printf.printf \" %g\") !digits;\n    print_newline();\n  in\n\n  digit_set();\n  while true do\n    print_string \"Expression: \";\n    let str = read_line() in\n    if str = \"q\" then exit 0;\n    if str = \"!\" then digit_set()\n    else begin\n      let expr = read_expression str in\n      let res = eval expr in\n      Printf.printf \" = %g\\n%!\" res;\n      if res = 24.\n      && (sort !digits) = (sort (extract [] expr))\n      then (print_endline \"Congratulations!\"; digit_set())\n      else print_endline \"Try again\"\n    end\n  done<\/lang>\n\n==[[:Category:OpenEdge\/Progress|OpenEdge\/Progress]][[Category:OpenEdge\/Progress]]==\nThe dynamic query parser is used to evaluate the expression.\n<lang Progress (OpenEdge ABL)>DEFINE TEMP-TABLE tt NO-UNDO FIELD ii AS INTEGER.\n\nDEFINE VARIABLE p_deanswer    AS DECIMAL     NO-UNDO.\nDEFINE VARIABLE idigits       AS INTEGER     NO-UNDO EXTENT 4.\nDEFINE VARIABLE ii            AS INTEGER     NO-UNDO.\nDEFINE VARIABLE Digits        AS CHARACTER   NO-UNDO FORMAT \"x(7)\".\nDEFINE VARIABLE Answer        AS CHARACTER   NO-UNDO FORMAT \"x(7)\".\nDEFINE VARIABLE cexpression   AS CHARACTER   NO-UNDO.\nDEFINE VARIABLE cmessage      AS CHARACTER   NO-UNDO.\nDEFINE VARIABLE cchar         AS CHARACTER   NO-UNDO.\n\nFUNCTION calculate RETURNS LOGICAL (\n   i_de AS DECIMAL\n):\n   p_deanswer = i_de.\nEND FUNCTION.\n\n\/* generate problem *\/\nDO ii = 1 TO 4:\n   ASSIGN\n      idigits [ii]   =  RANDOM( 1, 9 ).\n      Digits         =  Digits + STRING( idigits [ii] ) + \" \"\n      .\nEND.\n\n\/* ui *\/\nDISPLAY Digits.\nUPDATE Answer.\n\n\/* check valid input *\/\nDO ii = 1 TO 7:\n   cchar = SUBSTRING( Answer, ii, 1 ).\n   IF cchar > \"\" THEN DO:\n      IF ii MODULO 2 = 1 THEN DO:\n         IF LOOKUP( cchar, Digits, \" \" ) = 0 THEN\n            cmessage = cmessage + SUBSTITUTE( \"Invalid digit: &1.~r\", cchar ).\n         ELSE \n            ENTRY( LOOKUP( cchar, Digits, \" \" ), Digits, \" \" ) = \"\".\n      END.\n      ELSE DO:\n         IF LOOKUP( cchar, \"+,-,\/,*\" ) = 0 THEN\n            cmessage = cmessage + SUBSTITUTE( \"&1 is not a valid operator.~r\", cchar ).\n      END.\n   END.\nEND.\nIF TRIM( Digits ) > \"\" THEN\n   cmessage = cmessage + SUBSTITUTE( \"You did not use digits: &1\":U, TRIM( Digits ) ).\n\nIF cmessage = \"\" THEN DO:\n   \/* expressions need spacing *\/\n   DO ii = 1 TO 7:\n      cexpression = cexpression + SUBSTRING( Answer, ii, 1 ) + \" \".\n   END.\n   \/* use dynamic query to parse expression *\/\n   TEMP-TABLE tt:DEFAULT-BUFFER-HANDLE:FIND-FIRST( \n      SUBSTITUTE(\n         \"WHERE NOT DYNAMIC-FUNCTION( 'calculate', DECIMAL( &1 ) )\",\n         cexpression\n      )\n   ) NO-ERROR.\n   IF p_deanswer <> 24 THEN\n      cmessage = cmessage + SUBSTITUTE( \"The expression evaluates to &1.\", p_deanswer ).\n   ELSE \n      cmessage = \"Solved!\".\nEND.\n\nMESSAGE cmessage VIEW-AS ALERT-BOX.\n<\/lang>\n\n==[[:Category:PARI\/GP|PARI\/GP]][[Category:PARI\/GP]]==\n{| class=\"messagebox\" style=\"text-align: center; background-color: #ffffd8; clear: both;\"\n| This example is '''untested'''. Please check that it's correct, debug it as necessary, and remove this message.\n|}[[Category:Examples needing attention]]\n<lang parigp>game()={\n  my(v=vecsort(vector(4,i,random(8)+1)));\n  print(\"Form 24 using *\/+-() and: \"v);\n  while(1,\n    my(ans=input);\n    if (!valid(s,v), next);\n    trap(,\n      print(\"Arithmetic error\");\n      next\n    ,\n      if(eval(s)==24, break, print(\"Bad sum\"))\n    )\n  );\n  print(\"You win!\")\n};\nvalid(s,v)={\n  my(op=vecsort(Vec(\"+-*\/()\")),u=[]);\n  s=Vec(s);\n  for(i=1,#s,\n    if(setsearch(op,s[i]),next);\n    trap(,\n      print(\"Invalid character \"s[i]);\n      return(0)\n    ,\n      if(setsearch(v,eval(s[i])),\n        u=concat(u,eval(s[i]))\n      ,\n        print(s[i]\" not allowed\");\n        return(0)\n      )\n    )\n  );\n  for(i=2,#s,\n    if(!setsearch(op,s[i])&!setsearch(op,s[i-1]),\n      print(\"Concatenating digits is not allowed!\");\n      return(0)\n    )\n  );\n  if(vecsort(u)!=v,\n    print(\"Invalid digits\");\n    0\n  ,\n    1\n  )\n};<\/lang>\n\n==[[:Category:Perl|Perl]][[Category:Perl]]==\n<lang perl>#!\/usr\/bin\/perl\n\nuse strict; \nuse warnings;\n\nprint <<'EOF';\nThe 24 Game\n\nGiven any four digits in the range 1 to 9, which may have repetitions,\nUsing just the +, -, *, and \/ operators; and the possible use of\nbrackets, (), show how to make an answer of 24.\n\nAn answer of \"q\" will quit the game.\nAn answer of \"!\" will generate a new set of four digits.\nOtherwise you are repeatedly asked for an expression until it evaluates to 24\n\nNote: you cannot form multiple digit numbers from the supplied digits,\nso an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.\nEOF\n\nwhile(1)\n{\n    my $iteration_num = 0;\n\n    my $numbers = make_numbers();\n    \n    TRY_SOLVING:\n    while(1)\n    {\n        $iteration_num++;\n        print \"Expression ${iteration_num}: \";\n\n        my $entry = <>;\n        chomp($entry);\n\n        last TRY_SOLVING if $entry eq '!';\n\n        exit if $entry eq 'q';\n\n        my $result = play($numbers, $entry);\n\n        if (!defined $result)\n        {\n            print \"That's not valid\\n\";\n            next TRY_SOLVING;\n        }\n        elsif ($result != 24)\n        {\n            print \"Sorry, that's $result\\n\";\n            next TRY_SOLVING;\n        }\n        else\n        { \n            print \"That's right! 24!!\\n\";\n            exit; \n        }\n    }\n}\n\nsub make_numbers\n{\n    my %numbers = ();\n\n    print \"Your four digits:\";\n\n    for(1..4)\n    {\n        my $i = 1 + int(rand(9));\n        $numbers{$i}++;\n        print \"$i \";\n    }\n\n    print \"\\n\";\n\n    return \\%numbers;\n}\n\nsub play\n{\n    my ($numbers, $expression) = @_;\n\n    my %running_numbers = %$numbers;\n\n    my @chars = split \/\/, $expression;\n\n    my $operator = 1;\n\n    CHARS:\n    foreach (@chars)\n    {\n        next CHARS if $_ =~ \/[()]\/;\n\n        $operator = !$operator;\n\n        if (! $operator)\n        {\n            if (defined $running_numbers{$_} && $running_numbers{$_} > 0)\n            {\n                $running_numbers{$_}--;\n                next CHARS;\n            }\n            else\n            {\n                return;\n            }\n        }\n        else\n        {\n            return if $_ !~ m{[-+*\/]};\n        }\n    }\n\n    foreach my $remaining (values(%running_numbers))\n    {\n        if ($remaining > 0)\n        {\n            return;\n        }\n    }\n\n    return eval($expression);\n}\n<\/lang>\n\n==[[:Category:Perl 6|Perl 6]][[Category:Perl 6]]==\n\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Rakudo]] version 2010.09.16[[SMW::on]]<\/div>\n<lang perl6>grammar Exp24 {\n    token TOP { ^ <exp> $ }\n    token exp { <term> [ <op> <term> ]* }\n    token term { '(' <exp> ')' | \\d }\n    token op { '+' | '-' | '*' | '\/' }\n}\n\nmy @digits = roll 4, 1..9;  # to a gamer, that's a \"4d9\" roll\nsay \"Here's your digits: {@digits}\";\n\nwhile my $exp = prompt \"\\n24-Exp? \" {\n    unless is-valid($exp, @digits) {\n        say \"Sorry, your expression is not valid!\";\n        next;\n    }\n\n    my $value = eval $exp;\n    say \"$exp = $value\";\n    if $value == 24 {\n        say \"You win!\";\n        last;\n    }\n    say \"Sorry, your expression doesn't evaluate to 24!\";\n}\n\nsub is-valid($exp, @digits) {\n    unless ?Exp24.parse($exp) {\n        say \"Expression doesn't match rules!\";\n        return False;\n    }\n\n    unless $exp.comb(\/\\d\/).sort.join == @digits.sort.join {\n        say \"Expression must contain digits {@digits} only!\";\n        return False;\n    }\n\n    return True;\n}<\/lang>\n\n==[[:Category:PicoLisp|PicoLisp]][[Category:PicoLisp]]==\n<lang PicoLisp>(de checkExpression (Lst Exe)\n   (make\n      (when (diff Lst (fish num? Exe))\n         (link \"Not all numbers used\" ) )\n      (when (diff (fish num? Exe) Lst)\n         (link \"Using wrong number(s)\") )\n      (when (diff (fish sym? Exe) '(+ - * \/))\n         (link \"Using illegal operator(s)\") ) ) )\n\n(loop\n   (setq Numbers (make (do 4 (link (rand 1 9)))))\n   (prinl\n      \"Please enter a Lisp expression using (, ), +, -, *, \/ and \"\n      (glue \", \" Numbers) )\n   (prin \"Or a single dot '.' to stop: \")\n   (T (= \".\" (setq Reply (catch '(NIL) (in NIL (read)))))\n      (bye) )\n   (cond\n      ((str? Reply)\n         (prinl \"-- Input error: \" Reply) )\n      ((checkExpression Numbers Reply)\n         (prinl \"-- Illegal Expression\")\n         (for S @\n            (space 3)\n            (prinl S) ) )\n      ((str? (setq Result (catch '(NIL) (eval Reply))))\n         (prinl \"-- Evaluation error: \" @) )\n      ((= 24 Result)\n         (prinl \"++ Congratulations! Correct result :-)\") )\n      (T (prinl \"Sorry, this gives \" Result)) )\n   (prinl) )<\/lang>\nOutput:\n<pre>Please enter a Lisp expression using (, ), +, -, *, \/ and 1, 3, 3, 5\nOr a single dot '.' to stop: (* (+ 3 1) (+ 5 1))\n++ Congratulations! Correct result :-)\n\nPlease enter a Lisp expression using (, ), +, -, *, \/ and 8, 4, 7, 1\nOr a single dot '.' to stop: (* 8 (% 7 3) 9)\n-- Illegal Expression\n   Not all numbers used\n   Using wrong number(s)\n   Using illegal operator(s)\n\nPlease enter a Lisp expression using (, ), +, -, *, \/ and 4, 2, 2, 3\nOr a single dot '.' to stop: (\/ (+ 4 3) (- 2 2))\n-- Evaluation error: Div\/0\n\nPlease enter a Lisp expression using (, ), +, -, *, \/ and 8, 4, 5, 9\nOr a single dot '.' to stop: .<\/pre>\n\n==[[:Category:PL\/I|PL\/I]][[Category:PL\/I]]==\n<lang PL\/I>\n\/* Plays the game of 24. *\/\n\nTWENTYFOUR: procedure options (main);            \/* 14 August 2010 *\/\n\nCTP: procedure (E) returns (character(50) varying);\n   declare E character (*) varying;\n   declare OUT character (length(E)) varying;\n   declare S character (length(E)) varying controlled;\n   declare c character (1);\n   declare i fixed binary;\n\n\/* This procedure converts an arithmetic expression to Reverse Polish Form. *\/\n\/* A push-down pop-up stack is used for operators. *\/\npriority: procedure (a) returns (fixed decimal (1));\n   declare a character (1);\n   declare ops character (10) initial ('#+-*\/') varying static;\n   declare pri(6) fixed decimal (1) initial (1,2,2,3,3,4) static;\n   declare i fixed binary;\n\n   i = index(ops,a);\n   return (pri(i));\nend priority;\n\n   allocate S; S = '#'; out = '';\n   do i = 1 to length(E);\n      c = substr(E, i, 1);\n      if index('+-*\/', c) > 0 then\n         do;\n            \/* Copy any higher priority operators on the stack to the output. *\/\n            do while ( priority(c) <= priority((S)) );\n               out = out || S;\n               free S;\n            end;\n            \/* Copy the input character to the stack. *\/\n            allocate S; S = c;\n         end;\n\n      if index('123456789', c) > 0 then\n         out = out || c;\n   end;\n   do while (allocation(S) > 1);\n      out = out || s;\n      free S;\n   end;\n   return (out);\nend CTP;\n\n\/* Given a push-down pop-up stack, and an expresion in  *\/\n\/* Reverse Polish notation, evaluate the expression.    *\/\nEVAL: procedure (E) returns (fixed decimal(15));\n   declare E character (*) varying;\n   declare S fixed decimal (15) controlled;\n   declare (a, b) fixed decimal (15);\n   declare c character (1);\n   declare p fixed binary;\n   declare (empty_stack, invalid_expression) condition;\n\n   on condition (empty_stack) begin;\n      put skip list ('Your expression is not valid.');\n      stop;\n   end;\n   on condition (invalid_expression) begin;\n      put skip list ('Your expression is not valid.');\n      stop;\n   end;\n\n   do p = 1 to length(E);\n      c = substr(E, p, 1);\n      if index('123456789', c) > 0 then\n         do; allocate S; S = c; end;\n      else\n         do;\n            if allocation(S) = 0 then signal condition (empty_stack);\n            b = S; free S;\n            if allocation(S) = 0 then signal condition (empty_stack);\n            a = S;\n            select (c);\n               when ('+') S = a + b; \n               when ('-') S = a - b;\n               when ('*') S = a * b;\n               when ('\/') S = a \/ b;\n               when ('^') S = a ** b;\n               otherwise signal condition (invalid_expression);\n            end;\n         end;\n   end;\n   if allocation(S) ^= 1 then signal condition (invalid_expression);\n   return (S);\nEND eval;\n\n\/* Check that the player has used every digit and no others. *\/\nVALIDATE: procedure (E);\n   declare E character (*) varying;\n   declare E2 character (length(E)), (i, j) fixed binary;\n   declare digits(9) character (1) static initial\n      ('1', '2', '3', '4', '5', '6', '7', '8', '9');\n\n   E2 = translate(E, '    ', '+-*\/' );\n   do i = 1 to 4;\n      j = index(E2, digits(k(i)));\n      if j > 0 then\n         substr(E2, j, 1) = ' ';\n      else\n         do; put skip list ('You must use the digits supplied.'); stop; end;\n   end;\n   if E2 ^= '' then\n      do; put skip list ('You must use every digit supplied, and no others.'); stop; end;\nend VALIDATE;\n\n   declare E character (40) varying;\n   declare k(4) fixed decimal;\n   declare (time, random) builtin;\n   declare V fixed decimal (15);\n\n   k = random(TIME);\n   k = 9*random() + 1;\n   put skip edit ('Here are four integers:', k) (a);\n   put skip list ('With these integers, make up an arithmetic expression' ||\n      ' that evaluates to 24.');\n   put skip list ('You can use any of the operators +, -, *, and \/');\n   put skip list ('E.g., Given the integers 1, 3, 7, and 6,' ||\n      ' the expression 6*3+7-1 evaluates to 24.');\n\n   put skip list ('Please type an arithmetic expression :');\n   get edit (E) (L) COPY;\n\n   CALL VALIDATE (E); \/* Check that the player has used every digit and no others. *\/\n\n   E = CTP(E);\n   V = EVAL (E);\n   if V = 24 then\n      put skip list ('Congratulations: the expression evaluates to 24.');\n   else\n      put skip edit ('The result is ', trim(V), ' which is not correct') (a);\n\nend TWENTYFOUR;\n<\/lang>\n\n==[[:Category:PowerShell|PowerShell]][[Category:PowerShell]]==\nThe \"isNumeric\" function was taken from the \"Determine_if_a_string_is_numeric\" task.\n\ntodo: add a validation that all given digits were used. Right now the validation is that 4 digits should be used in the expression, but not exactly the ones given. (example: if you are given the digits 2, 2, 6, 9 this program accepts the following solution: 6 * '''4''' * 2 \/ 2)\n\n<lang powershell>\nCLS\n\nFunction isNumeric ($x)\n{\n    $x2 = 0    \n    $isNum = [System.Int32]::TryParse($x,[ref]$x2)\nReturn $isNum\n}\n\n$NumberOne = Random -Maximum 10 -Minimum 1\n$NumberTwo = Random -Maximum 10 -Minimum 1\n$NumberThree = Random -Maximum 10 -Minimum 1\n$NumberFour = Random -Maximum 10 -Minimum 1\n$NumberArray = @()\n$NumberArray += $NumberOne\n$NumberArray += $NumberTwo\n$NumberArray += $NumberThree\n$NumberArray += $NumberFour\n\nWrite-Host \"Welcome to the 24 game!`n`nHere are your numbers: $NumberOne,$NumberTwo,$NumberThree and $NumberFour.`nUse division, multiplication, subtraction and addition to get 24 as a result with these 4 numbers.`n\"\n\nDo\n{\n$Wrong = 0\n$EndResult = $null\n$TempChar = $null\n$TempChar2 = $null\n$Count = $null\n    $Result = Read-Host\n        Foreach($Char in $Result.ToCharArray())\n        {\n            Switch($Char)\n            {\n                $NumberOne\n                {\n                }\n                $NumberTwo\n                {\n                }\n                $NumberThree\n                {\n                }\n                $NumberFour\n                {\n                }\n                \"+\"\n                {\n                }\n                \"-\"\n                {\n                }\n                \"*\"\n                {\n                }\n                \"\/\"\n                {\n                }\n                \"(\"\n                {\n                }\n                \")\"\n                {\n                }\n                \" \"\n                {\n                }\n                Default\n                {\n                    $Wrong = 1\n                }\n            }\n        }\n        If($Wrong -eq 1)\n        {\n            Write-Warning \"Wrong input! Please use only the given numbers.\"\n        }\n        Foreach($Char in $Result.ToCharArray())\n        {\n            If((IsNumeric $TempChar) -AND (IsNumeric $Char))\n            {\n                Write-Warning \"Wrong input! Combining two or more numbers together is not allowed!\"\n            }\n            $TempChar = $Char\n        }\n        Foreach($Char in $Result.ToCharArray())\n        {\n            If(IsNumeric $Char)\n            {\n                $Count++\n            }\n        }\n        If($Count -eq 4)\n        {\n            $EndResult = Invoke-Expression $Result\n                If($EndResult -eq 24)\n                {\n                    Write-Host \"`nYou've won the game!\"\n                }\n                Else\n                {\n                    Write-Host \"`n$EndResult is not 24! Too bad.\"\n                }\n        }\n        Else\n        {\n            Write-Warning \"Wrong input! You did not supply four numbers.\"\n        }\n}\nWhile($EndResult -ne 24)\n<\/lang>\n\n==[[:Category:ProDOS|ProDOS]][[Category:ProDOS]]==\n==Note==\nThis example uses the math module:\n<lang ProDOS>:a\neditvar \/modify -random- = <10\nprintline These are your four digits: -random- -random- -random- -random-\nprintline Use an algorithm to make the number 24.\neditvar \/newvar \/value=a \/userinput=1 \/title=Algorithm:\ndo -a-\nif -a- \/hasvalue 24 printline Your algorithm worked! & goto :b (\n) else printline Your algorithm did not work.\n:b \neditvar \/newvar \/value=b \/userinput=1 \/title=Do you want to play again?\nif -b- \/hasvalue y goto :a else exitcurrentprogram<\/lang>\n\n==[[:Category:PureBasic|PureBasic]][[Category:PureBasic]]==\n<lang PureBasic>#digitCount = 4\nGlobal Dim digits(#digitCount - 1) ;holds random digits\n\nProcedure showDigits()\n  Print(#CRLF$ + \"These are your four digits: \")\n  Protected i\n  For i = 0 To #digitCount - 1\n    Print(Str(digits(i)))\n    If i < (#digitCount - 1)\n      Print(\", \")\n    Else\n      PrintN(\"\")\n    EndIf\n  Next\n  Print(\"24 = \")\nEndProcedure\n\nProcedure playAgain()\n  Protected answer.s\n  Repeat \n    Print(\"Play again (y\/n)? \")\n    answer = LCase(Left(Trim(Input()), 1))\n    Select answer\n      Case \"n\"\n        ProcedureReturn #False\n      Case \"y\"\n        ProcedureReturn #True\n      Default\n        PrintN(\"\")\n        Continue\n    EndSelect\n  ForEver\nEndProcedure\n\nProcedure allDigitsUsed()\n  Protected i\n  For i = 0 To #digitCount - 1\n    If digits(i) <> 0\n      ProcedureReturn #False\n    EndIf\n  Next \n  ProcedureReturn #True \nEndProcedure\n\nProcedure isValidDigit(d)\n  For i = 0 To #digitCount - 1\n    If digits(i) = d\n      digits(i) = 0\n      ProcedureReturn #True\n    EndIf \n  Next \n  ProcedureReturn #False\nEndProcedure\n\nProcedure doOperation(List op.c(), List operand.f())\n  Protected x.f, y.f, op.c\n  op = op(): DeleteElement(op())\n  If op = '('\n    ProcedureReturn #False ;end of sub-expression\n  EndIf \n  \n  y = operand(): DeleteElement(operand())\n  x = operand()\n  Select op\n    Case '+'\n      x + y\n    Case '-'\n      x - y\n    Case '*' \n      x * y\n    Case '\/' \n      x \/ y\n  EndSelect\n  operand() = x\n  ProcedureReturn #True ;operation completed\nEndProcedure \n\n;returns error if present and the expression results in *result\\f\nProcedure.s parseExpression(expr.s, *result.Float)\n  NewList op.c()\n  NewList operand.f()\n  expr = ReplaceString(expr, \" \", \"\") ;remove spaces\n  \n  If Len(expr) = 0: *result\\f = 0: ProcedureReturn \"\": EndIf ;no expression, return zero\n  \n  Protected *ech.Character = @expr, lastWasDigit, lastWasOper, parenCheck, c.c\n  While *ech\\c\n    c = *ech\\c\n    Select c\n      Case '*', '\/', '-', '+'\n        If Not lastWasDigit: ProcedureReturn \"Improper syntax, need a digit between operators.\": EndIf\n        If ListSize(op()) And (FindString(\"*\/\", Chr(op()), 1) Or (FindString(\"+-\", Chr(op()), 1) And FindString(\"+-\", Chr(c), 1)))\n          doOperation(op(), operand())\n        EndIf \n        AddElement(op()): op() = c\n        lastWasOper = #True: lastWasDigit = #False\n      Case '('\n        If lastWasDigit: ProcedureReturn \"Improper syntax, need an operator before left paren.\": EndIf\n        AddElement(op()): op() = c\n        parenCheck + 1: lastWasOper = #False\n      Case ')'\n        parenCheck - 1: If parenCheck < 0: ProcedureReturn \"Improper syntax, missing a left paren.\": EndIf\n        If Not lastWasDigit: ProcedureReturn \"Improper syntax, missing a digit before right paren.\": EndIf\n        Repeat: Until Not doOperation(op(),operand())\n        lastWasDigit = #True\n      Case '1' To '9'\n        If lastWasDigit: ProcedureReturn \"Improper syntax, need an operator between digits.\": EndIf\n        AddElement(operand()): operand() = c - '0'\n        If Not isValidDigit(operand()): ProcedureReturn \"'\" + Chr(c) + \"' is not a valid digit.\": EndIf\n        lastWasDigit = #True: lastWasOper = #False\n      Default\n        ProcedureReturn \"'\" + Chr(c) + \"' is not allowed in the expression.\"\n    EndSelect\n    *ech + SizeOf(Character)\n  Wend \n  \n  If parenCheck <> 0 Or lastWasOper: ProcedureReturn \"Improper syntax, missing a right paren or digit.\": EndIf\n  Repeat\n    If Not ListSize(op()): Break: EndIf\n  Until Not doOperation(op(),operand())\n  *result\\f = operand()\n  ProcedureReturn \"\" ;no error\nEndProcedure\n\nDefine success, failure, result.f, error.s, i\nIf OpenConsole()\n  PrintN(\"The 24 Game\" + #CRLF$)\n  PrintN(\"Given four digits and using just the +, -, *, and \/ operators; and the\")\n  PrintN(\"possible use of brackets, (), enter an expression that equates to 24.\")\n  Repeat\n    For i = 0 To #digitCount - 1\n      digits(i) = 1 + Random(8)\n    Next\n    \n    showDigits()\n    error = parseExpression(Input(), @result)\n    If error = \"\"\n      If Not allDigitsUsed()\n        PrintN( \"Wrong! (you didn't use all digits)\"): failure + 1\n      ElseIf result = 24.0\n        PrintN(\"Correct!\"): success + 1\n      Else\n        Print(\"Wrong! (you got \")\n        If result <> Int(result)\n          PrintN(StrF(result, 2) + \")\")\n        Else\n          PrintN(Str(result) + \")\")\n        EndIf \n        failure + 1\n      EndIf \n    Else\n      PrintN(error): failure + 1\n    EndIf \n  Until Not playAgain()\n  \n  PrintN(\"success:\" + Str(success) + \" failure:\" + Str(failure) + \" total:\" + Str(success + failure))\n  \n  Print(#CRLF$ + \"Press ENTER to exit\"): Input()\n  CloseConsole()\nEndIf<\/lang>\nSample output:\n<pre>The 24 Game\n\nGiven four digits and using just the +, -, *, and \/ operators; and the\npossible use of brackets, (), enter an expression that equates to 24.\n\nThese are your four digits: 9, 2, 8, 7\n24 = 9*8\/2-7\nWrong! (you got 29)\nPlay again (y\/n)? y\n\nThese are your four digits: 5, 5, 5, 6\n24 = 5*5+5-6\nCorrect!\nPlay again (y\/n)? n\nsuccess:1 failure:1 total:2<\/pre>\n\n==[[:Category:Python|Python]][[Category:Python]]==\nUses eval, the in-built expression evaluator of infix expressions.\n<lang python>'''\n The 24 Game\n\n Given any four digits in the range 1 to 9, which may have repetitions,\n Using just the +, -, *, and \/ operators; and the possible use of\n brackets, (), show how to make an answer of 24.\n\n An answer of \"q\" will quit the game.\n An answer of \"!\" will generate a new set of four digits.\n Otherwise you are repeatedly asked for an expression until it evaluates to 24\n\n Note: you cannot form multiple digit numbers from the supplied digits,\n so an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.\n\n'''\n\nfrom __future__ import division, print_function\nimport random, ast, re\nimport sys\n\nif sys.version_info[0] < 3: input = raw_input\n\ndef choose4():\n    'four random digits >0 as characters'\n    return [str(random.randint(1,9)) for i in range(4)]\n\ndef welcome(digits):\n    print (__doc__)\n    print (\"Your four digits: \" + ' '.join(digits))\n\ndef check(answer, digits):\n    allowed = set('() +-*\/\\t'+''.join(digits))\n    ok = all(ch in allowed for ch in answer) and \\\n         all(digits.count(dig) == answer.count(dig) for dig in set(digits)) \\\n         and not re.search('\\d\\d', answer)\n    if ok:\n        try:\n            ast.parse(answer)\n        except:\n            ok = False\n    return ok\n\ndef main():    \n    digits = choose4()\n    welcome(digits)\n    trial = 0\n    answer = ''\n    chk = ans = False\n    while not (chk and ans == 24):\n        trial +=1\n        answer = input(\"Expression %i: \" % trial)\n        chk = check(answer, digits)\n        if answer.lower() == 'q':\n            break\n        if answer == '!':\n            digits = choose4()\n            print (\"New digits:\", ' '.join(digits))\n            continue\n        if not chk:\n            print (\"The input '%s' was wonky!\" % answer)\n        else:\n            ans = eval(answer)\n            print (\" = \", ans)\n            if ans == 24:\n                print (\"Thats right!\")\n    print (\"Thank you and goodbye\")   \nmain()<\/lang>\n\n'''Sample Output'''\n<pre>\n The 24 Game\n\n Given any four digits in the range 1 to 9, which may have repetitions,\n Using just the +, -, *, and \/ operators; and the possible use of\n brackets, (), show how to make an answer of 24.\n\n An answer of \"q\" will quit the game.\n An answer of \"!\" will generate a new set of four digits.\n\n Note: you cannot form multiple digit numbers from the supplied digits,\n so an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.\n\n\nYour four digits: 3 2 4 6\nExpression 1: (3 - 1)*(6*4)\nThe input '(3 - 1)*(6*4)' was wonky!\nExpression 2: (3 - 2) * 6 * 4\n =  24\nThats right!\nThank you and goodbye<\/pre>\n\n==[[:Category:R|R]][[Category:R]]==\nThis makes use of R's metaprogramming (parse, eval, etc.). It uses parse to obtain a parse tree, which is scanned for containing only permitted elements before evaluating.\n\n<lang r>twenty.four <- function(operators=c(\"+\", \"-\", \"*\", \"\/\", \"(\"),\n                        selector=function() sample(1:9, 4, replace=TRUE),\n                        arguments=selector(),\n                        goal=24) {\n  newdigits <- function() {\n    arguments <<- selector()\n    cat(\"New digits:\", paste(arguments, collapse=\", \"), \"\\n\")\n  } \n  help <- function() cat(\"Make\", goal,\n      \"out of the numbers\",paste(arguments, collapse=\", \"),\n      \"and the operators\",paste(operators, collapse=\", \"), \".\",\n      \"\\nEnter 'q' to quit, '!' to select new digits,\",\n      \"or '?' to repeat this message.\\n\")\n  help()\n  repeat {\n    switch(input <- readline(prompt=\"> \"),\n           q={ cat(\"Goodbye!\\n\"); break },\n           `?`=help(),\n           `!`=newdigits(),\n           tryCatch({\n             expr <- parse(text=input, n=1)[[1]]\n             check.call(expr, operators, arguments)\n             result <- eval(expr)\n             if (isTRUE(all.equal(result, goal))) {\n               cat(\"Correct!\\n\")\n               newdigits()\n             } else {\n               cat(\"Evaluated to\", result, \"( goal\", goal, \")\\n\")\n             }\n           },error=function(e) cat(e$message, \"\\n\")))\n  }\n}\n\ncheck.call <- function(expr, operators, arguments) {\n  unexpr <- function(x) {\n    if (is.call(x))\n      unexpr(as.list(x))\n    else if (is.list(x))\n      lapply(x,unexpr)\n    else x\n  }\n  leaves <- unlist(unexpr(expr))\n  if (any(disallowed <-\n          !leaves %in% c(lapply(operators, as.name),\n                         as.list(arguments)))) {\n    stop(\"'\", paste(sapply(leaves[disallowed], as.character),\n                    collapse=\", \"),\n         \"' not allowed. \")\n  }\n  numbers.used <- unlist(leaves[sapply(leaves, mode) == 'numeric'])\n  \n  if (! isTRUE(all.equal(sort(numbers.used), sort(arguments))))\n   stop(\"Must use each number once.\")\n}<\/lang>\nExample Session\n<lang r>> twenty.four()\n\nMake 24 out of the numbers 1, 6, 7, 5 and the operators +, -, *, \/, ( . \nEnter 'q' to quit, '!' to select new digits, or '?' to repeat this message.\n> 6*(5-1)\nMust use each number once. \n> 1 + 6*5 - 7\nCorrect!\nNew digits: 7, 2, 9, 3 \n> (7+9)\/2*3\nCorrect!\nNew digits: 1, 4, 1, 7 \n> 4*(7-1)\nMust use each number once. \n> (7-1)*4*1\nCorrect!\nNew digits: 1, 5, 2, 8 \n> (5-1)^2+8\n'^' not allowed.\n> !\nNew digits: 2, 8, 5, 2 \n> 52-28\n'52, 28' not allowed.\n> (8-2)*(5-2\/2)\nMust use each number once. \n> (8+2)*2+5\nEvaluated to 25 ( goal 24 )\n> q\nGoodbye!\n<\/lang>\n\n==[[:Category:REXX|REXX]][[Category:REXX]]==\n<lang rexx>\/*REXX program to play the game of  24.                             *\/\n\/*------------------------------------------------------------------+\n | Argument is either of three forms:   (blank)                     |\n |                                      ssss                        |\n |                                      ssss-ffff                   |\n |                                                                  |\n | where one or both strings must be exactly four numerals (digits) |\n | comprised soley of the numerals (digits)  1 --> 9   (no zeroes). |\n |                                                                  |\n |                                      SSSS  is the start,         |\n |                                      FFFF  is the start.         |\n |                                                                  |\n | If no argument is specified, this program finds a four digit     |\n | number (no zeroes) which has at least one solution, and shows    |\n | the number to the user, requesting that they enter a solution    |\n | in the form of:    a  operator  b  operator  c  operator  d      |\n | where  a  b  c  and  d  are single digit numbers  (no zeroes),   |\n | and    operator  can be any one of:     +    -    *    or    \/   |\n | Parentheses ()  may be used in the normal manner for grouping,   |\n | as well as brackets []  or braces  {}.                           |\n +------------------------------------------------------------------*\/\nparse arg orig               \/*get the  guess  from the argument.   *\/\norig=space(orig,0)           \/*remove extraneous blanks from  ORIG. *\/\nparse var orig start '-' finish    \/*get the start & finish (maybe).*\/\nfinish=word(finish start,1)  \/*if no  FINISH  specified, use  START.*\/\nopers='+-*\/'                 \/*define the legal arithmetic operators*\/\nops=length(opers)            \/* ... and the count of them (length). *\/\ngroupsymbols='()[]{}'        \/*legal grouping symbols.              *\/\nindent=left('',30)           \/*used to indent display of solutions. *\/\nLpar='('                     \/*a string to make REXX code prettier. *\/\nRpar=')'                     \/*ditto.                               *\/\nshow=1                       \/*flag used show solutions  (0 = not). *\/\ndigs=123456789               \/*numerals (digits) that can be used.  *\/\n\n  do j=1 for ops             \/*define a version for fast execution. *\/\n  o.j=substr(opers,j,1)\n  end   \/*j*\/\n\nif orig\\=='' then do\n                  sols=solve(start,finish)\n                  if sols<0 then exit 13\n                  if sols==0 then sols='No'         \/*un-geek SOLS.*\/\n                  say\n                  say sols 'unique solution's(finds) \"found for\" orig     \/*pluralize.*\/\n                  exit\n                  end\nshow=0                       \/*stop SOLVE from blabbing solutions. *\/\n        do forever\n        rrrr=random(1111,9999)\n        if pos(0,rrrr)\\==0 then iterate\n        if solve(rrrr)\\==0 then leave\n        end\nshow=1                       \/*enable SOLVE to show solutions.     *\/\nrrrr=sort(rrrr)              \/*sort four elements.                 *\/\nrd.=0\n        do j=1 for 9         \/*digit count # for each digit in RRRR*\/\n        _=substr(rrrr,j,1)\n        rd._=countdigs(rrrr,_)\n        end   \/*j*\/\n\n  do guesses=1;   say\n  say 'Using the digits',\n       rrrr\", enter an expression that equals 24 (or QUIT):\"\n  pull y\n  y=space(y,0);    if y=='QUIT' then exit\n  _v=verify(y,digs||opers||groupsymbols)\n  if _v\\==0 then do\n                 call ger 'invalid character:' substr(_v,1)\n                 iterate\n                 end\n  yl=length(y)\n  if y='' then do\n               call validate y\n               iterate\n               end\n\n    do j=1 to yl-1\n    _=substr(y,j,1)\n    if \\datatype(_,'W') then iterate\n    _=substr(y,j+1,1)\n    if datatype(_,'W') then do\n                            call ger 'invalid use of digit abuttal'\n                            iterate guesses\n                            end\n    end   \/*j*\/\n\n  yd=countdigs(y,digs)                  \/*count of digits 123456789.*\/\n  if yd<4 then do\n               call ger 'not enough digits entered.'\n               iterate guesses\n               end\n  if yd>4 then do\n               call ger 'too many digits entered.'\n               iterate guesses\n               end\n\n    do j=1 for 9\n    if rd.j==0 then iterate\n    _d=countdigs(y,j)\n    if _d==rd.j then iterate\n    if _d<rd.j then call ger 'not enough' j \"digits, must be\" rd.j\n               else call ger 'too many' j \"digits, must be\" rd.j\n    iterate guesses\n    end   \/*j*\/\n\n  y=translate(y,'()()',\"[]{}\")\n  signal on syntax\n  interpret 'ans='y\n  ans=ans\/1\n  if ans==24 then leave guesses\n  say 'incorrect,' y'='ans\n  end   \/*guesses*\/\n\nsay\nsay center('+---------------------+',79)\nsay center('|                     |',79)\nsay center('|  congratulations !  |',79)\nsay center('|                     |',79)\nsay center('+---------------------+',79)\nexit\n\nsyntax: call ger 'illegal syntax in' y; exit\n\/*---------------------------SOLVE subroutine-----------------------*\/\nsolve: parse arg ssss,ffff   \/*parse the argument passed to  SOLVE. *\/\nif ffff=='' then ffff=ssss   \/*create a   FFFF   if necessary.      *\/\nif \\validate(ssss) then return -1\nif \\validate(ffff) then return -1\nfinds=0                      \/*number of found solutions (so far).  *\/\nx.=0                         \/*a method to hold unique expressions. *\/\n                             \/*alternative:  indent=copies(' ',30)  *\/\n\n  do g=ssss to ffff          \/*process a (possible) range of values.*\/\n  if pos(0,g)\\==0 then iterate   \/*ignore values with zero in them. *\/\n\n      do j=1 for 4           \/*define a version for fast execution. *\/\n      g.j=substr(g,j,1)\n      end   \/*j*\/\n\n    do i=1 for ops           \/*insert an operator after 1st number. *\/\n      do j=1 for ops         \/*insert an operator after 2nd number. *\/\n        do k=1 for ops       \/*insert an operator after 2nd number. *\/\n          do m=0 to 4-1\n          L.=                \/*assume no left parenthesis so far.   *\/\n            do n=m+1 to 4    \/*match left paren with a right paren. *\/\n            L.m=Lpar         \/*define a left paren, m=0 means ignore*\/\n            R.=''            \/*un-define all right parenthesis.     *\/\n            if m==1 & n==2 then L.=''   \/*special case:  (n)+ ...   *\/\n                           else if m\\==0 then R.n=Rpar  \/*no (, no )*\/\n            e=L.1 g.1 o.i L.2 g.2 o.j L.3 g.3 R.3 o.k g.4 R.4\n            e=space(e,0)     \/*remove all blanks from the expression*\/\n\n                             \/*(below) change expression:           *\/\n                             \/*       \/(yyy)   ===>   \/div(yyy)     *\/\n                             \/*Enables to check for division by zero*\/\n            origE=e          \/*keep old version for the display.    *\/\n            if pos('\/(',e)\\==0 then e=changestr('\/(',e,\"\/div(\")\n                             \/*The above could be replaced by:      *\/\n                             \/*   e=changestr('\/(',e,\"\/div(\")       *\/\n\n                                 \/*INTERPRET stresses REXX's groin, *\/\n                                 \/*so try to avoid repeated lifting.*\/\n            if x.e then iterate  \/*was the expression already used? *\/\n            x.e=1                \/*mark this expression as unique.  *\/\n                                 \/*have REXX do the heavy lifting.  *\/\n            interpret 'x='e\n            x=x\/1                \/*remove trailing decimal points.  *\/\n            if x\\==24 then iterate        \/*Not correct?  Try again.*\/\n            finds=finds+1        \/*bump number of found solutions.  *\/\n            _=translate(origE,'][',\")(\")       \/*show  [],  not  ().*\/\n            if show then say indent 'a solution:' _  \/*show solution*\/\n            end   \/*n*\/\n          end     \/*m*\/\n        end       \/*k*\/\n      end         \/*j*\/\n    end           \/*i*\/\n  end             \/*g*\/\n\nreturn finds\n\/*---------------------------DIV subroutine-------------------------*\/\ndiv: procedure; parse arg q  \/*tests if dividing by  0  (zero).     *\/\nif q=0 then q=1e9            \/*if dividing by zero, change divisor. *\/\nreturn q                     \/*changing Q invalidates the expression*\/\n\/*---------------------------COUNTDIGS subroutine-------------------*\/\ncountdigs: arg field,numerals            \/*count of digits NUMERALS.*\/\nreturn length(field)-length(space(translate(field,,numerals),0))\n\/*---------------------------GER subroutine-------------------------*\/\nger: say; say '*** error! *** for argument:' y; say arg(1); say; errCode=1; return 0\n\/*---------------------------SORT subroutine------------------------*\/\nsort: procedure ; arg nnnn\nL=length(nnnn)\n\n     do j=1 for L             \/*build an array of digits from  NNNN.*\/\n     a.j=substr(nnnn,j,1)     \/*this enables SORT to sort an array. *\/\n     end\n\n  do j=1 for L\n  _=a.j\n    do k=j+1 to L\n    if a.k<_ then do; a.j=a.k; a.k=_; _=a.k; end\n    end   \/*k*\/\n  end     \/*j*\/\nreturn a.1 || a.2 || a.3 || a.4\n\/*---------------------------validate subroutine--------------------*\/\nvalidate: parse arg y; errCode=0; _v=verify(y,digs)\n  select\n  when y==''        then call ger 'no digits entered.'\n  when length(y)<4  then call ger 'not enough digits entered, must be 4'\n  when length(y)>4  then call ger 'too many digits entered, must be 4'\n  when pos(0,y)\\==0 then call ger \"can't use the digit  0 (zero)\"\n  when _v\\==0       then call ger 'illegal character:' substr(y,_v,1)\n  otherwise nop\n  end    \/*select*\/\nreturn \\errCode\n\/*---------------------------S subroutine---------------------------*\/\ns:if arg(1)=1 then return ''; return 's'        \/*simple pluralizer.*\/<\/lang>\n\n==[[:Category:Ruby|Ruby]][[Category:Ruby]]==\n<lang ruby>require \"rational\"\n\ndef play\n  digits = Array.new(4) {1+rand(9)}\n  loop do\n    guess = get_guess(digits)\n    result = evaluate(guess)\n    if result == 24.0\n      puts \"yes!\"\n      break\n    else\n      puts \"nope: #{guess} = #{result}\"\n      puts \"try again\"\n    end\n  end\nend\n\ndef get_guess(digits)\n  loop do\n    print \"\\nEnter your guess using #{digits.inspect}: \"\n    guess = $stdin.gets.chomp\n\n    # ensure input is safe to eval\n    invalid_chars = guess.scan(%r{[^\\d\\s()+*\/-]})\n    unless invalid_chars.empty?\n      puts \"invalid characters in input: #{invalid_chars.inspect}\"\n      next\n    end\n\n    guess_digits = guess.scan(\/\\d\/).map {|ch| ch.to_i}\n    if guess_digits.sort != digits.sort\n      puts \"you didn't use the right digits\"\n      next\n    end\n\n    if guess.match(\/\\d\\d\/)\n      puts \"no multi-digit numbers allowed\"\n      next\n    end\n\n    return guess\n  end\nend\n\n# convert expression to use rational numbers, evaluate, then return as float\ndef evaluate(guess)\n  as_rat = guess.gsub(\/(\\d)\/, 'Rational(\\1,1)')\n  begin\n    eval \"(#{as_rat}).to_f\"\n  rescue SyntaxError\n    \"[syntax error]\"\n  end\nend\n\nplay<\/lang>\n\n==[[:Category:Scala|Scala]][[Category:Scala]]==\nThe solution below is much more complex than strictly needed, because it shows off\nScala's Parser library, which enables easy construction of parsers from\nEBNF grammars.\n\nOnly problems with solution are shown to the user.\n<div style='width: full; overflow: scroll'><lang scala>object TwentyFourGame {\n  def main(args: Array[String]) {\n    import Parser.TwentyFourParser\n    \n    println(welcome)\n    \n    var parser = new TwentyFourParser(problemsIterator.next)\n    println(\"Your four digits: \"+parser+\".\")\n    \n    var finished = false\n    var expressionCount = 1\n    do {\n      val line = Console.readLine(\"Expression \"+expressionCount+\": \")\n      line match {\n        case \"!\" =>\n          parser = new TwentyFourParser(problemsIterator.next)\n          println(\"New digits: \"+parser+\".\")\n          \n        case \"q\" =>\n          finished = true\n        \n        case _ =>\n          parser readExpression line match {\n            case Some(24) => println(\"That's right!\"); finished = true\n            case Some(n) => println(\"Sorry, that's \"+n+\".\")\n            case None =>\n          }\n      }\n      expressionCount += 1\n    } while (!finished)\n    \n    println(\"Thank you and goodbye!\")\n  }\n  \n  val welcome = \"\"\"|The 24 Game\n                   |\n                   |Given any four digits in the range 1 to 9, which may have repetitions,\n                   |Using just the +, -, *, and \/ operators; and the possible use of\n                   |brackets, (), show how to make an answer of 24.\n                   |\n                   |An answer of \"q\" will quit the game.\n                   |An answer of \"!\" will generate a new set of four digits.\n                   |Otherwise you are repeatedly asked for an expression until it evaluates to 24\n                   |\n                   |Note: you cannot form multiple digit numbers from the supplied digits,\n                   |so an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.\n                   |\"\"\".stripMargin\n  \n  val problemsIterator = (\n    Iterator \n    continually List.fill(4)(scala.util.Random.nextInt(9) + 1 toDouble) \n    filter hasSolution\n  )\n  \n  def hasSolution(l: List[Double]) = permute(l) flatMap computeAllOperations exists (_ == 24)\n  \n  def computeAllOperations(l: List[Double]): List[Double] = l match {\n    case Nil => Nil\n    case x :: Nil => l\n    case x :: xs =>\n      for {\n        y <- computeAllOperations(xs)\n        z <- if (y == 0) List(x*y, x+y, x-y) else List(x*y, x\/y, x+y, x-y)\n      } yield z\n  }\n  \n  def permute(l: List[Double]): List[List[Double]] = l match {\n    case Nil => List(Nil)\n    case x :: xs =>\n      for {\n        ys <- permute(xs)\n        position <- 0 to ys.length\n        (left, right) = ys splitAt position\n      } yield left ::: (x :: right)\n  }\n  \n  object Parser {\n    \/*  Arithmetic expression grammar production rules in EBNF form:\n     *\n     * <expr> --> <term> ( '+' <term> | '-' <term> )*\n     * <term> --> <factor> ( '*'  <factor> | '\/'  <factor> )*\n     * <factor> --> '(' <expr> ')' | <digit>\n     * <digit> --> 0 | 1  | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9\n     * \n     * Semantically, <digit> can only be a digit from the list of remaining digits.\n     *\/\n    \n    class TwentyFourParser(digits: List[Double]) extends scala.util.parsing.combinator.RegexParsers {\n      require(digits.length == 4 && digits.forall(d => 0 <= d && d <= 9))\n      override val toString = digits.map(_.toInt).mkString(\", \")\n      \n      \/\/ Grammar\n      def exprConsumingAllDigits = expr ^? (remainingDigits.allDigitsConsumed, digitsRemainingError) \/\/ Guarantees all digits consumed\n      def expr : Parser[Double] = term ~ rep( \"+\" ~ term | \"-\" ~ term) ^^ solveOperationChain\n      def term = factor ~ rep( \"*\" ~ factor | \"\/\" ~ factor) ^^ solveOperationChain\n      def factor = \"(\" ~> expr <~ \")\" | digit\n      def digit = digitRegex ^? (remainingDigits.consumeDigit, digitNotAllowedError) \n      def digitRegex = \"\\\\d\".r | digitExpected\n      def digitExpected: Parser[String] = \".\".r <~ failure(expectedDigitError) \/\/ Produces clear error messages\n    \n      \/\/ Evaluate expressions\n      def readExpression(input: String): Option[Double] = {\n        remainingDigits = new DigitList(digits) \/\/ Initialize list of digits to be consumed\n        parseAll(exprConsumingAllDigits, input) match {\n          case Success(result, _) => Some(result)\n          case NoSuccess(msg, next) =>\n            println(ParsingErrorFormatter(msg, next))\n            None\n        }\n      }\n      \n      \/\/ List of digits to be consumed\n      private var remainingDigits: DigitList = _\n      \n      \/\/ Solve partial results from parsing\n      private def solveOperationChain(partialResult: ~[Double,List[~[String,Double]]]): Double = partialResult match {\n        case first ~ chain => chain.foldLeft(first)(doOperation)\n      }\n      private def doOperation(acc: Double, op: ~[String, Double]): Double = op match {\n        case \"+\" ~ operand => acc + operand\n        case \"-\" ~ operand => acc - operand\n        case \"*\" ~ operand => acc * operand\n        case \"\/\" ~ operand => acc \/ operand\n        case x => error(\"Unknown operation \"+x+\".\") \n      }\n      \n      \/\/ Error messages\n      private def digitNotAllowedError(d: String) = \"Digit \"+d+\" is not allowed here. Available digits: \"+remainingDigits+\".\"\n      private def digitsRemainingError(x: Any) = \"Not all digits were consumed. Digits remaining: \"+remainingDigits+\".\"\n      private def expectedDigitError = \"Unexpected input. Expected a digit from the list: \"+remainingDigits+\".\"\n    }\n    \n    private object ParsingErrorFormatter {\n      def apply[T](msg: String, next: scala.util.parsing.input.Reader[T]) =\n        \"%s\\n%s\\n%s\\n\" format (msg, next.source.toString.trim, \" \"*(next.offset - 1)+\"^\")\n    }\n    \n    private class DigitList(digits: List[Double]) {\n      private var remainingDigits = digits\n      override def toString = remainingDigits.map(_.toInt).mkString(\", \")\n      \n      def consumeDigit: PartialFunction[String, Double] = {\n        case d if remainingDigits contains d.toDouble =>\n          val n = d.toDouble\n          remainingDigits = remainingDigits diff List(n)\n          n\n      }\n      \n      def allDigitsConsumed: PartialFunction[Double, Double] = {\n        case n if remainingDigits.isEmpty => n\n      }\n    }\n  }\n}<\/lang><\/div>\n\n'''Sample Output'''\n<pre>\nC:\\Workset>scala TwentyFourGame\nThe 24 Game\n\nGiven any four digits in the range 1 to 9, which may have repetitions,\nUsing just the +, -, *, and \/ operators; and the possible use of\nbrackets, (), show how to make an answer of 24.\n\nAn answer of \"q\" will quit the game.\nAn answer of \"!\" will generate a new set of four digits.\nOtherwise you are repeatedly asked for an expression until it evaluates to 24\n\nNote: you cannot form multiple digit numbers from the supplied digits,\nso an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.\n\nYour four digits: 2, 7, 7, 2.\nExpression 1: 2*7+2+7\nSorry, that's 23.0.\nExpression 2: 7*7\/2-2\nSorry, that's 22.5.\nExpression 3: 2*7+(7-2)\nSorry, that's 19.0.\nExpression 4: 2*(7+7-2)\nThat's right!\nThank you and goodbye!\n<\/pre>\n\n==[[:Category:Scheme|Scheme]][[Category:Scheme]]==\n\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[PLT Scheme]] version 4[[SMW::on]]<\/div>\n\nThis uses read to read in a scheme expression, and eval to evaluate it, so in that sense it's not ideal (eval is evil etc.) but any expression that is valid should be safe and terminate in a timely manner.\n\n<lang scheme>#lang scheme\n(require srfi\/27 srfi\/1) ;; random-integer, every\n\n(define (play)\n  (let* ([numbers (build-list 4 (lambda (n)\n                                  (add1 (random-integer 9))))]\n         [valid?  (curryr valid? numbers)])\n    (printf startup-message numbers)\n    (let loop ([exp (read)])\n      (with-handlers ([exn:fail? (lambda (err)\n                                   (printf error-message exp (exn-message err))\n                                   (loop (read)))])\n       (cond [(eq? exp '!) (play)]\n             \n             [(or (eq? exp 'q)\n                  (eof-object? exp)) (printf quit-message)]\n             \n             [(not (valid? exp))\n              (printf bad-exp-message exp)\n              (loop (read))]\n            \n             [(not (= (eval exp) 24))\n              (printf bad-result-message exp (eval exp))\n              (loop (read))]\n            \n             [else (printf winning-message)])))))\n\n(define (valid? exp numbers)\n  ;; must contain each number exactly once and only valid symbols\n  (define (valid-symbol? sym)\n    ;; only +, -, *, and \/ are valid\n    (case sym\n      [(+ - * \/) #t]\n      [else #f]))\n  \n  (let* ([ls (flatten exp)]\n         [numbers* (filter number? ls)]\n         [symbols  (remove number? ls)])\n    (and (equal? (sort numbers <)\n                 (sort numbers* <))\n         (every valid-symbol? symbols))))\n\n(define startup-message \"\nWrite a lisp expression that evaluates to 24\nusing only (, ), +, -, *, \/\nand these four numbers: ~a\n\nor '!' to get a new set of numbers\nor 'q' to quit\")\n\n(define error-message \"\nYour expression ~a raised an exception:\n\n  \\\"~a\\\"\n\nPlease try again\")\n\n(define bad-exp-message \"Sorry, ~a is a bad expression.\")\n(define bad-result-message \"Sorry, ~a evaluates to ~a, not 24.\")\n(define quit-message \"Thanks for playing...\")\n(define winning-message \"You win!\")\n\n(provide play)\n<\/lang>\n\n'''Sample Output'''\n<pre>\n> (require \"24game.ss\")\n> (play)\n\nWrite a lisp expression that evaluates to 24\nusing only (, ), +, -, *, \/\nand these four numbers: (2 7 2 5)\n\nor '!' to get a new set of numbers\nor 'q' to quit\n!\n\nWrite a lisp expression that evaluates to 24\nusing only (, ), +, -, *, \/\nand these four numbers: (9 2 7 6)\n\nor '!' to get a new set of numbers\nor 'q' to quit\n(9 7 6 2)\n\nYour expression (9 7 6 2) raised an exception:\n\n  \"procedure application: expected procedure, given: 9; arguments were: 7 6 2\"\n\nPlease try again\n(+ 9 7 6 2)\nYou win!\n<\/pre>\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Racket]][[SMW::on]]<\/div> (PLT Scheme has been renamed to Racket, this solution may be redundant)\n<lang scheme>\n#lang racket\n\n(define (random-4)\n  (sort\n    (for\/list ((i (in-range 4)))\n      (add1 (random 9)))\n    <))\n\n(define (check-valid-chars lst-nums str)\n  (let ((regx (string-join (list\n                            \"^[\"\n                            (string-join (map number->string lst-nums) \"\")\n                            \"\\\\(\\\\)\\\\+\\\\-\\\\\/\\\\*\\\\ ]*$\")\n                           \"\")))\n    (regexp-match? regx str)))\n\n(define (check-all-numbers lst-nums str)\n  (equal?\n   (sort\n    (map (lambda (x) (string->number x))\n        (regexp-match* \"([0-9])\" str)) <)\n   lst-nums))\n\n\n(define (start-game)\n  (display \"** 24 **\\nInput \\\"q\\\" to quit or your answer in Racket notation, like (- 1 (* 3 2))\\n\\n\")\n  (new-question))\n\n(define (new-question)\n  (let ((numbers (random-4)))\n    (apply printf \"Your numbers: ~a - ~a - ~a - ~a\\n\" numbers)\n    (define (do-loop)\n      (let ((user-expr (read-line)))\n        (cond\n          ((equal? user-expr \"q\")\n           (exit))\n          ((not (check-valid-chars numbers user-expr))\n           (display \"Your expression seems invalid, please retry:\\n\")\n           (do-loop))\n          ((not (check-all-numbers numbers user-expr))\n           (display \"You didn't use all the provided numbers, please retry:\\n\")\n           (do-loop))\n          ((if (equal? 24 (eval (with-input-from-string user-expr read) (make-base-namespace)))\n               (display \"OK!!\")\n               (begin\n                 (display \"Incorrect\\n\")\n                 (do-loop)))))\n          ))\n        (do-loop)))\n\n(start-game)\n<\/lang>\n\n==[[:Category:Tcl|Tcl]][[Category:Tcl]]==\n<div class=\"examplemeta translation\">'''Translation of''': [[24 game#Python|Python]]<\/div>\nThis version also terminates cleanly on end-of-file.\n<lang tcl># Four random non-zero digits\nproc choose4 {} {\n    set digits {}\n    foreach x {1 2 3 4} {lappend digits [expr {int(1+rand()*9)}]}\n    return [lsort $digits]\n}\n\n# Print out a welcome message\nproc welcome digits {\n    puts [string trim \"\nThe 24 Game\n\nGiven any four digits in the range 1 to 9, which may have repetitions,\nUsing just the +, -, *, and \/ operators; and the possible use of\nbrackets, (), show how to make an answer of 24.\n\nAn answer of \\\"q\\\" will quit the game.\nAn answer of \\\"!\\\" will generate a new set of four digits.\nOtherwise you are repeatedly asked for an expression until it evaluates to 24\n\nNote: you cannot form multiple digit numbers from the supplied digits,\nso an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.\n    \"]\n    puts \"\\nYour four digits: $digits\"\n}\n\n# Check whether we've got a legal answer\nproc check {answer digits} {\n    if {\n\t[regexp \"\\[^-+*\/() \\t[join $digits {}]\\]\" $answer]\n\t|| [regexp {\\d\\d} $answer]\n    } then {\n\treturn false\n    }\n    set digs [lsort [regexp -inline -all {\\d} $answer]]\n    if {$digs ne $digits} {\n\treturn false\n    }\n    expr {![catch {expr $answer}]}\n}\n\n# The main game loop\nproc main {} {\n    fconfigure stdout -buffering none\n\n    set digits [choose4]\n    welcome $digits\n    set trial 0\n    while true {\n\tputs -nonewline \"Expression [incr trial]: \"\n\tgets stdin answer\n\n        # Check for various types of non-answer\n\tif {[eof stdin] || $answer eq \"q\" || $answer eq \"Q\"} {\n\t    break\n\t} elseif {$answer eq \"!\"} {\n\t    set digits [choose4]\n\t    puts \"New digits: $digits\"\n\t    continue\n\t} elseif {![check $answer $digits]} {\n\t    puts \"The input '$answer' was wonky!\"\n            continue\n\t}\n\n        # Check to see if it is the right answer\n\tset ans [expr [regsub {\\d} $answer {&.0}]]\n\tputs \" = [string trimright $ans .0]\"\n\tif {$ans == 24.0} {\n\t    puts \"That's right!\"\n            break\n\t}\n    }\n    puts \"Thank you and goodbye\"\n}\nmain<\/lang>\n==[[:Category:TUSCRIPT|TUSCRIPT]][[Category:TUSCRIPT]]==\n<lang tuscript>\n$$ MODE TUSCRIPT\nBUILD X_TABLE blanks = \":': :\"\n\nSECTION game\noperators=\"*'\/'+'-'(')\",numbers=\"\"\n\nLOOP n=1,4\nnumber=RANDOM_NUMBERS (1,9,1)\nnumbers=APPEND(numbers,number)\nENDLOOP\n\nSET allowed=APPEND (numbers,operators)\nSET allowed=MIXED_SORT (allowed)\nSET allowed=REDUCE (allowed)\nBUILD S_TABLE ALLOWED =*\nDATA '{allowed}'\n\nSET checksum=DIGIT_SORT (numbers)\n\nprintnumbers=EXCHANGE (numbers,blanks)\nprintoperat=EXCHANGE (operators,blanks)\n\nPRINT \"Your numbers \", printnumbers\nPRINT \"Use only these operators \", printoperat\nPRINT \"Enter an expression that equates to 24\"\nPRINT \"Enter 'l' for new numbers\"\nPRINT \"Your 4 digits: \",printnumbers\n\nDO play\nENDSECTION\n\nSECTION check_expr\n SET pos = VERIFY (expr,allowed)\n IF (pos!=0) THEN\n  PRINT \"wrong entry on position \",pos\n  DO play\n  STOP\n ELSE\n  SET yourdigits   = STRINGS (expr,\":>\/:\")\n  SET yourchecksum = DIGIT_SORT (yourdigits)\n   IF (checksum!=yourchecksum) THEN\n    PRINT\/ERROR \"wrong digits\"\n    DO play\n    STOP\n   ELSE\n    CONTINUE\n   ENDIF\n ENDIF\nENDSECTION\n\nSECTION play\nLOOP n=1,3\nASK   \"Expression {n}\": expr=\"\"\nIF (expr==\"l\") THEN\nRELEASE S_TABLE allowed\nPRINT \"Your new numbers\"\nDO game\nELSEIF (expr!=\"\") THEN\nDO check_expr\nsum={expr}\n IF (sum!=24) THEN\n  PRINT\/ERROR expr,\" not equates 24 but \",sum\n  CYCLE\n ELSE\n  PRINT \"BINGO \", expr,\" equates \", sum\n  STOP\n ENDIF\nELSE\n CYCLE\nENDIF\nENDLOOP\nENDSECTION\nDO game\n<\/lang>\nOutput:\n<pre style='height:30ex;overflow:scroll'>\nYour numbers 2 8 9 9\nUse only these operators * \/ + - ( )\nEnter an expression that equates to 24\nEnter 'l' for new numbers\nYour 4 digits: 2 8 9 9\nExpression 1 >l\nYour new numbers\nYour numbers 2 4 2 3\nUse only these operators * \/ + - ( )\nEnter an expression that equates to 24\nEnter 'l' for new numbers\nYour 4 digits: 2 4 2 3\nExpression 1 >2+4+2+3\n@@@@@@@@  2+4+2+3 not equates 24 but 11                                @@@@@@@@\nExpression 2 >2+2+2+3\n@@@@@@@@  wrong digits                                                 @@@@@@@@\nExpression 1 >2+2+a+3\nwrong entry on position 5\nExpression 1 >(2+4+2)*3\nBINGO (2+4+2)*3 equates 24\n<\/pre>\n\n[[Category:GUISS\/Omit]]"}]}}}}