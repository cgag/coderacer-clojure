{"query":{"pages":{"3131":{"pageid":3131,"ns":0,"title":"Abstract type","revisions":[{"*":"<div class=\"infobox\" style=\"width: 2in\">[[File:Rcode-button-task-crushed.png|64px|left|alt=Task|link=Category:Solutions by Programming Task]]'''Abstract type'''<br\/>\nYou are encouraged to [[Rosetta Code:Solve a Task|solve this task]] according to the task description, using any language you may know.[[Category:Programming Tasks]][[Category:Basic language learning]]<\/div>\n[[Category:Object oriented]]\n[[Category:Type System]]\n'''Abstract type''' is a type without instances or without definition.\n\nFor example in [[object-oriented programming]] using some languages, abstract types can be partial implementations of other types, which are to be derived there-from. An abstract type may provide implementation of some operations and\/or components. Abstract types without any implementation are called '''interfaces'''. In the languages that do not support multiple [[inheritance]] ([[Ada]], [[Java]]), classes can, nonetheless, inherit from multiple interfaces. The languages with multiple inheritance (like [[C++]]) usually make no distinction between partially implementable abstract types and interfaces. Because the abstract type's implementation is incomplete, [[object-oriented programming | OO]] languages normally prevent instantiation from them  (instantiation must derived from one of their descendant classes).\n\nThe term '''abstract datatype''' also may denote a type, with an implementation provided by the programmer rather than directly by the language (a '''built-in''' or an inferred type). Here the word ''abstract'' means that the implementation is abstracted away, irrelevant for the user of the type. Such implementation can and should be hidden if the language supports separation of implementation and specification. This hides complexity while allowing the implementation to change without repercussions on the usage. The corresponding software design practice is said to follow the [[wp:Information_hiding|information hiding principle]].\n\nIt is important not to confuse this ''abstractness'' (of implementation) with one of the '''abstract type'''. The latter is abstract in the sense that the set of its values is empty. In the sense of implementation abstracted away, all user-defined types are abstract.\n\nIn some languages, like for example in Objective Caml which is strongly statically typed, it is also possible to have '''abstract types''' that are not OO related and are not an abstractness too. These are ''pure abstract types'' without any definition even in the implementation and can be used for example for the type algebra, or for some consistence of the type inference. For example in this area, an abstract type can be used as a phantom type to augment another type as its parameter. \n\n'''Task''': show how an abstract type can be declared in the language. If the language makes a distinction between interfaces and partially implemented types illustrate both.\n\n\n==[[:Category:ABAP|ABAP]][[Category:ABAP]]==\n=== Abstract Class ===\n<lang ABAP>class abs definition abstract.\n  public section.\n    methods method1 abstract importing iv_value type f exporting ev_ret type i.\n  protected section.\n    methods method2 abstract importing iv_name type string exporting ev_ret type i.\n    methods add importing iv_a type i iv_b type i exporting ev_ret type i.\nendclass.\n\nclass abs implementation.\n  method add.\n    ev_ret = iv_a + iv_b.\n  endmethod.\nendclass.<\/lang>\n\n=== Interfaces ===\nInterfaces in ABAP are classes with the following restrictions:\n1. All methods must be abstract instance methods (Static methods aren't allowed).\n2. Variables must be static final. The values may be computed at run time.\n3. No static initialiser blockers. No static initialiser helper methods.\n<lang ABAP>interface inter.\n  methods: method1 importing iv_value type f exporting ev_ret type i,\n           method2 importing iv_name type string exporting ev_ret type i,\n           add importing iv_a type i iv_b type i exporting ev_ret type i.\nendinterface.<\/lang>\n\n==[[:Category:ActionScript|ActionScript]][[Category:ActionScript]]==\nWhile ActionScript does not support explicit abstract classes, it does have interfaces. Interfaces in ActionScript may not implement any methods and all methods are public and implicitly abstract. Interfaces can extend other interfaces, and interfaces may be multiply inherited.\n<lang actionscript>package\n{\n    public interface IInterface\n    {\n        function method1():void;\n        function method2(arg1:Array, arg2:Boolean):uint;\n    }\n}<\/lang>\n\n==[[:Category:Ada|Ada]][[Category:Ada]]==\n===Interface===\nInterfaces in [[Ada]] may have no components or implemented operation except for ones implemented as null operations. Interfaces can be multiply inherited.\n<lang ada>type Queue is limited interface;\nprocedure Enqueue (Lounge : in out Queue; Item : in out Element) is abstract;\nprocedure Dequeue (Lounge : in out Queue; Item : in out Element) is abstract;<\/lang>\nInterfaces can be declared synchronized or task when intended implementations are to be provided by protected objects or [[task]]s. For example:\n<lang ada>type Scheduler is task interface;\nprocedure Plan (Manager : in out Scheduler; Activity : in out Job) is abstract;<\/lang>\n===Abstract type===\nAbstract types may provide components and implementation of their operations. Abstract types are singly inherited.\n<lang ada>with Ada.Finalization;\n...\ntype Node is abstract new Ada.Finalization.Limited_Controlled and Queue with record\n   Previous : not null access Node'Class := Node'Unchecked_Access;\n   Next     : not null access Node'Class := Node'Unchecked_Access;\nend record;   \noverriding procedure Finalize (X : in out Node); -- Removes the node from its list if any\noverriding procedure Dequeue (Lounge : in out Node; Item : in out Element);\noverriding procedure Enqueue (Lounge : in out Node; Item : in out Element);\nprocedure Process (X : in out Node) is abstract; -- To be implemented<\/lang>\nHere Node is an abstract type that is inherited from Limited_Controlled and implements a node of a [[Doubly-Linked List (element) | doubly linked list]]. It also implements the interface of a queue described above, because any node can be considered a head of the queue of linked elements. For the operation Finalize an implementation is provided to ensure that the element of a list is removed from there upon its finalization. The operation itself is inherited from the parent type Limited_Controlled and then overridden. The operations Dequeue and Enqueue of the Queue interface are also implemented.\n\n==[[:Category:Agda|Agda]][[Category:Agda]]==\nUsing [http:\/\/wiki.portal.chalmers.se\/agda\/agda.php?n=ReferenceManual.Records records] for storing the interface methods and [http:\/\/wiki.portal.chalmers.se\/agda\/pmwiki.php?n=ReferenceManual.InstanceArguments instance arguments] (which are [http:\/\/wiki.portal.chalmers.se\/agda\/pmwiki.php?n=ReferenceManual.ModellingTypeClassesWithInstanceArguments similar] to Haskell type classes) for overloading:\n\n<lang agda>module AbstractInterfaceExample where\n\nopen import Function\nopen import Data.Bool\nopen import Data.String\n\n-- * One-parameter interface for the type `a' with only one method.\n\nrecord VoiceInterface (a : Set) : Set where\n  constructor voice-interface\n  field say-method-of : a \u2192 String\n\nopen VoiceInterface\n\n-- * An overloaded method.\n\nsay : {a : Set} \u2192 \u2983 _ : VoiceInterface a \u2984 \u2192 a \u2192 String\nsay \u2983 instance \u2984 = say-method-of instance\n\n-- * Some data types.\n\ndata Cat : Set where\n  cat : Bool \u2192 Cat\n\ncrazy! = true\nplain-cat = false\n\n-- | This cat is crazy?\ncrazy? : Cat \u2192 Bool\ncrazy? (cat x) = x\n\n-- | A 'plain' dog.\ndata Dog : Set where\n  dog : Dog\n\n-- * Implementation of the interface (and method).\n\ninstance-for-cat : VoiceInterface Cat\ninstance-for-cat = voice-interface case where\n  case : Cat \u2192 String\n  case x with crazy? x\n  ... | true = \"meeeoooowwwww!!!\"\n  ... | false = \"meow!\"\n\ninstance-for-dog : VoiceInterface Dog\ninstance-for-dog = voice-interface $ const \"woof!\"\n\n-- * and then:\n-- \n-- say dog => \"woof!\"\n-- say (cat crazy!) => \"meeeoooowwwww!!!\"\n-- say (cat plain-cat) => \"meow!\"\n-- <\/lang>\n\nThere is <code>dog<\/code> and <code>cat<\/code> is objects of different types for which the interface method is implemented.\n\n==[[:Category:Aikido|Aikido]][[Category:Aikido]]==\nAn abstract class contains functions that have no body defined.  You cannot instantiate a class that contains abstract functions.\n\n<lang aikido>class Abs {\n        public function method1...\n        public function method2...\n\n}<\/lang>\nInterfaces in Aikido define a set of functions, operators, classes, interfaces, monitors or threads (but no variables) that must be implemented by a class implementing the interface.\n<lang aikido>interface Inter {\n    function isFatal : integer\n    function operate (para : integer = 0) \n    operator -> (stream, isout)\n}<\/lang>\n\n==[[:Category:Argile|Argile]][[Category:Argile]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Argile]] version 1.0.0[[SMW::on]]<\/div>\n<lang Argile>use std\n\n(: abstract class :)\n\nclass Abs\n   text\t\tname\n   AbsIface\tiface\n\nclass AbsIface\n   function(Abs)(int)->int\tmethod\n\nlet Abs_Iface = Cdata AbsIface@ {.method = nil}\n\n.: new Abs :. -> Abs {let a = new(Abs); a.iface = Abs_Iface; a}\n\n=: <Abs self>.method <int i> := -> int\n   (self.iface.method is nil) ? 0 , (call self.iface.method with self i)\n\n(: implementation :)\n\nclass Sub <- Abs { int value }\n\nlet Sub_Iface = Cdata AbsIface@ {.method = (code of (nil the Sub).method 0)}\n\n.: new Sub (<int value = -1>) :. -> Sub\n   let s = new (Sub)\n   s.iface = Sub_Iface\n   s.value = value\n   s\n\n.: <Sub this>.method <int i> :. -> int {this.value + i}\n\n(: example use :)\n\n.:foobar<Abs a>:. {print a.method 12 ; del a}\nfoobar (new Sub 34)\t(: prints 46 :)\nfoobar (new Sub)\t(: prints 11 :)\nfoobar (new Abs)\t(: prints  0 :)<\/lang>\n==[[:Category:AutoHotkey|AutoHotkey]][[Category:AutoHotkey]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[ AutoHotkey_L]][[SMW::on]]<\/div>\n<lang AutoHotkey>color(r, g, b){ \n   static color\n   If !color \n      color := Object(\"base\", Object(\"R\", r, \"G\", g, \"B\", b \n                                    ,\"GetRGB\", \"Color_GetRGB\"))\n   return  Object(\"base\", Color) \n} \nColor_GetRGB(clr) {\n    return \"not implemented\"\n}\n\nwaterColor(r, g, b){ \n   static waterColor\n   If !waterColor \n      waterColor := Object(\"base\", color(r, g, b),\"GetRGB\", \"WaterColor_GetRGB\")\n   return  Object(\"base\", WaterColor) \n} \n\nWaterColor_GetRGB(clr){\nreturn clr.R << 16 | clr.G << 8 | clr.B\n}\n\ntest:\nblue := color(0, 0, 255)\nmsgbox % blue.GetRGB() ; displays \"not implemented\"\nblue := waterColor(0, 0, 255)\nmsgbox % blue.GetRGB() ; displays 255\nreturn\n<\/lang>\n==[[:Category:C|C]][[Category:C]]==\nDoing abstract types in C is not particularly trivial as C doesn't really support classes.  The following series will show an abstract type, followed by a realizable class that provides the abstract interface, and finally followed by an example of usage.\n\nThe header file for the abstract class, interfaceAbs.h\n<lang c>#ifndef INTERFACE_ABS\n#define INTERFACE_ABS\n\ntypedef struct sAbstractCls *AbsCls;\n\ntypedef struct sAbstractMethods {\n    int         (*method1)(AbsCls c, int a);\n    const char *(*method2)(AbsCls c, int b);\n    void        (*method3)(AbsCls c, double d);\n} *AbstractMethods, sAbsMethods;\n\nstruct sAbstractCls {\n    AbstractMethods  klass;\n    void     *instData;\n};\n\n#define ABSTRACT_METHODS( cName, m1, m2, m3 ) \\\n    static sAbsMethods cName ## _Iface = { &m1, &m2, &m3 }; \\\n    AbsCls cName ## _Instance( void *clInst) { \\\n        AbsCls ac = malloc(sizeof(struct sAbstractCls)); \\\n        if (ac) { \\\n            ac->klass = &cName ## _Iface; \\\n            ac->instData = clInst; \\\n        }\\\n        return ac; }\n\n#define Abs_Method1( c, a) (c)->klass->method1(c, a)\n#define Abs_Method2( c, b) (c)->klass->method2(c, b)\n#define Abs_Method3( c, d) (c)->klass->method3(c, d)\n#define Abs_Free(c) \\\n  do { if (c) { free((c)->instData); free(c); } } while(0);\n \n#endif<\/lang>\nThat will define the abstract class. The next section declares a public interface for a class providing the interface of the abstract class. This class is Silly and\nthe code is in file silly.h. Note the actual structure of the class is not provided\nhere. We don't want it visible.\n<lang c>#ifndef SILLY_H\n#define SILLY_H\n#include intefaceAbs.h \n\ntypedef struct sillyStruct *Silly;\nextern Silly NewSilly( double, const char *);\nextern AbsCls Silly_Instance(void *); \n\n#endif<\/lang>\nOk. Now it is necessary to provide the implementation of the realizable class.\nThis code should be in silly.c.\n<lang c>#include \"silly.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstruct sillyStruct {\n    double  v1;\n    char   str[32];\n};\n\nSilly NewSilly(double vInit, const char *strInit)\n{\n    Silly sily = malloc(sizeof( struct sillyStruct ));\n    sily->v1 = vInit;\n    sily->str[0] = '\\0';\n    strncat(sily->str, strInit, 31);\n    return sily;\n}\n\nstatic\nint MyMethod1(  AbsCls c, int a)\n{\n    Silly s = (Silly)(c->instData);\n    return a+strlen(s->str);\n}\n\nstatic\nconst char *MyMethod2(AbsCls c, int b)\n{\n    Silly s = (Silly)(c->instData);\n    sprintf(s->str, \"%d\", b);\n    return s->str;\n}\n\nstatic\nvoid  MyMethod3(AbsCls c, double d)\n{\n    Silly s = (Silly)(c->instData);\n    printf(\"InMyMethod3, %f\\n\",s->v1 * d);\n}\n\nABSTRACT_METHODS( Silly, MyMethod1, MyMethod2, MyMethod3)<\/lang>\nThat last macro, ABSTRACT_METHODS may need a little explanation. First note that macros do a string substitution of the parameter values into the arguments of the defined macro, with a little hitch. In the macro definition the ' ## ' expression is special. Here cName ## _Iface gets converted to Silly_Iface, as 'Silly' replaces cName. So the macro call declares an instance of the class record, and defines a constructor named Silly_Instance, which takes a Silly structure as an arguments\nand uses the class record it previously set up as well.\n\nThe methods MyMethod1, MyMethod2, and MyMethod3 are called through the abstract class interface and do not need to be visible outside this file. Hence, they are declared static. \n\nNow all's left is some example code that uses all this stuff. \n<lang c>#include <stdio.h>\n#include \"silly.h\"\n\nint main()\n{\n    AbsCls abster = Silly_Instance(NewSilly( 10.1, \"Green Tomato\"));\n\n    printf(\"AbsMethod1: %d\\n\", Abs_Method1(abster, 5));\n    printf(\"AbsMethod2: %s\\n\", Abs_Method2(abster, 4));\n    Abs_Method3(abster, 21.55);\n    Abs_Free(abster);\n    return 0;\n}\n<\/lang>\n\n==<span id=\"C sharp\">[[:Category:C sharp|C#]]<\/span>[[Category:C sharp]]==\n<lang csharp>abstract class Class1\n{\n   public abstract void method1();\n\n   public int method2()\n   {\n      return 0;\n   }\n}<\/lang>\n\n==[[:Category:C++|C++]][[Category:C++]]==\nYou can declare a virtual function to not have an implementation (called \"pure virtual function\") by the following \"<tt>= 0<\/tt>\" syntax after the method declaration. A class containing at least one pure virtual function (or inheriting one and not overriding it) cannot be instantiated.\n<lang cpp>class Abs {\npublic:\n\tvirtual int method1(double value) = 0;\n\tvirtual int add(int a, int b){\n\t\treturn a+b;\n\t}\n};<\/lang>\nBecause C++ allows multiple inheritance of classes, no distinction is made between interfaces and abstract classes.\n\n==[[:Category:Clojure|Clojure]][[Category:Clojure]]==\n\nUsing defprotocol, we can define what is essentially an interface.\n\n<lang lisp>(defprotocol Foo (foo [this]))<\/lang>\n\n==[[:Category:Common Lisp|Common Lisp]][[Category:Common Lisp]]== \n\nIn Common Lisp, classes do not implement methods, but methods specialized for particular kinds of arguments may be defined for generic functions.  Since we can programmatically determine whether methods are defined for a list of arguments, we can simulate a kind of abstract type.  We define an abstract type <code>kons<\/code> to which an object belongs if methods for <code>kar<\/code> and <code>kdr<\/code> are defined for it.  We define a type predicate <code>konsp<\/code> and a type <code>kons<\/code> in terms of the type predicate.\n\n<lang lisp>(defgeneric kar (kons)\n  (:documentation \"Return the kar of a kons.\"))\n\n(defgeneric kdr (kons)\n  (:documentation \"Return the kdr of a kons.\"))\n\n(defun konsp (object &aux (args (list object)))\n  \"True if there are applicable methods for kar and kdr on object.\"\n  (not (or (endp (compute-applicable-methods #'kar args))\n           (endp (compute-applicable-methods #'kdr args)))))\n\n(deftype kons ()\n  '(satisfies konsp))<\/lang>\n\nWe can make the built-in types <code>cons<\/code> and <code>integer<\/code> <code>kons<\/code>es.  We start with <code>cons<\/code>, using the obvious definitions.\n\n<lang lisp>(defmethod kar ((cons cons))\n  (car cons))\n\n(defmethod kdr ((cons cons))\n  (cdr cons))\n\n(konsp (cons 1 2))       ; => t\n(typep (cons 1 2) 'kons) ; => t\n(kar (cons 1 2))         ; => 1\n(kdr (cons 1 2))         ; => 2<\/lang>\n\nFor integers, we'll define the <code>kar<\/code> of <var>n<\/var> to be <var>1<\/var> and the <code>kdr<\/code> of <var>n<\/var> to be <var>n - 1<\/var>.  This means that for an integer <var>n<\/var>, <var>n<\/var> = <code>(+ (kar <var>n<\/var>) (kdr <var>n<\/var>))<\/code>.\n\n<lang lisp>(defmethod kar ((n integer))\n  1)\n\n(defmethod kdr ((n integer))\n  (if (zerop n) nil\n    (1- n)))\n\n(konsp 45)         ; => t\n(typep 45 'kons)   ; => t\n(kar 45)           ; => 1\n(kdr 45)           ; => 44<\/lang>\n\n==[[:Category:D|D]][[Category:D]]==\n<lang d>import std.stdio;\n\nclass Foo {\n    \/\/ abstract methods can have an implementation for\n    \/\/ use in super calls\n    abstract void foo() {\n        writeln(\"Test\");\n    }\n}\n\ninterface Bar {\n    \/\/ interface methods are implicitly abstract and cannot\n    \/\/ provide default implementations\n    void bar();\n}\n\nclass Baz : Foo, Bar { \/\/ super class must come first\n    override void foo() {\n        writefln(\"Meep\");\n        super.foo();\n    }\n\n    void bar() {}\n}\n\nvoid main() {}<\/lang>\n\n==[[:Category:Delphi|Delphi]][[Category:Delphi]]==\nAbstract Class introduced in Delphi 2006.  An abstract class cannot be instantiated and must be derived from in order to be used.\n\n<lang delphi>TSomeClass = class abstract (TObject)\n  ...\nend;<\/lang>\n\n\nAbstract Methods can only be implemented in derived classes.  A concrete class that contains abstract methods can be instantiated.  A warning will be generated at compile time, and an EAbstractError exception will thrown if the method is called at run time.\n\n<lang delphi>type\n  TMyObject = class(TObject)\n  public\n    procedure AbstractFunction; virtual; abstract; \/\/ Your virtual abstract function to overwrite in descendant\n    procedure ConcreteFunction; virtual; \/\/ Concrete function calling the abstract function\n  end;\n\nimplementation\n\nprocedure TMyObject.ConcreteFunction;\nbegin\n  AbstractFunction; \/\/ Calling the abstract function\nend;<\/lang>\n\n==[[:Category:DWScript|DWScript]][[Category:DWScript]]==\n\nDWScript has both abstract classes and abstract methods.\n\nSee [[Abstract_type#Delphi|Delphi]].\n\n==[[:Category:E|E]][[Category:E]]==\n\nIn E, the implementation of an object is never used to determine type membership (except when dealing with the host platform's objects if it uses such distinctions, such as the JVM), so all types are abstract.\n\nA simple abstract type without enforcement can be created using the interface expression:\n\n<lang e>interface Foo {\n    to bar(a :int, b :int)\n}<\/lang>\n\nWith enforcement, a separate ''stamp'' is created which must be applied to the instances. This is analogous to a Java interface.\n\n<lang e>interface Foo guards FooStamp {\n    to bar(a :int, b :int)\n}\n\ndef x implements FooStamp {\n    to bar(a :int, b :int) {\n        return a - b\n    }\n}<\/lang>\n\n==[[:Category:Eiffel|Eiffel]][[Category:Eiffel]]==\n\n<lang Eiffel>\ndeferred class \n    AN_ABSTRACT_CLASS\n\nfeature\n\n    a_deferred_feature\n        -- a feature whose implementation is left to a descendent\n        deferred\n        end\n\n    an_effective_feature: STRING\n        -- deferred (abstract) classes may still include effective features\n        do\n            Result := \"I am implemented!\"\n        end\n\nend\n<\/lang>\n\n==[[:Category:Fantom|Fantom]][[Category:Fantom]]==\n<lang fantom>\nabstract class X\n{\n  Void method1 ()\n  {\n    echo (\"Method 1 in X\")\n  }\n\n  abstract Void method2 ()\n}\n\nclass Y : X\n{\n  \/\/ Y must override the abstract method in X\n  override Void method2 ()\n  {\n    echo (\"Method 2 in Y\")\n  }\n}\n\nclass Main\n{\n  public static Void main () \n  {\n    y := Y()\n    y.method1\n    y.method2\n  }\n}\n<\/lang>\n\n\n==<span id=\"F Sharp\">[[:Category:F Sharp|F#]]<\/span>[[Category:F Sharp]]==\nA type with only abstract members and without constructors is an '''interface''' (when not marked with the <code>AbstractClass<\/code> attribute). Example:\n<lang fsharp>type Shape =\n  abstract Perimeter: unit -> float\n  abstract Area: unit -> float\n\ntype Rectangle(width, height) =\n  interface Shape with\n    member x.Perimeter() = 2.0 * width + 2.0 * height\n    member x.Area() = width * height<\/lang>\n\nA type that leaves some or all members unimplemented, is an '''abstract class'''. It has to be marked with the <code>AbstractClass<\/code> attribute. Example:\n<lang  fsharp>[<AbstractClass>]\ntype Bird() =\n  \/\/ an abstract (=virtual) method with default impl.\n  abstract Move : unit -> unit\n  default x.Move() = printfn \"flying\"\n  \/\/ a pure virtual method\n  abstract Sing: unit -> string\n\ntype Blackbird() =\n  inherit Bird()\n  override x.Sing() = \"tra-la-la\"\n\ntype Ostrich() =\n  inherit Bird()\n  override x.Move() = printfn \"walking\"\n  override x.Sing() = \"hiss hiss!\"<\/lang>\n\n==[[:Category:Genyris|Genyris]][[Category:Genyris]]==\nIn Genyris by default there are no constructors. In effect all classes are Abstract until they are used to tag (describe) an object. This in keeping with the language's roots in Description Logic. To prevent the class ever being associated with an instance it suffices to force the validator to fail. \n<lang genyris>class AbstractStack()\n   def .valid?(object) nil\n\ntag AbstractStack some-object # always fails<\/lang>\n\nHowever this is not much use if we want to use an abstract class to define an '''interface'''. Here is a quasi-abstract class which can be used to tag objects if they conform to the class's membership expectations. In this case it wants two methods, ''.enstack'' and ''.destack'':\n<lang genyris>class StackInterface()\n   def .valid?(object)\n      object\n         and\n            bound? .enstack\n            is-instance? .enstack Closure\n            bound? .destack\n            is-instance? .destack Closure<\/lang>\n\nSo if ever we find an object which conforms to the validator it can be tagged. Here's a 'traditional' class definition using the Object class which ''does'' provide a constructor:\n<lang genyris>class XYZstack(Object)\n    def .init()\n        var .items ()\n    def .enstack(object)\n        setq .items (cons object .items)\n    def .destack()\n        var tmp  (car .items)\n        setq .items (cdr .items)\n        tmp<\/lang>\nNow we can tag an object that conforms to the Interface:\n<lang genyris>tag StackInterface (XYZstack(.new))<\/lang>\n\n==[[:Category:Go|Go]][[Category:Go]]==\nGo's ''interface type'' is an abstract type. It defines a set of methods that a value must have.\n<lang go>interface {\n    Method1(value float64) int\n    SetName(name string)\n    GetName() string\n}<\/lang>\n\nA variable of an interface type can hold a value of any type that implements the methods that are specified in the interface. You don't need to explicitly \"declare\" that the type \"implements\" the interface or anything like that -- the compatibility is purely structural based on the methods.\n\n==[[:Category:Groovy|Groovy]][[Category:Groovy]]==\n<div class=\"examplemeta translation\">'''Translation of''': [[Abstract type#Java|Java]]<\/div>\n\nAs in [[Java]], methods that are declared but not implemented are called \"abstract\" methods. An interface is a class-level typing construct that can only contain abstract method declarations (well, and constants, but pay no attention to those).\n<lang groovy>public interface Interface {\n    int method1(double value)\n    int method2(String name)\n    int add(int a, int b)\n}<\/lang>\n\nAn abstract class may implement some of its methods and leave others unimplemented. The unimplemented methods and the class itself must be declared \"abstract\".\n<lang groovy>public abstract class Abstract1 {\n    abstract public int methodA(Date value)\n    abstract protected int methodB(String name)\n    int add(int a, int b) { a + b }\n}<\/lang>\n\nAn abstract class may also be used to partially implement an interface. Here class \"Abstract2\" implements the \"add\" method from the inherited \"Interface\", but leaves the other two methods, \"method1\" and \"method2\", unimplemented. Abstract methods that an abstract class inherits from an interface or another abstract class do not have to be redeclared.\n<lang groovy>public abstract class Abstract2 implements Interface {\n    int add(int a, int b) { a + b }\n}<\/lang>\n\nInterfaces and abstract classes cannot be instantiated directly. There must be a \"concrete subclass\" that contains a complete implementation in order to instantiate an object.\n<lang groovy>public class Concrete1 implements Interface {\n    public int method1(double value) { value as int }\n    public int method2(String name) { (! name) ? 0 : name.toList().collect { it as char }.sum() }\n    public int add(int a, int b) { a + b }\n}\n\npublic class Concrete2 extends Abstract1 {\n    public int methodA(Date value) { value.toCalendar()[Calendar.DAY_OF_YEAR] }\n    protected int methodB(String name) { (! name) ? 0 : name.toList().collect { it as char }.sum() }\n}\n\npublic class Concrete3 extends Abstract2 {\n    public int method1(double value) { value as int }\n    public int method2(String name) { (! name) ? 0 : name.toList().collect { it as char }.sum() }\n}<\/lang>\n\nNotice that there are no extra descriptive keywords on the interface method declarations. Interface methods are assumed to be both abstract and public.\n\nObligatory test:\n<lang groovy>def c1 = new Concrete1()\nassert c1 instanceof Interface\nprintln (new Concrete1().method2(\"Superman\"))\n\ndef c2 = new Concrete2()\nassert c2 instanceof Abstract1\nprintln (new Concrete2().methodB(\"Spiderman\"))\n\ndef c3 = new Concrete3()\nassert c3 instanceof Interface\nassert c3 instanceof Abstract2\nprintln (new Concrete3().method2(\"Hellboy\"))<\/lang>\n\nObligatory test output:\n<pre>843\n931\n719<\/pre>\n\nLike [[Java]], [[Groovy]] does not allow subclasses to inherit from multiple superclasses, even abstract superclasses, but it does let subclasses inherit from multiple interfaces.\n\n==[[:Category:Haskell|Haskell]][[Category:Haskell]]==\n\nIn Haskell an abstract type is a type class. A type class specifies an interface. One can then define \"instances\" to provide implementations of the type class for various types.\n\nFor example, the built-in type class Eq (the types that can be compared for equality) can be declared as follows:\n<lang haskell>class  Eq a  where\n   (==) :: a -> a -> Bool\n   (\/=) :: a -> a -> Bool<\/lang>\n\nDefault implementations of the functions can be provided:\n<lang haskell>class  Eq a  where\n   (==) :: a -> a -> Bool\n   (\/=) :: a -> a -> Bool\n   x \/= y     =  not (x == y)\n   x == y     =  not (x \/= y)<\/lang>\nHere default implementations of each of the operators is circularly defined in terms of the other, for convenience of the programmer; so the programmer only needs to implement one of them for it to work.\n\nConsider the following function which uses the operator == of the type class Eq from above. The arguments to == above were of the unknown type \"a\", which is of class Eq, so the type of the expression below now must include this restriction:\n<lang haskell>func :: (Eq a) => a -> Bool\nfunc x = x == x<\/lang>\n\nSuppose I make a new type\n<lang haskell>data Foo = Foo {x :: Integer, str :: String}<\/lang>\n\nOne could then provide an implementation (\"instance\") the type class Eq with this type\n<lang haskell>instance Eq Foo where\n   (Foo x1 str1) == (Foo x2 str2) =\n      (x1 == x2) && (str1 == str2)<\/lang>\nAnd now I can, for example, use the function \"func\" on two arguments of type Foo.\n\n==Icon and [[:Category:Unicon|Unicon]][[Category:Unicon]]==\n\nUnicon does not distinguish between abstract and concrete classes.\nAn abstract class is a class with abstract methods.  Icon is not object-oriented.\n\n<lang unicon>class abstraction()\n    abstract method compare(l,r) # generates runerr(700, \"method compare()\")\nend<\/lang>\n\n==[[:Category:J|J]][[Category:J]]==\nJ does not support abstract types, as defined here.  In J, types are typically treated as a necessary evil, which should be minimized, disguised, hidden, neglected or ignored wherever practical.  (2=1+1 regardless of the type of 1 and the type of 2.)  And allowing user defined types would complicate this approach.\n\nNote also: Types are sometimes thought of as being related to function domains.  But, in the general case, domains of independently defined functions are independent of each other, and the intersections of these domains may or may not be empty.\n\nThat said: it's useful to define a type, in the context of J, as \"the set of values which may result from a parenthesized expression\".  And, if compilation to machine code is supported, it may also be useful to define constraint mechanisms to be used in expressions, so that machine code may be more easily generated.\n\n==[[:Category:Java|Java]][[Category:Java]]==\nMethods that don't have an implementation are called abstract methods in Java. A class that contains an abstract method or inherits one but did not override it must be an abstract class; but an abstract class does not need to contain any abstract methods. An abstract class cannot be instantiated. If a method is abstract, it must be public or protected\n<lang java>public abstract class Abs {\n\tabstract public int method1(double value);\n\tabstract protected int method2(String name);\n\tint add(int a, int b){\n\t\treturn a+b;\n\t}\n}<\/lang>\nInterfaces in Java may not implement any methods and all methods are implicitly public and abstract.\n<lang java>public interface Inter {\n\tint method1(double value);\n\tint method2(String name);\n\tint add(int a, int b);\n}<\/lang>\n\n==[[:Category:Logtalk|Logtalk]][[Category:Logtalk]]==\nIn Logtalk, methods (predicates) must be declared but their definition is not mandatory. Being a logic-based language and making use of the closed-world assumption, invoking a method that is declared but not defined simply fails. If necessary, is trivial to define a method such that it throws an exception. Moreover, Logtalk doesn't define an \"abstract\" or \"virtual\" keyword. Instead it uses an operational definition where e.g. a class is considered abstract if it doesn't provide a method for creating new instances.\n\nLogtalk supports the definition of interfaces (protocols), which can contain public, protected, and private declarations of methods (predicates). In addition, an object can qualify an implements relation with an interface (protocol) using the keywords \"public\", \"protected\", and \"private\".\n<lang logtalk>\n:- protocol(datep).\n\n    :- public(today\/3).\n    :- public(leap_year\/1).\n    :- public(name_of_day\/3).\n    :- public(name_of_month\/3).\n    :- public(days_in_month\/3).\n\n:- end_protocol.\n<\/lang>\n\n==[[:Category:Lua|Lua]][[Category:Lua]]==\nLua does not include built-in object oriented paradigms. These features can be added using simple code such as the following:\n<lang lua>BaseClass = {}\n\nfunction class ( baseClass )\n    local new_class = {}\n    local class_mt = { __index = new_class }\n\n    function new_class:new()\n        local newinst = {}\n        setmetatable( newinst, class_mt )\n        return newinst\n    end\n\n    if not baseClass then baseClass = BaseClass end\n        setmetatable( new_class, { __index = baseClass } )\n\n    return new_class\nend\n\nfunction abstractClass ( self )\n    local new_class = {}\n    local class_mt = { __index = new_class }\n\n    function new_class:new()\n        error(\"Abstract classes cannot be instantiated\")\n    end\n\n    if not baseClass then baseClass = BaseClass end\n        setmetatable( new_class, { __index = baseClass } )\n\n    return new_class\nend\n\nBaseClass.class = class\nBaseClass.abstractClass = abstractClass<\/lang>\nThe 'class' function produces a new class from an existing parent class (BaseClass is default). From this class other classes or instances can be created. If a class is created through the 'abstractClass' function, however, the resulting class will throw an error if one attempts to instantiate it. Example:\n<lang lua>A = class()         -- New class A inherits BaseClass by default\nAA = A:class()      -- New class AA inherits from existing class A\nB = abstractClass() -- New abstract class B\nBB = B:class()      -- BB is not abstract\nA:new()             -- Okay: New class instance\nAA:new()            -- Okay: New class instance\nB:new()             -- Error: B is abstract\nBB:new()            -- Okay: BB is not abstract<\/lang>\n\n==[[:Category:NetRexx|NetRexx]][[Category:NetRexx]]==\n<lang NetRexx>\/* NetRexx *\/\noptions replace format comments java crossref savelog symbols binary\n\n-- -----------------------------------------------------------------------------\nclass RCAbstractType public final\n\nmethod main(args = String[]) public constant\n\n  say '  Testing' RCAbstractType.class.getSimpleName\n  say '  Creating an object of type:' Concrete.class.getSimpleName\n  conk = Concrete()\n  say    'getClassName:'.right(20) conk.getClassName\n  say    'getIfaceName:'.right(20) conk.getIfaceName\n  say   'mustImplement:'.right(20) conk.mustImplement\n  say    'canOverride1:'.right(20) conk.canOverride1\n  say    'canOverride2:'.right(20) conk.canOverride2\n  say 'callOverridden2:'.right(20) conk.callOverridden2\n\n  return\n\n-- -----------------------------------------------------------------------------\nclass RCAbstractType.Iface interface\n\nifaceName = RCAbstractType.Iface.class.getSimpleName\n\nmethod getIfaceName() public returns String\nmethod canOverride1() public returns String\nmethod canOverride2() public returns String\n\n-- -----------------------------------------------------------------------------\nclass RCAbstractType.Abstraction abstract implements RCAbstractType.Iface\n\nproperties inheritable\n  className = String\n\nmethod Abstraction() public\n  setClassName(this.getClass.getSimpleName)\n  return\n\nmethod mustImplement() public abstract returns String\n\nmethod getClassName() public returns String\n  return className\n\nmethod setClassName(nm = String) public\n  className = nm\n  return\n\nmethod getIfaceName() public returns String\n  return RCAbstractType.Iface.ifaceName\n\nmethod canOverride1() public returns String\n  return 'In' RCAbstractType.Abstraction.class.getSimpleName'.canOverride1'\n\nmethod canOverride2() public returns String\n  return 'In' RCAbstractType.Abstraction.class.getSimpleName'.canOverride2'\n\n-- -----------------------------------------------------------------------------\nclass RCAbstractType.Concrete extends RCAbstractType.Abstraction\n\nmethod Concrete() public\n  super()\n  return\n\nmethod mustImplement() public returns String\n  return 'In' RCAbstractType.Concrete.class.getSimpleName'.mustImplement'\n\nmethod canOverride2() public returns String\n  return 'In' RCAbstractType.Concrete.class.getSimpleName'.canOverride2'\n\nmethod callOverridden2() public returns String\n  return super.canOverride2\n<\/lang>\n;Output\n<pre>\n  Testing RCAbstractType\n  Creating an object of type: Concrete\n       getClassName: Concrete\n       getIfaceName: Iface\n      mustImplement: In Concrete.mustImplement\n       canOverride1: In Abstraction.canOverride1\n       canOverride2: In Concrete.canOverride2\n    callOverridden2: In Abstraction.canOverride2\n<\/pre>\n\n==[[:Category:NewLISP|NewLISP]][[Category:NewLISP]]==\n\n<lang NewLISP>; file:   abstract.lsp\n; url:    http:\/\/rosettacode.org\/wiki\/Abstract_type\n; author: oofoe 2012-01-28\n\n; Abstract Shape Class\n\n(new Class 'Shape)     ; Derive new class.\n\n(define (Shape:Shape   ; Shape constructor.\n         (pen \"X\"))    ; Default value.\n  (list (context)      ; Assemble data packet.\n        (list 'pen pen) \n        (list 'size (args))))\n\n(define (Shape:line x) ; Print out row with 'pen' character.\n  (dotimes (i x) \n    (print (lookup 'pen (self)))) \n  (println))\n\n(define (Shape:draw))  ; Placeholder, does nothing.\n\n; Derived Objects\n\n(new Shape 'Box)\n\n(define (Box:draw)     ; Override base draw method.\n  (let ((s (lookup 'size (self))))\n    (dotimes (i (s 0)) (:line (self) (s 0)))))\n\n(new Shape 'Rectangle)\n\n(define (Rectangle:draw)\n  (let ((size (lookup 'size (self))))\n    (dotimes (i (size 1)) (:line (self) (size 0)))))\n\n; Demonstration\n\n(:draw (Shape))        ; Nothing happens. \n\n(println \"A box:\")\n(:draw (Box \"O\" 5))    ; Create Box object and call draw method.\n\n(println \"\\nA rectangle:\")\n(:draw (Rectangle \"R\" 32 4))\n\n(exit)<\/lang>\n\nSample output:\n\n<pre>A box:\nOOOOO\nOOOOO\nOOOOO\nOOOOO\nOOOOO\n\nA rectangle:\nRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR\nRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR\nRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR\nRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR\n<\/pre>\n\n==[[:Category:Objeck|Objeck]][[Category:Objeck]]==\n<lang objeck>\nclass ClassA {\n   method : virtual : public : MethodA() ~ Int;\n \n   method : public : MethodA() ~ Int {\n      return 0;\n   }\n}\n<\/lang>\n\n==[[:Category:OCaml|OCaml]][[Category:OCaml]]==\n\n===Virtual===\n\nThe equivalent of what is called abstract type in the other OO examples of this page is just called '''virtual''' in Objective Caml to define '''virtual methods''' and '''virtual classes''':\n\n<lang ocaml>class virtual foo =\n  object\n    method virtual bar : int\n  end<\/lang>\n\n===Abstract Type===\n\nIn OCaml what we call an abstract type is not OO related, it is only a type defined without definition, for example:\n<lang ocaml>type t<\/lang>\nit is used for example to hide an implementation from the interface of a module or for type algebra.\n\nExample of abstracting a type in an interface:\n<lang ocaml>module Foo : sig\n  type t\nend = struct\n  type t = int * int\nend<\/lang>\n\nPure abstract types in the implementation:\n<lang ocaml>type u\ntype v\ntype 'a t\ntype ut = u t\ntype vt = v t<\/lang>\n\n==[[:Category:ooRexx|ooRexx]][[Category:ooRexx]]==\n\n<lang ooRexx>  -- Example showing an abstract type in ooRexx                         \n  -- shape is the abstract class that defines the abstract method area   \n  -- which is then implemented by its two subclasses, rectangle and circle\n  -- name is the method inherited by the subclasses.                    \n  -- author:         Rony G. Flatscher, 2012-05-26\n  -- changed\/edited: Walter Pachl, 2012-05-28 28 \n  -- highlighting:   to come \n\n  r=.rectangle~new(5,2)\n  say r\n  say r~name\n  say \"r~area:\" r~area\n  say\n\n  c=.circle~new(2)\n  say c\n  say c~name\n  say \"c~area:\" c~area\n  say\n\n  g=.shape~new\n  say g\n  say g~name\n  say \"g~area:\" g~area -- invoking abstract method results in a runtime error.\n\n  ::class shape\n    ::method area abstract\n    ::method name\n      return \"self~class~id:\" self~class~id\n\n\n  ::class rectangle subclass shape\n\n    ::method init\n      expose length width\n      use strict arg length=0, width=0\n\n    ::method area\n      expose length width\n      return length*width\n\n  ::class circle subclass shape\n\n    ::method init\n      expose radius\n      use strict arg radius=0\n\n    ::method area\n      expose radius\n      numeric digits 20\n      return radius*radius*3.14159265358979323846<\/lang>\n\n\n\n\n\n==[[:Category:Oz|Oz]][[Category:Oz]]==\n<div class=\"examplemeta translation\">'''Translation of''': [[Abstract type#Python|Python]]<\/div>\n\nThere are no abstract types as part of the language, but we can do as in Python and raise exceptions:\n\n<lang oz>declare\n  class BaseQueue\n     attr\n        contents:nil\n      \n     meth init\n        raise notImplemented(self init) end\n     end\n\n     meth enqueue(Item)\n        raise notImplemented(self enqueue) end\n     end\n\n     meth dequeue(?Item)\n        raise notImplemented(self dequeue) end\n     end\n\n     meth printContents\n        {ForAll @contents Show}\n     end\n  end\n\n  Queue = {New BaseQueue init} %% throws<\/lang>\n\n==[[:Category:Pascal|Pascal]][[Category:Pascal]] and [[:Category:Object Pascal|Object Pascal]][[Category:Object Pascal]] ==\nIn ObjectPascal mode FreePascal has classes and abstract methods.\n\nSee [[#Delphi | Delphi]]\n\n==[[:Category:Perl|Perl]][[Category:Perl]]==\n\n<lang perl>package AbstractFoo;\n\nuse strict;\n\nsub frob { die \"abstract\" }\nsub baz { die \"abstract\" }\n\nsub frob_the_baz {\n    my $self = shift;\n    $self->frob($self->baz());\n}\n\n\n1;<\/lang>\nPerl 6 inspired roles are provided by the [http:\/\/search.cpan.org\/perldoc?Moose Moose] library\n\n<lang perl>package AbstractFoo;\n\nuse Moose::Role;\n\nrequires qw\/frob baz\/;\n\nsub frob_the_baz {\n    my $self = shift;\n    $self->frob($self->baz());\n}\n\n1;<\/lang>\n\n==[[:Category:Perl 6|Perl 6]][[Category:Perl 6]]==\n\nPerl 6 supports roles, which are a bit like interfaces, but unlike interfaces in Java they can also contain some implementation.\n\n<lang perl6>\nuse v6;\n\nrole A {\n    # must be filled in by the class it is composed into\n    method abstract() { ... };\n\n    # can be overridden in the class, but that's not mandatory\n    method concrete() { say '# 42' };\n}\n\nclass SomeClass does A {\n    method abstract() {\n        say \"# made concrete in class\"\n    }\n}\n\nmy $obj = SomeClass.new;\n$obj.abstract();\n$obj.concrete();\n\n# output:\n# made concrete in class\n# 42\n<\/lang>\n\n==[[:Category:PHP|PHP]][[Category:PHP]]==\nThe following is for PHP 5.\n\nMethods that don't have an implementation are called abstract methods in PHP. A class that contains an abstract method or inherits one but did not override it must be an abstract class; but an abstract class does not need to contain any abstract methods. An abstract class cannot be instantiated. If a method is abstract, it must be public or protected\n<lang php>abstract class Abs {\n\tabstract public function method1($value);\n\tabstract protected function method2($name);\n\tfunction add($a, $b){\n\t\treturn a + b;\n\t}\n}<\/lang>\nInterfaces in PHP may not implement any methods and all methods are public and implicitly abstract.\n<lang php>interface Inter {\n\tpublic function method1($value);\n\tpublic function method2($name);\n\tpublic function add($a, $b);\n}<\/lang>\n\n==[[:Category:PicoLisp|PicoLisp]][[Category:PicoLisp]]==\n<lang PicoLisp># In PicoLisp there is no formal difference between abstract and concrete\n# classes, just a naming convention where abstract classes start with a\n# lower case character after the '+' (the naming convention for classes).\n# This tells the programmer that this class has not sufficient methods\n# defined to survive on its own.\n   \n(class +abstractClass)\n   \n(dm someMethod> () \n   (foo)\n   (bar) )<\/lang>\n\n==[[:Category:Python|Python]][[Category:Python]]==\n\n<lang python>class BaseQueue(object):\n    \"\"\"Abstract\/Virtual Class \n    \"\"\"\n    def __init__(self):\n        self.contents = list()\n        raise NotImplementedError\n    def Enqueue(self, item):\n        raise NotImplementedError\n    def Dequeue(self):\n        raise NotImplementedError\n    def Print_Contents(self):\n        for i in self.contents:\n            print i,<\/lang>\n\nPython allows multiple inheritance and it's more common to implement \"mix-in\" classes rather than abstract interfaces.  (Mix-in classes can implement functionality as well define interfaces).\n\nIn this example we're simply following the Python convention of raising the built-in \"NotImplementedError\" for each function which must be implemented by our subclasses.  This is a \"purely virtual\" class because all of its methods raise the exception.  (It is sufficient for __init__ to do so for any partial virtual abstractions since that still ensures that the exception will be raised if anyone attempts to instantiate the base\/abstract class directly rather than one of its concrete (fully implemented) descendents).\n\nThe method signatures and the instantiation of a \"contents\" list shown here can be viewed as documentary hints to anyone inheriting from this class.  They won't actually do anything in the derived classes (since these methods must be over-ridden therein).\n\nIn this case we've implemented one method (''Print_Contents'').  This would be inherited by any derived classes.  It could be over-ridden, of course.  If it's not over-ridden it establishes a requirement that all derived classes provide some \"contents\" attribute which must allow for iteration and printing as shown.  Without this method the class would be \"purely virtual\" or \"purely abstract.\"  With its inclusion the class becomes \"partially implemented.\"\n\n:'''Note:''' This \"BaseQueue\" example should not be confused with Python's standard library Queue class.  That is used as the principle \"producer\/consumer\" communications mechanism among threads (and newer ''multiprocessing'' processes).\n\nStarting from Python 2.6, abstract classes can be created using the standard abc module:\n<lang python>from abc import ABCMeta, abstractmethod\n\nclass BaseQueue():\n    \"\"\"Abstract Class \n    \"\"\"\n    __metaclass__ = ABCMeta\n\n    def __init__(self):\n        self.contents = list()\n\n    @abstractmethod\n    def Enqueue(self, item):\n        pass\n\n    @abstractmethod\n    def Dequeue(self):\n        pass\n\n    def Print_Contents(self):\n        for i in self.contents:\n            print i,<\/lang>\n\n==[[:Category:Racket|Racket]][[Category:Racket]]==\n\n<lang scheme>#lang racket\n\n(define animal-interface (interface () say))\n\n(define cat% (class* object% (animal-interface) (super-new))) ;; error\n\n(define cat% (class* object% (animal-interface)\n               (super-new)\n               (define\/public (say)\n                 (display \"meeeeew!\"))))\n\n(define tom (new cat%))\n(send tom say)<\/lang>\n\n==[[:Category:REBOL|REBOL]][[Category:REBOL]]==\n<lang REBOL>REBOL [\n\tTitle: \"Abstract Type\"\n\tAuthor: oofoe\n\tDate: 2009-12-05\n\tURL: http:\/\/rosettacode.org\/wiki\/Abstract_type\n]\n\n; The \"shape\" class is an abstract class -- it defines the \"pen\"\n; property and \"line\" method, but \"size\" and \"draw\" are undefined and\n; unimplemented.\n\nshape: make object! [\n\tpen:  \"X\"\n\tsize: none\n\n\tline: func [count][loop count [prin self\/pen]  prin crlf]\n\tdraw: does [none]\n]\n\n; The \"box\" class inherits from \"shape\" and provides the missing\n; information for drawing boxes.\n\nbox: make shape [\n\tsize: 10\n\tdraw: does [loop self\/size [line self\/size]]\n]\n\n; \"rectangle\" also inherits from \"shape\", but handles the\n; implementation very differently.\n\nrectangle: make shape [\n\tsize: 20x10\n\tdraw: does [loop self\/size\/y [line self\/size\/x]]\n]\n\n; Unlike some languages discussed, REBOL has absolutely no qualms\n; about instantiating an \"abstract\" class -- that's how I created the\n; derived classes of \"rectangle\" and \"box\", after all.\n\ns: make shape []  s\/draw ; Nothing happens.\n\nprint \"A box:\"\nb: make box [pen: \"O\" size: 5]  b\/draw\n\nprint [crlf \"A rectangle:\"]\nr: make rectangle [size: 32x5]  r\/draw<\/lang>\n\n==[[:Category:Ruby|Ruby]][[Category:Ruby]]==\nThe Python and Tcl provisos apply to Ruby too.  Nevertheless, a <div class=\"examplemeta libheader\">'''Library:''' [[SMW::off]][[:Category:RubyGems|RubyGems]][[Category:RubyGems]][[SMW::on]]<\/div> package called [http:\/\/github.com\/Peeja\/abstraction\/tree\/master abstraction] exists where:\n\n<lang ruby>require 'abstraction'\n\nclass AbstractQueue\n  abstract\n  def enqueue(object)\n    raise NotImplementedError\n  end\n  def dequeue\n    raise NotImplementedError\n  end\nend\n\nclass ConcreteQueue < AbstractQueue\n  def enqueue(object)\n    puts \"enqueue #{object.inspect}\"\n  end\nend<\/lang>\nSo:\n<pre>irb(main):032:0> a = AbstractQueue.new\nAbstractClassError: AbstractQueue is an abstract class and cannot be instantiated\n        from \/usr\/lib\/ruby\/gems\/1.8\/gems\/abstraction-0.0.3\/lib\/abstraction.rb:10:in `new'\n        from (irb):32\n        from :0\nirb(main):033:0> c = ConcreteQueue.new\n=> #<ConcreteQueue:0x7fdea114>\nirb(main):034:0> c.enqueue('foo')\nenqueue \"foo\"\n=> nil\nirb(main):040:0> c.dequeue\nNotImplementedError: NotImplementedError\n        from (irb):37:in `dequeue'\n        from (irb):40\n        from :0\n<\/pre>\n\n==[[:Category:Scala|Scala]][[Category:Scala]]==\nScala has ''abstract classes'', which are classes that cannot be instantiated. They\ncan contain implementation as well as just interface. Non-abstract classes, on the\nother hand, cannot contain interfaces without implementation.\n\nScala also has ''traits'', which may contain implementations or not as needed, without\nany abstract requirement. On the other hand, traits must be ''mixed in'' a class,\ninstead of being directly instantiated. That doesn't matter all that much, as they can\nbe mixed with <tt>AnyRef<\/tt>, which is the base parent class of all user-defined\nclasses.\n\nAny element of a trait or class can be made abstract, including types, with a very\ndifferent meaning that described in this page. Here are some examples:\n\n<lang scala>abstract class X {\n  type A\n  var B: A\n  val C: A\n  def D(a: A): A\n}\n\ntrait Y {\n  val x: X\n}<\/lang>\n\nWhen integrating with Java, traits without implementation appear as interfaces.\n\n==[[:Category:Tcl|Tcl]][[Category:Tcl]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Tcl]] version 8.6[[SMW::on]]<\/div> or <div class=\"examplemeta libheader\">'''Library:''' [[SMW::off]][[:Category:TclOO|TclOO]][[Category:TclOO]][[SMW::on]]<\/div>\n\nWhile in general Tcl does not use abstract classes at all (and has no need at all for interfaces due to supporting multiple inheritance and mixins), an equivalent effect can be had by concealing the construction methods on the class instance; instances are only created by subclassing the class first (or by mixing it in). In this example, the methods are also error-returning stubs...\n<lang Tcl>oo::class create AbstractQueue {\n    method enqueue item {\n        error \"not implemented\"\n    }\n    method dequeue {} {\n        error \"not implemented\"\n    }\n    self unexport create new\n}<\/lang>\n\n==[[:Category:Visual Basic|Visual Basic]][[Category:Visual Basic]]==\n=== Abstract Classes ===\nVisual Basic doesn't support abstract classes or implementation inheritance.\n\n=== Interfaces ===\nIn Visual Basic, every class is also an interface that other classes can implement. It has this feature because it is based on COM.\n\n==[[:Category:Visual Basic .NET|Visual Basic .NET]][[Category:Visual Basic .NET]]==\n=== Abstract Classes ===\n* Overridable means subclasses may change the method's implementation. By default, methods in VB cannot be overridden.\n* MustOverride means the subclasses must provide an implementation\n* By convention all abstract classes have one or more Protected constructors.\n\n<lang vbnet>MustInherit Class Base\n\n   Protected Sub New()\n\n   End Sub\n\n   Public Sub StandardMethod()\n       'code\n   End Sub\n\n   Public Overridable Sub Method_Can_Be_Replaced()\n       'code\n   End Sub\n\n   Public MustOverride Sub Method_Must_Be_Replaced()\n\nEnd Class<\/lang>\n\n=== Interfaces ===\n\nInterfaces may contain Functions, Subroutines, Properties, and Events.\n\n<lang vbnet>Interface IBase\n   Sub Method_Must_Be_Implemented()\nEnd Interface<\/lang>\n\n[[Category:Applesoft BASIC\/Omit]]\n[[Category:ALGOL 68\/Omit]]\n[[Category:AWK\/Omit]]\n[[Category:BASIC\/Omit]]\n[[Category:Fortran\/Omit]]\n[[Category:Factor\/Omit]]\n[[Category:Falcon\/Omit]]\n[[Category:gnuplot\/Omit]]\n[[Category:Integer BASIC\/Omit]]\n[[Category:J\/Omit]]\n[[Category:JavaScript\/Omit]]\n[[Category:Icon\/Omit]]\n[[Category:LaTeX\/Omit]]\n[[Category:Make\/Omit]]\n[[Category:Mathematica\/Omit]]\n[[Category:M4\/Omit]]\n[[Category:Metafont\/Omit]]\n[[Category:ML\/I\/Omit]]\n[[Category:Modula-2\/Omit]]\n[[Category:MOO\/Omit]]\n[[Category:NSIS\/Omit]]\n[[Category:Octave\/Omit]]\n[[Category:PlainTeX\/Omit]]\n[[Category:PARI\/GP\/Omit]]\n[[Category:Scratch\/Omit]]\n[[Category:TI-89 BASIC\/Omit]]\n[[Category:UNIX Shell\/Omit]]\n[[Category:ZX Spectrum Basic\/Omit]]"}]}}},"query-continue":{"revisions":{"rvstartid":137623}}}