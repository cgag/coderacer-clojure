{"query":{"pages":{"1985":{"pageid":1985,"ns":0,"title":"Address of a variable","revisions":[{"*":"<div class=\"infobox\" style=\"width: 2in\">[[File:Rcode-button-task-crushed.png|64px|left|alt=Task|link=Category:Solutions by Programming Task]]'''Address of a variable'''<br\/>\nYou are encouraged to [[Rosetta Code:Solve a Task|solve this task]] according to the task description, using any language you may know.[[Category:Programming Tasks]][[Category:Basic Data Operations]]<\/div><div class=\"infobox\" style=\"width: 2in\">\n<big>'''Basic Data Operation'''<\/big><br>\nThis is a basic data operation.  It represents a fundamental action on a basic data type.\n\nYou may see other such operations in the [[:Category:Basic Data Operations|Basic Data Operations]] category, or:\n\n<center><small>\n'''Integer Operations'''\n<br>\n[[Arithmetic\/Integer|Arithmetic]] |\n[[Integer comparison|Comparison]]\n\n'''Boolean Operations'''\n<br>\n[[Bitwise operations|Bitwise]] |\n[[Logical operations|Logical]]\n\n'''String Operations'''\n<br>\n[[String concatenation|Concatenation]] |\n[[String interpolation (included)|Interpolation]] |\n[[Character matching|Matching]]\n\n'''Memory Operations'''\n<br>\n[[Pointers and references|Pointers &amp; references]] |\n[[Address of a variable|Addresses]]\n<\/small><\/center><\/div>\n[[Category:Basic Data Operations]]\nDemonstrate how to get the address of a variable and how to set the address of a variable.\n\n==[[:Category:Ada|Ada]][[Category:Ada]]==\n===Get The Address===\n<lang ada>The_Address : System.Address;\nI : Integer;\nThe_Address := I'Address;<\/lang>\n===Set The Address===\nSet the address of a variable to address A100 in hexadecimal\n<lang ada>I : Integer;\nfor I'Address use 16#A100#;<\/lang>\nSet the address of one variable to the address of another variable, creating an overlay.\n<lang ada>I : Integer;\nJ : Integer;\nfor I'Address use J'Address;<\/lang>\n[[Category:Lua\/Omit]]\n\n==[[:Category:ALGOL 68|ALGOL 68]][[Category:ALGOL 68]]==\nBasically ALGOL 68 refuses to let the programmer access the memory directly.  The language does \nallow \"references\" any variables.  These references are effectively the address a particular\nvariable.  But the value of the actual address is not available for printing or any arithmetic.\n<lang algol68>[4]INT test := (222,444,666,888);\nREF INT reference := test[3];\nREF INT(reference) := reference + 111;\nprint((\"test value is now: \",test))<\/lang>\nOutput:\n<pre>test value is now:        +222       +444       +777       +888<\/pre>\n\nThe other reason specific addresses are using in languages like [[C]]  to manipulate \ndevices.  For this purpose site are expected to implement channels for their programmers to use.\nTo quote the ALGOL 68 Revised Report: <i>A \"channel\" corresponds to one or more physical devices (e.g., \na card reader, a card punch or a line printer, or even to a set up in \nnuclear physics the results of which are collected by the computer), \nor to a filestore maintained by the operating system<\/i>[http:\/\/www.xs4all.nl\/~jmvdveer\/report_5.html#A312aa].\n\nTo establish a channel with such a device there is a special standard procedure:<lang algol68>PROC establish = (REF FILE file, STRING idf, CHANNEL chan, INT p, l, c) INT: ~<\/lang>\nWhere the <tt>idf<\/tt> string is text describing which device to open, and possibly \noptions.  And <tt>chan<\/tt> is the actual device type.  Standard CHANNELs in \nALGOL 68 are <tt>stand in channel<\/tt>, <tt>stand out channel<\/tt>, and <tt>stand \nback channel<\/tt>.  These determine the type of the pre opened stdio FILEs <tt>stand in<\/tt>, \n<tt>stand out<\/tt>, and <tt>stand back<\/tt>. A site would be expected to \nimplement their own CHANNELs for network connections, database queries and particle accelerators etc.\n\n==[[:Category:Argile|Argile]][[Category:Argile]]==\n=== Get the address ===\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Argile]] version 1.0.0[[SMW::on]]<\/div>\n<lang Argile>use std, array\t\t(: array.arg also defines pointer operators :)\nlet var = 42\nlet ptr = &var\t\t(: value of ptr is address of var :)\nprint var\t\t(: prints 42 :)\n(*ptr)++\t\t(: increments value pointed by ptr :)\nprint var\t\t(: prints 43 :)<\/lang>\n=== Set the address ===\nSince we cannot set address of a variable, we use a macro\nthat returns a reference.\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Argile]] version 1.0.0[[SMW::on]]<\/div>\n<lang Argile>use std, array\n=:mac:= -> int& { * (0x400000 as int*) }\nprintf \"%x\\n\" mac\t(: may crash depending on operating system :)\n<\/lang>\n\n==[[:Category:AutoHotkey|AutoHotkey]][[Category:AutoHotkey]]==\nGetting or setting the address of a variable is not supported as a builtin function.\nHowever, you can get the address of contents pointed to by the variable structure var\n<lang AutoHotkey>msgbox % &var<\/lang>\n\n==[[:Category:BASIC|BASIC]][[Category:BASIC]]==\nMany BASICs, especially older flavors like [[QuickBASIC]], lack the ability to set a variable's address (and indeed, they pretty much all lack the ability to work with pointers in any fashion).\n<lang qbasic>'get a variable's address:\nDIM x AS INTEGER, y AS LONG\ny = VARPTR(x)\n\n'can't set the address, but can access a given memory location... 1 byte at a time\nDIM z AS INTEGER\nz = PEEK(y)\nz = z + (PEEK(y) * 256)<\/lang>\n\n==[[:Category:BBC BASIC|BBC BASIC]][[Category:BBC BASIC]]==\nThe original BBC BASIC doesn't provide an address-of operator, but ''BBC BASIC for Windows'' does:\n<lang bbcbasic>REM get a variable's address:\ny% = ^x%\n\nREM can't set a variable's address, but can access a given memory location (4 bytes):\nx% = !y%<\/lang>\n\nWith BBC BASIC on other platforms the address of a variable can be found by calling a short piece of machine code, see [http:\/\/beebwiki.jonripley.com\/Address_of_a_variable BeebWiki].\n\n==<span id=\"C sharp\">[[:Category:C sharp|C#]]<\/span>[[Category:C sharp]]==\n\nUse of pointers in C# is restricted to <code>unsafe<\/code> sections of code, which is enabled in Microsoft's C# compiler with the commandline parameter <code>\/unsafe<\/code> or in Mono's C# compiler with <code>-unsafe<\/code> (or <code>--unsafe<\/code> in older versions).\n\n=== Get the address ===\nNote that void* is a \"pure\" address which doesn't carry the type information anymore. If you need the type information (e.g. to recover the variable itself in a type safe manner), use a pointer to the appropriate type instead; in this case int*.\n\n<lang csharp>unsafe\n{\n  int i = 5;\n  void* address_of_i = &i;\n}<\/lang>\n\n==[[:Category:C|C]][[Category:C]] \/ [[:Category:C++|C++]][[Category:C++]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[gcc]][[SMW::on]]<\/div>\/ [[g++]]\n=== Get the address ===\nNote that void* is a \"pure\" address which doesn't carry the type information anymore. If you need the type information (e.g. to recover the variable itself in a type safe manner), use a pointer to the appropriate type instead; in this case int*.\n int i;\n void* address_of_i = &i;\n=== Set the address ===\nWhile C++ doesn't directly support putting a variable at a given address, the same effect can be achieved by creating a reference to that address:\n int& i = *(int*)0xA100;\nOverlaying of variables is done with anonymous unions; however at global\/namespace scope such variables have to be static (i.e. local to the current file):\n static union\n {\n   int i;\n   int j;\n };\n'''C++ only:''' An alternative (and cleaner) solution is to use references:\n int i;\n int& j = i;\nNote that in this case, the variables can be non-static.\n\n[[Category:Clojure\/Omit]]\n\n==[[:Category:COBOL|COBOL]][[Category:COBOL]]==\nUsing OpenCOBOL 1.1pre-release, which includes a few features from the draft 20xx standard efforts.\n\n===Get Address===\nuse the ADDRESS OF clause.\n<lang cobol>\ndata division.\nworking-storage section.\n01 ptr usage pointer.\n01 var pic x(64).\n\nprocedure division.\nset ptr to address of var.\n<\/lang>\n\n===Set Address===\nSet address of a variable: using BASED clause.\n''there are other methods, in particular LINKAGE SECTION variables''\n<lang cobol>\nOCOBOL*> Rosetta Code set address example\n      *> tectonics: cobc -x setaddr.cob && .\/setaddr \n       program-id. setaddr.\n       data division.\n       working-storage section.\n       01 prealloc  pic x(8) value 'somedata'.\n       01 var       pic x(8) based.\n       procedure division.\n       set address of var to address of prealloc\n       display var end-display\n       goback.\n       end program setaddr.\n<\/lang>\n\n==[[:Category:Common Lisp|Common Lisp]][[Category:Common Lisp]]==\n\n===Simulated Address of Variable===\n\nCommon Lisp has no means to take a simple address reference to a ''place'' (the Lisp term for any one of many types of assignable storage locations). For instance, to access the slot of a structure, we need the structure itself (which is essentially a pointer) and a symbol denoting the slot name. To access an array, we need that array object, and an index. To access a local variable, we need the closure object, which is only accessible to code within the lexical scope, which is a long-winded way of saying, we can only access a variable via an expression which is in the lexical scope of the variable.\n\nYet, thanks to Lisp macros and lexical closures, we can create reference values which behave like address of places. A tiny module for doing this is found in [http:\/\/paste.lisp.org\/display\/71952 Lisppaste #71952], required by the following example:\n\n<lang lisp>;;; Demonstration of references by swapping two variables using a function rather than a macro\n;;; Needs http:\/\/paste.lisp.org\/display\/71952\n(defun swap (ref-left ref-right)\n  ;; without with-refs we would have to write this:\n  ;; (psetf (deref ref-left) (deref ref-right)\n  ;;        (deref ref-right) (deref ref-left))\n  (with-refs ((l ref-left) (r ref-right))\n    (psetf l r r l)))\n\n(defvar *x* 42)\n(defvar *y* 0)\n\n(swap (ref *x*) (ref *y*))\n\n;; *y* -> 42\n;; *x* -> 0<\/lang>\n\nThese references are completely safe to use. There is no way that a place can disappear, leaving a reference dangling, because if a reference is a live object, it prevents the object which contains the referenced place from becoming garbage. Also note that if two references are taken to the same memory location, they are two distinct objects. A function could be provided to test two references for referential equality (do they point to the same object).\n\n===Varible-Like Moniker for External Location===\n\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[CLISP]][[SMW::on]]<\/div> <div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Linux]][[SMW::on]]<\/div> <div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Cygwin]][[SMW::on]]<\/div>\n\nWhat does it mean to \"set the address of a variable?\" One interpretation of this task is: rather than let the programming language compiler or run-time allocate a named storage location in its usual ways, force the allocation of a variable at some particular memory location, such as a hardware register, or a variable in a foreign library.  Lisp implementations have foreign function interfaces for doing this sort of thing.\n\nHere is an example specific to CLISP running on either Linux or Cygwin. It creates a Lisp <code>errno<\/code> variable which is located in the C Library's <code>errno<\/code>.  The C Library's <code>errno<\/code> is actually thread-specific, whose location is retrieved by calling a hidden function.\n\nWe wrap this function with a Lisp foreign call which is properly annotated as returning a C pointer to int. When we call this function, we get an object that behaves like a reference to that location. All we need then is a macro which looks like a storage location.\n\n<lang lisp>(use-package :ffi)\n\n(defmacro def-libc-call-out (name &rest args)\n  `(def-call-out ,name\n     (:language :stdc)\n     #-cygwin(:library \"libc.so.6\")\n     #+cygwin (:library \"cygwin1.dll\")\n     ,@args))\n\n(progn\n  (def-libc-call-out errno-location\n    #-cygwin (:name \"__errno_location\")\n    #+cygwin (:name \"__errno\")\n    (:arguments)\n    (:return-type (c-pointer int)))\n\n  (defun get-errno ()\n    (let ((loc (errno-location)))\n      (foreign-value loc)))\n\n  (defun set-errno (value)\n    (let ((loc (errno-location)))\n      (setf (foreign-value loc) value)))\n\n  (defsetf get-errno set-errno)\n\n  (define-symbol-macro errno (get-errno)))<\/lang>\n\nTest:\n\n<pre>[1]> (setf errno 42)\n42\n[2]> errno\n0   ;; Oops! the REPL itself executed a bunch of code which cleared errno\n[3]> (progn (delete-file \"nonexistent\") errno)\n2   ;; Aha! 2 is ENOENT: No such file or directory<\/pre>\n\n==[[:Category:D|D]][[Category:D]]==\n\nTake the address of a variable:\n<lang d>int i;\nint* ip = &i;<\/lang>\n\nUsing a numeric value:\n<lang d>int* ip = cast(int*)0xdeadf00d;<\/lang>\n\nLocating a \"regular\" variable at a specific address is not possible.\n\nThe closest thing is passing a dereferenced pointer to a reference parameter.\n\n<lang d>void test(ref int i) {\n    writefln(&i);\n}\n\nvoid main() {\n    test(* (cast(int*)0xdeadf00d) );\n}<\/lang>\n\n==[[:Category:Delphi|Delphi]][[Category:Delphi]]==\n\nTurbo\/Borland Pascal and Delphi (Object Pascal) support the @ ( address of ) operator and the var : [type] absolute declaration.\n\nTo get the address of any variable, structure, procedure or function use the @ operator.\n\n  var\n    Int : integer ;\n    p   : ^integer ;\n  begin\n    P := @int ;\n    writeln(p^);\n  end;\n\nA variable can be declared as absolute ie: to reside at a specific address.\n\n  Var\n    CrtMode : integer absolute $0040 ;\n    Str     : string[100] ;\n    StrLen  : byte absolute Str ;\n\n==[[:Category:Forth|Forth]][[Category:Forth]]==\nVariables and created memory blocks return their address when referenced. The \"fetch\" operator '''@''' could also be pronounced \"dereference\".\n variable foo\n foo .  \\ some large number, an address\n 8 foo !\n foo @ .  \\ 8\n\nYou can define a constant or value with an address, which then acts like a variable. This can be used to refer to fixed addresses (such as I\/O ports), graphics buffers, or allocated memory.\n $3F8 constant LPT1:\n 8 LPT1: !\n\n 100 cells allocate throw value buffer\n 42 buffer 20 cells + !\n==[[:Category:Fortran|Fortran]][[Category:Fortran]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Fortran]] version 90 and later[[SMW::on]]<\/div>\n<lang fortran>program test_loc\n\n  implicit none\n  integer :: i\n  real :: r\n\n  i = loc (r)\n  write (*, '(i0)') i\n\nend program test_loc<\/lang>\nNote: <code>loc<\/code> is a common extension that is implemented by e.g. the Intel Fortran Compiler, G95 and gfortran.\n\n==[[:Category:Go|Go]][[Category:Go]]==\nGo has pointers. Just like in C, you can \"take the address\" of an addressable value by using the <code>&<\/code> operator, and access the value pointed to by a pointer using the <code>*<\/code> operator.\n\nUnlike in C, pointers are not readily convertible to integers. You may print out the address of a pointer, either using the Print function on the pointer, or using the <code>%p<\/code> format specifier in formatted output (just like in C). If you really want, you may convert a pointer to an integer using the unsafe package\n\nThe following demonstrates getting the address of a variable.  It is not possible in Go to set the address of a variable.\n<lang go>package main\n\nimport (\n    \"fmt\"\n    \"unsafe\"\n)\n\nfunc main() {\n    myVar := 3.14\n    myPointer := &myVar\n    fmt.Println(myPointer)\n    fmt.Printf(\"%p\\n\", myPointer)\n\n    addr := int64(uintptr(unsafe.Pointer(myPointer)))\n    fmt.Printf(\"0x%x\\n\", addr)\n}<\/lang>\nExample output:\n<pre>\n0xf840026018\n0xf840026018\n0xf840026018\n<\/pre>\n\n== [[:Category:J|J]][[Category:J]] ==\n\nJ hides the details of pointers and memory allocation from the programmer, so it is rarely, if ever, necessary to do this.  However, for those times when there is no better substitute, J provides access to these low-level details:\n\n<lang>   var      =: 52                NB.  Any variable (including data, functions, operators etc)\n   var_addr =: 15!:6<'var'       NB.  Get address\n   new_var  =: 15!:7 var_addr    NB.  Set address<\/lang>\n\n==[[:Category:Java|Java]][[Category:Java]]==\n\nThere is no way to access addresses in Java. However, the [http:\/\/download.oracle.com\/javase\/6\/docs\/api\/java\/lang\/Object.html#hashCode%28%29 default hashCode()] method defined in the Object class, \"is typically implemented by converting the internal address of the object into an integer\". Therefore, in some Java implementations at least, the hash code returned by <code>Object.hashCode()<\/code> reflects at least part of the address of an object. For objects whose classes have overridden the <code>hashCode()<\/code> method, you can still access the original hash code through the [http:\/\/download.oracle.com\/javase\/6\/docs\/api\/java\/lang\/System.html#identityHashCode%28java.lang.Object%29 System.identityHashCode()] function.\n\n[[Category:K\/Omit]]\n\n==[[:Category:Modula-2|Modula-2]][[Category:Modula-2]]==\n===Get Address===\n<lang modula2>MODULE  GetAddress;\n\nFROM    SYSTEM IMPORT ADR;\nFROM    InOut  IMPORT WriteInt, WriteLn;\n\nVAR     var : INTEGER;\n        adr : LONGINT;\nBEGIN\n    adr := ADR(var);    (*get the address*)\n    WriteInt(adr, 0);\n    WriteLn;\nEND GetAddress.<\/lang>\n\n===Set Address===\n<lang modula2>MODULE  SetAddress;\n\nCONST   adress  = 134664460;\n\nVAR     var [adress] : INTEGER;\n\nBEGIN\n    (*do nothing*)\nEND SetAddress.<\/lang>\n==[[:Category:NewLISP|NewLISP]][[Category:NewLISP]]==\n===Get Address===\n<lang NewLISP>\n(set 'a '(1 2 3))\n(address a)\n<\/lang>\n\n==[[:Category:Oberon-2|Oberon-2]][[Category:Oberon-2]]==\n===Get Address===\n<pre>\nVAR a: LONGINT;\nVAR b: INTEGER;\n\nb := 10;\na := SYSTEM.ADR(b); (* Sets variable a to the address of variable b *)\n<\/pre>\n\n===Set Address===\n<pre>\nSYSTEM.PUT(a, b); (* Sets the address of b to the address of a *)\n<\/pre>\n\n==[[:Category:OCaml|OCaml]][[Category:OCaml]]==\n\nOCaml is a high-level programming language, and thus does not explose the addresses of variables to the programmer.\n\n==[[:Category:PARI\/GP|PARI\/GP]][[Category:PARI\/GP]]==\nIn GP you can sent the address to built-in commands like issquare\n<lang parigp>issquare(n, &m)<\/lang>\nbut you cannot directly compute with it.  You can view the address of a variable and other debugging information with the\n<pre>\\x<\/pre>\ncommand.\n\nIn PARI you can use standard [[#C_.2F_C.2B.2B|C]] commands.\n\n==[[:Category:Pascal|Pascal]][[Category:Pascal]]==\nSee [[Address_of_a_variable#Delphi | Delphi]]\n\n==[[:Category:Perl|Perl]][[Category:Perl]]==\nTo get the address, get the reference to a variable, and either stringify it, or use Scalar::Util's refaddr() to get just the address. Also see Devel::Peek.\n<lang perl>use Scalar::Util qw(refaddr);\nprint refaddr(\\my $v), \"\\n\";  # 135691508<\/lang>\nUse Devel::Pointer::PP if you want to dereference a certain address in memory.\n\nChanging the address of a variable is not easily possible, but see perlapi. Wanting to go against the automatic memory management is a sign that this is only used to hack around the deficiencies of dafter languages. I can imagine address munging is commonly used to make variable aliasing possible, but Perl already has a higher level syntax for that.\n\nSimple reference (address) manipulation.\n<lang perl>my $a = 12;\nmy $b = \\$a; # get reference\n$$b = $$b + 30; # access referenced value\nprint $a; # prints 42<\/lang>\n\nExample how to make variable overlay.\n<lang perl>my $a = 12;\nour $b; # you can overlay only global variables (this line is only for strictness)\n*b = \\$a;\nprint $b; # prints 12\n$b++;\nprint $a; # prints 13<\/lang>\n\n==[[:Category:PicoLisp|PicoLisp]][[Category:PicoLisp]]==\nThe PicoLisp function '[http:\/\/software-lab.de\/doc\/refA.html#adr adr]' returns\nthe address of a variable. A variable may be either a symbol or a list cell in\nPicoLisp.\n\nThe returned address is a number representing an encoded pointer. For symbols,\nit is a negative number, and for cells a positive number. The same function\n'adr' can then be used to convert that pointer back to the original object.\n<lang PicoLisp>: (setq X 7)\n-> 7\n\n: (adr 'X)  \n-> -2985527269106\n\n: (val (adr -2985527269106))\n-> 7\n\n: (set (adr -2985527269106) '(a b c))\n-> (a b c)\n\n: X                                  \n-> (a b c)<\/lang>\n\n==[[:Category:PL\/I|PL\/I]][[Category:PL\/I]]==\n<lang PL\/I>\ndeclare p pointer;\nk = addr(b); \/* Obtain address of variable, stored in integer variable k *\/\np = addr(q); \/* assigns address to pointer variable p. *\/\n<\/lang>\n\n==[[:Category:PowerBASIC|PowerBASIC]][[Category:PowerBASIC]]==\n<lang powerbasic>'get a variable's address:\nDIM x AS INTEGER, y AS LONG\ny = VARPTR(x)\n\n'can't set the address of a single variable, but can access memory locations\nDIM z AS INTEGER\nz = PEEK(INTEGER, y)\n\n'or can do it one byte at a time\nDIM zz(1) AS BYTE\nzz(0) = PEEK(BYTE, y)\nzz(1) = PEEK(BYTE, y + 1)\n'(MAK creates an INTEGER, LONG, or QUAD out of the next smaller type)\nz = MAK(INTEGER, zz(0), zz(1))\n\n'*can* set the address of an array\nDIM zzz(1) AS BYTE AT y\n'zzz(0) = low byte of x, zzz(1) = high byte of x<\/lang>\n\n==[[:Category:PureBasic|PureBasic]][[Category:PureBasic]]==\nGet the address of a variable using the '@' operator.\n<lang PureBasic>a.i = 5\nMessageRequester(\"Address\",Str(@a))<\/lang>\n\n\nSet the address of a structured pointer. The pointer can be dereferenced to interact with it's data.  Ensure that there is access to the memory address that is assigned to the pointer (i.e. part of allocated memory).\n<lang PureBasic>a.i = 5\n*b.Integer = @a    ;set *b equal to the address of variable a \n*c.Integer = $A100 ;set *c to point at memory location $A100 (in hex)\n\n\nMessageRequester(\"Address\",Str(*b)) ;display the address being pointed at by *b\nMessageRequester(\"Value\",Str(*b\\i)) ;de-reference the pointer *b to display the data being pointed at<\/lang>\n\n==[[:Category:Python|Python]][[Category:Python]]==\n\nPython traditionally doesn't support low-level operations on memory addresses, except in the limited sense that one can use the ''mmap'' module where it's available, and manipulate offsets into memory map objects...including serializing other objects into and out of the memory mapping. New versions of Python support a ''ctypes'' module which permits some low level address operations on C-type objects (see [http:\/\/docs.python.org\/lib\/ctypes-ctypes-reference.html C-types Reference] for details).\n\nThe Python ''id()'' function returns a unique ID for any object. This just happens to be implemented as the base address of the object in C Python[http:\/\/docs.python.org\/library\/functions.html#id]; but that is not guaranteed by the semantics of the language and should not be considered a standard, nor used as such. But for comparison purposes the ID can be used as an address, since different extant objects will have different IDs.\n\n<lang python>foo = object()  # Create (instantiate) an empty object\naddress = id(foo)<\/lang>\n\nIn addition some folks have written binary Python modules which implement \"peek\" and \"poke\" operations, but these are non-standard.\n\n==[[:Category:Retro|Retro]][[Category:Retro]]==\nRetro is only able to directly access memory as 32-bit values within a linear address space.\n\n===Get The Address===\n<lang Retro>variable a\n&a<\/lang>\n\n===Set The Address===\nCreate variable '''b''' and point it to address '''100'''\n<lang Retro>variable b\n100 @last !d->xt<\/lang>\n\n===Byte Addressing===\nRetro includes a standard library allowing for creation and access of byte-level data. This is done by creating a ''pool'', which the library functions can then access individual bytes from. The pool has a physical address, which can be set or read, and virtual addresses (starting with zero, and increasing linearly) which are used by the library functions.\n\nTo read the address of the currently active pool:\n\n<lang Retro>needs bad'\n^bad'pool @<\/lang>\n\nOr to set the pool to a specific physical location such as address 100:\n\n<lang Retro>100 ^bad'pool !<\/lang>\n\n==[[:Category:REXX|REXX]][[Category:REXX]]==\nREXX has no way of getting the address of varables within the langage itself, but since each\n<br>\nREXX variable can be accessed by name and it's name passed to (say) subroutines [PROCEDUREs], \n<br>\nwith the use of the VALUE and SYMBOL built-in functions (BIFs), it's possible to determine \n<br>\nthe state of any variable (defined or not, it's value, length).\n\n==[[:Category:Ruby|Ruby]][[Category:Ruby]]==\n\nThe Ruby <code>object_id<\/code> method returns an object ID that is unique among active objects. It turns out that for the official Ruby implementation, the object ID is based on the address. For non-immediate objects (i.e. anything other than a <code>Fixnum<\/code>, <code>Symbol<\/code>, <code>true<\/code>, <code>false<\/code>, or <code>nil<\/code>), the address can be obtained by shifting the object ID one to the left. For more information, see the source code for the <code>object_id<\/code> method:[http:\/\/www.ruby-doc.org\/core\/Object.html#method-i-object_id].\n\nFor classes that do not override the <code>to_s<\/code> method, the <code>to_s<\/code> method also shows the address.\n\n<lang ruby>>foo = Object.new  # => #<Object:0x10ae32000>\n>id = foo.object_id  # => 2238812160\n>\"%x\" % (id << 1)  # => \"10ae32000\"\n<\/lang>\n\n==[[:Category:Tcl|Tcl]][[Category:Tcl]]==\nIt is highly unusual to want to directly manipulate the address of a variable in Tcl, as it is a thoroughly unsafe operation. Indeed, Tcl does not expose any mechanism to do so at the script level. However, Tcl does contain a C-level API function, <tt>[http:\/\/www.tcl.tk\/man\/tcl8.6\/TclLib\/LinkVar.htm Tcl_LinkVar]<\/tt>, to arrange for a variable's value to always reflect the contents of a particular address in memory. (See [[Machine Address#Tcl|Machine Address]] for an example of how to do that.)\n\nHowever, that's not the only way of doing it. You can also use the '''critcl''' library to put [[C]] code directly inside a Tcl script and so work with addresses directly that way.\n<br>\n<div class=\"examplemeta libheader\">'''Library:''' [[SMW::off]][[:Category:critcl|critcl]][[Category:critcl]][[SMW::on]]<\/div>\n<lang tcl>package require critcl\n# This code assumes an ILP32 architecture, like classic x86 or VAX.\ncritcl::cproc peek {int addr} int {\n    union {\n       int i;\n       int *a;\n    } u;\n\n    u.i = addr;\n    return *u.a;\n}\ncritcl::cproc poke {int addr int value} void {\n    union {\n        int i;\n        int *a;\n    } u;\n\n    u.i = addr;\n    *u.a = value;\n}\npackage provide poker 1.0<\/lang>\nDemonstrating:\n<lang tcl>package require poker\n\n# Increment a memory location; this will probably crash if you try for real.\n# We don't define how to get a good address, but it's not usually a problem\n# for embedded programming...\nset where 0x12340\npoke $where [expr {[peek $where] + 1}]<\/lang>\nHave great care with this sort of code; the damage you can do by writing to random locations is considerable and being able to read from anywhere could allow information to flow to otherwise unauthorized programs.\n\n==[[:Category:Toka|Toka]][[Category:Toka]]==\n\n===Get the Address===\nThe default behaviour of a data element in Toka is to return its address. This makes obtaining the address trivial:\n\n variable foo\n foo .\n\n===Set the Address===\nYou can manually assign a name to any memory address (or other number), but you\nshould make sure it's part of allocated memory first.\n\n  hex abcdef is-data foo\n  foo .\n\n==[[:Category:Visual Basic .NET|Visual Basic .NET]][[Category:Visual Basic .NET]]==\n\nVisual Basic uses managed memory that can be moved around at any time. If a memory address for a variable is needed, the address is created first and then its contents copied.\n\n===Get the Address===\nAllocates a stable address in unmanaged memory, copies a variable to it, then returns the address itself.\n\n  Dim x = 5\n  Dim ptrX As IntPtr\n  ptrX = Marshal.AllocHGlobal(Marshal.SizeOf(GetType(Integer)))\n  Marshal.StructureToPtr(5, ptrX, False)\n  Dim addressX = ptrX.ToInt64\n\n===Set the Address===\nSets the pointer to the address A100 in hex.\n\n  Dim ptrX As New IntPtr(&HA100)\n\n==[[:Category:Yorick|Yorick]][[Category:Yorick]]==\n\nYorick has pointers, but they are typically used in an opaque fashion. Pointer arithmetic is not supported, not is referencing arbitrary memory locations. However, a pointer address may be copied to other variables. Here is an interactive example that illustrates some of this.\n<pre>> foo = 1\n> bar = &foo\n> bar\n0x15f42c18\n> baz = bar\n> *baz = 5\n> *bar\n5\n> *baz\n5<\/pre>\n\n[[Category:AWK\/Omit]]\n[[Category:Common Lisp\/Omit]]\n[[Category:E\/Omit]]\n[[Category:Erlang\/Omit]]\n[[Category:Factor\/Omit]]\n[[Category:Falcon\/Omit]]\n[[Category:gnuplot\/Omit]]\n[[Category:Groovy\/Omit]]\n[[Category:GUISS\/Omit]]\n[[Category:Haskell\/Omit]]\n[[Category:JavaScript\/Omit]]\n[[Category:Joy\/Omit]] \n[[Category:Icon\/Omit]][[Category:Unicon\/Omit]]\n[[Category:LaTeX\/Omit]]\n[[Category:M4\/Omit]]\n[[Category:Make\/Omit]]\n[[Category:MATLAB\/Omit]]\n[[Category:Mathematica\/Omit]]\n[[Category:Metafont\/Omit]]\n[[Category:ML\/I\/Omit]]\n[[Category:MUMPS\/Omit]]\n[[Category:NetRexx\/Omit]]\n[[Category:NSIS\/Omit]]\n[[Category:OCaml\/Omit]]\n[[Category:Octave\/Omit]]\n[[Category:Oz\/Omit]]\n[[Category:PlainTeX\/Omit]]\n[[Category:Scratch\/Omit]]\n[[Category:TI-89 BASIC\/Omit]]\n[[Category:Unlambda\/Omit]]\n[[Category:Verilog\/Omit]]\n[[Category:VHDL\/Omit]]\n[[Category:XSLT\/Omit]]"}]}}},"query-continue":{"revisions":{"rvstartid":131283}}}