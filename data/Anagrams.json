{"query-continue":{"search":{"gsroffset":1},"revisions":{"rvstartid":137772}},"query":{"pages":{"3052":{"pageid":3052,"ns":0,"title":"Anagrams","revisions":[{"*":"<div class=\"infobox\" style=\"width: 2in\">[[File:Rcode-button-task-crushed.png|64px|left|alt=Task|link=Category:Solutions by Programming Task]]'''Anagrams'''<br\/>\nYou are encouraged to [[Rosetta Code:Solve a Task|solve this task]] according to the task description, using any language you may know.[[Category:Programming Tasks]][[Category:Text processing]]<\/div>\nTwo or more words can be composed of the same characters, but in a different order. Using the word list at http:\/\/www.puzzlers.org\/pub\/wordlists\/unixdict.txt, find the sets of words that share the same characters that contain the most words in them.\n\n==[[:Category:ABAP|ABAP]][[Category:ABAP]]==\n<lang ABAP>report zz_anagrams no standard page heading.\ndefine update_progress.\n  call function 'SAPGUI_PROGRESS_INDICATOR'\n    exporting\n      text = &1.\nend-of-definition.\n\n\" Selection screen segment allowing the person to choose which file will act as input.\nselection-screen begin of block file_choice.\n  parameters p_file type string lower case.\nselection-screen end of block file_choice.\n\n\" When the user requests help with input, run the routine to allow them to navigate the presentation server.\nat selection-screen on value-request for p_file.\n  perform getfile using p_file.\n\nat selection-screen output.\n  %_p_file_%_app_%-text = 'Input File: '.\n\nstart-of-selection.\n  data: gt_data type table of string.\n\n  \" Read the specified file from the presentation server into memory.\n  perform readfile using p_file changing gt_data.\n  \" After the file has been read into memory, loop through it line-by-line and make anagrams.\n  perform anagrams using gt_data.\n\n\" Subroutine for generating a list of anagrams.\n\" The supplied input is a table, with each entry corresponding to a word.\nform anagrams using it_data like gt_data.\n  types begin of ty_map.\n    types key type string.\n    types value type string.\n  types end of ty_map.\n\n  data: lv_char     type c,\n        lv_len      type i,\n        lv_string   type string,\n        ls_entry    type ty_map,\n        lt_anagrams type standard table of ty_map,\n        lt_c_tab    type table of string.\n\n  field-symbols: <fs_raw> type string.\n  \" Loop through each word in the table, and make an associative array.\n  loop at gt_data assigning <fs_raw>.\n    \" First, we need to re-order the word alphabetically. This generated a key. All anagrams will use this same key.\n    \" Add each character to a table, which we will then sort alphabetically.\n    lv_len = strlen( <fs_raw> ).\n    refresh lt_c_tab.\n    do lv_len times.\n      lv_len = sy-index  - 1.\n      append <fs_raw>+lv_len(1) to lt_c_tab.\n    enddo.\n    sort lt_c_tab as text.\n    \" Now append the characters to a string and add it as a key into the map.\n    clear lv_string.\n    loop at lt_c_tab into lv_char.\n      concatenate lv_char lv_string into lv_string respecting blanks.\n    endloop.\n    ls_entry-key = lv_string.\n    ls_entry-value = <fs_raw>.\n    append ls_entry to lt_anagrams.\n  endloop.\n  \" After we're done processing, output a list of the anagrams.\n  clear lv_string.\n  loop at lt_anagrams into ls_entry.\n    \" Is it part of the same key --> Output in the same line, else a new entry.\n    if lv_string = ls_entry-key.\n        write: ', ', ls_entry-value.\n    else.\n      if sy-tabix <> 1.\n        write: ']'.\n      endif.\n      write:  \/ '[', ls_entry-value.\n    endif.\n    lv_string = ls_entry-key.\n  endloop.\n  \" Close last entry.\n  write ']'.\nendform.\n\n\" Read a specified file from the presentation server.\nform readfile using i_file type string changing it_raw like gt_data.\n  data: l_datat type string,\n        l_msg(2048),\n        l_lines(10).\n\n  \" Read the file into memory.\n  update_progress 'Reading file...'.\n  call method cl_gui_frontend_services=>gui_upload\n    exporting\n      filename = i_file\n    changing\n      data_tab = it_raw\n    exceptions\n      others   = 1.\n  \" Output error if the file could not be uploaded.\n  if sy-subrc <> 0.\n    write : \/ 'Error reading the supplied file!'.\n    return.\n  endif.\nendform.<\/lang>\nOutput:\n<pre>[ angel ,  angle ,  galen ,  glean ,  lange ]\n[ elan ,  lane ,  lean ,  lena ,  neal ]\n[ alger ,  glare ,  lager ,  large ,  regal ]\n[ abel ,  able ,  bale ,  bela ,  elba ]\n[ evil ,  levi ,  live ,  veil ,  vile ]\n[ caret ,  carte ,  cater ,  crate ,  trace ]<\/pre>\n\n==[[:Category:Ada|Ada]][[Category:Ada]]==\n<lang ada>with Ada.Text_IO;  use Ada.Text_IO;\n\nwith Ada.Containers.Indefinite_Ordered_Maps;\nwith Ada.Containers.Indefinite_Ordered_Sets;\n\nprocedure Words_Of_Equal_Characters is\n   package Set_Of_Words is new Ada.Containers.Indefinite_Ordered_Sets (String);\n   use Ada.Containers, Set_Of_Words;\n   package Anagrams is new Ada.Containers.Indefinite_Ordered_Maps (String, Set);\n   use Anagrams;\n\n   File   : File_Type;\n   Result : Map;\n   Max    : Count_Type := 1;\n\n   procedure Put (Position : Anagrams.Cursor) is\n      First : Boolean := True;\n      List  : Set renames Element (Position);\n      procedure Put (Position : Set_Of_Words.Cursor) is\n      begin\n         if First then\n            First := False;\n         else\n            Put (',');\n         end if;\n         Put (Element (Position));\n      end Put;\n   begin\n      if List.Length = Max then\n         Iterate (List, Put'Access);\n         New_Line;\n      end if;\n   end Put;\n\nbegin\n   Open (File, In_File, \"unixdict.txt\");\n   loop\n      declare\n         Word : constant String     := Get_Line (File);\n         Key  : String (Word'Range) := (others => Character'Last);\n         List : Set;\n         Position : Anagrams.Cursor;\n      begin\n         for I in Word'Range loop\n            for J in Word'Range loop\n               if Key (J) > Word (I) then\n                  Key (J + 1..I) := Key (J..I - 1);\n                  Key (J) := Word (I);\n                  exit;\n               end if;\n            end loop;\n         end loop;\n         Position := Find (Result, Key);\n         if Has_Element (Position) then\n            List := Element (Position);\n            Insert (List, Word);\n            Replace_Element (Result, Position, List);\n         else\n            Insert (List, Word);\n            Include (Result, Key, List);\n         end if;\n         Max := Count_Type'Max (Max, Length (List));\n      end;\n   end loop;\nexception\n   when End_Error =>\n      Iterate (Result, Put'Access);\n      Close (File);\nend Words_Of_Equal_Characters;<\/lang>\nSample output:\n<pre>\nabel,able,bale,bela,elba\ncaret,carte,cater,crate,trace\nangel,angle,galen,glean,lange\nalger,glare,lager,large,regal\nelan,lane,lean,lena,neal\nevil,levi,live,veil,vile\n<\/pre>\n\n==[[:Category:AutoHotkey|AutoHotkey]][[Category:AutoHotkey]]==\ncontributed by Laszlo on the ahk [http:\/\/www.autohotkey.com\/forum\/post-276367.html#276367 forum]\n<lang AutoHotkey>MsgBox % anagrams(\"able\")\n\nanagrams(word) {\n   Static dict\n   IfEqual dict,, FileRead dict, unixdict.txt ; file in the script directory\n   w := sort(word)\n   Loop Parse, dict, `n, `r\n      If (w = sort(A_LoopField))\n         t .= A_LoopField \"`n\"\n   Return t\n}\n\nsort(word) {\n   a := RegExReplace(word,\".\",\"$0`n\")\n   Sort a\n   Return a\n}<\/lang> \n\n==[[:Category:AWK|AWK]][[Category:AWK]]==\n<lang AWK># JUMBLEA.AWK - words with the most duplicate spellings contributed by Dan Nielsen\n# syntax: GAWK -f JUMBLEA.AWK UNIXDICT.TXT\n{   for (i=1; i<=NF; i++) {\n      w = sortstr(toupper($i))\n      arr[w] = arr[w] $i \" \"\n      n = gsub(\/ \/,\"&\",arr[w])\n      if (max_n < n) { max_n = n }\n    }\n}\nEND {\n    for (w in arr) {\n      if (gsub(\/ \/,\"&\",arr[w]) == max_n) {\n        printf(\"%s\\t%s\\n\",w,arr[w])\n      }\n    }\n    exit(0)\n}\nfunction sortstr(str,  i,j,leng) {\n    leng = length(str)\n    for (i=2; i<=leng; i++) {\n      for (j=i; j>1 && substr(str,j-1,1) > substr(str,j,1); j--) {\n        str = substr(str,1,j-2) substr(str,j,1) substr(str,j-1,1) substr(str,j+1)\n      }\n    }\n    return(str)\n}<\/lang>\nProduces this output:\n<pre>\nABEL    abel able bale bela elba\nACERT   caret carte cater crate trace\nAEGLN   angel angle galen glean lange\nAEGLR   alger glare lager large regal\nAELN    elan lane lean lena neal\nEILV    evil levi live veil vile\n<\/pre>\n\n==[[:Category:BBC BASIC|BBC BASIC]][[Category:BBC BASIC]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[BBC BASIC for Windows]][[SMW::on]]<\/div>\n<lang bbcbasic>      INSTALL @lib$+\"SORTLIB\"\n      sort% = FN_sortinit(0,0)\n      \n      REM Count number of words in dictionary:\n      nwords% = 0\n      dict% = OPENIN(\"unixdict.txt\")\n      WHILE NOT EOF#dict%\n        word$ = GET$#dict%\n        nwords% += 1\n      ENDWHILE\n      CLOSE #dict%\n      \n      REM Create arrays big enough to contain the dictionary:\n      DIM dict$(nwords%), sort$(nwords%)\n      \n      REM Load the dictionary and sort the characters in the words:\n      dict% = OPENIN(\"unixdict.txt\")\n      FOR word% = 1 TO nwords%\n        word$ = GET$#dict%\n        dict$(word%) = word$\n        sort$(word%) = FNsortchars(word$)\n      NEXT word%\n      CLOSE #dict%\n      \n      REM Sort arrays using the 'sorted character' words as a key:\n      C% = nwords%\n      CALL sort%, sort$(1), dict$(1)\n      \n      REM Count the longest sets of anagrams:\n      max% = 0\n      set% = 1\n      FOR word% = 1 TO nwords%-1\n        IF sort$(word%) = sort$(word%+1) THEN\n          set% += 1\n        ELSE\n          IF set% > max% THEN max% = set%\n          set% = 1\n        ENDIF\n      NEXT word%\n      \n      REM Output the results:\n      set% = 1\n      FOR word% = 1 TO nwords%-1\n        IF sort$(word%) = sort$(word%+1) THEN\n          set% += 1\n        ELSE\n          IF set% = max% THEN\n            FOR anagram% = word%-max%+1 TO word%\n              PRINT dict$(anagram%),;\n            NEXT\n            PRINT\n          ENDIF\n          set% = 1\n        ENDIF\n      NEXT word%\n      END\n      \n      DEF FNsortchars(word$)\n      LOCAL C%, char&()\n      DIM char&(LEN(word$))\n      $$^char&(0) = word$\n      C% = LEN(word$)\n      CALL sort%, char&(0)\n      = $$^char&(0)<\/lang>\nProduces this output:\n<pre>\nabel      able      bale      bela      elba\ncaret     carte     cater     crate     trace\nangel     angle     galen     glean     lange\nalger     glare     lager     large     regal\nelan      lane      lean      lena      neal\nevil      levi      live      veil      vile\n<\/pre>\n\n==[[:Category:Bracmat|Bracmat]][[Category:Bracmat]]==\n\nThis solution makes extensive use of  Bracmat's computer algebra mechanisms. A trick is needed to handle words that are merely repetitions of a single letter, such as <code>iii<\/code>. That's why the variabe <code>sum<\/code> isn't initialised with <code>0<\/code>, but with a non-number, in this case the empty string. Also te correct handling of characters 0-9 needs a trick so that they are not numerically added: they are prepended with a non-digit, an <code>N<\/code> in this case. After completely traversing the word list, the program writes a file <code>product.txt<\/code> that can be visually inspected.\nThe program is not fast. (Minutes rather than seconds.)\n<lang bracmat>( get$(\"unixdict.txt\",STR):?list\n& 1:?product\n&   whl\n  ' ( @(!list:(%?word:?w) \\n ?list)\n    & :?sum\n    &   whl\n      ' ( @(!w:%?let ?w)\n        & (!let:~#|str$(N !let))+!sum:?sum\n        )\n    & !sum^!word*!product:?product\n    )\n& lst$(product,\"product.txt\",NEW)\n& 0:?max\n& :?group\n& (   !product\n    :   ?\n      * ?^(%+%:?exp)\n      * ( ?\n        &   !exp\n          :   ?\n            + ( [>!max:[?max&!exp:?group\n              | [~<!max&!group !exp:?group\n              )\n        & ~\n        )\n  | out$!group\n  )\n);<\/lang>\nOutput:\n<pre>  abel+able+bale+bela+elba\n  caret+carte+cater+crate+trace\n  angel+angle+galen+glean+lange\n  alger+glare+lager+large+regal\n  elan+lane+lean+lena+neal\n  evil+levi+live+veil+vile<\/pre>\n\n==[[:Category:C|C]][[Category:C]]==\n<lang c>#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <time.h>\n\nchar *sortedWord(const char *word, char *wbuf)\n{\n    char *p1, *p2, *endwrd;\n    char t;\n    int swaps;\n\n    strcpy(wbuf, word);\n    endwrd = wbuf+strlen(wbuf);\n    do {\n       swaps = 0;\n       p1 = wbuf; p2 = endwrd-1;\n       while (p1<p2) {\n          if (*p2 > *p1) {\n             t = *p2; *p2 = *p1; *p1 = t;\n             swaps = 1;\n          }\n          p1++; p2--;\n       }\n       p1 = wbuf; p2 = p1+1;\n       while(p2 < endwrd) {\n           if (*p2 > *p1) {\n             t = *p2; *p2 = *p1; *p1 = t;\n             swaps = 1;\n           }\n           p1++; p2++;\n       }\n    } while (swaps);\n    return wbuf;\n}\n\nstatic\nshort cxmap[] = {\n    0x06, 0x1f, 0x4d, 0x0c, 0x5c, 0x28, 0x5d, 0x0e, 0x09, 0x33, 0x31, 0x56,\n    0x52, 0x19, 0x29, 0x53, 0x32, 0x48, 0x35, 0x55, 0x5e, 0x14, 0x27, 0x24,\n    0x02, 0x3e, 0x18, 0x4a, 0x3f, 0x4c, 0x45, 0x30, 0x08, 0x2c, 0x1a, 0x03,\n    0x0b, 0x0d, 0x4f, 0x07, 0x20, 0x1d, 0x51, 0x3b, 0x11, 0x58, 0x00, 0x49,\n    0x15, 0x2d, 0x41, 0x17, 0x5f, 0x39, 0x16, 0x42, 0x37, 0x22, 0x1c, 0x0f,\n    0x43, 0x5b, 0x46, 0x4b, 0x0a, 0x26, 0x2e, 0x40, 0x12, 0x21, 0x3c, 0x36,\n    0x38, 0x1e, 0x01, 0x1b, 0x05, 0x4e, 0x44, 0x3d, 0x04, 0x10, 0x5a, 0x2a,\n    0x23, 0x34, 0x25, 0x2f, 0x2b, 0x50, 0x3a, 0x54, 0x47, 0x59, 0x13, 0x57,\n   };\n#define CXMAP_SIZE (sizeof(cxmap)\/sizeof(short))\n\n\nint Str_Hash( const char *key, int ix_max )\n{\n   const char *cp;\n   short mash;\n   int  hash = 33501551;\n   for (cp = key; *cp; cp++) {\n      mash = cxmap[*cp % CXMAP_SIZE];\n      hash = (hash >>4) ^ 0x5C5CF5C ^ ((hash<<1) + (mash<<5));\n      hash &= 0x3FFFFFFF;\n      }\n   return  hash % ix_max;\n}\n\ntypedef struct sDictWord  *DictWord;\nstruct sDictWord {\n    const char *word;\n    DictWord next;\n};\n\ntypedef struct sHashEntry *HashEntry;\nstruct sHashEntry {\n    const char *key;\n    HashEntry next;\n    DictWord  words;\n    HashEntry link;\n    short wordCount;\n};\n\n#define HT_SIZE 8192\n\nHashEntry hashTable[HT_SIZE];\n\nHashEntry mostPerms = NULL;\n\nint buildAnagrams( FILE *fin )\n{\n    char buffer[40];\n    char bufr2[40];\n    char *hkey;\n    int hix;\n    HashEntry he, *hep;\n    DictWord  we;\n    int  maxPC = 2;\n    int numWords = 0;\n    \n    while ( fgets(buffer, 40, fin)) {\n        for(hkey = buffer; *hkey && (*hkey!='\\n'); hkey++);\n        *hkey = 0;\n        hkey = sortedWord(buffer, bufr2);\n        hix = Str_Hash(hkey, HT_SIZE);\n        he = hashTable[hix]; hep = &hashTable[hix];\n        while( he && strcmp(he->key , hkey) ) {\n            hep = &he->next;\n            he = he->next;\n        }\n        if ( ! he ) {\n            he = malloc(sizeof(struct sHashEntry));\n            he->next = NULL;\n            he->key = strdup(hkey);\n            he->wordCount = 0;\n            he->words = NULL;\n            he->link = NULL;\n            *hep = he;\n        }\n        we = malloc(sizeof(struct sDictWord));\n        we->word = strdup(buffer);\n        we->next = he->words;\n        he->words = we;\n        he->wordCount++;\n        if ( maxPC < he->wordCount) {\n            maxPC = he->wordCount;\n            mostPerms = he;\n            he->link = NULL;\n        }\n        else if (maxPC == he->wordCount) {\n            he->link = mostPerms;\n            mostPerms = he;\n        }\n         \n        numWords++;\n    }\n    printf(\"%d words in dictionary max ana=%d\\n\", numWords, maxPC);\n    return maxPC;\n}\n\n\nint main( ) \n{\n    HashEntry he;\n    DictWord  we;\n    FILE *f1;\n    \n    f1 = fopen(\"unixdict.txt\",\"r\");\n    buildAnagrams(f1);\n    fclose(f1);\n    \n    f1 = fopen(\"anaout.txt\",\"w\");\n\/\/    f1 = stdout;\n\n    for (he = mostPerms; he; he = he->link) {\n        fprintf(f1,\"%d:\", he->wordCount);\n        for(we = he->words; we; we = we->next) {\n            fprintf(f1,\"%s, \", we->word);\n        }\n        fprintf(f1, \"\\n\");\n    }\n\n    fclose(f1);\n    return 0;\n}<\/lang>\nOutput: (less than 1 second on old P500)\n<pre>5:vile, veil, live, levi, evil, \n5:trace, crate, cater, carte, caret, \n5:regal, large, lager, glare, alger, \n5:neal, lena, lean, lane, elan, \n5:lange, glean, galen, angle, angel, \n5:elba, bela, bale, able, abel, \n<\/pre>\nA much shorter version with no fancy data structures:\n<lang c>#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys\/stat.h>\n#include <string.h>\n\ntypedef struct { char *key, *word; int cnt; } kw_t;\n\nint lst_cmp(const void *a, const void *b)\n{\n\treturn strcmp(((kw_t*)a)->key, ((kw_t*)b)->key);\n}\n\n\/* Bubble sort.  Faster than stock qsort(), believe it or not *\/\nvoid sort_letters(char *s)\n{\n\tint i, j;\n\tchar t;\n\tfor (i = 0; s[i] != '\\0'; i++) {\n\t\tfor (j = i + 1; s[j] != '\\0'; j++)\n\t\t\tif (s[j] < s[i]) {\n\t\t\t\tt = s[j]; s[j] = s[i]; s[i] = t;\n\t\t\t}\n\t}\n}\n\nint main()\n{\n\tstruct stat s;\n\tchar *words, *keys;\n\tsize_t i, j, k, longest, offset;\n\tint n_word = 0;\n\tkw_t *list;\n\n\tint fd = open(\"unixdict.txt\", O_RDONLY);\n\tif (fd == -1) return 1;\n\tfstat(fd, &s);\n\twords = malloc(s.st_size * 2);\n\tkeys  = words + s.st_size;\n\n\tread(fd, words, s.st_size);\n\tmemcpy(keys, words, s.st_size);\n\n\t\/* change newline to null for easy use; sort letters in keys *\/\n\tfor (i = j = 0; i < s.st_size; i++) {\n\t\tif (words[i] == '\\n') {\n\t\t\twords[i] = keys[i] = '\\0';\n\t\t\tsort_letters(keys + j);\n\t\t\tj = i + 1;\n\t\t\tn_word ++;\n\t\t}\n\t}\n\n\tlist = calloc(n_word, sizeof(kw_t));\n\n\t\/* make key\/word pointer pairs for sorting *\/\n\tfor (i = j = k = 0; i < s.st_size; i++) {\n\t\tif (words[i] == '\\0') {\n\t\t\tlist[j].key = keys + k;\n\t\t\tlist[j].word = words + k;\n\t\t\tk = i + 1;\n\t\t\tj++;\n\t\t}\n\t}\n\n\tqsort(list, n_word, sizeof(kw_t), lst_cmp);\n\n\t\/* count each key's repetition *\/\n\tfor (i = j = k = offset = longest = 0; i < n_word; i++) {\n\t\tif (!strcmp(list[i].key, list[j].key)) {\n\t\t\t++k;\n\t\t\tcontinue;\n\t\t}\n\n\t\t\/* move current longest to begining of array *\/\n\t\tif (k < longest) {\n\t\t\tk = 0;\n\t\t\tj = i;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (k > longest) offset = 0;\n\n\t\twhile (j < i) list[offset++] = list[j++];\n\t\tlongest = k;\n\t\tk = 0;\n\t}\n\n\t\/* show the longest *\/\n\tfor (i = 0; i < offset; i++) {\n\t\tprintf(\"%s \", list[i].word);\n\t\tif (i < n_word - 1 && strcmp(list[i].key, list[i+1].key))\n\t\t\tprintf(\"\\n\");\n\t}\n\n\t\/* free(list); free(words); *\/\n\tclose(fd);\n\treturn 0;\n}<\/lang>\noutput\n<pre>\nabel able bale bela elba \ncaret carte cater crate trace \nangel angle galen glean lange \nalger glare lager large regal \nelan lane lean lena neal \nevil levi live veil vile\n<\/pre>\n\n==[[:Category:C++|C++]][[Category:C++]]==\n<lang cpp>#include <iostream>\n#include <fstream>\n#include <string>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <iterator>\n \nint main() {\n  std::ifstream in(\"unixdict.txt\");\n  typedef  std::map<std::string, std::vector<std::string> > AnagramMap;\n  AnagramMap anagrams;\n \n  std::string word;\n  size_t count = 0;\n  while (std::getline(in, word)) {\n    std::string key = word;\n    std::sort(key.begin(), key.end());\n    \/\/ note: the [] op. automatically inserts a new value if key does not exist\n    AnagramMap::mapped_type & v = anagrams[key];\n    v.push_back(word);\n    count = std::max(count, v.size());\n  }\n \n  in.close();\n \n  for (AnagramMap::const_iterator it = anagrams.begin(), e = anagrams.end();\n       it != e; it++)\n    if (it->second.size() >= count) {\n      std::copy(it->second.begin(), it->second.end(),\n                std::ostream_iterator<std::string>(std::cout, \", \"));\n      std::cout << std::endl;\n    }\n  return 0;\n}<\/lang>\nOutput:\n abel, able, bale, bela, elba, \n caret, carte, cater, crate, trace, \n angel, angle, galen, glean, lange, \n alger, glare, lager, large, regal, \n elan, lane, lean, lena, neal, \n evil, levi, live, veil, vile,\n\n==<span id=\"C sharp\">[[:Category:C sharp|C#]]<\/span>[[Category:C sharp]]==\n<lang csharp>using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.IO;\n\nnamespace Anagram\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var words = File.ReadAllLines(\"unixdict.txt\");\n            var groups = from w in words\n                         group w by new String(w.ToCharArray().OrderBy(x => x).ToArray()) into c\n                         where c.Count() > 1\n                         orderby c.Count() descending\n                         select c;\n            groups.ToList().ForEach(x => Console.WriteLine(String.Join(\",\", x.ToArray())));\n        }\n    }\n}<\/lang>\noutput:\n<pre>\nabel,able,bale,bela,elba\nalger,glare,lager,large,regal\nangel,angle,galen,glean,lange\ncaret,carte,cater,crate,trace\nelan,lane,lean,lena,neal\nevil,levi,live,veil,vile\nabet,bate,beat,beta\naden,dane,dean,edna\naires,aries,arise,raise\namen,mane,mean,name\names,mesa,same,seam\napt,pat,pta,tap\nare,ear,era,rae\nate,eat,eta,tea\nbeard,bread,debar,debra\ncereus,recuse,rescue,secure\ndare,dear,erda,read\ndiet,edit,tide,tied\n... etc\n<\/pre>\n\n==[[:Category:Clojure|Clojure]][[Category:Clojure]]==\nAssume ''wordfile'' is the path of the local file containing the words. This code makes a map (''groups'') whose keys are sorted letters and values are lists of the key's anagrams. It then determines the length of the longest list, and prints out all the lists of that length.\n<lang clojure>(require '[clojure.java.io :as io])\n\n(def groups\n  (with-open [r (io\/reader wordfile)]\n    (group-by sort (line-seq r)))\n\n(let [wordlists (sort-by (comp - count) (vals groups)\n      maxlength (count (first wordlists))]\n  (doseq [wordlist (take-while #(= (count %) maxlength) wordlists)]\n    (println wordlist))<\/lang>\n\n==[[:Category:CoffeeScript|CoffeeScript]][[Category:CoffeeScript]]==\n<lang coffeescript>http = require 'http'\n\nshow_large_anagram_sets = (word_lst) ->\n  anagrams = {}\n  max_size = 0\n  \n  for word in word_lst\n    key = word.split('').sort().join('')\n    anagrams[key] ?= []\n    anagrams[key].push word\n    size = anagrams[key].length\n    max_size = size if size > max_size\n    \n  for key, variations of anagrams\n    if variations.length == max_size\n      console.log variations.join ' '\n\nget_word_list = (process) ->\n  options =\n    host: \"www.puzzlers.org\"\n    path: \"\/pub\/wordlists\/unixdict.txt\"\n  \n  req = http.request options, (res) ->\n    s = ''\n    res.on 'data', (chunk) ->\n      s += chunk\n    res.on 'end', ->\n      process s.split '\\n'\n  req.end()\n  \nget_word_list show_large_anagram_sets<\/lang>\noutput\n<lang coffeescript>> coffee anagrams.coffee \n[ 'abel', 'able', 'bale', 'bela', 'elba' ]\n[ 'alger', 'glare', 'lager', 'large', 'regal' ]\n[ 'angel', 'angle', 'galen', 'glean', 'lange' ]\n[ 'caret', 'carte', 'cater', 'crate', 'trace' ]\n[ 'elan', 'lane', 'lean', 'lena', 'neal' ]\n[ 'evil', 'levi', 'live', 'veil', 'vile' ]<\/lang>\n\n==[[:Category:Common Lisp|Common Lisp]][[Category:Common Lisp]]==\n<div class=\"examplemeta libheader\">'''Library:''' [[SMW::off]][[:Category:DRAKMA|DRAKMA]][[Category:DRAKMA]][[SMW::on]]<\/div> to retrieve the wordlist.\n<lang lisp>(defun anagrams (&optional (url \"http:\/\/www.puzzlers.org\/pub\/wordlists\/unixdict.txt\"))\n  (let ((words (drakma:http-request url :want-stream t))\n        (wordsets (make-hash-table :test 'equalp)))\n    ;; populate the wordsets and close stream\n    (do ((word (read-line words nil nil) (read-line words nil nil)))\n        ((null word) (close words))\n      (let ((letters (sort (copy-seq word) 'char<)))\n        (multiple-value-bind (pair presentp)\n            (gethash letters wordsets)\n          (if presentp\n           (setf (car pair) (1+ (car pair))\n                 (cdr pair) (cons word (cdr pair)))\n           (setf (gethash letters wordsets)\n                 (cons 1 (list word)))))))\n    ;; find and return the biggest wordsets\n    (loop with maxcount = 0 with maxwordsets = '()\n          for pair being each hash-value of wordsets\n          if (> (car pair) maxcount)\n          do (setf maxcount (car pair)\n                   maxwordsets (list (cdr pair)))\n          else if (eql (car pair) maxcount)\n          do (push (cdr pair) maxwordsets)\n          finally (return (values maxwordsets maxcount)))))<\/lang>\nEvalutating\n<lang lisp>(multiple-value-bind (wordsets count) (anagrams)\n  (pprint wordsets)\n  (print count))<\/lang>\nproduces the following output.\n<pre>((\"vile\" \"veil\" \"live\" \"levi\" \"evil\")\n (\"regal\" \"large\" \"lager\" \"glare\" \"alger\")\n (\"lange\" \"glean\" \"galen\" \"angle\" \"angel\")\n (\"neal\" \"lena\" \"lean\" \"lane\" \"elan\")\n (\"trace\" \"crate\" \"cater\" \"carte\" \"caret\")\n (\"elba\" \"bela\" \"bale\" \"able\" \"abel\"))\n5<\/pre>\nAnother method, assuming file is local:\n<lang lisp>(defun read-words (file)\n  (with-open-file (stream file)\n    (loop with w = \"\" while w collect (setf w (read-line stream nil)))))\n\n(defun anagram (file)\n  (let ((wordlist (read-words file))\n\t(h (make-hash-table :test #'equal))\n\tlongest)\n    (loop for w in wordlist with ws do\n\t  (setf ws (sort (copy-seq w) #'char<))\n\t  (setf (gethash ws h) (cons w (gethash ws h))))\n    (loop for w being the hash-keys in h using (hash-value wl)\n\t  with max-len = 0 do\n\t  (let ((l (length wl)))\n\t    (if (> l max-len) (setf longest nil max-len l))\n\t    (if (= l max-len) (push wl longest))))\n    longest))\n\n(format t \"~{~{~a ~}~^~%~}\" (anagram \"unixdict.txt\"))<\/lang>\noutput\n<pre>elba bela bale able abel \nregal large lager glare alger \nlange glean galen angle angel \ntrace crate cater carte caret \nneal lena lean lane elan \nvile veil live levi evil<\/pre>\n\n== [[:Category:D|D]][[Category:D]] ==\nThe current versions don't download the word list.\n===Short Functional Version===\n<lang d>import std.stdio, std.algorithm, std.range, std.string;\n\nvoid main() {\n    dstring[][dstring] anags;\n    foreach (dchar[] w; File(\"unixdict.txt\").lines())\n        anags[w.chomp().sort().release().idup] ~= w.chomp().idup;\n    immutable m = anags.byValue.map!(ws => ws.length)().reduce!max();\n    writefln(\"%(%s\\n%)\", anags.byValue.filter!(ws => ws.length == m)());\n}<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>[\"caret\", \"carte\", \"cater\", \"crate\", \"trace\"]\n[\"evil\", \"levi\", \"live\", \"veil\", \"vile\"]\n[\"abel\", \"able\", \"bale\", \"bela\", \"elba\"]\n[\"elan\", \"lane\", \"lean\", \"lena\", \"neal\"]\n[\"alger\", \"glare\", \"lager\", \"large\", \"regal\"]\n[\"angel\", \"angle\", \"galen\", \"glean\", \"lange\"]<\/pre>\n\n===Faster Version===\nTwice faster but less safe, same output.\n<lang d>import std.stdio, std.algorithm, std.file;\n\nvoid main() {\n    char[] keys = cast(char[])read(\"unixdict.txt\");\n    string vals = keys.idup;\n    string[][string] anags;\n    foreach (w; std.array.splitter(keys)) {\n        const k = cast(string)sort(cast(ubyte[])w).release();\n        anags[k] ~= vals[k.ptr-keys.ptr .. k.ptr-keys.ptr + k.length];\n    }\n    immutable m = anags.byValue.map!(ws => ws.length)().reduce!max();\n    writefln(\"%(%s\\n%)\", filter!(ws => ws.length == m)(anags.byValue));\n}<\/lang>\n\n===Alternative Version===\nD1 with Phobos and scrapple.tools extension library:\n<lang d>import std.stdio, std.stream, tools.functional, tools.base;\n\nvoid main() {\n  ( (new BufferedFile(\"\/usr\/share\/dict\/cracklib-small\"))\n    \/map\/ ex!(\"s -> s.dup\")\n    \/groupby\/ ex!(\"s -> s.dup.sort\")                                 \n    \/map\/ (string key, string[] value) { return value; }\n    \/qsort\/ ex!(\"a, b -> a.length < b.length\")\n  )[$-1].writefln();\n}<\/lang>\n\n==[[:Category:E|E]][[Category:E]]==\n<lang e>println(\"Downloading...\")\nwhen (def wordText := <http:\/\/www.puzzlers.org\/pub\/wordlists\/unixdict.txt> <- getText()) -> {\n    def words := wordText.split(\"\\n\")\n\n    def storage := [].asMap().diverge()\n    def anagramTable extends storage {\n        to get(key) { return storage.fetch(key, fn { storage[key] := [].diverge() }) }\n    }\n\n    println(\"Grouping...\")\n    var largestGroupSeen := 0\n    for word in words {\n        def anagramGroup := anagramTable[word.sort()]\n        anagramGroup.push(word)\n        largestGroupSeen max= anagramGroup.size()\n    }\n\n    println(\"Selecting...\")\n    for _ => anagramGroup ? (anagramGroup.size() == mostSeen) in anagramTable {\n        println(anagramGroup.snapshot())\n    }\n}<\/lang>\n\n==[[:Category:Elena|Elena]][[Category:Elena]]==\n<lang elena>#define std'dictionary'*.\n#define std'basic'*.\n#define std'patterns'*.\n#define std'routines'*.\n#define std'collections'*.\n#define ext'patterns'*.\n#define sys'dates'*.\n\n#symbol Str2IntListing\n    = Summing::{ &action_var:List &action_prop:literal }.\n\n#symbol Normalized : aLiteral\n    = WideStrValue::(Summing::String start:\n        (Scan::((Str2IntListing start:Scan::aLiteral)~eindexeditem~esort run: aPair => (aPair former < aPair later)))).\n\n#symbol Program =>\n[\n    #var aStart := Now.\n    \n    #var aDictionary := Dictionary.\n    \n    TextFileScan::\"unixdict.txt\" run:\n        aWord => \n        [    \n            #var anItem := aDictionary@(Normalized::aWord).\n            \n            #if anItem content isnot &nillable\n            | [\n                anItem set &content:List.\n            ].\n            \n            anItem += WideStrValue::aWord.\n        ].\n        \n    aDictionary~eindexeditem~esort run: aPair => (aPair former count > aPair later count).\n    \n    #var aCounter := Integer::20.\n    Scan::aDictionary seek: aList =>\n    [\n        'program'output << aList << \"%n\".\n        \n        aCounter -= 1.\n        \n        ^(aCounter == 0).\n    ].\n    \n    #var anEnd := Now.\n    \n    #var aDiff := anEnd - aStart.\n    'program'output << \"%nTime elapsed in msec:\" << aDiff milliseconds.    \n].<\/lang>\n\n==[[:Category:Erlang|Erlang]][[Category:Erlang]]==\n<lang erlang>-module(anagrams).\n-compile(export_all).\n\nplay() ->\n    {ok, P} = file:read_file('unixdict.txt'),\n    D = dict:new(),\n    E=fetch(string:tokens(binary_to_list(P), \"\\n\"), D),\n    get_value(dict:fetch_keys(E), E).\n\nfetch([H|T], D) ->\n    fetch(T, dict:append(lists:sort(H), H, D));\nfetch([], D) ->\n    D.\n\nget_value(L, D) -> get_value(L,D,1,[]).\nget_value([H|T], D, N, L) ->\n    Var = dict:fetch(H,D),\n    Len = length(Var),\n    if\n        Len > N ->\n            get_value(T, D, Len, [Var]);\n        Len == N ->\n            get_value(T, D, Len, [Var | L]);\n        Len < N ->\n            get_value(T, D, N, L)\n    end;\n\nget_value([], _, _, L) ->\n    L.\n<\/lang>\nOutput:\n<pre>\n1> anagrams:play().\n[[\"caret\",\"carte\",\"cater\",\"crate\",\"trace\"],\n [\"elan\",\"lane\",\"lean\",\"lena\",\"neal\"],\n [\"alger\",\"glare\",\"lager\",\"large\",\"regal\"],\n [\"angel\",\"angle\",\"galen\",\"glean\",\"lange\"],\n [\"evil\",\"levi\",\"live\",\"veil\",\"vile\"],\n [\"abel\",\"able\",\"bale\",\"bela\",\"elba\"]]\n2>\n<\/pre>\n==[[:Category:Euphoria|Euphoria]][[Category:Euphoria]]==\n<lang euphoria>include sort.e\n\nfunction compare_keys(sequence a, sequence b)\n    return compare(a[1],b[1])\nend function\n\nconstant fn = open(\"unixdict.txt\",\"r\")\nsequence words, anagrams\nobject word\nwords = {}\nwhile 1 do\n    word = gets(fn)\n    if atom(word) then\n        exit\n    end if\n    word = word[1..$-1] -- truncate new-line character\n    words = append(words, {sort(word), word})\nend while\nclose(fn)\n\ninteger maxlen\nmaxlen = 0\nwords = custom_sort(routine_id(\"compare_keys\"), words)\nanagrams = {words[1]}\nfor i = 2 to length(words) do\n    if equal(anagrams[$][1],words[i][1]) then\n        anagrams[$] = append(anagrams[$], words[i][2])\n    elsif length(anagrams[$]) = 2 then\n        anagrams[$] = words[i]\n    else\n        if length(anagrams[$]) > maxlen then\n            maxlen = length(anagrams[$])\n        end if\n        anagrams = append(anagrams, words[i])\n    end if\nend for\nif length(anagrams[$]) = 2 then\n    anagrams = anagrams[1..$-1]\nend if\n\nfor i = 1 to length(anagrams) do\n    if length(anagrams[i]) = maxlen then\n        for j = 2 to length(anagrams[i]) do\n            puts(1,anagrams[i][j])\n            puts(1,' ')\n        end for\n        puts(1,\"\\n\")\n    end if\nend for<\/lang>\nOutput:\n<pre>abel bela bale elba able\ncrate cater carte caret trace\nangle galen glean lange angel\nregal lager large alger glare\nelan lean neal lane lena\nlive veil vile levi evil\n<\/pre>\n\n==<span id=\"F Sharp\">[[:Category:F Sharp|F#]]<\/span>[[Category:F Sharp]]==\nRead the lines in the dictionary, group by the sorted letters in each word, find the length of the longest sets of anagrams, extract the longest sequences of words sharing the same letters (i.e. anagrams):\n<lang fsharp>let xss = Seq.groupBy (Array.ofSeq >> Array.sort) (System.IO.File.ReadAllLines \"unixdict.txt\")\nSeq.map snd xss |> Seq.filter (Seq.length >> ( = ) (Seq.map (snd >> Seq.length) xss |> Seq.max))<\/lang>\nNote that it is necessary to convert the sorted letters in each word from sequences to arrays because the groupBy function uses the default comparison and sequences do not compare structurally (but arrays do in F#).\n\nTakes 0.8s to return:\n<lang fsharp>val it : string seq seq =\n  seq\n    [seq [\"abel\"; \"able\"; \"bale\"; \"bela\"; \"elba\"];\n     seq [\"alger\"; \"glare\"; \"lager\"; \"large\"; \"regal\"];\n     seq [\"angel\"; \"angle\"; \"galen\"; \"glean\"; \"lange\"];\n     seq [\"caret\"; \"carte\"; \"cater\"; \"crate\"; \"trace\"];\n     seq [\"elan\"; \"lane\"; \"lean\"; \"lena\"; \"neal\"];\n     seq [\"evil\"; \"levi\"; \"live\"; \"veil\"; \"vile\"]]<\/lang>\n\n== [[:Category:Factor|Factor]][[Category:Factor]] ==\n<lang factor> \"resource:unixdict.txt\" utf8 file-lines\n [ [ natural-sort >string ] keep ] { } map>assoc sort-keys\n [ [ first ] compare +eq+ = ] monotonic-split\n dup 0 [ length max ] reduce '[ length _ = ] filter [ values ] map .<\/lang>\n<lang factor>{\n    { \"abel\" \"able\" \"bale\" \"bela\" \"elba\" }\n    { \"caret\" \"carte\" \"cater\" \"crate\" \"trace\" }\n    { \"angel\" \"angle\" \"galen\" \"glean\" \"lange\" }\n    { \"alger\" \"glare\" \"lager\" \"large\" \"regal\" }\n    { \"elan\" \"lane\" \"lean\" \"lena\" \"neal\" }\n    { \"evil\" \"levi\" \"live\" \"veil\" \"vile\" }\n}<\/lang>\n\n==[[:Category:Fantom|Fantom]][[Category:Fantom]]==\n<lang fantom>class Main\n{\n  \/\/ take given word and return a string rearranging characters in order\n  static Str toOrderedChars (Str word)\n  {\n    Str[] chars := [,]\n    word.each |Int c| { chars.add (c.toChar) }\n    return chars.sort.join(\"\")\n  }\n\n  \/\/ add given word to anagrams map\n  static Void addWord (Str:Str[] anagrams, Str word)\n  {\n    Str orderedWord := toOrderedChars (word)\n    if (anagrams.containsKey (orderedWord))\n      anagrams[orderedWord].add (word)\n    else\n      anagrams[orderedWord] = [word]\n  }\n\n  public static Void main ()\n  {\n    Str:Str[] anagrams := [:] \/\/ map Str -> Str[]\n    \/\/ loop through input file, adding each word to map of anagrams\n    File (`unixdict.txt`).eachLine |Str word|\n    {\n      addWord (anagrams, word)\n    }\n    \/\/ loop through anagrams, keeping the keys with values of largest size\n    Str[] largestKeys := [,]\n    anagrams.keys.each |Str k|\n    {\n      if ((largestKeys.size < 1) || (anagrams[k].size == anagrams[largestKeys[0]].size))\n        largestKeys.add (k)\n      else if (anagrams[k].size > anagrams[largestKeys[0]].size)\n        largestKeys = [k]\n    }\n    largestKeys.each |Str k|\n    {\n      echo (\"Key: $k -> \" + anagrams[k].join(\", \"))\n    }\n  }\n}<\/lang>\n\nOutput:\n<pre>Key: abel -> abel, able, bale, bela, elba\nKey: aeln -> elan, lane, lean, lena, neal\nKey: eilv -> evil, levi, live, veil, vile\nKey: aegln -> angel, angle, galen, glean, lange\nKey: aeglr -> alger, glare, lager, large, regal\nKey: acert -> caret, carte, cater, crate, trace\n<\/pre>\n\n== [[:Category:Fortran|Fortran]][[Category:Fortran]] ==\nThis program:\n<lang fortran>!***************************************************************************************\n\tmodule anagram_routines\n!***************************************************************************************\n\timplicit none\n\t\n\t!the dictionary file:\n\tinteger,parameter :: file_unit = 1000\n\tcharacter(len=*),parameter :: filename = 'unixdict.txt'\n\t\n\t!maximum number of characters in a word:\n\tinteger,parameter :: max_chars = 50\n\t\n\t!maximum number of characters in the string displaying the anagram lists:\n\tinteger,parameter :: str_len = 256\n\t\n\ttype word \n\t  character(len=max_chars) :: str = repeat(' ',max_chars)    !the word from the dictionary\n\t  integer                  :: n = 0                          !length of this word\n\t  integer                  :: n_anagrams = 0\t             !number of anagrams found\n\t  logical                  :: checked = .false.              !if this one has already been checked\n\t  character(len=str_len)   :: anagrams = repeat(' ',str_len) !the anagram list for this word\n\tend type word\n\t\n\t!the dictionary structure:\n\ttype(word),dimension(:),allocatable,target :: dict\n\t\n\tcontains\n!***************************************************************************************\n\n\t!******************************************************************************\n\t\tfunction count_lines_in_file(fid) result(n_lines)\n\t!******************************************************************************\n\t\timplicit none\n\t\n\t\tinteger             :: n_lines\n\t\tinteger,intent(in)  :: fid\t\t\n\t\tcharacter(len=1)    :: tmp\n\t\tinteger             :: i\n\t\tinteger             :: ios\n\t\t\n\t\t!the file is assumed to be open already.\n\t\t\n\t\trewind(fid)\t  !rewind to beginning of the file\n\t\t\n\t\tn_lines = 0\n\t\tdo !read each line until the end of the file.\n\t\t\tread(fid,'(A1)',iostat=ios) tmp\n\t\t\tif (ios < 0) exit      !End of file\n\t\t\tn_lines = n_lines + 1  !row counter\n\t\tend do\n\n\t\trewind(fid)   !rewind to beginning of the file\t\n\t\t\t\t\n\t!******************************************************************************\n\t\tend function count_lines_in_file\n\t!******************************************************************************\n\t\n\t!******************************************************************************\n\t\tpure elemental function is_anagram(x,y)\n\t!******************************************************************************\n\t\timplicit none\n\t\tcharacter(len=*),intent(in) :: x\n\t\tcharacter(len=*),intent(in) :: y\n\t\tlogical :: is_anagram\n\t\n\t\tcharacter(len=len(x)) :: x_tmp\t!a copy of x\n\t\tinteger :: i,j\n\t\t\n\t\t!a character not found in any word:\n\t\tcharacter(len=1),parameter :: null = achar(0)\n\t\t\t\n\t\t!x and y are assumed to be the same size.\n\t\t\n\t\tx_tmp = x\n\t\tdo i=1,len_trim(x)\n\t\t\tj = index(x_tmp, y(i:i)) !look for this character in x_tmp\n\t\t\tif (j\/=0) then\n\t\t\t\tx_tmp(j:j) = null  !clear it so it won't be checked again\n\t\t\telse\n\t\t\t\tis_anagram = .false. !character not found: x,y are not anagrams\n\t\t\t\treturn\n\t\t\tend if\n\t\tend do\n\t\n\t\t!if we got to this point, all the characters \n\t\t! were the same, so x,y are anagrams:\n\t\tis_anagram = .true.\n\t\t\t\t\t\n\t!******************************************************************************\n\t\tend function is_anagram\n\t!******************************************************************************\n\n!***************************************************************************************\n\tend module anagram_routines\n!***************************************************************************************\n\n!***************************************************************************************\n\tprogram main\n!***************************************************************************************\n\tuse anagram_routines\n\timplicit none\n\t\n\tinteger :: n,i,j,n_max\n\ttype(word),pointer :: x,y\n\tlogical :: first_word\n\treal :: start, finish\n\t\n\tcall cpu_time(start)\t!..start timer\n\t\n\t!open the dictionary and read in all the words:\n\topen(unit=file_unit,file=filename)      !open the file\n\tn = count_lines_in_file(file_unit)      !count lines in the file\n\tallocate(dict(n))                       !allocate dictionary structure\n\tdo i=1,n                                !\n\t\tread(file_unit,'(A)') dict(i)%str   !each line is a word in the dictionary\n\t\tdict(i)%n = len_trim(dict(i)%str)   !saving length here to avoid trim's below\n\tend do\t\t\n\tclose(file_unit)                        !close the file\n\t\n\t!search dictionary for anagrams:\n\tdo i=1,n\n\t\t\n\t\tx => dict(i)\t!pointer to simplify code\n\t\tfirst_word = .true.\t!initialize\n\t\t\n\t\tdo j=i,n\n\t\t\n\t\t\ty => dict(j)\t!pointer to simplify code\n\t\t\t\n\t\t\t!checks to avoid checking words unnecessarily:\n\t\t\tif (x%checked .or. y%checked) cycle     !both must not have been checked already\n\t\t\tif (x%n\/=y%n) cycle                     !must be the same size\n\t\t\tif (x%str(1:x%n)==y%str(1:y%n)) cycle   !can't be the same word\n\t\t\t\n\t\t\t! check to see if x,y are anagrams:\n\t\t\tif (is_anagram(x%str(1:x%n), y%str(1:y%n))) then\n\t\t\t\t!they are anagrams.\n\t\t\t\ty%checked = .true. \t!don't check this one again.\n\t\t\t\tx%n_anagrams = x%n_anagrams + 1\n\t\t\t\tif (first_word) then\n\t\t\t\t\t!this is the first anagram found for this word.\n\t\t\t\t\tfirst_word = .false.\n\t\t\t\t\tx%n_anagrams = x%n_anagrams + 1\n\t\t\t\t\tx%anagrams = trim(x%anagrams)\/\/x%str(1:x%n)  !add first word to list\n\t\t\t\tend if\n\t\t\t\tx%anagrams = trim(x%anagrams)\/\/','\/\/y%str(1:y%n) !add next word to list\n\t\t\tend if\n\t\n\t\tend do\n\t\tx%checked = .true.  !don't check this one again\n\t\t \n\tend do\n\t\n\t!anagram groups with the most words:\n\twrite(*,*) ''\n\tn_max = maxval(dict%n_anagrams)\n\tdo i=1,n\n\t\tif (dict(i)%n_anagrams==n_max) write(*,'(A)') trim(dict(i)%anagrams)\n\tend do\n\t\n\t!anagram group containing longest words:\n\twrite(*,*) ''\n\tn_max = maxval(dict%n, mask=dict%n_anagrams>0)\n\tdo i=1,n\n\t\tif (dict(i)%n_anagrams>0 .and. dict(i)%n==n_max) write(*,'(A)') trim(dict(i)%anagrams)\n\tend do\n\twrite(*,*) ''\n\n\tcall cpu_time(finish)\t!...stop timer\n\twrite(*,'(A,F6.3,A)') '[Runtime = ',finish-start,' sec]'\n\twrite(*,*) ''\n\n!***************************************************************************************\n\tend program main\n!***************************************************************************************<\/lang>\n\nproduces this output:\n\n<pre>\n\tabel,able,bale,bela,elba\n\talger,glare,lager,large,regal\n\tangel,angle,galen,glean,lange\n\tcaret,carte,cater,crate,trace\n\telan,lane,lean,lena,neal\n\tevil,levi,live,veil,vile\n\t \n\tconservation,conversation\n\n\t[Runtime =  6.897 sec]\n<\/pre>\n\n==[[:Category:GAP|GAP]][[Category:GAP]]==\n<lang gap>Anagrams := function(name)\n  local f, p, L, line, word, words, swords, res, cur, r;\n  words := [ ];\n  swords := [ ];\n  f := InputTextFile(name);\n  while true do\n    line := ReadLine(f);\n    if line = fail then\n      break;\n    else\n      word := Chomp(line);\n      Add(words, word);\n      Add(swords, SortedList(word));\n    fi;\n  od;\n  CloseStream(f);\n  p := SortingPerm(swords);\n  L := Permuted(words, p);\n  r := \"\";\n  cur := [ ];\n  res := [ ];\n  for word in L do\n    if SortedList(word) = r then\n      Add(cur, word);\n    else\n      if Length(cur) > 0 then\n        Add(res, cur);\n      fi;\n      r := SortedList(word);\n      cur := [ word ];\n    fi;\n  od;\n  if Length(cur) > 0 then\n    Add(res, cur);\n  fi;\n  return Filtered(res, v -> Length(v) > 1);\nend;\n\n\nana := Anagrams(\"my\/gap\/unixdict.txt\");;\n\n# What is the longest anagram sequence ?\nMaximum(List(ana, Length));\n# 5\n\n# Which are they ?\nFiltered(ana, v -> Length(v) = 5);\n# [ [ \"abel\", \"able\", \"bale\", \"bela\", \"elba\" ],\n#   [ \"caret\", \"carte\", \"cater\", \"crate\", \"trace\" ],\n#   [ \"angel\", \"angle\", \"galen\", \"glean\", \"lange\" ],\n#   [ \"alger\", \"glare\", \"lager\", \"large\", \"regal\" ],\n#   [ \"elan\", \"lane\", \"lean\", \"lena\", \"neal\" ],\n#   [ \"evil\", \"levi\", \"live\", \"veil\", \"vile\" ] ]<\/lang>\n\n==[[:Category:Go|Go]][[Category:Go]]==\n<lang go>package main\n\nimport (\n    \"fmt\"\n    \"io\/ioutil\"\n    \"sort\"\n    \"strings\"\n)\n\nfunc main() {\n    b, err := ioutil.ReadFile(\"unixdict.txt\")\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    var ma int\n    m := make(map[string][]string)\n    for _, word := range strings.Split(string(b), \"\\n\") {\n        bs := byteSlice(word)\n        sort.Sort(bs)\n        k := string(bs)\n        a := append(m[k], word)\n        if len(a) > ma {\n            ma = len(a)\n        }\n        m[k] = a\n    }\n    for _, a := range m {\n        if len(a) == ma {\n            fmt.Println(a)\n        }\n    }\n}\n\ntype byteSlice []byte\n\nfunc (b byteSlice) Len() int { return len(b) }\nfunc (b byteSlice) Swap(i, j int) { b[i], b[j] = b[j], b[i] }\nfunc (b byteSlice) Less(i, j int) bool { return b[i] < b[j] }<\/lang>\nOutput:\n<pre>\n[angel angle galen glean lange]\n[elan lane lean lena neal]\n[evil levi live veil vile]\n[abel able bale bela elba]\n[caret carte cater crate trace]\n[alger glare lager large regal]\n<\/pre>\n\n== [[:Category:Groovy|Groovy]][[Category:Groovy]] ==\nThis program:\n<lang groovy>def words = new URL('http:\/\/www.puzzlers.org\/pub\/wordlists\/unixdict.txt').text.readLines()\ndef groups = words.groupBy{ it.toList().sort() }\ndef bigGroupSize = groups.collect{ it.value.size() }.max()\ndef isBigAnagram = { it.value.size() == bigGroupSize }\nprintln groups.findAll(isBigAnagram).collect{ it.value }.collect{ it.join(' ') }.join('\\n')<\/lang>\nproduces this output:\n<pre>\nabel able bale bela elba\nalger glare lager large regal\nangel angle galen glean lange\ncaret carte cater crate trace\nelan lane lean lena neal\nevil levi live veil vile\n<\/pre>\n\n== [[:Category:Haskell|Haskell]][[Category:Haskell]] ==\n<lang haskell>import Data.List\n\ngroupon f x y = f x == f y\n\nmain = do\n  f <- readFile \".\/..\/Puzzels\/Rosetta\/unixdict.txt\"\n  let  words = lines f\n       wix = groupBy (groupon fst) . sort $ zip (map sort words) words\n       mxl = maximum $ map length wix\n  mapM_ (print . map snd) . filter ((==mxl).length) $ wix<\/lang>\nSample output:\n<lang haskell>*Main> main\n[\"abel\",\"able\",\"bale\",\"bela\",\"elba\"]\n[\"caret\",\"carte\",\"cater\",\"crate\",\"trace\"]\n[\"angel\",\"angle\",\"galen\",\"glean\",\"lange\"]\n[\"alger\",\"glare\",\"lager\",\"large\",\"regal\"]\n[\"elan\",\"lane\",\"lean\",\"lena\",\"neal\"]\n[\"evil\",\"levi\",\"live\",\"veil\",\"vile\"]<\/lang>\n\n==[[:Category:Icon|Icon]][[Category:Icon]] and [[:Category:Unicon|Unicon]][[Category:Unicon]]==\n<lang icon>procedure main(args)\n    every writeSet(!getLongestAnagramSets())\nend\n\nprocedure getLongestAnagramSets()\n    wordSets := table()\n    longestWSet := 0\n    longSets := set()\n\n    every word := !&input do {\n        wChars := csort(word)\n        \/wordSets[wChars] := set()\n        insert(wordSets[wChars], word)\n\n        if 1 < *wordSets[wChars} == longestWSet then\n            insert(longSets, wordSets[wChars])\n        if 1 < *wordSets[wChars} > longestWSet then {\n            longestWSet := *wordSets[wChars}\n            longSets := set([wordSets[wChars]])\n            }\n        }\n\n    return longSets\nend\n\nprocedure writeSet(words)\n    every writes(\"\\t\"|!words,\" \")\n    write()\nend\n\nprocedure csort(w)\n    every (s := \"\") ||:= (find(c := !cset(w),w),c)\n    return s\nend<\/lang>\nSample run:\n<pre>->an <unixdict.txt\n         abel bale bela able elba \n         lean neal elan lane lena \n         angle galen lange angel glean \n         alger glare lager large regal \n         veil evil levi live vile \n         caret cater crate carte trace\n-><\/pre>\n\n== [[:Category:J|J]][[Category:J]] ==\nIf the unixdict file has been retrieved and saved in the current directory (for example, using wget):\n<lang j>   (#~ a: ~: {:\"1) (]\/.~ \/:~&>) <;._2 ] 1!:1 <'unixdict.txt'\n+-----+-----+-----+-----+-----+\n|abel |able |bale |bela |elba |\n+-----+-----+-----+-----+-----+\n|alger|glare|lager|large|regal|\n+-----+-----+-----+-----+-----+\n|angel|angle|galen|glean|lange|\n+-----+-----+-----+-----+-----+\n|caret|carte|cater|crate|trace|\n+-----+-----+-----+-----+-----+\n|elan |lane |lean |lena |neal |\n+-----+-----+-----+-----+-----+\n|evil |levi |live |veil |vile |\n+-----+-----+-----+-----+-----+<\/lang>\nExplanation:\n<lang J>   <;._2 ] 1!:1 <'unixdict.txt'<\/lang>\nThis reads in the dictionary and produces a list of boxes.  Each box contains one line (one word) from the dictionary.\n<lang J>   (]\/.~ \/:~&>)<\/lang>\nThis groups the words into rows where anagram equivalents appear in the same row.  In other words, creates a copy of the original list where the characters contained in each box have been sorted.  Then it organizes the contents of the original list in rows, with each new row keyed by the values in the new list.\n<lang J>   (#~ a: ~: {:\"1)<\/lang>\nThis selects rows whose last element is not an empty box.<br>\n(In the previous step we created an array of rows of boxes.  The short rows were automatically padded with empty boxes so that all rows would be the same length.)\n\n==[[:Category:Java|Java]][[Category:Java]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Java]] version 1.5+[[SMW::on]]<\/div>\nThe key to this algorithm is the sorting of the characters in each word from the dictionary. The line <tt>Arrays.sort(chars);<\/tt> sorts all of the letters in the word in ascending order using a built-in [[quicksort]], so all of the words in the first group in the result end up under the key \"aegln\" in the anagrams map.\n<lang java5>import java.net.*;\nimport java.io.*;\nimport java.util.*;\n \npublic class WordsOfEqChars {\n    public static void main(String[] args) throws IOException {\n        URL url = new URL(\"http:\/\/www.puzzlers.org\/pub\/wordlists\/unixdict.txt\");\n        InputStreamReader isr = new InputStreamReader(url.openStream());\n        BufferedReader reader = new BufferedReader(isr);\n\n        Map<String, Collection<String>> anagrams = new HashMap<String, Collection<String>>();\n        String word;\n        int count = 0;\n        while ((word = reader.readLine()) != null) {\n            char[] chars = word.toCharArray();\n            Arrays.sort(chars);\n            String key = new String(chars);\n            if (!anagrams.containsKey(key))\n                anagrams.put(key, new ArrayList<String>());\n            anagrams.get(key).add(word);\n            count = Math.max(count, anagrams.get(key).size());\n        }\n\n        reader.close();\n\n        for (Collection<String> ana : anagrams.values())\n            if (ana.size() >= count)\n                System.out.println(ana);\n    }   \n}<\/lang>\nOutput:\n [angel, angle, galen, glean, lange]\n [elan, lane, lean, lena, neal]\n [alger, glare, lager, large, regal]\n [abel, able, bale, bela, elba]\n [evil, levi, live, veil, vile]\n [caret, carte, cater, crate, trace]\n\n==[[:Category:K|K]][[Category:K]]==\n<lang k>{x@&a=|\/a:#:'x}{x g@&1<#:'g:={x@<x}'x}0::`unixdict.txt<\/lang>\n\n==[[:Category:Liberty BASIC|Liberty BASIC]][[Category:Liberty BASIC]]==\n<lang lb>' count the word list\nopen \"unixdict.txt\" for input as #1\nwhile not(eof(#1))\n    line input #1,null$\n    numWords=numWords+1\nwend\nclose #1\n\n'import to an array appending sorted letter set\nopen \"unixdict.txt\" for input as #1\ndim wordList$(numWords,3)\ndim chrSort$(45)\nwordNum=1\nwhile wordNum<numWords\n    line input #1,actualWord$\n    wordList$(wordNum,1)=actualWord$\n    wordList$(wordNum,2)=sorted$(actualWord$)\n    wordNum=wordNum+1\nwend\n\n'sort on letter set\nsort wordList$(),1,numWords,2\n\n'count and store number of anagrams found\nwordNum=1\nstartPosition=wordNum\nnumAnagrams=0\ncurrentChrSet$=wordList$(wordNum,2)\nwhile wordNum < numWords\n    while currentChrSet$=wordList$(wordNum,2)\n        numAnagrams=numAnagrams+1\n        wordNum=wordNum+1\n    wend\n    for n= startPosition to startPosition+numAnagrams\n        wordList$(n,3)=right$(\"0000\"+str$(numAnagrams),4)+wordList$(n,2)\n    next\n    startPosition=wordNum\n    numAnagrams=0\n    currentChrSet$=wordList$(wordNum,2)\nwend\n\n'sort on number of anagrams+letter set\nsort wordList$(),numWords,1,3\n\n'display the top anagram sets found\nwordNum=1\nwhile wordNum<150\n    currentChrSet$=wordList$(wordNum,2)\n    print \"Anagram set\";\n    while currentChrSet$=wordList$(wordNum,2)\n        print \" : \";wordList$(wordNum,1);\n        wordNum=wordNum+1\n    wend\n    print\n    currentChrSet$=wordList$(wordNum,2)\nwend\n\nclose #1\nend\n\nfunction sorted$(w$)\n    nchr=len(w$)\n    for chr = 1 to nchr\n        chrSort$(chr)=mid$(w$,chr,1)\n    next\n    sort chrSort$(),1,nchr\n    sorted$=\"\"\n    for chr = 1 to nchr\n        sorted$=sorted$+chrSort$(chr)\n    next\nend function<\/lang>\n\n==[[:Category:Lua|Lua]][[Category:Lua]]==\nLua's core library is very small and does not include built-in network functionality. If a networking library were imported, the local file in the following script could be replaced with the remote dictionary file. This may or may not be a good implementation, but I thought the method was interesting.\n<lang lua>-- Build the word set\nlocal set = {}\nlocal file = io.open(\"unixdict.txt\")\nlocal str = file:read()\nwhile str do\n    table.insert(set,str)\n    str = file:read()\nend\n\n-- Build the anagram tree\nlocal tree = {}\nfor i,word in next,set do\n    -- Sort a string from lowest char to highest\n    local function sortString(str)\n        if #str <= 1 then\n            return str\n        end\n        local less = ''\n        local greater = ''\n        local pivot = str:byte(1)\n        for i = 2, #str do\n            if str:byte(i) <= pivot then\n                less = less..(str:sub(i,i))\n            else\n                greater = greater..(str:sub(i,i))\n            end\n        end\n        return sortString(less)..str:sub(1,1)..sortString(greater)\n    end\n    local sortchar = sortString(word)\n    if not tree[#word] then tree[#word] = {} end\n    local node = tree[#word]\n    for i = 1,#word do\n        if not node[sortchar:byte(i)] then\n            node[sortchar:byte(i)] = {}\n        end\n        node = node[sortchar:byte(i)]\n    end\n    table.insert(node,word)\nend\n\n-- Gather largest groups by gathering all groups of current max size and droping gathered groups and increasing max when a new largest group is found\nlocal max = 0\nlocal set = {}\nlocal function recurse (tree)\n    local num = 0\n    for i,node in next,tree do\n        if type(node) == 'string' then\n            num = num + 1\n        end\n    end\n    if num > max then\n        set = {}\n        max = num\n    end\n    if num == max then\n        local newset = {}\n        for i,node in next,tree do\n            if type(node) == 'string' then\n                table.insert(newset,node)\n            end\n        end\n        table.insert(set,newset)\n    end\n    for i,node in next,tree do\n        if type(node) == 'table' then\n            recurse(node)\n        end\n    end\nend\n\nrecurse (tree)\nfor i,v in next,set do io.write (i..':\\t')for j,u in next,v do io.write (u..' ') end print() end<\/lang>\n\n==[[:Category:M4|M4]][[Category:M4]]==\n<lang M4>divert(-1)\nchangequote(`[',`]')\ndefine([for],\n   [ifelse($#,0,[[$0]],\n   [ifelse(eval($2<=$3),1,\n   [pushdef([$1],$2)$4[]popdef([$1])$0([$1],incr($2),$3,[$4])])])])\ndefine([_bar],include(t.txt))\ndefine([eachlineA],\n   [ifelse(eval($2>0),1,\n      [$3(substr([$1],0,$2))[]eachline(substr([$1],incr($2)),[$3])])])\ndefine([eachline],[eachlineA([$1],index($1,[\n]),[$2])])\ndefine([removefirst],\n   [substr([$1],0,$2)[]substr([$1],incr($2))])\ndefine([checkfirst],\n   [ifelse(eval(index([$2],substr([$1],0,1))<0),1,\n      0,\n      [ispermutation(substr([$1],1),\n            removefirst([$2],index([$2],substr([$1],0,1))))])])\ndefine([ispermutation],\n   [ifelse([$1],[$2],1,\n      eval(len([$1])!=len([$2])),1,0,\n      len([$1]),0,0,\n      [checkfirst([$1],[$2])])])\ndefine([_set],[define($1<$2>,$3)])\ndefine([_get],[defn([$1<$2>])])\ndefine([_max],1)\ndefine([_n],0)\ndefine([matchj],\n   [_set([count],$2,incr(_get([count],$2)))[]ifelse(eval(_get([count],$2)>_max),\n         1,[define([_max],incr(_max))])[]_set([list],$2,[_get([list],$2) $1])])\ndefine([checkwordj],\n   [ifelse(ispermutation([$1],_get([word],$2)),1,[matchj([$1],$2)],\n         [addwordj([$1],incr($2))])])\ndefine([_append],\n   [_set([word],_n,[$1])[]_set([count],_n,1)[]_set([list],_n,\n         [$1 ])[]define([_n],incr(_n))])\ndefine([addwordj],\n   [ifelse($2,_n,[_append([$1])],[checkwordj([$1],$2)])])\ndefine([addword],\n   [addwordj([$1],0)])\ndivert\neachline(_bar,[addword])\n_max\nfor([x],1,_n,[ifelse(_get([count],x),_max,[_get([list],x)\n])])<\/lang>\n\nMemory limitations keep this program from working on the full-sized dictionary.\nRun against the first 100 words, here is the output:\n<pre>\n2\nabel  able\naboard  abroad\n<\/pre>\n\n==[[:Category:Mathematica|Mathematica]][[Category:Mathematica]]==\nDownload the dictionary, split the lines, split the word in characters and sort them. Now sort by those words, and find sequences of equal 'letter-hashes'. Return the longest sequences:\n<lang Mathematica>list=Import[\"http:\/\/www.puzzlers.org\/pub\/wordlists\/unixdict.txt\",\"Lines\"];\ntext={#,StringJoin@@Sort[Characters[#]]}&\/@list;\ntext=SortBy[text,#[[2]]&];\nsplits=Split[text,#1[[2]]==#2[[2]]&][[All,All,1]];\nmaxlen=Max[Length\/@splits];\nSelect[splits,Length[#]==maxlen&]<\/lang>\ngives back:\n<lang Mathematica>{{abel,able,bale,bela,elba},{caret,carte,cater,crate,trace},{angel,angle,galen,glean,lange},{alger,glare,lager,large,regal},{elan,lane,lean,lena,neal},{evil,levi,live,veil,vile}}<\/lang>\nAn alternative is faster, but requires version 7 (for <code>Gather<\/code>):\n<lang Mathematica>splits = Gather[list, Sort[Characters[#]] == Sort[Characters[#2]] &];\nmaxlen = Max[Length \/@ splits];\nSelect[splits, Length[#] == maxlen &]<\/lang>\n\nOr using build-in functions for sorting and gathering elements in lists it can be implimented as:\n<lang Mathematica>anagramGroups = GatherBy[SortBy[GatherBy[list,Sort[Characters[#]] &],Length],Length];\nanagramGroups[[-1]]<\/lang>\nAlso, Mathematica's own word list is available; replacing the list definition with <code>list = WordData[];<\/code> and forcing <code>maxlen<\/code> to 5 yields instead this result:\n\n {{angered,derange,enraged,grandee,grenade},\n  {anisometric,creationism,miscreation,reactionism,romanticise},\n  {aper,pare,pear,rape,reap},\n  {ardeb,barde,bared,beard,bread,debar},\n  {aril,lair,lari,liar,lira,rail,rial},\n  {aster,rates,stare,tears,teras},\n  {caret,carte,cater,crate,react,trace},\n  {east,eats,sate,seat,seta},\n  {ester,reset,steer,teres,terse},\n  {inert,inter,niter,nitre,trine},\n  {latrine,ratline,reliant,retinal,trenail},\n  {least,slate,stale,steal,stela,tesla},\n  {luster,lustre,result,rustle,sutler,ulster},\n  {merit,miter,mitre,remit,timer},\n  {part,prat,rapt,tarp,trap},\n  {resin,rinse,risen,serin,siren},\n  {respect,scepter,sceptre,specter,spectre}}\n\n==[[:Category:Maxima|Maxima]][[Category:Maxima]]==\n<lang maxima>read_file(name) := block([file, s, L], file: openr(name), L: [],\nwhile stringp(s: readline(file)) do L: cons(s, L), close(file), L)$\n\nu: read_file(\"C:\/my\/mxm\/unixdict.txt\")$\n\nv: map(lambda([s], [ssort(s), s]), u)$\n\nw: sort(v, lambda([x, y], orderlessp(x[1], y[1])))$\n\nana(L) := block([m, n, p, r, u, v, w],\nL: endcons([\"\", \"\"], L),\nn: length(L),\nr: \"\",\nm: 0,\nv: [ ],\nw: [ ],\nfor i from 1 thru n do (\n   u: L[i],\n   if r = u[1] then (\n      w: cons(u[2], w)\n   ) else (\n      p: length(w),\n      if p >= m then (\n         if p > m then (m: p, v: []),\n         v: cons(w, v)\n      ),\n      w: [u[2]],\n      r: u[1]\n   )\n),\nv)$\n\nana(w);\n\/* [[\"evil\", \"levi\", \"live\", \"veil\", \"vile\"],\n    [\"elan\", \"lane\", \"lean\", \"lena\", \"neal\"],\n    [\"alger\", \"glare\", \"lager\", \"large\", \"regal\"],\n    [\"angel\", \"angle\", \"galen\", \"glean\", \"lange\"],\n    [\"caret\", \"carte\", \"cater\", \"crate\", \"trace\"],\n    [\"abel\", \"able\", \"bale\", \"bela\", \"elba\"]] *\/<\/lang>\n\n==[[:Category:MUMPS|MUMPS]][[Category:MUMPS]]==\n<lang MUMPS>Anagrams\tNew ii,file,longest,most,sorted,word\n\tSet file=\"unixdict.txt\"\n\tOpen file:\"r\" Use file\n\tFor  Quit:$ZEOF  DO\n\t. New char,sort\n\t. Read word Quit:word=\"\"\n\t. For ii=1:1:$Length(word) Do\n\t. . Set char=$ASCII(word,ii)\n\t. . If char>64,char<91 Set char=char+32\n\t. . Set sort(char)=$Get(sort(char))+1\n\t. . Quit\n\t. Set (sorted,char)=\"\" For  Set char=$Order(sort(char)) Quit:char=\"\"  Do\n\t. . For ii=1:1:sort(char) Set sorted=sorted_$Char(char)\n\t. . Quit\n\t. Set table(sorted,word)=1\n\t. Quit\n\tClose file\n\tSet sorted=\"\" For  Set sorted=$Order(table(sorted)) Quit:sorted=\"\"  Do\n\t. Set ii=0,word=\"\" For  Set word=$Order(table(sorted,word)) Quit:word=\"\"  Set ii=ii+1\n\t. Quit:ii<2\n\t. Set most(ii,sorted)=1\n\t. Quit\n\tWrite !,\"The anagrams with the most variations:\"\n\tSet ii=$Order(most(\"\"),-1)\n\tSet sorted=\"\" For  Set sorted=$Order(most(ii,sorted)) Quit:sorted=\"\"  Do\n\t. Write ! Set word=\"\" For  Set word=$Order(table(sorted,word)) Quit:word=\"\"  Write \"  \",word\n\t. Quit\n\tWrite !,\"The longest anagrams:\"\n\tSet ii=$Order(longest(\"\"),-1)\n\tSet sorted=\"\" For  Set sorted=$Order(longest(ii,sorted)) Quit:sorted=\"\"  Do\n\t. Write ! Set word=\"\" For  Set word=$Order(table(sorted,word)) Quit:word=\"\"  Write \"  \",word\n\t. Quit\n\tQuit\n\nDo Anagrams<\/lang>\n<pre>\nThe anagrams with the most variations:\n  abel  able  bale  bela  elba\n  caret  carte  cater  crate  trace\n  angel  angle  galen  glean  lange\n  alger  glare  lager  large  regal\n  elan  lane  lean  lena  neal\n  evil  levi  live  veil  vile\nThe longest anagrams:\n  conservation  conversation\n<\/pre>\n\n==[[:Category:OCaml|OCaml]][[Category:OCaml]]==\n<lang ocaml>let explode str =\n  let l = ref [] in\n  let len = String.length str in\n  for i = len - 1 downto 0 do\n    l := str.[i] :: !l\n  done;\n  (!l)\n\nlet implode li =\n  let len = List.length li in\n  let s = String.create len in\n  let i = ref 0 in\n  List.iter (fun c -> s.[!i] <- c; incr i) li;\n  (s)\n\nlet () =\n  let h = Hashtbl.create 3571 in\n  let ic = open_in \"unixdict.txt\" in\n  try while true do\n    let w = input_line ic in\n    let k = implode(List.sort compare (explode w)) in\n    let l =\n      try Hashtbl.find h k\n      with Not_found -> [] \n    in\n    Hashtbl.add h k (w::l);\n  done with End_of_file -> ();\n  let n = Hashtbl.fold (fun _ lw n -> max n (List.length lw)) h 0 in\n  Hashtbl.iter (fun _ lw ->\n    if List.length lw >= n then\n    ( List.iter (Printf.printf \" %s\") lw;\n      print_newline())\n  ) h;\n;;<\/lang>\n\n==[[:Category:Oz|Oz]][[Category:Oz]]==\n<lang oz>declare\n  %% Helper function\n  fun {ReadLines Filename}\n     File = {New class $ from Open.file Open.text end init(name:Filename)}\n  in\n     for collect:C break:B do\n\tcase {File getS($)} of false then {File close} {B}\n\t[] Line then {C Line}\n        end\n     end\n  end\n\n  %% Groups anagrams by using a mutable dictionary\n  %% with sorted words as keys\n  WordDict = {Dictionary.new}\n  for Word in {ReadLines \"unixdict.txt\"}  do\n     Keyword = {String.toAtom {Sort Word Value.'<'}}\n  in\n     WordDict.Keyword := Word|{CondSelect WordDict Keyword nil}\n  end\n  Sets = {Dictionary.items WordDict}\n\n  %% Filter such that only the largest sets remain\n  MaxSetSize = {FoldL {Map Sets Length} Max 0}\n  LargestSets = {Filter Sets fun {$ S} {Length S} == MaxSetSize end}\nin\n  %% Display result (make sure strings are shown as string, not as number lists)\n  {Inspector.object configureEntry(widgetShowStrings true)}\n  {Inspect LargestSets}<\/lang>\n\n==[[:Category:Pascal|Pascal]][[Category:Pascal]]==\n<lang pascal>Program Anagrams;\n\n\/\/ assumes a local file\n\nuses\n  classes, math;\n\nvar\n  i, j, k, maxCount: integer;\n  sortedString:      string;\n  WordList:          TStringList;\n  SortedWordList:    TStringList;\n  AnagramList:       array of TStringlist;\n  \nbegin\n  WordList := TStringList.Create;\n  WordList.LoadFromFile('unixdict.txt');\n  for i := 0 to WordList.Count - 1 do\n  begin\n    setLength(sortedString,Length(WordList.Strings[i]));\n    sortedString[1] := WordList.Strings[i][1];\n\n    \/\/ sorted assign\n    j := 2;\n    while j <=  Length(WordList.Strings[i]) do\n    begin\n      k := j - 1;\n      while (WordList.Strings[i][j] < sortedString[k]) and (k > 0) do\n      begin\n        sortedString[k+1] := sortedString[k];\n        k := k - 1;\n      end;\n      sortedString[k+1] :=  WordList.Strings[i][j];\n      j := j + 1;\n    end;\n\n    \/\/ create the stringlists of the sorted letters and \n    \/\/ the list of the original words\n    if not assigned(SortedWordList) then\n    begin\n      SortedWordList := TStringList.Create;\n      SortedWordList.append(sortedString);\n      setlength(AnagramList,1);\n      AnagramList[0] := TStringList.Create;\n      AnagramList[0].append(WordList.Strings[i]);\n    end\n    else\n    begin\n      j := 0;\n      while sortedString <> SortedWordList.Strings[j] do\n      begin\n        inc(j);\n        if j = (SortedWordList.Count) then \n        begin\n          SortedWordList.append(sortedString);\n          setlength(AnagramList,length(AnagramList) + 1);\n          AnagramList[j] := TStringList.Create;\n \t  break;\n        end;  \n      end;\n      AnagramList[j].append(WordList.Strings[i]);\n    end;\n  end;\n\n  maxCount := 1;\n  for i := 0 to length(AnagramList) - 1 do\n    maxCount := max(maxCount, AnagramList[i].Count);\n    \n  \/\/ create output\n  writeln('The largest sets of words have ', maxCount, ' members:');\n  for i := 0 to length(AnagramList) - 1 do\n  begin\n    if AnagramList[i].Count = maxCount then\n    begin\n      write('\"', SortedWordList.strings[i], '\": ');\n      for j := 0 to AnagramList[i].Count - 2 do\n        write(AnagramList[i].strings[j], ', ');\n      writeln(AnagramList[i].strings[AnagramList[i].Count - 1]);\n    end;\n  end;\n\n  \/\/ Cleanup\n  WordList.Destroy;\n  SortedWordList.Destroy;\n  for i := 0 to length(AnagramList) - 1 do\n    AnagramList[i].Destroy;\n\nend.<\/lang>\nOutput:\n<pre>\nThe largest sets of words have 5 members:\n\"abel\": abel, able, bale, bela, elba\n\"aeglr\": alger, glare, lager, large, regal\n\"aegln\": angel, angle, galen, glean, lange\n\"acert\": caret, carte, cater, crate, trace\n\"aeln\": elan, lane, lean, lena, neal\n\"eilv\": evil, levi, live, veil, vile\n<\/pre>\n\n==[[:Category:Perl|Perl]][[Category:Perl]]==\n<lang perl>use LWP::Simple;\nuse List::Util qw(max);\n\nmy @words = split(' ', get('http:\/\/www.puzzlers.org\/pub\/wordlists\/unixdict.txt'));\nmy %anagram;\nforeach my $word (@words) {\n    push @{ $anagram{join('', sort(split(\/\/, $word)))} }, $word;\n}\n\nmy $count = max(map {scalar @$_} values %anagram);\nforeach my $ana (values %anagram) {\n    if (@$ana >= $count) {\n        print \"@$ana\\n\";\n    }\n}<\/lang>\nrefactor of above:\n<lang perl>use LWP::Simple;\n\nfor (split ' ' => get 'http:\/\/www.puzzlers.org\/pub\/wordlists\/unixdict.txt')\n    {push @{$anagram{ join '' => sort split \/\/ }}, $_}\n\n$max > @$_  or  $max = @$_    for values %anagram;\n@$_ >= $max and print \"@$_\\n\" for values %anagram;<\/lang>\nOutput:\n alger glare lager large regal\n abel able bale bela elba\n evil levi live veil vile\n angel angle galen glean lange\n elan lane lean lena neal\n caret carte cater crate trace\n\n==[[:Category:Perl 6|Perl 6]][[Category:Perl 6]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Rakudo]] version 2010.07[[SMW::on]]<\/div>\n<lang perl6>my %anagram = slurp('unixdict.txt').words.classify( { .comb.sort.join } );\n\nmy $max = [max] map { +@($_) }, %anagram.values;\n\n%anagram.values.grep( { +@($_) >= $max } )\u00bb.join(' ')\u00bb.say;<\/lang>\nOutput:\n caret carte cater crate trace\n angel angle galen glean lange\n alger glare lager large regal\n elan lane lean lena neal\n evil levi live veil vile\n abel able bale bela elba\n\nJust for the fun of it, here's one-liner that uses no temporaries.  Since it would be rather long, we've oriented it vertically:\n<lang perl6>slurp('unixdict.txt')\\\n.words\\\n.classify( *.comb.sort.join )\\\n.classify( +*.value )\\\n.sort( -*.key )[0]\\\n.value\\\n.values\\\n\u00bb.value\\\n\u00bb.say<\/lang>\n\n==[[:Category:PHP|PHP]][[Category:PHP]]==\n<lang php><?php\n$words = explode(\"\\n\", file_get_contents('http:\/\/www.puzzlers.org\/pub\/wordlists\/unixdict.txt'));\nforeach ($words as $word) {\n    $chars = str_split($word);\n    sort($chars);\n    $anagram[implode($chars)][] = $word;\n}\n\n$best = max(array_map('count', $anagram));\nforeach ($anagram as $ana)\n    if (count($ana) == $best)\n        print_r($ana);\n?><\/lang>\n\n==[[:Category:PicoLisp|PicoLisp]][[Category:PicoLisp]]==\nA straight-forward implementation using 'group' takes 48 seconds on a 1.7 GHz Pentium:\n<lang PicoLisp>(flip\n   (by length sort\n      (by '((L) (sort (copy L))) group\n         (in \"unixdict.txt\" (make (while (line) (link @)))) ) ) )<\/lang>\nUsing a binary tree with the 'idx' function, it takes only 0.42 seconds on the same machine, a factor of 100 faster:\n<lang PicoLisp>(let Words NIL\n   (in \"unixdict.txt\"\n      (while (line)\n         (let (Word (pack @)  Key (pack (sort @)))\n            (if (idx 'Words Key T)\n               (push (car @) Word)\n               (set Key (list Word)) ) ) ) )\n   (flip (by length sort (mapcar val (idx 'Words)))) )<\/lang>\nOutput:\n<pre>-> ((\"vile\" \"veil\" \"live\" \"levi\" \"evil\") (\"trace\" \"crate\" \"cater\" \"carte\" \"caret\n\") (\"regal\" \"large\" \"lager\" \"glare\" \"alger\") (\"neal\" \"lena\" \"lean\" \"lane\" \"elan\"\n) (\"lange\" \"glean\" \"galen\" \"angle\" \"angel\") (\"elba\" \"bela\" \"bale\" \"able\" \"abel\")\n (\"tulsa\" \"talus\" \"sault\" \"latus\") ...<\/pre>\n\n==[[:Category:PL\/I|PL\/I]][[Category:PL\/I]]==\n<lang PL\/I>\/* Search a list of words, finding those having the same letters. *\/\n\nword_test: proc options (main);\n   declare words (50000) character (20) varying,\n           frequency (50000) fixed binary;\n   declare word character (20) varying;\n   declare (i, k, wp, most) fixed binary (31);\n\n   on endfile (sysin) go to done;\n\n   words = ''; frequency = 0;\n   wp = 0;\n   do forever;\n      get edit (word) (L);\n      call search_word_list (word);\n   end;\n\ndone:\n   put skip list ('There are ' || wp || ' words');\n   most = 0;\n   \/* Determine the word(s) having the greatest number of anagrams. *\/\n   do i = 1 to wp;\n      if most < frequency(i) then most = frequency(i);\n   end;\n   put skip edit ('The following word(s) have ', trim(most), ' anagrams:') (a);\n   put skip;\n   do i = 1 to wp;\n      if most = frequency(i) then put edit (words(i)) (x(1), a);\n   end;\n\nsearch_word_list: procedure (word) options (reorder);\n   declare word character (*) varying;\n   declare i fixed binary (31);\n\n   do i = 1 to wp;\n      if length(words(i)) = length(word) then\n         if is_anagram(word, words(i)) then\n            do;\n               frequency(i) = frequency(i) + 1;\n               return;\n            end;\n   end;\n   \/* The word does not exist in the list, so add it. *\/\n   if wp >= hbound(words,1) then return;\n   wp = wp + 1;\n   words(wp) = word;\n   frequency(wp) = 1;\n   return;\nend search_word_list;\n\n\/* Returns true if the words are anagrams, otherwise returns false. *\/\nis_anagram: procedure (word1, word2) returns (bit(1)) options (reorder);\n   declare (word1, word2) character (*) varying;\n   declare tword character (20) varying, c character (1);\n   declare (i, j) fixed binary;\n\n   tword = word2;\n   do i = 1 to length(word1);\n      c = substr(word1, i, 1);\n      j = index(tword, c);\n      if j = 0 then return ('0'b);\n      substr(tword, j, 1) = ' ';\n   end;\n   return ('1'b);\nend is_anagram;\n\nend word_test;<\/lang>\nOutput:\n<pre>\nThere are          23565 words \nThe following word(s) have 5 anagrams:\n abel alger angel caret elan evil\n<\/pre>\n\n==[[:Category:PowerShell|PowerShell]][[Category:PowerShell]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[PowerShell]] version 2[[SMW::on]]<\/div>\n<lang powershell>$c = New-Object Net.WebClient\n$words = -split ($c.DownloadString('http:\/\/www.puzzlers.org\/pub\/wordlists\/unixdict.txt'))\n$top_anagrams = $words `\n    | ForEach-Object {\n          $_ | Add-Member -PassThru NoteProperty Characters `\n                   (-join (([char[]] $_) | Sort-Object))\n      } `\n    | Group-Object Characters `\n    | Group-Object Count `\n    | Sort-Object Count `\n    | Select-Object -First 1\n\n$top_anagrams.Group | ForEach-Object { $_.Group -join ', ' }<\/lang>\nOutput:\n<pre>abel, able, bale, bela, elba\nalger, glare, lager, large, regal\nangel, angle, galen, glean, lange\ncaret, carte, cater, crate, trace\nelan, lane, lean, lena, neal\nevil, levi, live, veil, vile<\/pre>\n\n==[[:Category:Prolog|Prolog]][[Category:Prolog]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[SWI-Prolog]] version 5.10.0[[SMW::on]]<\/div> \n<lang Prolog>:- use_module(library( http\/http_open )).\n\nanagrams:-\n        % we read the URL of the words\n\thttp_open('http:\/\/www.puzzlers.org\/pub\/wordlists\/unixdict.txt',\tIn, []),\n\tread_file(In, [], Out),\n\tclose(In),\n\n        % we get a list of pairs key-value where key = a-word value = <list-of-its-codes>\n        % this list must be sorted\n\tmsort(Out, MOut),\n\n        % in order to gather values with the same keys\n\tgroup_pairs_by_key(MOut, GPL),\n\n        % we sorted this list in decreasing order of the length of values\n\tpredsort(my_compare, GPL, GPLSort),\n\n\t% we extract the first 6 items \n        GPLSort = [_H1-T1, _H2-T2, _H3-T3, _H4-T4, _H5-T5, _H6-T6 | _],\n\n        % Tnn are lists of codes (97 for 'a'), we create the strings \n\tmaplist(maplist(atom_codes), L, [T1, T2, T3, T4, T5, T6] ),\n\n\tmaplist(writeln, L).\n\n\nread_file(In, L, L1) :-\n\tread_line_to_codes(In, W),\n\t(   W == end_of_file -> \n               % the file is read\n\t       L1 = L\n\t       ; \n               % we sort the list of codes of the line\n\t       msort(W, W1),\n\n               % to create the key in alphabetic order\n\t       atom_codes(A, W1), \n\n               % and we have the pair Key-Value in the result list\n\t       read_file(In, [A-W | L], L1)).\n\n% predicate for sorting list of pairs Key-Values\n% if the lentgh of values is the same\n% we sort the keys in alhabetic order\nmy_compare(R, K1-V1, K2-V2) :-\n\tlength(V1, L1),\n\tlength(V2, L2),\n\t(   L1 < L2 -> R = >; L1 > L2 -> R = <; compare(R, K1, K2)).<\/lang>\nThe result is\n<pre>[abel,able,bale,bela,elba]\n[caret,carte,cater,crate,trace]\n[angel,angle,galen,glean,lange]\n[alger,glare,lager,large,regal]\n[elan,lane,lean,lena,neal]\n[evil,levi,live,veil,vile]\ntrue<\/pre>\n\n==[[:Category:PureBasic|PureBasic]][[Category:PureBasic]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[PureBasic]] version 4.4[[SMW::on]]<\/div> \n<lang PureBasic>InitNetwork()  ;\nOpenConsole()\n\nProcedure.s sortWord(word$)\n  len.i = Len(word$)\n  Dim CharArray.s (len)\n \n  For n = 1 To len                                 ; Transfering each single character \n     CharArray(n) = Mid(word$, n, 1)      ; of the word into an array.\n  Next                               \n \n  SortArray(CharArray(),#PB_Sort_NoCase ) ; Sorting the array. \n \n  word$ =\"\" \n  For n = 1 To len                       ; Writing back each single \n     word$ + CharArray(n)             ; character of the array.\n  Next \n \n  ProcedureReturn word$\nEndProcedure\n\n\ntmpdir$   = GetTemporaryDirectory()\nfilename$ = tmpdir$ + \"unixdict.txt\"\nStructure ana\n   isana.l\n   anas.s\nEndStructure\n\nNewMap anaMap.ana()\n\nIf ReceiveHTTPFile(\"http:\/\/www.puzzlers.org\/pub\/wordlists\/unixdict.txt\", filename$)\n  If ReadFile(1, filename$)\n    Repeat\n      word$ = (ReadString(1))             ; Reading a word from a file.\n      key$  = (sortWord(word$))             ; Sorting the word and storing in key$.\n     \n      If FindMapElement(anaMap(), key$)   ; Looking up if a word already had the same key$.\n      \n                                          ; if yes \n         anaMap()\\anas  = anaMap()\\anas+ \", \" + word$   ; adding the word\n         anaMap()\\isana + 1   \n      Else\n                                          ; if no       \n         anaMap(key$)\\anas = word$        ; applying  a new record\n         anaMap()\\isana + 1 \n      EndIf\n    Until Eof(1)\n    CloseFile(1)\n    DeleteFile(filename$)\n   \n    ;----- output -----\n    ForEach anaMap()\n      If anaMap()\\isana >= 4      ; only emit what had 4 or more hits.\n        PrintN(anaMap()\\anas)\n      EndIf \n    Next\n   \n    PrintN(\"Press any key\"): Repeat: Until Inkey() <> \"\"       \n  EndIf\nEndIf <\/lang>\n\n==[[:Category:Python|Python]][[Category:Python]]==\nPython 3.2 shell input (IDLE)\n<lang python>>>> import urllib.request\n>>> from collections import defaultdict\n>>> words = urllib.request.urlopen('http:\/\/www.puzzlers.org\/pub\/wordlists\/unixdict.txt').read().split()\n>>> anagram = defaultdict(list) # map sorted chars to anagrams\n>>> for word in words:\n\tanagram[tuple(sorted(word))].append( word )\n\n\t\n>>> count = max(len(ana) for ana in anagram.values())\n>>> for ana in anagram.values():\n\tif len(ana) >= count:\n\t\tprint ([x.decode() for x in ana])<\/lang>\n\nPython 3.2.1 groupby (in place sort instead of max)\n<lang python>import urllib.request, itertools\nimport time\nwords = urllib.request.urlopen('http:\/\/www.puzzlers.org\/pub\/wordlists\/unixdict.txt').read().split()\nprint('Words ready')\nt0 = time.clock()\nanagrams = [list(g) for k,g in itertools.groupby(sorted(words, key=sorted), key=sorted)]\nanagrams.sort(key=len, reverse=True)\ncount = len(anagrams[0])\nfor ana in anagrams:\n    if len(ana) < count:\n        break\n    print(ana)\nt0 -= time.clock()\nprint('Finished in %f s' % -t0)<\/lang>\n\nPython 2.5 shell input (IDLE)\n<lang python>>>> import urllib\n>>> from collections import defaultdict\n>>> words = urllib.urlopen('http:\/\/www.puzzlers.org\/pub\/wordlists\/unixdict.txt').read().split()\n>>> len(words)\n25104\n>>> anagram = defaultdict(list) # map sorted chars to anagrams\n>>> for word in words:\n\tanagram[tuple(sorted(word))].append( word )\n\n\t\n>>> count = max(len(ana) for ana in anagram.itervalues())\n>>> for ana in anagram.itervalues():\n\tif len(ana) >= count:\n\t\tprint ana\n\n\t\t\n['angel', 'angle', 'galen', 'glean', 'lange']\n['alger', 'glare', 'lager', 'large', 'regal']\n['caret', 'carte', 'cater', 'crate', 'trace']\n['evil', 'levi', 'live', 'veil', 'vile']\n['elan', 'lane', 'lean', 'lena', 'neal']\n['abel', 'able', 'bale', 'bela', 'elba']\n>>> count\n5\n>>><\/lang>\n\n<div class=\"examplemeta translation\">'''Translation of''': [[Anagrams#Haskell|Haskell]]<\/div>\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Python]] version 2.6[[SMW::on]]<\/div> sort and then group using groupby()\n<lang python>>>> import urllib, itertools\n>>> words = urllib.urlopen('http:\/\/www.puzzlers.org\/pub\/wordlists\/unixdict.txt').read().split()\n>>> len(words)\n25104\n>>> anagrams = [list(g) for k,g in itertools.groupby(sorted(words, key=sorted), key=sorted)]\n\n\n>>> count = max(len(ana) for ana in anagrams)\n>>> for ana in anagrams:\n\tif len(ana) >= count:\n\t\tprint ana\n\n\t\t\n['abel', 'able', 'bale', 'bela', 'elba']\n['caret', 'carte', 'cater', 'crate', 'trace']\n['angel', 'angle', 'galen', 'glean', 'lange']\n['alger', 'glare', 'lager', 'large', 'regal']\n['elan', 'lane', 'lean', 'lena', 'neal']\n['evil', 'levi', 'live', 'veil', 'vile']\n>>> count\n5\n>>><\/lang>\n\n==[[:Category:R|R]][[Category:R]]==\n<lang R>words <- readLines(\"http:\/\/www.puzzlers.org\/pub\/wordlists\/unixdict.txt\")\nword_group <- sapply(\n    strsplit(words, split=\"\"), # this will split all words to single letters...\n    function(x) paste(sort(x), collapse=\"\") # ...which we sort and paste again\n)\n\ncounts <- tapply(words, word_group, length) # group words by class to get number of anagrams\nanagrams <- tapply(words, word_group, paste, collapse=\", \") # group to get string with all anagrams\n\n# Results\ntable(counts)\ncounts\n    1     2     3     4     5 \n22263  1111   155    31     6 \n\nanagrams[counts == max(counts)]\n                               abel                               acert \n     \"abel, able, bale, bela, elba\" \"caret, carte, cater, crate, trace\" \n                              aegln                               aeglr \n\"angel, angle, galen, glean, lange\" \"alger, glare, lager, large, regal\" \n                               aeln                                eilv \n     \"elan, lane, lean, lena, neal\"      \"evil, levi, live, veil, vile\" <\/lang>\n\n==[[:Category:Racket|Racket]][[Category:Racket]]==\n<lang scheme>#lang racket\n\n(require net\/url)         \n\n(define (get-lines url-string)\n  (define port (get-pure-port (string->url url-string)))\n  (for\/list ([l (in-lines port)]) l))\n\n(define (hash-words words)\n  (for\/fold ([ws-hash (hash)]) ([w words])\n    (hash-update ws-hash \n                 (list->string (sort (string->list w) < #:key (\u03bb (c) (char->integer c))))\n                 (\u03bb (ws) (cons w ws))\n                 (\u03bb () '()))))\n\n(define (get-maxes h)\n  (define max-ws (apply max (map length (hash-values h))))\n  (define max-keys (filter (\u03bb (k) (= (length (hash-ref h k)) max-ws)) (hash-keys h)))\n  (map (\u03bb (k) (hash-ref h k)) max-keys))\n\n(get-maxes (hash-words (get-lines \"http:\/\/www.puzzlers.org\/pub\/wordlists\/unixdict.txt\")))<\/lang>\nOutput:\n<lang scheme>'((\"neal\" \"lena\" \"lean\" \"lane\" \"elan\")\n  (\"trace\" \"crate\" \"cater\" \"carte\" \"caret\")\n  (\"regal\" \"large\" \"lager\" \"glare\" \"alger\")\n  (\"elba\" \"bela\" \"bale\" \"able\" \"abel\")\n  (\"lange\" \"glean\" \"galen\" \"angle\" \"angel\")\n  (\"vile\" \"veil\" \"live\" \"levi\" \"evil\"))<\/lang>\n\n==[[:Category:Rascal|Rascal]][[Category:Rascal]]==\n<lang rascal>import Prelude;\n\nlist[str] OrderedRep(str word){\t\n\treturn sort([word[i] | i <- [0..size(word)-1]]);\n}\npublic list[set[str]] anagram(){\n\tallwords = readFileLines(|http:\/\/www.puzzlers.org\/pub\/wordlists\/unixdict.txt|);\n\tAnagramMap = invert((word : OrderedRep(word) | word <- allwords));\n\tlongest = max([size(group) | group <- range(AnagramMap)]);\n\treturn [AnagramMap[rep]| rep <- AnagramMap, size(AnagramMap[rep]) == longest];\n}<\/lang>\nReturns:\n<lang rascal>value: [\n  {\"glean\",\"galen\",\"lange\",\"angle\",\"angel\"},\n  {\"glare\",\"lager\",\"regal\",\"large\",\"alger\"},\n  {\"carte\",\"trace\",\"crate\",\"caret\",\"cater\"},\n  {\"lane\",\"lena\",\"lean\",\"elan\",\"neal\"},\n  {\"able\",\"bale\",\"abel\",\"bela\",\"elba\"},\n  {\"levi\",\"live\",\"vile\",\"evil\",\"veil\"}\n]<\/lang>\n\n==[[:Category:Revolution|Revolution]][[Category:Revolution]]==\n<lang revolution>on mouseUp\n   repeat for each word W in url \"http:\/\/www.puzzlers.org\/pub\/wordlists\/unixdict.txt\"\n      put W & comma after A[sortChars(W)]\n   end repeat\n   put 0 into winningLength\n   repeat for each element E in A\n      get the number of items in E\n      if it < winningLength then next repeat\n      if it > winningLength then\n         put it into winningLength\n         put empty into winningList\n      end if\n      put (char 1 to -2 of E) & cr after winningList\n   end repeat\n   put winningList\nend mouseUp\n\nfunction sortChars X\n   get charsToItems(X)\n   sort items of it\n   return itemsToChars(it)\nend sortChars\n\nfunction charsToItems X\n   repeat for each char C in X\n      put C & comma after R\n   end repeat\n   return char 1 to -2 of R\nend charsToItems\n\nfunction itemsToChars X\n   replace comma with empty in X\n   return X\nend itemsToChars<\/lang>\nOutput:\n<pre>abel,able,bale,bela,elba\nelan,lane,lean,lena,neal\nevil,levi,live,veil,vile\ncaret,carte,cater,crate,trace\nangel,angle,galen,glean,lange\nalger,glare,lager,large,regal<\/pre>\n\n==[[:Category:REXX|REXX]][[Category:REXX]]==\n<lang rexx>\/*REXX program finds words with the largest set of anagrams (same size).*\/\nn.=0                                   \/*number of anagrams for word X. *\/\na.=''                                  \/*          anagrams for word X. *\/\nifid='unixdict.txt'                    \/*input file identifier.         *\/\n             do j=1 while lines(ifid)\n             @.j=linein(ifid)\n             end\nwords=j-1                              \/*number of words in dictionary. *\/\nsay copies('-',20) words 'words in the dictionary file:' ifid\n\n  do j=1 for words                     \/*process the words in dictionary*\/\n  x=@.j; Lx=length(x); if Lx<3 then iterate  \/*onezys & twozys can't win*\/\n  notHas.=1\n         do i=1 for Lx                 \/*build fast way to compare chars*\/\n         _=substr(x,i,1);  notHas._=0  \/*indicate this char is in word X*\/\n         end\n    do k=1 for words                   \/*plow through the other words.  *\/\n    if length(@.k)\\==Lx then iterate   \/*Y length isn't right, skip it. *\/\n    y=@.k\n           do m=Lx by -1 for Lx        \/*see if all Y chars are in X.   *\/\n           _=substr(y,m,1)             \/*(backwards is faster.)         *\/\n           if notHas._ then iterate k  \/*if doesn't have it, skip word. *\/\n           end\n    xx=x                               \/*make a throwaway copy of  X.   *\/\n         do p=1 for Lx                 \/*discount dup chars not in  X.  *\/\n         _=pos(substr(y,p,1),xx)       \/*find position of the char in X.*\/\n         if _==0 then iterate k        \/*Not there?  Must be a duplicate*\/\n         xx=overlay('0'x,XX,_)         \/*replace the char with  '00'x.  *\/\n         end\n    if k==j then iterate               \/*skip doing anagram on itself.  *\/\n    n.j=n.j+1;  a.j=a.j y              \/*bump counter, add --> anagrams.*\/\n    end   \/*k*\/\n  end     \/*j*\/\n\nmA=n.j\n do j=2 to words;  mA=max(mA,n.j);  end      \/*find maximum \"anagrams\". *\/\n do k=1 for words;  if n.k==mA & word(a.k,1)>@.k then say @.k a.k;  end<\/lang>\n'''output'''\n<pre>\n-------------------- 25104 words in the dictionary file: unixdict.txt\nabel  able bale bela elba\nalger  glare lager large regal\nangel  angle galen glean lange\ncaret  carte cater crate trace\nelan  lane lean lena neal\nevil  levi live veil vile\n<\/pre>\n\n==[[:Category:Ruby|Ruby]][[Category:Ruby]]==\n<lang ruby>require 'open-uri'\n\nanagram = Hash.new {|hash, key| hash[key] = []} # map sorted chars to anagrams\n\nopen('http:\/\/www.puzzlers.org\/pub\/wordlists\/unixdict.txt') do |f|\n  words = f.read.split\n  for word in words\n    anagram[word.split('').sort] << word\n  end\nend\n\ncount = anagram.values.map {|ana| ana.length}.max\nanagram.each_value do |ana|\n  if ana.length >= count\n    p ana\n  end\nend<\/lang>\nOutput:\n [\"evil\", \"levi\", \"live\", \"veil\", \"vile\"]\n [\"abel\", \"able\", \"bale\", \"bela\", \"elba\"]\n [\"elan\", \"lane\", \"lean\", \"lena\", \"neal\"]\n [\"alger\", \"glare\", \"lager\", \"large\", \"regal\"]\n [\"angel\", \"angle\", \"galen\", \"glean\", \"lange\"]\n [\"caret\", \"carte\", \"cater\", \"crate\", \"trace\"]\n\n<div class=\"examplemeta translation\">'''Translation of''': [[Anagrams#Haskell|Haskell]]<\/div>\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Ruby]] version 1.8.7+[[SMW::on]]<\/div> \n<lang ruby>require 'open-uri'\n\nanagram = nil\n\nopen('http:\/\/www.puzzlers.org\/pub\/wordlists\/unixdict.txt') do |f|\n  anagram = f.read.split.group_by {|s| s.each_char.sort}\nend\n\ncount = anagram.each_value.map {|ana| ana.length}.max\nanagram.each_value do |ana|\n  if ana.length >= count\n    p ana\n  end\nend<\/lang>\n\n==[[:Category:Run BASIC|Run BASIC]][[Category:Run BASIC]]==\n<lang runbasic>a$ = httpGet$(\"http:\/\/www.puzzlers.org\/pub\/wordlists\/unixdict.txt\")  ' get the words from this web\n\nsqliteconnect #mem, \":memory:\"                                       ' create in memory DB\n#mem execute(\"CREATE TABLE words(theWord,sortWord)\")\n\nii = 1\nwhile ii\n   jj       = instr(a$,chr$(10),ii + 1)\n   if jj > 0 then\n      theWord$ = mid$(a$,ii, jj - ii)                                 ' get each word\n      \n      if instr(theWord$,\"'\") <> 0 then theWord$ = dblQuote$(theWord$) ' eclipse the single quote\n      sortWord$ = theWord$\n     ' ------------------------------------\n     ' Sort word using the ol bubble sort\n     ' ------------------------------------\n      j = 1\n      while j\n         j = 0\n         for i = 1 to len(sortWord$) - 1\n            if mid$(sortWord$,i,1) > mid$(sortWord$,i + 1,1) then\n               sortWord$ = left$(sortWord$,i - 1) + mid$(sortWord$,i + 1,1) +  mid$(sortWord$,i,1) + mid$(sortWord$,i + 2)\n               j = 1\n            end if\n         next i\n      wend\n     ' ----------------------------\n     ' place in memory sql table\n     ' ----------------------------\n      #mem execute(\"INSERT INTO words VALUES('\";theWord$;\"','\";sortWord$;\"')\")\n   end if\n   ii = jj + 1\nwend\n\n' -----------------------------------------------------------\n' Select matched words in word order and print in html table\n' -----------------------------------------------------------\nhtml \"<table border=1>\"\nmem$ = \"SELECT words.theWord,\nmatchWords.theWord as mWord\nFROM words\nJOIN words as matchWords\nON   matchWords.sortWord = words.sortWord\nAND  matchWOrds.theWord <> words.theWord\nORDER BY words.theWord\"\n#mem execute(mem$)\nWHILE #mem hasanswer()\n   #row     = #mem #nextrow()\n   theWord$ = #row theWord$()\n   mWord$   = #row mWord$()\n   html \"<tr><td>\";theWord$;\"<\/td><td>\";mWord$;\"<\/td><\/tr>\"\nWEND\nhtml \"<\/table>\"\nend\n\n' -----------------------------------------\n' Convert single quotes to double quotes\n' -----------------------------------------\nFUNCTION dblQuote$(str$)\ni    = 1\nqq$  = \"\"\nwhile (word$(str$,i,\"'\")) <> \"\"\n   dblQuote$   = dblQuote$;qq$;word$(str$,i,\"'\")\n   qq$ = \"''\"\n   i   = i + 1\nWEND\nEND FUNCTION<\/lang>\nOutput (not the complete list)\n<table border=1>\n<tr><td>abel<\/td><td>able<\/td><\/tr>\n<tr><td>able<\/td><td>abel<\/td><\/tr>\n<tr><td>aboard<\/td><td>abroad<\/td><\/tr>\n<tr><td>abode<\/td><td>adobe<\/td><\/tr>\n<tr><td>abroad<\/td><td>aboard<\/td><\/tr>\n<tr><td>adler<\/td><td>alder<\/td><\/tr>\n<tr><td>adobe<\/td><td>abode<\/td><\/tr>\n<tr><td>ail<\/td><td>ali<\/td><\/tr>\n<tr><td>aim<\/td><td>ami<\/td><\/tr>\n<tr><td>alai<\/td><td>alia<\/td><\/tr>\n<tr><td>alder<\/td><td>adler<\/td><\/tr>\n<tr><td>alert<\/td><td>alter<\/td><\/tr>\n<tr><td>alexander<\/td><td>alexandre<\/td><\/tr>\n<tr><td>alexandre<\/td><td>alexander<\/td><\/tr>\n<tr><td>ali<\/td><td>ail<\/td><\/tr>\n<tr><td>alia<\/td><td>alai<\/td><\/tr>\n<tr><td>along<\/td><td>anglo<\/td><\/tr>\n<tr><td>alter<\/td><td>alert<\/td><\/tr>\n<tr><td>altern<\/td><td>antler<\/td><\/tr>\n<tr><td>alvin<\/td><td>anvil<\/td><\/tr>\n<tr><td>ami<\/td><td>aim<\/td><\/tr>\n<tr><td>angel<\/td><td>angle<\/td><\/tr>\n<tr><td>angle<\/td><td>angel<\/td><\/tr>\n<tr><td>anglo<\/td><td>along<\/td><\/tr>\n<tr><td>annale<\/td><td>anneal<\/td><\/tr>\n<tr><td>anneal<\/td><td>annale<\/td><\/tr>\n<tr><td>antler<\/td><td>altern<\/td><\/tr>\n<tr><td>anvil<\/td><td>alvin<\/td><\/tr>\n<\/table>\n\n==[[:Category:Scala|Scala]][[Category:Scala]]==\n<lang scala>val lines = scala.io.Source.fromURL(\"http:\/\/www.puzzlers.org\/pub\/wordlists\/unixdict.txt\").getLines.map(s=>s.trim())\n\nvar map = Map[String, Set[String]]() withDefaultValue Set()\ndef hash(s:String) = new String(s.toList.sort(_<_).toArray)\nmap = lines.foldLeft(map)((map,s) => map(hash(s)) += s)\n\nval max = map.values.foldLeft(0)((a,b) => a.max(b.size))\n\nmap.values.filter(l => l.size == max).foreach{l=>l.foreach(s=>print(s+\" \")); println()}<\/lang>\nOutput:\n<pre>\nglean angel angle galen lange \nelan neal lean lane lena \nregal alger large lager glare \nable abel bela bale elba \nvile levi live evil veil \ncaret trace cater carte crate\n<\/pre>\n----\nAnother take:\n<lang scala>Source\n  .fromURL(\"http:\/\/www.puzzlers.org\/pub\/wordlists\/unixdict.txt\").getLines.toList\n  .groupBy(_.sorted).values\n  .groupBy(_.size).maxBy(_._1)._2\n  .map(_.mkString(\"\\t\"))\n  .foreach(println)<\/lang>\nPrints:\n<pre>\nabel\table\tbale\tbela\telba\nangel\tangle\tgalen\tglean\tlange\nevil\tlevi\tlive\tveil\tvile\nalger\tglare\tlager\tlarge\tregal\nelan\tlane\tlean\tlena\tneal\ncaret\tcarte\tcater\tcrate\ttrace\n<\/pre>\n\n==[[:Category:SETL|SETL]][[Category:SETL]]==\n<lang SETL>h := open('unixdict.txt', \"r\");\nanagrams := {};\nwhile not eof(h) loop\n  geta(h, word);\n  if word = om or word = \"\" then\n    continue;\n  end if;\n  sorted := insertion_sort(word);\n  anagrams{sorted} with:= word;\nend loop;\n\nmax_size := 0;\nmax_words := {};\nfor words = anagrams{sorted} loop\n  size := #words;\n  if size > max_size then\n    max_size := size;\n    max_words := {words};\n  elseif size = max_size then\n    max_words with:= words;\n  end if;\nend loop;\n\nfor w in max_words loop\n  print(w);\nend loop;\n\n-- GNU SETL has no built-in sort()\nprocedure insertion_sort(A);\n  for i in [2..#A] loop\n    v := A(i);\n    j := i-1;\n    while j >= 1 and A(j) > v loop\n      A(j+1) := A(j);\n      j := j - 1;\n    end loop;\n    A(j+1) := v; \n end loop;\n return A;\nend procedure;<\/lang>\nOutput:\n<pre>{abel able bale bela elba}\n{alger glare lager large regal}\n{angel angle galen glean lange}\n{caret carte cater crate trace}\n{elan lane lean lena neal}\n{evil levi live veil vile}<\/pre>\n\n==[[:Category:Smalltalk|Smalltalk]][[Category:Smalltalk]]==\n<lang Smalltalk>list:= (FillInTheBlank request: 'myMessageBoxTitle') subStrings: String crlf.\ndict:= Dictionary new.\nlist do: [:val| \n\t(dict at: val copy sort ifAbsent: [dict at: val copy sort put: OrderedCollection new])\n\t\tadd: val.\n\t].\nsorted:=dict asSortedCollection: [:a :b| a size > b size].<\/lang>\nDocumentation:\n<pre>\nFirst ask the user for the list.\nThen create an empty dictionary (a Map). Which maps strings as keys to OrderedCollections as values.\nFor each entry in the list add an entry to the OrderedCollection under the key of the sorted string \n(and create a new empty OC if there was no previous entry).\nThen create a SortedCollection sorting by comparing the sizes of the OrderedCollections.\nThe first 6 entries are:\nan OrderedCollection('evil' 'levi' 'live' 'veil' 'vile') \nan OrderedCollection('angel' 'angle' 'galen' 'glean' 'lange') \nan OrderedCollection('alger' 'glare' 'lager' 'large' 'regal') \nan OrderedCollection('caret' 'carte' 'cater' 'crate' 'trace') \nan OrderedCollection('abel' 'able' 'bale' 'bela' 'elba') \nan OrderedCollection('elan' 'lane' 'lean' 'lena' 'neal')\n<\/pre>\n\n==[[:Category:SNOBOL4|SNOBOL4]][[Category:SNOBOL4]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Macro Spitbol]][[SMW::on]]<\/div>\nNote: unixdict.txt is passed in locally via STDIN. Newlines must be converted for Win\/DOS environment.\n<lang SNOBOL4>*       # Sort letters of word        \n        define('sortw(str)a,i,j') :(sortw_end)\nsortw   a = array(size(str))\nsw1     i = i + 1; str len(1) . a<i> = :s(sw1)\n        a = sort(a)\nsw2     j = j + 1; sortw = sortw a<j> :s(sw2)f(return)\nsortw_end        \n\n*       # Count words in string\n        define('countw(str)') :(countw_end)\ncountw  str break(' ') span(' ') = :f(return)\n        countw = countw + 1 :(countw)\ncountw_end        \n\n        ana = table()\nL1      wrd = input :f(L2) ;* unixdict.txt from stdin\n        sw = sortw(wrd); ana<sw> = ana<sw> wrd ' '\n        cw = countw(ana<sw>); max = gt(cw,max) cw\n        i = i + 1; terminal = eq(remdr(i,1000),0) wrd :(L1)\nL2      kv = convert(ana,'array')\nL3      j = j + 1; key = kv<j,1>; val = kv<j,2> :f(end)\n        output = eq(countw(val),max) key ': ' val :(L3)\nend<\/lang>       \nOutput:\n<pre>abel: abel able bale bela elba \naeglr: alger glare lager large regal \naegln: angel angle galen glean lange \nacert: caret carte cater crate trace \naeln: elan lane lean lena neal \neilv: evil levi live veil vile<\/pre>\n\n==[[:Category:Tcl|Tcl]][[Category:Tcl]]==\n<lang tcl>package require Tcl 8.5\npackage require http\n\nset url http:\/\/www.puzzlers.org\/pub\/wordlists\/unixdict.txt\nset response [http::geturl $url]\nset data [http::data $response]\nhttp::cleanup $response\n\nset max 0\narray set anagrams {}\n\nforeach line [split $data \\n] {\n    foreach word [split $line] {\n        set anagram [join [lsort [split $word \"\"]] \"\"]\n        lappend anagrams($anagram) $word\n        set max [::tcl::mathfunc::max $max [llength $anagrams($anagram)]]\n    }\n}\n\nforeach key [array names anagrams] {\n    if {[llength $anagrams($key)] == $max} {\n        puts $anagrams($key)\n    }\n}<\/lang>\nOutputs:\n<pre>evil levi live veil vile\ncaret carte cater crate trace\nabel able bale bela elba\nelan lane lean lena neal\nangel angle galen glean lange\nalger glare lager large regal<\/pre>\n\n==[[:Category:TUSCRIPT|TUSCRIPT]][[Category:TUSCRIPT]]==\n<lang tuscript>$$ MODE TUSCRIPT,{}\nrequestdata = REQUEST (\"http:\/\/www.puzzlers.org\/pub\/wordlists\/unixdict.txt\")\n\nDICT anagramm CREATE 99999\n\nCOMPILE\n LOOP word=requestdata\n  -> ? : any character\n  charsInWord=STRINGS (word,\" ? \")\n  charString =ALPHA_SORT (charsInWord)\n  DICT anagramm APPEND\/QUIET\/COUNT charString,num,freq,word;\" \"\n ENDLOOP\n\nDICT anagramm UNLOAD charString,all,freq,anagrams\n\nindex        =DIGIT_INDEX (freq)\nreverseIndex =REVERSE (index)\nfreq         =INDEX_SORT (freq,reverseIndex)\nanagrams     =INDEX_SORT (anagrams,reverseIndex)\ncharString   =INDEX_SORT (charString,reverseIndex)\n\nmostWords=SELECT (freq,1), adjust=MAX_LENGTH (charString)\n LOOP cs=charString, f=freq, a=anagrams\n  IF (f<mostWords) EXIT\n   cs=CENTER (cs,-adjust)\n   PRINT cs,\" \",f,\": \",a\n ENDLOOP\nENDCOMPILE<\/lang>\nOutput:\n<pre>\ne'i'l'v                                     5: evil levi live veil vile\na'e'l'n                                     5: elan lane lean lena neal\na'c'e'r't                                   5: caret carte cater crate trace\na'e'g'l'n                                   5: angel angle galen glean lange\na'e'g'l'r                                   5: alger glare lager large regal\na'b'e'l                                     5: abel able bale bela elba\n<\/pre>\n\n==[[:Category:Ursala|Ursala]][[Category:Ursala]]==\nSupplying the input file on the command line during compilation makes\nits contents accessible as a pre-declared identifier. The algorithm\nis to group the words together that are made from the same unordered lists of letters,\nthen collect the groups together that have the same number of words in\nthem, and then show the collection associated with the highest number.\n<lang Ursala>#import std\n\n#show+\n\nanagrams = mat` * leql$^&h eql|=@rK2tFlSS ^(~&,-<&)* unixdict_dot_txt<\/lang>\noutput:\n<pre>\nevil levi live veil vile\ncaret carte cater crate trace\nalger glare lager large regal\nelan lane lean lena neal\nangel angle galen glean lange\nabel able bale bela elba<\/pre>\n\n==[[:Category:Vedit macro language|Vedit macro language]][[Category:Vedit macro language]]==\nThis implementation first sorts characters of each word using Insertion sort in subroutine SORT_LETTERS.<br>\nThen the word list is sorted using built-in Sort function.<br>\nFinally, groups of words are analyzed and largest groups are recorded.\n\nThe word list is expected to be in the same directory as the script.\n<lang vedit>File_Open(\"|(PATH_ONLY)\\unixdict.txt\")\n\nRepeat(ALL) {\n    Reg_Copy_Block(10, CP, EOL_Pos)     \/\/ original word\n    Call(\"SORT_LETTERS\")                \/\/ sort letters of the word\n    EOL\n    IC(' ') Reg_Ins(10)                 \/\/ add the original word at eol\n    Line(1, ERRBREAK)\n}\n\nSort(0, File_Size)                      \/\/ sort list according to anagrams\n\nBOF\nSearch(\"|F\") Search(' ')                \/\/ first word in the list\nReg_Copy_Block(10, BOL_Pos, CP+1)       \/\/ reg 10 = sorted anagram word\nReg_Copy_Block(11, CP, EOL_Pos)         \/\/ reg 11 = list of words in current group\nReg_Empty(12)                           \/\/ reg 12 = list of words in largest groups\nReg_Set(13, \"\n\")\n#1 = 1                                  \/\/ words in this group\n#2 = 2                                  \/\/ words in largest group found\nRepeat(ALL) {\n    Line(1, ERRBREAK)\n    if (Match(@10, ADVANCE) == 0) {     \/\/ same group as previous word?\n        Reg_Copy_Block(11, CP-1, EOL_Pos, APPEND)  \/\/ add word to this group\n        #1++\n    } else {                            \/\/ different anagram group\n        Search(\" \", ERRBREAK)\n        if (#1 == #2) {                 \/\/ same size as the largest?\n            Reg_Set(12, @13, APPEND)    \/\/ append newline\n            Reg_Set(12, @11, APPEND)    \/\/ append word list\n        }\n        if (#1 > #2) {                  \/\/ new larger size of group\n            Reg_Set(12, @11)            \/\/ replace word list\n            #2 = #1\n        }\n        Reg_Copy_Block(10, BOL_Pos, CP+1)\n        Reg_Copy_Block(11, CP, EOL_Pos) \/\/ first word of new group\n        #1 = 1\n    }\n}\n\nBuf_Quit(OK)                    \/\/ close word list file\nBuf_Switch(Buf_Free)            \/\/ output results in a new edit buffer\nReg_Ins(12)                     \/\/ display all groups of longest anagram words\nReturn\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\n\/\/ Sort characters in current line using Insertion sort\n\/\/\n:SORT_LETTERS:\nGP(EOL_pos) #9 = Cur_Col-1\nfor (#1 = 2; #1 <= #9; #1++) {\n    Goto_Col(#1) #8 = Cur_Char\n    #2 = #1\n    while (#2 > 1) {\n        #7 = Cur_Char(-1)\n        if (#7 <= #8) { break }\n        Ins_Char(#7, OVERWRITE)\n        #2--\n        Goto_Col(#2)\n    }\n    Ins_Char(#8, OVERWRITE)\n}\nreturn<\/lang>\nOutput:\n abel able bale bela elba\n caret carte cater crate trace\n angel angle galen glean lange\n alger glare lager large regal\n elan lane lean lena neal\n evil levi live veil vile\n\n[[Category:PARI\/GP\/Omit]]\n\n==[[:Category:Visual Basic .NET|Visual Basic .NET]][[Category:Visual Basic .NET]]==\n<lang vbnet>Imports System.IO\nImports System.Collections.ObjectModel\n\nModule Module1\n\n  Dim sWords As New Dictionary(Of String, Collection(Of String))\n\n  Sub Main()\n\n    Dim oStream As StreamReader = Nothing\n    Dim sLines() As String = Nothing\n    Dim sSorted As String = Nothing\n    Dim iHighCount As Integer = 0\n    Dim iMaxKeyLength As Integer = 0\n    Dim sOutput As String = \"\"\n\n    oStream = New StreamReader(\"unixdict.txt\")\n    sLines = oStream.ReadToEnd.Split(New String() {vbCrLf}, StringSplitOptions.RemoveEmptyEntries)\n    oStream.Close()\n\n    For i As Integer = 0 To sLines.GetUpperBound(0)\n      sSorted = SortCharacters(sLines(i))\n\n      If Not sWords.ContainsKey(sSorted) Then sWords.Add(sSorted, New Collection(Of String))\n\n      sWords(sSorted).Add(sLines(i))\n\n      If sWords(sSorted).Count > iHighCount Then\n        iHighCount = sWords(sSorted).Count\n\n        If sSorted.Length > iMaxKeyLength Then iMaxKeyLength = sSorted.Length\n      End If\n    Next\n\n    For Each sKey As String In sWords.Keys\n      If sWords(sKey).Count = iHighCount Then\n        sOutput &= \"[\" & sKey.ToUpper & \"]\" & Space(iMaxKeyLength - sKey.Length + 1) & String.Join(\", \", sWords(sKey).ToArray()) & vbCrLf\n      End If\n    Next\n\n    Console.WriteLine(sOutput)\n    Console.ReadKey()\n\n  End Sub\n\n  Private Function SortCharacters(ByVal s As String) As String\n\n    Dim sReturn() As Char = s.ToCharArray()\n    Dim sTemp As Char = Nothing\n\n    For i As Integer = 0 To sReturn.GetUpperBound(0) - 1\n      If (sReturn(i + 1)) < (sReturn(i)) Then\n        sTemp = sReturn(i)\n        sReturn(i) = sReturn(i + 1)\n        sReturn(i + 1) = sTemp\n        i = -1\n      End If\n    Next\n\n    Return CStr(sReturn)\n\n  End Function\n\nEnd Module<\/lang>\nOutput:\n<PRE>\n[ABEL]  abel, able, bale, bela, elba\n[AEGLR] alger, glare, lager, large, regal\n[AEGLN] angel, angle, galen, glean, lange\n[ACERT] caret, carte, cater, crate, trace\n[AELN]  elan, lane, lean, lena, neal\n[EILV]  evil, levi, live, veil, vile\n<\/PRE>"}]}}}}