{"query-continue":{"search":{"gsroffset":1},"revisions":{"rvstartid":137923}},"query":{"pages":{"3050":{"pageid":3050,"ns":0,"title":"Ackermann function","revisions":[{"*":"<div class=\"infobox\" style=\"width: 2in\">[[File:Rcode-button-task-crushed.png|64px|left|alt=Task|link=Category:Solutions by Programming Task]]'''Ackermann function'''<br\/>\nYou are encouraged to [[Rosetta Code:Solve a Task|solve this task]] according to the task description, using any language you may know.[[Category:Programming Tasks]][[Category:Recursion]]<\/div>[[Category:Memoization]][[Category:Classic CS problems and programs]]The '''[[wp:Ackermann function|Ackermann function]]''' is a classic recursive example in computer science. It is a function that grows very quickly (in its value and in the size of its call tree). It is defined as follows:\n\n:<math> A(m, n) =\n \\begin{cases}\n n+1 & \\mbox{if } m = 0 \\\\\n A(m-1, 1) & \\mbox{if } m > 0 \\mbox{ and } n = 0 \\\\\n A(m-1, A(m, n-1)) & \\mbox{if } m > 0 \\mbox{ and } n > 0.\n \\end{cases}\n<\/math>\n\nIts arguments are never negative and it always terminates. Write a function which returns the value of <math>A(m, n)<\/math>. Arbitrary precision is preferred (since the function grows so quickly), but not required.\n\n==[[:Category:ABAP|ABAP]][[Category:ABAP]]==\n{| class=\"messagebox\" style=\"text-align: center; background-color: #ffc8c8; clear: both;\"\n| This example is '''incorrect'''.  the four Ackermann values shown are incorrect.  Please fix the code and remove this message.\n|}[[Category:ABAP examples needing attention]][[Category:Examples needing attention]]\n\n<lang ABAP>report z_ackermann\ndata: lv_local type i,\n      lv_y type i,\n      lv_x type i.\n\ndo 7 times.\n  lv_y = sy-index - 1.\n  do 5 times.\n    lv_x = sy-index - 1.\n    perform ackermann using lv_y lv_x changing lv_local.\n    write : \/ 'A(', (1) lv_x, ',', (1) lv_y, ') = ', (4) lv_local left-justified.\n  enddo.\nenddo.\n\nform ackermann using iv_x type i iv_y type i changing ev_out type i.\n  data: lv_x type i,\n        lv_y type i.\n\n  if iv_x is initial.\n    ev_out = iv_y + 1.\n    return.\n  endif.\n\n  lv_x = iv_x - 1.\n\n  if iv_y is initial.\n    perform ackermann using lv_x 1 changing ev_out.\n    return.\n  endif.\n\n  lv_y = iv_y - 1.\n\n  perform ackermann using iv_x lv_y changing lv_y.\n  perform ackermann using lv_x lv_y changing ev_out.\nendform.<\/lang>\n<div>\n;Output excerpt<nowiki>:<\/nowiki><\/div>\n<pre>\nA( 0 , 3 ) =  5\nA( 1 , 3 ) =  13\nA( 2 , 3 ) =  29\nA( 3 , 3 ) =  61\nA( 4 , 3 ) =  125<\/pre>\n\n==[[:Category:ActionScript|ActionScript]][[Category:ActionScript]]==\n<lang actionscript>public function ackermann(m:uint, n:uint):uint\n{\n    if (m == 0)\n    {\n        return n + 1;\n    }\n    if (n == 0)\n    {\n        return ackermann(m - 1, 1);\n    }\t\t\n\n    return ackermann(m - 1, ackermann(m, n - 1));\n}<\/lang>\n\n==[[:Category:Ada|Ada]][[Category:Ada]]==\n<lang ada>with Ada.Text_IO;  use Ada.Text_IO;\n\nprocedure Test_Ackermann is\n   function Ackermann (M, N : Natural) return Natural is\n   begin\n      if M = 0 then\n         return N + 1;\n      elsif N = 0 then\n         return Ackermann (M - 1, 1);\n      else\n         return Ackermann (M - 1, Ackermann (M, N - 1));\n      end if;\n   end Ackermann;\nbegin\n   for M in 0..3 loop\n      for N in 0..6 loop\n         Put (Natural'Image (Ackermann (M, N)));\n      end loop;\n      New_Line;\n   end loop;\nend Test_Ackermann;<\/lang>\nThe implementation does not care about arbitrary precision numbers because the Ackermann function does not only grow, but also slow quickly, when computed recursively. The example outputs first 4x7 Ackermann's numbers:\n<pre> 1 2 3 4 5 6 7\n 2 3 4 5 6 7 8\n 3 5 7 9 11 13 15\n 5 13 29 61 125 253 509<\/pre>\n\n==[[:Category:ALGOL 68|ALGOL 68]][[Category:ALGOL 68]]==\n<div class=\"examplemeta translation\">'''Translation of''': [[Ackermann function#Ada|Ada]]<\/div>\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[ALGOL 68]] version Standard - no extensions to language used[[SMW::on]]<\/div>\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[ALGOL 68G]] version Any - tested with release mk15-0.8b.fc9.i386[[SMW::on]]<\/div> \n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[ELLA ALGOL 68]] version Any (with appropriate job cards) - tested with release 1.8.8d.fc9.i386[[SMW::on]]<\/div>\n<lang algol68>PROC test ackermann = VOID: \nBEGIN\n   PROC ackermann = (INT m, n)INT:\n   BEGIN\n      IF m = 0 THEN\n         n + 1\n      ELIF n = 0 THEN\n         ackermann (m - 1, 1)\n      ELSE\n         ackermann (m - 1, ackermann (m, n - 1))\n      FI\n   END # ackermann #;\n\n   FOR m FROM 0 TO 3 DO\n      FOR n FROM 0 TO 6 DO\n         print(ackermann (m, n))\n      OD;\n      new line(stand out)\n   OD\nEND # test ackermann #;\ntest ackermann<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div><pre>\n         +1         +2         +3         +4         +5         +6         +7\n         +2         +3         +4         +5         +6         +7         +8\n         +3         +5         +7         +9        +11        +13        +15\n         +5        +13        +29        +61       +125       +253       +509<\/pre>\n\n==[[:Category:APL|APL]][[Category:APL]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Dyalog APL]][[SMW::on]]<\/div>\n<lang APL>ackermann\u2190{\n     0=1\u2283\u2375:1+2\u2283\u2375\n     0=2\u2283\u2375:\u2207(\u00af1+1\u2283\u2375)1\n     \u2207(\u00af1+1\u2283\u2375),\u2207(1\u2283\u2375),\u00af1+2\u2283\u2375\n }<\/lang>\n\n==[[:Category:ATS|ATS]][[Category:ATS]]==\n<lang ATS>fun ackermann\n  {m,n:nat} .<m,n>.\n  (m: int m, n: int n): Nat =\n  case+ (m, n) of\n  | (0, _) => n+1\n  | (_, 0) =>> ackermann (m-1, 1)\n  | (_, _) =>> ackermann (m-1, ackermann (m, n-1))\n\/\/ end of [ackermann]<\/lang>\n\n==[[:Category:Argile|Argile]][[Category:Argile]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Argile]] version 1.0.0[[SMW::on]]<\/div>\n<lang Argile>use std\n\nfor each (val nat n) from 0 to 6\n  for each (val nat m) from 0 to 3\n    print \"A(\"m\",\"n\") = \"(A m n)\n\n.:A <nat m, nat n>:. -> nat\n  return (n+1)\t\t\t\tif m == 0\n  return (A (m - 1) 1)\t\t\tif n == 0\n  A (m - 1) (A m (n - 1))<\/lang>\n\n==[[:Category:AutoHotkey|AutoHotkey]][[Category:AutoHotkey]]==\n<lang AutoHotkey>A(m, n) {\n  If (m > 0) && (n = 0)\n    Return A(m-1,1)\n  Else If (m > 0) && (n > 0)\n    Return A(m-1,A(m, n-1))\n  Else If (m=0)\n    Return n+1\n}\n\n; Example:\nMsgBox, % \"A(1,2) = \" A(1,2)<\/lang>\n\n==[[:Category:AWK|AWK]][[Category:AWK]]==\n<lang awk>function ackermann(m, n) \n{\n  if ( m == 0 ) { \n    return n+1\n  }\n  if ( n == 0 ) { \n    return ackermann(m-1, 1)\n  }\n  return ackermann(m-1, ackermann(m, n-1))\n}\n\nBEGIN {\n  for(n=0; n < 7; n++) {\n    for(m=0; m < 4; m++) {\n      print \"A(\" m \",\" n \") = \" ackermann(m,n)\n    }\n  }\n}<\/lang>\n\n==[[:Category:Babel|Babel]][[Category:Babel]]==\n<lang babel>main: \n        {((0 0) (0 1) (0 2)\n        (0 3) (0 4) (1 0)\n        (1 1) (1 2) (1 3)\n        (1 4) (2 0) (2 1)\n        (2 2) (2 3) (3 0)\n        (3 1) (3 2) (4 0)) \n    \n        { dup\n        \"A(\" << { %d \" \" . << } ... \") = \" <<\n    reverse give \n    ack \n    %d cr << } ... }\n\nack!: \n    { dup zero?\n        { <-> dup zero?\n            { <-> \n                cp\n                1 -\n                <- <- 1 - ->\n                ack -> \n                ack }\n            { <->\n                1 - \n                <- 1 -> \n                ack }\n        if }\n        { zap 1 + }\n    if }\n\nzero?!: { 0 = }\n\nOutput:\n\nA(0 0 ) = 1\nA(0 1 ) = 2\nA(0 2 ) = 3\nA(0 3 ) = 4\nA(0 4 ) = 5\nA(1 0 ) = 2\nA(1 1 ) = 3\nA(1 2 ) = 4\nA(1 3 ) = 5\nA(1 4 ) = 6\nA(2 0 ) = 3\nA(2 1 ) = 5\nA(2 2 ) = 7\nA(2 3 ) = 9\nA(3 0 ) = 5\nA(3 1 ) = 13\nA(3 2 ) = 29\nA(4 0 ) = 13<\/lang>\n\n==[[:Category:BASIC|BASIC]][[Category:BASIC]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[QuickBasic]] version 4.5[[SMW::on]]<\/div>\nBASIC runs out of stack space very quickly. The call <tt>ack(3, 4)<\/tt> gives a stack error.\n<lang qbasic>DECLARE FUNCTION ack! (m!, n!)\n\nFUNCTION ack (m!, n!)\n       IF m = 0 THEN ack = n + 1\n\n       IF m > 0 AND n = 0 THEN\n               ack = ack(m - 1, 1)\n       END IF\n       IF m > 0 AND n > 0 THEN\n               ack = ack(m - 1, ack(m, n - 1))\n       END IF\nEND FUNCTION<\/lang>\n\n==[[:Category:Batch File|Batch File]][[Category:Batch File]]==\nHad trouble with this, so called in the gurus at [http:\/\/stackoverflow.com\/questions\/2680668\/what-is-wrong-with-this-recursive-windows-cmd-script-it-wont-do-ackermann-prope StackOverflow]. Thanks to Patrick Cuff for pointing out where I was going wrong.\n<lang dos>::Ackermann.cmd\n@echo off\nset depth=0\n:ack\nif %1==0 goto m0\nif %2==0 goto n0\n\n:else\nset \/a n=%2-1\nset \/a depth+=1\ncall :ack %1 %n%\nset t=%errorlevel%\nset \/a depth-=1\nset \/a m=%1-1\nset \/a depth+=1\ncall :ack %m% %t%\nset t=%errorlevel%\nset \/a depth-=1\nif %depth%==0 ( exit %t% ) else ( exit \/b %t% )\n\n:m0\nset\/a n=%2+1\nif %depth%==0 ( exit %n% ) else ( exit \/b %n% )\n\n:n0\nset \/a m=%1-1\nset \/a depth+=1\ncall :ack %m% 1\nset t=%errorlevel%\nset \/a depth-=1\nif %depth%==0 ( exit %t% ) else ( exit \/b %t% )<\/lang>\nBecause of the <code>exit<\/code> statements, running this bare closes one's shell, so this test routine handles the calling of Ackermann.cmd\n<lang dos>::Ack.cmd\n@echo off\ncmd\/c ackermann.cmd %1 %2\necho Ackermann(%1, %2)=%errorlevel%<\/lang>\nA few test runs:\n<pre>D:\\Documents and Settings\\Bruce>ack 0 4\nAckermann(0, 4)=5\n\nD:\\Documents and Settings\\Bruce>ack 1 4\nAckermann(1, 4)=6\n\nD:\\Documents and Settings\\Bruce>ack 2 4\nAckermann(2, 4)=11\n\nD:\\Documents and Settings\\Bruce>ack 3 4\nAckermann(3, 4)=125<\/pre>\n\n==[[:Category:BBC BASIC|BBC BASIC]][[Category:BBC BASIC]]==\n<lang bbcbasic>      PRINT FNackermann(3, 7)\n      END\n      \n      DEF FNackermann(M%, N%)\n      IF M% = 0 THEN = N% + 1\n      IF N% = 0 THEN = FNackermann(M% - 1, 1)\n      = FNackermann(M% - 1, FNackermann(M%, N%-1))<\/lang>\n\n==[[:Category:bc|bc]][[Category:bc]]==\nRequires a <tt>bc<\/tt> that supports long names and the <tt>print<\/tt> statement.\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[OpenBSD bc]][[SMW::on]]<\/div>\n<lang bc>define ack(m, n) {\n   if ( m == 0 ) return (n+1);\n   if ( n == 0 ) return (ack(m-1, 1));\n   return (ack(m-1, ack(m, n-1)));\n}\n\nfor (n=0; n<7; n++) {\n  for (m=0; m<4; m++) {\n     print \"A(\", m, \",\", n, \") = \", ack(m,n), \"\\n\"; \n  }\n}\nquit<\/lang>\n\n==[[:Category:BCPL|BCPL]][[Category:BCPL]]==\n<lang BCPL>GET \"libhdr\"\n\nLET ack(m, n) = m=0 -> n+1,\n                n=0 -> ack(m-1, 1),\n                ack(m-1, ack(m, n-1))\n\nLET start() = VALOF\n{ FOR i = 0 TO 6 FOR m = 0 TO 3 DO\n    writef(\"ack(%n, %n) = %n*n\", m, n, ack(m,n))\n  RESULTIS 0\n}<\/lang>\n\n==[[:Category:Befunge|Befunge]][[Category:Befunge]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[CCBI]] version 2.1[[SMW::on]]<\/div>\n<lang befunge>r[1&&{0\n>v\n j\nu>.@ \n1>  \\:v\n^  v:\\_$1+\n\\^v_$1\\1-\nu^>1-0fp:1-\\0fg101-<\/lang>\nThe program reads two integers (first m, then n) from command line, idles around funge space, then outputs the result of the Ackerman function. Since the latter is calculated truly recursively, the execution time becomes unwieldy for most m>3.\n\n==[[:Category:Bracmat|Bracmat]][[Category:Bracmat]]==\nThree solutions are presented here. The first one is a purely recursive version, only using the formulas at the top of the page. The value of A(4,1) cannot be computed due to stack overflow. It can compute A(3,9) (4093), but probably not A(3,10)\n<lang bracmat>( Ack\n=   m n\n  .   !arg:(?m,?n)\n    & ( !m:0&!n+1\n      | !n:0&Ack$(!m+-1,1)\n      | Ack$(!m+-1,Ack$(!m,!n+-1))\n      )\n);<\/lang>\nThe second version is a purely non-recursive solution that easily can compute A(4,1). The program uses a stack for Ackermann function calls that are to be evaluated, but that cannot be computed given the currently known function values - the \"known unknowns\". The currently known values are stored in a hash table. The Hash table also contains incomplete Ackermann function calls, namely those for which the second argument is not known yet - \"the unknown unknowns\". These function calls are associated with \"known unknowns\" that are going to provide the value of the second argument. As soon as such an associated known unknown becomes known, the unknown unknown becomes a known unknown and is pushed onto the stack.\n\nAlthough all known values are stored in the hash table, the converse is not true: an element in the hash table is either a \"known known\" or an \"unknown unknown\" associated with an \"known unknown\".\n<lang bracmat>  ( A\n  =     m n value key eq chain\n      , find insert future stack va val\n    .   ( chain\n        =   key future skey\n          .   !arg:(?key.?future)\n            & str$!key:?skey\n            & (cache..insert)$(!skey..!future)\n            & \n        )\n      & (find=.(cache..find)$(str$!arg))\n      & ( insert\n        =   key value future v futureeq futurem skey\n          .   !arg:(?key.?value)\n            & str$!key:?skey\n            & (   (cache..find)$!skey:(?key.?v.?future)\n                & (cache..remove)$!skey\n                & (cache..insert)$(!skey.!value.)\n                & (   !future:(?futurem.?futureeq)\n                    & (!futurem,!value.!futureeq)\n                  | \n                  )\n              | (cache..insert)$(!skey.!value.)&\n              )\n        )\n      & !arg:(?m,?n)\n      & !n+1:?value\n      & :?eq:?stack\n      &   whl\n        ' ( (!m,!n):?key\n          &     (   find$!key:(?.#%?value.?future)\n                  & insert$(!eq.!value) !future\n                |   !m:0\n                  & !n+1:?value\n                  & ( !eq:&insert$(!key.!value)\n                    |   insert$(!key.!value) !stack:?stack\n                      & insert$(!eq.!value)\n                    )\n                |   !n:0\n                  &   (!m+-1,1.!key)\n                      (!eq:|(!key.!eq))\n                |   find$(!m,!n+-1):(?.?val.?)\n                  & (   !val:#%\n                      & (   find$(!m+-1,!val):(?.?va.?)\n                          & !va:#%\n                          & insert$(!key.!va)\n                        |   (!m+-1,!val.!eq)\n                            (!m,!n.!eq)\n                        )\n                    | \n                    )\n                |   chain$(!m,!n+-1.!m+-1.!key)\n                  &   (!m,!n+-1.)\n                      (!eq:|(!key.!eq))\n                )\n                !stack\n            : (?m,?n.?eq) ?stack\n          )\n      & !value\n  )\n& new$hash:?cache<\/lang>\n<div>\n;Some results<nowiki>:<\/nowiki><\/div>\n<pre>\nA$(0,0):1\nA$(3,13):65533\nA$(3,14):131069\nA$(4,1):65533\n<\/pre>\nThe last solution is a recursive solution that employs some extra formulas, inspired by the Common Lisp solution further down.\n<lang bracmat>( AckFormula\n=   m n\n  .   !arg:(?m,?n)\n    & ( !m:0&!n+1\n      | !m:1&!n+2\n      | !m:2&2*!n+3\n      | !m:3&2^(!n+3)+-3\n      | !n:0&AckFormula$(!m+-1,1)\n      | AckFormula$(!m+-1,AckFormula$(!m,!n+-1))\n      )\n)<\/lang>\n[[:Template:Some results]]\n<pre>AckFormula$(4,1):65533\nAckFormula$(4,2):2003529930406846464979072351560255750447825475569751419265016973.....22087777506072339445587895905719156733\n<\/pre>\nThe last computation costs about 0,03 seconds.\n\n==[[:Category:Brat|Brat]][[Category:Brat]]==\n<lang brat>ackermann = { m, n |\n\twhen { m == 0 } { n + 1 }\n\t\t{ m > 0 && n == 0 } { ackermann(m - 1, 1) }\n\t\t{ m > 0 && n > 0 } { ackermann(m - 1, ackermann(m, n - 1)) }\n}\n\np ackermann 3, 4  #Prints 125<\/lang>\n\n==[[:Category:C|C]][[Category:C]]==\nStraightforward implementation per Ackermann definition:\n<lang C>#include <stdio.h>\n\nint ackermann(int m, int n)\n{\n        if (!m) return n + 1;\n        if (!n) return ackermann(m - 1, 1);\n        return ackermann(m - 1, ackermann(m, n - 1));\n}\n\nint main()\n{\n        int m, n;\n        for (m = 0; m <= 4; m++)\n                for (n = 0; n < 6 - m; n++)\n                        printf(\"A(%d, %d) = %d\\n\", m, n, ackermann(m, n));\n\n        return 0;\n}<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>A(0, 0) = 1\nA(0, 1) = 2\nA(0, 2) = 3\nA(0, 3) = 4\nA(0, 4) = 5\nA(0, 5) = 6\nA(1, 0) = 2\nA(1, 1) = 3\nA(1, 2) = 4\nA(1, 3) = 5\nA(1, 4) = 6\nA(2, 0) = 3\nA(2, 1) = 5\nA(2, 2) = 7\nA(2, 3) = 9\nA(3, 0) = 5\nA(3, 1) = 13\nA(3, 2) = 29\nA(4, 0) = 13\n<program chokes at this point><\/pre>\nAckermann function makes <i>a lot<\/i> of recursive calls, so the above program is a bit naive.  We need to be slightly less naive, by doing some simple caching:\n<lang C>#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint m_bits, n_bits;\nint *cache;\n\nint ackermann(int m, int n)\n{\n        int idx, res;\n        if (!m) return n + 1;\n\n        if (n >= 1<<n_bits) {\n                printf(\"%d, %d\\n\", m, n);\n                idx = 0;\n        } else {\n                idx = (m << n_bits) + n;\n                if (cache[idx]) return cache[idx];\n        }\n\n        if (!n) res = ackermann(m - 1, 1);\n        else    res = ackermann(m - 1, ackermann(m, n - 1));\n\n        if (idx) cache[idx] = res;\n        return res;\n}\nint main()\n{\n        int m, n;\n\n        m_bits = 3;\n        n_bits = 20;  \/* can save n values up to 2**20 - 1, that's 1 meg *\/\n        cache = malloc(sizeof(int) * (1 << (m_bits + n_bits)));\n        memset(cache, 0, sizeof(int) * (1 << (m_bits + n_bits)));\n\n        for (m = 0; m <= 4; m++)\n                for (n = 0; n < 6 - m; n++) {\n                        printf(\"A(%d, %d) = %d\\n\", m, n, ackermann(m, n));\n\n        return 0;\n}<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>A(0, 0) = 1\nA(0, 1) = 2\nA(0, 2) = 3\nA(0, 3) = 4\nA(0, 4) = 5\nA(0, 5) = 6\nA(1, 0) = 2\nA(1, 1) = 3\nA(1, 2) = 4\nA(1, 3) = 5\nA(1, 4) = 6\nA(2, 0) = 3\nA(2, 1) = 5\nA(2, 2) = 7\nA(2, 3) = 9\nA(3, 0) = 5\nA(3, 1) = 13\nA(3, 2) = 29\nA(4, 0) = 13\nA(4, 1) = 65533<\/pre>\nWhee.  Well, with some extra work, we calculated <i>one more<\/i> n value, big deal, right?\nBut see, <code>A(4, 2) = A(3, A(4, 1)) = A(3, 65533) = A(2, A(3, 65532)) = ...<\/code> you can see how fast it blows up.  In fact, no amount of caching will help you calculate large m values;  on the machine I use A(4, 2) segfaults because the recursions run out of stack space--not a whole lot I can do about it.  At least it runs out of stack space <i>quickly<\/i>, unlike the first solution...\n\n==<span id=\"C sharp\">[[:Category:C sharp|C#]]<\/span>[[Category:C sharp]]==\n<lang csharp>using System;\nclass Program\n{\n    public static long Ackermann(long m, long n)\n    {\n        if(m > 0)\n        {\n            if (n > 0)\n                return Ackermann(m - 1, Ackermann(m, n - 1));\n            else if (n == 0)\n                return Ackermann(m - 1, 1);\n        }\n        else if(m == 0)\n        {\n            if(n >= 0) \n                return n + 1;\n        }\n\n        throw new System.ArgumentOutOfRangeException();\n    }\n    \n    static void Main()\n    {\n        for (long m = 0; m <= 3; ++m)\n        {\n            for (long n = 0; n <= 4; ++n)\n            {\n                Console.WriteLine(\"Ackermann({0}, {1}) = {2}\", m, n, Ackermann(m, n));\n            }\n        }\n    }\n}<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>\nAckermann(0, 0) = 1\nAckermann(0, 1) = 2\nAckermann(0, 2) = 3\nAckermann(0, 3) = 4\nAckermann(0, 4) = 5\nAckermann(1, 0) = 2\nAckermann(1, 1) = 3\nAckermann(1, 2) = 4\nAckermann(1, 3) = 5\nAckermann(1, 4) = 6\nAckermann(2, 0) = 3\nAckermann(2, 1) = 5\nAckermann(2, 2) = 7\nAckermann(2, 3) = 9\nAckermann(2, 4) = 11\nAckermann(3, 0) = 5\nAckermann(3, 1) = 13\nAckermann(3, 2) = 29\nAckermann(3, 3) = 61\nAckermann(3, 4) = 125\n<\/pre>\n\n==[[:Category:C++|C++]][[Category:C++]]==\n<lang cpp>#include <iostream>\nusing namespace std;\nlong ackermann(long x, long y)\n{    \n     if (x == 0)        return y+1;    \n     else if (y == 0)        return ackermann(x-1, 1);    \n     else return ackermann(x-1, ackermann(x, y-1));\n} \n\nint main() \n{\n        long x,y;\n        cout << \"x ve y..:\";\n        cin>>x;\n        cin>>y;\n        cout<<ackermann(x,y);\n        system(\"pause\");\n        return 0;\n}<\/lang>\n\n==[[:Category:Clay|Clay]][[Category:Clay]]==\n<lang Clay>ackermann(m, n) {\n    if(m == 0)\n      return n + 1;\n    if(n == 0)\n      return ackermann(m - 1, 1);\n\n    return ackermann(m - 1, ackermann(m, n - 1));\n}<\/lang>\n\n==[[:Category:CLIPS|CLIPS]][[Category:CLIPS]]==\n'''Functional solution'''\n<lang clips>(deffunction ackerman\n  (?m ?n)\n  (if (= 0 ?m)\n    then (+ ?n 1)\n    else (if (= 0 ?n)\n      then (ackerman (- ?m 1) 1)\n      else (ackerman (- ?m 1) (ackerman ?m (- ?n 1)))\n    )\n  )\n)<\/lang>\n<div>\n;Example usage<nowiki>:<\/nowiki><\/div>\n<pre>CLIPS> (ackerman 0 4)\n5\nCLIPS> (ackerman 1 4)\n6\nCLIPS> (ackerman 2 4)\n11\nCLIPS> (ackerman 3 4)\n125\n<\/pre>\n'''Fact-based solution'''\n<lang clips>(deffacts solve-items\n  (solve 0 4)\n  (solve 1 4)\n  (solve 2 4)\n  (solve 3 4)\n)\n\n(defrule acker-m-0\n  ?compute <- (compute 0 ?n)\n  =>\n  (retract ?compute)\n  (assert (ackerman 0 ?n (+ ?n 1)))\n)\n\n(defrule acker-n-0-pre\n  (compute ?m&:(> ?m 0) 0)\n  (not (ackerman =(- ?m 1) 1 ?))\n  =>\n  (assert (compute (- ?m 1) 1))\n)\n\n(defrule acker-n-0\n  ?compute <- (compute ?m&:(> ?m 0) 0)\n  (ackerman =(- ?m 1) 1 ?val)\n  =>\n  (retract ?compute)\n  (assert (ackerman ?m 0 ?val))\n)\n\n(defrule acker-m-n-pre-1\n  (compute ?m&:(> ?m 0) ?n&:(> ?n 0))\n  (not (ackerman ?m =(- ?n 1) ?))\n  =>\n  (assert (compute ?m (- ?n 1)))\n)\n\n(defrule acker-m-n-pre-2\n  (compute ?m&:(> ?m 0) ?n&:(> ?n 0))\n  (ackerman ?m =(- ?n 1) ?newn)\n  (not (ackerman =(- ?m 1) ?newn ?))\n  =>\n  (assert (compute (- ?m 1) ?newn))\n)\n\n(defrule acker-m-n\n  ?compute <- (compute ?m&:(> ?m 0) ?n&:(> ?n 0))\n  (ackerman ?m =(- ?n 1) ?newn)\n  (ackerman =(- ?m 1) ?newn ?val)\n  =>\n  (retract ?compute)\n  (assert (ackerman ?m ?n ?val))\n)\n\n(defrule acker-solve\n  (solve ?m ?n)\n  (not (compute ?m ?n))\n  (not (ackerman ?m ?n ?))\n  =>\n  (assert (compute ?m ?n))\n)\n\n(defrule acker-solved\n  ?solve <- (solve ?m ?n)\n  (ackerman ?m ?n ?result)\n  =>\n  (retract ?solve)\n  (printout t \"A(\" ?m \",\" ?n \") = \" ?result crlf)\n)<\/lang>\nWhen invoked, each required A(m,n) needed to solve the requested (solve ?m ?n) facts gets generated as its own fact. Below shows the invocation of the above, as well as an excerpt of the final facts list. Regardless of how many input (solve ?m ?n) requests are made, each possible A(m,n) is only solved once.\n<pre>CLIPS> (reset)\nCLIPS> (facts)\nf-0     (initial-fact)\nf-1     (solve 0 4)\nf-2     (solve 1 4)\nf-3     (solve 2 4)\nf-4     (solve 3 4)\nFor a total of 5 facts.\nCLIPS> (run)\nA(3,4) = 125\nA(2,4) = 11\nA(1,4) = 6\nA(0,4) = 5\nCLIPS> (facts)\nf-0     (initial-fact)\nf-15    (ackerman 0 1 2)\nf-16    (ackerman 1 0 2)\nf-18    (ackerman 0 2 3)\n...\nf-632   (ackerman 1 123 125)\nf-633   (ackerman 2 61 125)\nf-634   (ackerman 3 4 125)\nFor a total of 316 facts.\nCLIPS><\/pre>\n\n==[[:Category:Clojure|Clojure]][[Category:Clojure]]==\n<lang clojure>(defn ackermann [m n] \n  (cond (zero? m) (inc n)\n        (zero? n) (ackermann (dec m) 1)\n        :else (ackermann (dec m) (ackermann m (dec n)))))<\/lang>\n\n==[[:Category:CoffeeScript|CoffeeScript]][[Category:CoffeeScript]]==\n<lang coffeescript>ackermann = (m, n) ->\n  if m is 0 then n + 1\n  else if m > 0 and n is 0 then ackermann m - 1, 1\n  else ackermann m - 1, ackermann m, n - 1<\/lang>\n\n==[[:Category:Common Lisp|Common Lisp]][[Category:Common Lisp]]==\n<lang lisp>(defun ackermann (m n)\n  (cond ((zerop m) (1+ n))\n        ((zerop n) (ackermann (1- m) 1))\n        (t         (ackermann (1- m) (ackermann m (1- n))))))<\/lang>\nMore elaborately:\n<lang lisp>(defun ackermann (m n)\n  (case m ((0) (1+ n))\n    ((1) (+ 2 n))\n    ((2) (+ n n 3))\n    ((3) (- (expt 2 (+ 3 n)) 3))\n    (otherwise (ackermann (1- m) (if (zerop n) 1 (ackermann m (1- n)))))))\n\n(loop for m from 0 to 4 do\n      (loop for n from (- 5 m) to (- 6 m) do\n\t    (format t \"A(~d, ~d) = ~d~%\" m n (ackermann m n))))<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div><pre>A(0, 5) = 6\nA(0, 6) = 7\nA(1, 4) = 6\nA(1, 5) = 7\nA(2, 3) = 9\nA(2, 4) = 11\nA(3, 2) = 29\nA(3, 3) = 61\nA(4, 1) = 65533\nA(4, 2) = 2003529930 <... skipping a few digits ...> 56733<\/pre>\n\n==[[:Category:D|D]][[Category:D]]==\n===Basic version===\n<lang d>ulong ackermann(in ulong m, in ulong n) pure nothrow {\n    if (m == 0)\n        return n + 1;\n    if (n == 0)\n        return ackermann(m - 1, 1);\n    return ackermann(m - 1, ackermann(m, n - 1));\n}\n\nvoid main() {\n    assert(ackermann(2, 4) == 11);\n}<\/lang>\n===More efficient version===\n<div class=\"examplemeta translation\">'''Translation of''': [[Ackermann function#Mathematica|Mathematica]]<\/div>\n<lang d>import std.stdio, std.bigint, std.conv;\n\n\/*pure nothrow*\/ BigInt ipow(\/*in*\/ BigInt base, \/*in*\/ BigInt exp){\n    auto result = BigInt(1);\n    \/\/while (exp) {\n    while (exp != 0) {\n        \/\/if (exp & 1)\n        if (exp % 2)\n            result *= base;\n        exp >>= 1;\n        base *= base;\n    }\n\n    return result;\n}\n\n\/*pure nothrow*\/ BigInt ackermann(in int m, in int n)\nin {\n    assert(m >= 0 && n >= 0);\n} out(result) {\n    \/\/assert(result >= 0);\n    assert(cast()result >= 0);\n} body {\n    \/*pure nothrow*\/ static BigInt ack(in int m, \/*in*\/ BigInt n) {\n        switch (m) {\n            case 0: return n + 1;\n            case 1: return n + 2;\n            case 2: return 3 + 2 * n;\n            \/\/case 3: return 5 + 8 * (2 ^^ n - 1);\n            case 3: return 5 + 8 * (ipow(BigInt(2), n) - 1);\n            default: if (n == 0)\n                        return ack(m - 1, BigInt(1));\n                     else\n                        return ack(m - 1, ack(m, n - 1));\n        }\n    }\n\n    return ack(m, BigInt(n));\n}\n\nvoid main() {\n    foreach (m; 1 .. 4)\n        foreach (n; 1 .. 9)\n            writefln(\"ackermann(%d, %d): %s\", m, n, ackermann(m, n));\n    writefln(\"ackermann(4, 1): %s\", ackermann(4, 1));\n\n    auto a = text(ackermann(4, 2));\n    writefln(\"ackermann(4, 2)) (%d digits):\\n%s...\\n%s\",\n             a.length, a[0 .. 94], a[$-96 .. $]);\n}<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>ackermann(1, 1): 3\nackermann(1, 2): 4\nackermann(1, 3): 5\nackermann(1, 4): 6\nackermann(1, 5): 7\nackermann(1, 6): 8\nackermann(1, 7): 9\nackermann(1, 8): 10\nackermann(2, 1): 5\nackermann(2, 2): 7\nackermann(2, 3): 9\nackermann(2, 4): 11\nackermann(2, 5): 13\nackermann(2, 6): 15\nackermann(2, 7): 17\nackermann(2, 8): 19\nackermann(3, 1): 13\nackermann(3, 2): 29\nackermann(3, 3): 61\nackermann(3, 4): 125\nackermann(3, 5): 253\nackermann(3, 6): 509\nackermann(3, 7): 1021\nackermann(3, 8): 2045\nackermann(4, 1): 65533\nackermann(4, 2)) (19729 digits):\n2003529930406846464979072351560255750447825475569751419265016973710894059556311453089506130880...\n699146577530041384717124577965048175856395072895337539755822087777506072339445587895905719156733<\/pre>\n\n==[[:Category:Dart|Dart]][[Category:Dart]]==\nno caching, the implementation takes ages even for A(4,1)\n<lang dart>int A(int m, int n) => m==0 ? n+1 : n==0 ? A(m-1,1) : A(m-1,A(m,n-1));\n\nmain() {\n  print(A(0,0));\n  print(A(1,0));\n  print(A(0,1));\n  print(A(2,2));\n  print(A(2,3));\n  print(A(3,3));\n  print(A(3,4));\n  print(A(3,5));\n  print(A(4,0));\n}<\/lang>\n\n==[[:Category:Delphi|Delphi]][[Category:Delphi]]==\n<lang delphi>function Ackermann(m,n:Int64):Int64;\nbegin\n    if m = 0 then\n        Result := n + 1\n    else if n = 0 then\n        Result := Ackermann(m-1, 1)\n    else\n        Result := Ackermann(m-1, Ackermann(m, n - 1));\nend;<\/lang>\n\n==[[:Category:DWScript|DWScript]][[Category:DWScript]]==\n<lang delphi>function Ackermann(m, n : Integer) : Integer;\nbegin\n    if m = 0 then\n        Result := n+1\n    else if n = 0 then\n        Result := Ackermann(m-1, 1)\n    else Result := Ackermann(m-1, Ackermann(m, n-1));\nend;<\/lang>\n\n==[[:Category:Dylan|Dylan]][[Category:Dylan]]==\n<lang dylan>define method ack(m == 0, n :: <integer>)\n   n + 1\nend;\ndefine method ack(m :: <integer>, n :: <integer>)\n   ack(m - 1, if (n == 0) 1 else ack(m, n - 1) end)\nend;<\/lang>\n\n==[[:Category:E|E]][[Category:E]]==\n<lang e>def A(m, n) {\n    return if (m <=> 0)          { n+1              } \\\n      else if (m > 0 && n <=> 0) { A(m-1, 1)        } \\\n      else                       { A(m-1, A(m,n-1)) }\n}<\/lang>\n\n==[[:Category:Eiffel|Eiffel]][[Category:Eiffel]]==\n<lang Eiffel>note\n\tdescription: \"Example of Ackerman function\"\n\tURI: \"http:\/\/rosettacode.org\/wiki\/Ackermann_function\"\n\nclass\n\tACKERMAN_EXAMPLE\n\ncreate\n\tmake\n\nfeature {NONE} -- Initialization\n\n\tmake\n\t\tdo\n\t\t\tprint (\"%N A(0,0):\" + ackerman (0, 0).out)\n\t\t\tprint (\"%N A(1,0):\" + ackerman (1, 0).out)\n\t\t\tprint (\"%N A(0,1):\" + ackerman (0, 1).out)\n\t\t\tprint (\"%N A(1,1):\" + ackerman (1, 1).out)\n\t\t\tprint (\"%N A(2,0):\" + ackerman (2, 0).out)\n\t\t\tprint (\"%N A(2,1):\" + ackerman (2, 1).out)\n\t\t\tprint (\"%N A(2,2):\" + ackerman (2, 2).out)\n\t\t\tprint (\"%N A(0,2):\" + ackerman (0, 2).out)\n\t\t\tprint (\"%N A(1,2):\" + ackerman (1, 2).out)\n\t\t\tprint (\"%N A(3,3):\" + ackerman (3, 3).out)\n\t\t\tprint (\"%N A(3,4):\" + ackerman (3, 4).out)\n\t\tend\n\nfeature -- Access\n\n\tackerman (m: NATURAL; n: NATURAL): NATURAL\n\t\tdo\n\t\t\tif m = 0 then\n\t\t\t\tResult := n + 1\n\t\t\telseif m > 0 and n = 0 then\n\t\t\t\tResult := ackerman (m - 1, 1)\n\t\t\telseif m > 0 and n > 0 then\n\t\t\t\tResult := ackerman (m - 1, ackerman (m, n - 1))\n\t\t\tend\n\t\tend\n\t\t\nend<\/lang>\n\n==[[:Category:Ela|Ela]][[Category:Ela]]==\n<lang ela>let ack 0 n = n+1\n    ack m 0 = ack (m-1) 1\n    ack m n = ack (m-1) <| ack m <| n-1<\/lang>\n\n==[[:Category:Elena|Elena]][[Category:Elena]]==\n<lang elena>#define std'dictionary'*.\n#define std'patterns'*.\n#define std'basic'*.\n\n#subject a_function, m, n.\n\n\/\/ --- Ackermann function ---\n\n#symbol Ackermann =\n{\n    a_function &m:anM &n:anN\n    [\n        #if anM\n            ifequal:0 [ ^ anN + 1. ]\n            | greater:0 ?\n            [\n                #if anN\n                    ifequal:0 [ ^ self a_function &m:(anM - 1) &n:1. ]\n                    | greater:0 ? [ ^ self a_function &m:(anM - 1) &n:(self a_function &m:anM &n:(anN - 1)). ].\n            ].\n        \n        control fail.\n    ]\n}.\n\n\/\/ --- Arguments ---\n\n#class(signature:(a_function, m, n)) AckermanValue\n{\n    #field(arg:m)theM.\n    \n    #field(arg:n)theN.\n    \n    #method m'get = Int64Value::theM.\n    \n    #method n'get = Int64Value::theN.\n    \n    #method numeric'save : aWriter = aWriter write &:(Ackermann a_function:self).\n    \n    #method literal_writer'save : aWriter\n    [\n        aWriter << \"A(\" << theM << \",\" << theN << \")=\" << Int64Value::self.\n\n        ^ aWriter.\n    ]\n}\n\n#symbol Program =>\n[\n    loop &&for:0 &to:3 run: anM =>\n    [\n        loop &&for:0 &to:5 run: anN =>\n        [\n            'program'output << { &a_function &m:anM &n:anN } << \"%n\".\n        ].\n    ].\n    \n    'program'Input get.\n].<\/lang>\n\n==[[:Category:Erlang|Erlang]][[Category:Erlang]]==\n<lang erlang>-module(main).\n-export([main\/1]).\n \nmain( [ A | [ B |[]]]) ->\n   io:fwrite(\"~p~n\",[ack(toi(A),toi(B))]).\n \ntoi(E) -> element(1,string:to_integer(E)).\n \nack(0,N) -> N + 1;\nack(M,0) -> ack(M-1, 1);\nack(M,N) -> ack(M-1,ack(M,N-1)).<\/lang>\n\nIt can be used with \n |escript .\/ack.erl 3 4\n =125\n\n==[[:Category:Euphoria|Euphoria]][[Category:Euphoria]]==\nThis is based on the [[VBScript]] example.\n<lang Euphoria>function ack(atom m, atom n)\n    if m = 0 then \n        return n + 1\n    elsif m > 0 and n = 0 then\n        return ack(m - 1, 1)\n    else\n        return ack(m - 1, ack(m, n - 1))\n    end if\nend function\n\nfor i = 0 to 3 do\n    for j = 0 to 6 do\n        printf( 1, \"%5d\", ack( i, j ) )\n    end for\n    puts( 1, \"\\n\" )\nend for<\/lang>\n\n==<span id=\"F_Sharp\">[[:Category:F_Sharp|F#]]<\/span>[[Category:F_Sharp]]==\nThe following program implements the Ackermann function in F# but is not tail-recursive and so runs out of stack space quite fast.\n<lang fsharp>let rec ackermann m n = \n    match m, n with\n    | 0, n -> n + 1\n    | m, 0 -> ackermann (m - 1) 1\n    | m, n -> ackermann (m - 1) ackermann m (n - 1)\n\ndo\n    printfn \"%A\" (ackermann (int fsi.CommandLineArgs.[1]) (int fsi.CommandLineArgs.[2]))<\/lang>\nTransforming this into continuation passing style avoids limited stack space by permitting tail-recursion.\n<lang fsharp>let ackermann M N =\n    let rec acker (m, n, k) =\n        match m,n with\n            | 0, n -> k(n + 1)\n            | m, 0 -> acker ((m - 1), 1, k)\n            | m, n -> acker (m, (n - 1), (fun x -> acker ((m - 1), x, k)))\n    acker (M, N, (fun x -> x))<\/lang>\n\n==[[:Category:Factor|Factor]][[Category:Factor]]==\n<lang factor>USING: kernel math locals combinators ;\nIN: ackermann\n\n:: ackermann ( m n -- u ) \n    { \n        { [ m 0 = ] [ n 1 + ] } \n        { [ n 0 = ] [ m 1 - 1 ackermann ] } \n        [ m 1 - m n 1 - ackermann ackermann ] \n    } cond ;<\/lang>\n\n==[[:Category:Falcon|Falcon]][[Category:Falcon]]==\n<lang falcon>function ackermann( m, n )\n if m == 0:  return( n + 1 )\n if n == 0:  return( ackermann( m - 1, 1 ) )\n return( ackermann( m - 1, ackermann( m, n - 1 ) ) )\nend\n\nfor M in [ 0:4 ]\n for N in [ 0:7 ]\n   >> ackermann( M, N ), \" \"\n end\n >\nend<\/lang>\nThe above will output the below.  Formating options to make this pretty are available but for this example only basic output is used.\n<pre>\n1 2 3 4 5 6 7 \n2 3 4 5 6 7 8 \n3 5 7 9 11 13 15 \n5 13 29 61 125 253 509 \n<\/pre>\n\n==[[:Category:FALSE|FALSE]][[Category:FALSE]]==\n<lang false>[$$[%\n  \\$$[%\n     1-\\$@@a;!  { i j -> A(i-1, A(i, j-1)) }\n  1]?0=[\n     %1         { i 0 -> A(i-1, 1) }\n   ]?\n  \\1-a;!\n1]?0=[\n  %1+           { 0 j -> j+1 }\n ]?]a: { j i }\n\n3 3 a;! .  { 61 }<\/lang>\n\n==[[:Category:Fantom|Fantom]][[Category:Fantom]]==\n<lang fantom>class Main\n{\n  \/\/ assuming m,n are positive\n  static Int ackermann (Int m, Int n)\n  {\n    if (m == 0)\n      return n + 1\n    else if (n == 0)\n      return ackermann (m - 1, 1)\n    else\n      return ackermann (m - 1, ackermann (m, n - 1))\n  }\n\n  public static Void main ()\n  {\n    (0..3).each |m|\n    {\n      (0..6).each |n|\n      {\n        echo (\"Ackerman($m, $n) = ${ackermann(m, n)}\")\n      }\n    }\n  }\n}<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>\nAckerman(0, 0) = 1\nAckerman(0, 1) = 2\nAckerman(0, 2) = 3\nAckerman(0, 3) = 4\nAckerman(0, 4) = 5\nAckerman(0, 5) = 6\nAckerman(0, 6) = 7\nAckerman(1, 0) = 2\nAckerman(1, 1) = 3\nAckerman(1, 2) = 4\nAckerman(1, 3) = 5\nAckerman(1, 4) = 6\nAckerman(1, 5) = 7\nAckerman(1, 6) = 8\nAckerman(2, 0) = 3\nAckerman(2, 1) = 5\nAckerman(2, 2) = 7\nAckerman(2, 3) = 9\nAckerman(2, 4) = 11\nAckerman(2, 5) = 13\nAckerman(2, 6) = 15\nAckerman(3, 0) = 5\nAckerman(3, 1) = 13\nAckerman(3, 2) = 29\nAckerman(3, 3) = 61\nAckerman(3, 4) = 125\nAckerman(3, 5) = 253\nAckerman(3, 6) = 509\n<\/pre>\n\n==[[:Category:Forth|Forth]][[Category:Forth]]==\n<lang forth>: acker ( m n -- u )\n\tover 0= IF  nip 1+ EXIT  THEN\n\tswap 1- swap ( m-1 n -- )\n\tdup  0= IF  1+  recurse EXIT  THEN\n\t1- over 1+ swap recurse recurse ;<\/lang>\n<div>\n;Example of use<nowiki>:<\/nowiki><\/div>\n<pre>FORTH> 0 0 acker . 1  ok\nFORTH> 3 4 acker . 125  ok<\/pre>\n\n==[[:Category:Fortran|Fortran]][[Category:Fortran]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Fortran]] version 90 and later[[SMW::on]]<\/div>\n<lang fortran>PROGRAM EXAMPLE  \n  IMPLICIT NONE\n \n  INTEGER :: i, j\n \n  DO i = 0, 3\n    DO j = 0, 6\n       WRITE(*, \"(I10)\", ADVANCE=\"NO\") Ackermann(i, j)\n    END DO\n    WRITE(*,*)\n  END DO\n \nCONTAINS\n \n  RECURSIVE FUNCTION Ackermann(m, n) RESULT(ack)\n    INTEGER :: ack, m, n\n\n    IF (m == 0) THEN\n      ack = n + 1\n    ELSE IF (n == 0) THEN\n      ack = Ackermann(m - 1, 1)\n    ELSE\n      ack = Ackermann(m - 1, Ackermann(m, n - 1))\n    END IF\n  END FUNCTION Ackermann\n\nEND PROGRAM EXAMPLE<\/lang>\n\n==[[:Category:GAP|GAP]][[Category:GAP]]==\n<lang gap>ack := function(m, n)\n  if m = 0 then\n    return n + 1;\n  elif (m > 0) and (n = 0) then\n    return ack(m - 1, 1);\n  elif (m > 0) and (n > 0) then\n    return ack(m - 1, ack(m, n - 1));\n  else\n    return fail;\n  fi;\nend;<\/lang>\n\n==[[:Category:Genyris|Genyris]][[Category:Genyris]]==\n<lang genyris>def A (m n)\n   cond\n      (equal? m 0)\n          + n 1\n      (equal? n 0) \n          A (- m 1) 1\n      else\n          A (- m 1)\n             A m (- n 1)<\/lang>\n\n==[[:Category:GML|GML]][[Category:GML]]==\nfor a function named \"ackermann\":\n<lang GML>m=argument0\nn=argument1\nif(m=0)\n    return (n+1)\nelse if(n=0)\n    return (ackermann(m-1,1,1))\nelse\n    return (ackermann(m-1,ackermann(m,n-1,2),1))<\/lang>\n\n==[[:Category:gnuplot|gnuplot]][[Category:gnuplot]]==\n<lang gnuplot>A (m, n) = m == 0 ? n + 1 : n == 0 ? A (m - 1, 1) : A (m - 1, A (m, n - 1))\nprint A (0, 4)\nprint A (1, 4)\nprint A (2, 4)\nprint A (3, 4)<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n 5\n 6\n 11\n stack overflow\n\n==[[:Category:Go|Go]][[Category:Go]]==\nClassic version\n<lang go>func Ackermann(m, n uint) uint {\n  switch {\n    case m == 0:\n      return n + 1\n    case n == 0:\n      return Ackermann(m - 1, 1)\n  }\n  return Ackermann(m - 1, Ackermann(m, n - 1))\n}<\/lang>\nExpanded version\n<lang go>func Ackermann2(m, n uint) uint {\n  switch {\n    case m == 0:\n      return n + 1\n    case m == 1:\n      return n + 2\n    case m == 2:\n      return 2*n + 3\n    case m == 3:\n      return 8 << n - 3\n    case n == 0:\n      return Ackermann2(m - 1, 1)\n  }\n  return Ackermann2(m - 1, Ackermann2(m, n - 1))\n}<\/lang>\nExpanded version with arbitrary precision and demonstration program\n<lang go>package main\n\nimport (\n    \"fmt\"\n    \"math\/big\"\n    \"unsafe\"\n)\n\nvar one = big.NewInt(1)\nvar two = big.NewInt(2)\nvar three = big.NewInt(3)\nvar eight = big.NewInt(8)\nvar u uint\nvar uBits = int(unsafe.Sizeof(u))*8 - 1\n\nfunc Ackermann2(m, n *big.Int) *big.Int {\n    if m.Cmp(three) <= 0 {\n        switch m.Int64() {\n        case 0:\n            return new(big.Int).Add(n, one)\n        case 1:\n            return new(big.Int).Add(n, two)\n        case 2:\n            r := new(big.Int).Lsh(n, 1)\n            return r.Add(r, three)\n        case 3:\n            if n.BitLen() > uBits {\n                panic(\"way too big\")\n            }\n            r := new(big.Int).Lsh(eight, uint(n.Int64()))\n            return r.Sub(r, three)\n        }\n    }\n    if n.BitLen() == 0 {\n        return Ackermann2(new(big.Int).Sub(m, one), one)\n    }\n    return Ackermann2(new(big.Int).Sub(m, one),\n        Ackermann2(m, new(big.Int).Sub(n, one)))\n}\n\nfunc main() {\n    show(0, 0)\n    show(1, 2)\n    show(2, 4)\n    show(3, 100)\n    show(4, 1)\n    show(4, 3)\n}\n\nfunc show(m, n int64) {\n    fmt.Printf(\"A(%d, %d) = \", m, n)\n    fmt.Println(Ackermann2(big.NewInt(m), big.NewInt(n)))\n}<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>\nA(0, 0) = 1\nA(1, 2) = 4\nA(2, 4) = 11\nA(3, 100) = 10141204801825835211973625643005\nA(4, 1) = 65533\nA(4, 3) = panic: way too big\n\ngoroutine 1 [running]:\nmain.Ackermann2(0xf84001a480, 0xf84001a5a0, 0xf84001a5a0, 0xf84001a4a0, 0xf84001a460, ...)\n        a.go:28 +0x2c3\nmain.Ackermann2(0xf84001a440, 0xf84001a460, 0x2b91c7e9ff50, 0x200000002, 0xa, ...)\n        a.go:37 +0x1fb\nmain.show(0x4, 0x3, 0x40cee3, 0x0)\n        a.go:51 +0x145\nmain.main()\n        a.go:46 +0x9b\n<\/pre>\n\n==[[:Category:Golfscript|Golfscript]][[Category:Golfscript]]==\n<lang golfscript>{\n  :_n; :_m;\n  _m 0= {_n 1+}\n        {_n 0= {_m 1- 1 ack}\n               {_m 1- _m _n 1- ack ack}\n               if}\n        if\n}:ack;<\/lang>\n\n==[[:Category:Groovy|Groovy]][[Category:Groovy]]==\n<lang groovy>def ack ( m, n ) {\n    assert m >= 0 && n >= 0 : 'both arguments must be non-negative'\n    m == 0 ? n + 1 : n == 0 ? ack(m-1, 1) : ack(m-1, ack(m, n-1))\n}<\/lang>\nTest program:\n<lang groovy>def ackMatrix = (0..3).collect { m -> (0..8).collect { n -> ack(m, n) } }\nackMatrix.each { it.each { elt -> printf \"%7d\", elt }; println() }<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>      1      2      3      4      5      6      7      8      9\n      2      3      4      5      6      7      8      9     10\n      3      5      7      9     11     13     15     17     19\n      5     13     29     61    125    253    509   1021   2045<\/pre>\nNote: In the default groovyConsole configuration for WinXP, \"ack(4,1)\" caused a stack overflow error!\n\n==[[:Category:Haskell|Haskell]][[Category:Haskell]]==\n<lang haskell>ack 0 n = n + 1\nack m 0 = ack (m-1) 1\nack m n = ack (m-1) (ack m (n-1))<\/lang>\n<div>\n;Example of use<nowiki>:<\/nowiki><\/div>\n<pre> Prelude> ack 0 0\n 1\n Prelude> ack 3 4\n 125<\/pre>\n\n==[[:Category:haXe|haXe]][[Category:haXe]]==\n<lang haXe>class RosettaDemo\n{\n    static public function main()\n    {\n        neko.Lib.print(ackermann(3, 4));\n    }\n\n    static function ackermann(m : Int, n : Int)\n    {\n        if (m == 0)\n        {\n            return n + 1;\n        }\n        else if (n == 0)\n        {\n            return ackermann(m-1, 1);\n        }\n        return ackermann(m-1, ackermann(m, n-1));\n    }\n}<\/lang>\n\n==[[:Category:Icon|Icon]][[Category:Icon]] and [[:Category:Unicon|Unicon]][[Category:Unicon]]==\n<div class=\"examplemeta libheader\">'''Library:''' [[SMW::off]][[:Category:Icon Programming Library|Icon Programming Library]][[Category:Icon Programming Library]][[SMW::on]]<\/div> \nTaken from the public domain Icon Programming Library's [http:\/\/www.cs.arizona.edu\/icon\/library\/procs\/memrfncs.htm acker in memrfncs],\nwritten by Ralph E. Griswold.\n<lang Icon>procedure acker(i, j)\n   static memory\n\n   initial {\n      memory := table()\n      every memory[0 to 100] := table()\n      }\n\n   if i = 0 then return j + 1\n\n   if j = 0 then \/memory[i][j] := acker(i - 1, 1)\n   else \/memory[i][j] := acker(i - 1, acker(i, j - 1))\n\n   return memory[i][j]\n\nend\n\nprocedure main()\n   every m := 0 to 3 do {\n      every n := 0 to 8 do {\n         writes(acker(m, n) || \" \")\n         }\n      write()\n      }\nend<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>\n1 2 3 4 5 6 7 8 9 \n2 3 4 5 6 7 8 9 10 \n3 5 7 9 11 13 15 17 19 \n5 13 29 61 125 253 509 1021 2045<\/pre>\n\n==[[:Category:Ioke|Ioke]][[Category:Ioke]]==\n<div class=\"examplemeta translation\">'''Translation of''': [[Ackermann function#Clojure|Clojure]]<\/div>\n<lang ioke>ackermann = method(m,n,\n  cond(\n    m zero?, n succ,\n    n zero?, ackermann(m pred, 1),\n    ackermann(m pred, ackermann(m, n pred)))\n)<\/lang>\n\n==[[:Category:J|J]][[Category:J]]==\nAs posted at the [[j:Essays\/Ackermann%27s%20Function|J wiki]]\n<lang j>ack=: c1`c1`c2`c3 @. (#.@,&*) M.\nc1=: >:@]                        NB. if 0=x, 1+y\nc2=: <:@[ ack 1:                 NB. if 0=y, (x-1) ack 1\nc3=: <:@[ ack [ ack <:@]         NB. else,   (x-1) ack x ack y-1<\/lang>\n<div>\n;Example use<nowiki>:<\/nowiki><\/div>\n<lang j>   0 ack 3\n4\n   1 ack 3\n5\n   2 ack 3\n9\n   3 ack 3\n61<\/lang>\nJ's stack was too small for me to compute <tt>4 ack 1<\/tt>.\n;Alternative Version\nThis version works by first generating verbs (functions) and then applying them to compute the rows of the Ackermann function.  It also uses extended precision to be able to compute 4 Ack 2.\n<lang j>o=. @: NB. Composition of verbs\n\nrows0to3=. <;._1 o (' >: 2&+&.(3&+) 2&*&.(3&+) 2&^&.(3&+)'\"_)\nnext=. '(1x ('\"_ , ] , ')@:]^:(1+[)~ ])'\"_\nrow=. (] {:: ::([ next o ]^:([ - 3:) _1 {:: ]) rows0to3)\"0\n\nAck=. (row o [ apply ]) f. NB. Applying the left arg row verb (function) to the right arg<\/lang>\nExample use:<lang j>   0 1 2 3 Ack 0 1 2 3 4 5 6 7 8\n1  2  3  4   5   6   7    8    9\n2  3  4  5   6   7   8    9   10\n3  5  7  9  11  13  15   17   19\n5 13 29 61 125 253 509 1021 2045\n   4 Ack 0 1 2\n13 65533 2003529930406846464979072351560255750447825475569751419265016973710894059556311453089506130880933348101038234342907263181822949382118812668869506364761547029165041871916351587966347219442930927982084309104855990570159318959639524863372367203002916...\n   5 Ack 0                    NB. Equal to 4 Ack 1 as expected\n65533\n   # o \": 4 Ack 2             NB. Number of digits\n19729\n   (4 Ack 2) = (2^2^2^2^2x)-3 NB. Check \n1\n   \n   row o i. 9                 NB. The verbs (functions) associated to the first nine rows\n>:                                                                                                            \n2&+&.(3&+)                                                                                                    \n2&*&.(3&+)                                                                                                    \n2&^&.(3&+)                                                                                                    \n(1x (2&^&.(3&+))@:]^:(1+[)~ ])                                                                                \n(1x ((1x (2&^&.(3&+))@:]^:(1+[)~ ]))@:]^:(1+[)~ ])                                                            \n(1x ((1x ((1x (2&^&.(3&+))@:]^:(1+[)~ ]))@:]^:(1+[)~ ]))@:]^:(1+[)~ ])                                        \n(1x ((1x ((1x ((1x (2&^&.(3&+))@:]^:(1+[)~ ]))@:]^:(1+[)~ ]))@:]^:(1+[)~ ]))@:]^:(1+[)~ ])                    \n(1x ((1x ((1x ((1x ((1x (2&^&.(3&+))@:]^:(1+[)~ ]))@:]^:(1+[)~ ]))@:]^:(1+[)~ ]))@:]^:(1+[)~ ]))@:]^:(1+[)~ ])\n   \n   Ack                        NB. The fixed (raw) code\n(] {:: ::([ ('(1x ('\"_ , ] , ')@:]^:(1+[)~ ])'\"_)@:]^:([ - 3:) _1 {:: ]) <;._1@:(' >: 2&+&.(3&+) 2&*&.(3&+) 2&^&.(3&+)'\"_))\"0@:[ 128!:2 ]<\/lang>\n\n==[[:Category:Java|Java]][[Category:Java]]==\n[[Category:Arbitrary precision]]\n<lang java>import java.math.BigInteger;\n\npublic static BigInteger ack(BigInteger m, BigInteger n) {\n    return m.equals(BigInteger.ZERO)\n            ? n.add(BigInteger.ONE)\n            : ack(m.subtract(BigInteger.ONE),\n                        n.equals(BigInteger.ZERO) ? BigInteger.ONE : ack(m, n.subtract(BigInteger.ONE)));\n}<\/lang>\n\n==[[:Category:JavaScript|JavaScript]][[Category:JavaScript]]==\n<lang javascript>function ack(m, n)\n{\n return m === 0 ? n + 1 : ack(m - 1, n === 0  ? 1 : ack(m, n - 1));\n}<\/lang>\n\n==[[:Category:Joy|Joy]][[Category:Joy]]==\nFrom [http:\/\/www.latrobe.edu.au\/phimvt\/joy\/jp-nestrec.html here]\n<lang joy>DEFINE ack == [ [ [pop null]  popd succ ] \n                [ [null]  pop pred 1 ack ] \n                [ [dup pred swap] dip pred ack ack ] ] \n              cond.<\/lang>\nanother using a combinator\n<lang joy>DEFINE ack == [ [ [pop null]  [popd succ] ] \n\t\t[ [null]  [pop pred 1]  [] ] \n\t\t[ [[dup pred swap] dip pred] [] [] ] ] \n              condnestrec.<\/lang>\nWhenever there are two definitions with the same name, the last one is the one that is used, when invoked.\n\n==[[:Category:K|K]][[Category:K]]==\nSee [https:\/\/github.com\/kevinlawler\/kona\/wiki the K wiki]\n<lang k>ack:{:[0=x;y+1;0=y;_f[x-1;1];_f[x-1;_f[x;y-1]]]}\nack[2;2]<\/lang>\n\n==[[:Category:Kdf9 Usercode|Kdf9 Usercode]][[Category:Kdf9 Usercode]]==\n<lang kdf9 usercode>V6; W0;\nYS26000;\nRESTART; J999; J999;\nPROGRAM;                   (main program);\n   V1 = B1212121212121212; (radix 10 for FRB);\n   V2 = B2020202020202020; (high bits for decimal digits);\n   V3 = B0741062107230637; (\"A[3,\"  in Flexowriter code);\n   V4 = B0727062200250007; (\"7] = \" in Flexowriter code);\n   V5 = B7777777777777777;\n\n      ZERO; NOT; =M1;      (Q1 := 0\/0\/-1);\n      SETAYS0; =M2; I2=2;  (Q2 := 0\/2\/AYS0: M2 is the stack pointer);\n      SET 3; =RC7;         (Q7 := 3\/1\/0: C7 = m);\n      SET 7; =RC8;         (Q8 := 7\/1\/0: C8 = n);\n   JSP1;                   (call Ackermann function);\n      V1; REV; FRB;        (convert result to base 10);\n      V2; OR;              (convert decimal digits to characters);\n      V5; REV;\n      SHLD+24; =V5; ERASE; (eliminate leading zeros);\n      SETAV5; =RM9;\n      SETAV3; =I9;\n      POAQ9;               (write result to Flexowriter);\n\n999;  ZERO; OUT;           (terminate run);\n\nP1; (To compute A[m, n]);\n\n   99;\n      J1C7NZ;           (to 1 if m \u00b1 0);\n         I8; =+C8;      (n := n + 1);\n         C8;            (result to NEST);\n      EXIT 1;           (return);\n   *1;\n      J2C8NZ;           (to 2 if n \u00b1 0);\n         I8; =C8;       (n := 1);\n         DC7;           (m := m - 1);\n      J99;              (tail recursion for A[m-1, 1]);\n   *2;\n         LINK; =M0M2;   (push return address);\n         C7; =M0M2QN;   (push m);\n         DC8;           (n := n - 1);\n      JSP1;             (full recursion for A[m, n-1]);\n         =C8;           (n := A[m, n-1]);\n         M1M2; =C7;     (m := top of stack);\n         DC7;           (m := m - 1);\n         M-I2;          (pop stack);\n         M0M2; =LINK;   (return address := top of stack);\n      J99;              (tail recursion for A[m-1, A[m, n-1]]);\n\nFINISH;<\/lang>\n\n==[[:Category:Liberty BASIC|Liberty BASIC]][[Category:Liberty BASIC]]==\n<lang lb>Print Ackermann(1, 2)\n\n    Function Ackermann(m, n)\n        Select Case\n            Case (m < 0) Or (n < 0)\n                Exit Function\n            Case (m = 0)\n                Ackermann = (n + 1)\n            Case (m > 0) And (n = 0)\n                Ackermann = Ackermann((m - 1), 1)\n            Case (m > 0) And (n > 0)\n                Ackermann = Ackermann((m - 1), Ackermann(m, (n - 1)))\n        End Select\n    End Function<\/lang>\n\n==[[:Category:Logo|Logo]][[Category:Logo]]==\n<lang logo>to ack :i :j\n  if :i = 0 [output :j+1]\n  if :j = 0 [output ack :i-1 1]\n  output ack :i-1 ack :i :j-1\nend<\/lang>\n\n==[[:Category:Logtalk|Logtalk]][[Category:Logtalk]]==\n<lang logtalk>ack(0, N, V) :-\n    !,\n    V is N + 1.\nack(M, 0, V) :-\n    !,\n    M2 is M - 1,\n    ack(M2, 1, V).\nack(M, N, V) :-\n    M2 is M - 1,\n    N2 is N - 1,\n    ack(M, N2, V2),\n    ack(M2, V2, V).<\/lang>\n\n==[[:Category:Lua|Lua]][[Category:Lua]]==\n<lang lua>function ack(M,N)\n    if M == 0 then return N + 1 end\n    if N == 0 then return ack(M-1,1) end\n    return ack(M-1,ack(M, N-1))\nend<\/lang>\n\n==[[:Category:Lucid|Lucid]][[Category:Lucid]]==\n<lang lucid>ack(m,n)\n where\n  ack(m,n) = if m eq 0 then n+1\n                       else if n eq 0 then ack(m-1,1)\n                                      else ack(m-1, ack(m, n-1)) fi\n                       fi;\n end<\/lang>\n\n==[[:Category:M4|M4]][[Category:M4]]==\n<lang M4>define(`ack',`ifelse($1,0,`incr($2)',`ifelse($2,0,`ack(decr($1),1)',`ack(decr($1),ack($1,decr($2)))')')')dnl\nack(3,3)<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>61 <\/pre>\n\n==[[:Category:Mathematica|Mathematica]][[Category:Mathematica]]==\nTwo possible implementations would be:\n<lang Mathematica>$RecursionLimit=Infinity\nAckermann1[m_,n_]:=\n If[m==0,n+1,\n  If[ n==0,Ackermann1[m-1,1],\n   Ackermann1[m-1,Ackermann1[m,n-1]]\n  ]\n ]\n\n Ackermann2[0,n_]:=n+1;\n Ackermann2[m_,0]:=Ackermann1[m-1,1];\n Ackermann2[m_,n_]:=Ackermann1[m-1,Ackermann1[m,n-1]]<\/lang>\nNote that the second implementation is quite a bit faster, as doing 'if' comparisons is slower than the built-in pattern matching algorithms.\nExamples:\n<lang Mathematica>Flatten[#,1]&@Table[{\"Ackermann2[\"<>ToString[i]<>\",\"<>ToString[j]<>\"] =\",Ackermann2[i,j]},{i,3},{j,8}]\/\/Grid<\/lang>\ngives back:\n<lang Mathematica>Ackermann2[1,1] =\t3\nAckermann2[1,2] =\t4\nAckermann2[1,3] =\t5\nAckermann2[1,4] =\t6\nAckermann2[1,5] =\t7\nAckermann2[1,6] =\t8\nAckermann2[1,7] =\t9\nAckermann2[1,8] =\t10\nAckermann2[2,1] =\t5\nAckermann2[2,2] =\t7\nAckermann2[2,3] =\t9\nAckermann2[2,4] =\t11\nAckermann2[2,5] =\t13\nAckermann2[2,6] =\t15\nAckermann2[2,7] =\t17\nAckermann2[2,8] =\t19\nAckermann2[3,1] =\t13\nAckermann2[3,2] =\t29\nAckermann2[3,3] =\t61\nAckermann2[3,4] =\t125\nAckermann2[3,5] =\t253\nAckermann2[3,6] =\t509\nAckermann2[3,7] =\t1021\nAckermann2[3,8] =\t2045<\/lang>\nIf we would like to calculate Ackermann[4,1] or Ackermann[4,2] we have to optimize a little bit:\n<lang Mathematica>Clear[Ackermann3]\n$RecursionLimit=Infinity;\nAckermann3[0,n_]:=n+1;\nAckermann3[1,n_]:=n+2;\nAckermann3[2,n_]:=3+2n;\nAckermann3[3,n_]:=5+8 (2^n-1);\nAckermann3[m_,0]:=Ackermann3[m-1,1];\nAckermann3[m_,n_]:=Ackermann3[m-1,Ackermann3[m,n-1]]<\/lang>\nNow computing Ackermann[4,1] and Ackermann[4,2] can be done quickly (<0.01 sec):\nExamples 2:\n<lang Mathematica>Ackermann3[4, 1]\nAckermann3[4, 2]<\/lang>\ngives back:\n<div style=\"width:full;overflow:scroll\"><lang Mathematica>65533\n2003529930406846464979072351560255750447825475569751419265016973710894059556311453089506130880........699146577530041384717124577965048175856395072895337539755822087777506072339445587895905719156733<\/lang><\/div>\nAckermann[4,2] has 19729 digits, several thousands of digits omitted in the result above for obvious reasons. Ackermann[5,0] can be computed also quite fast, and is equal to 65533. \nSummarizing Ackermann[0,n_], Ackermann[1,n_], Ackermann[2,n_], and Ackermann[3,n_] can all be calculated for n>>1000. Ackermann[4,0], Ackermann[4,1], Ackermann[4,2] and Ackermann[5,0]  are only possible now. Maybe in the future we can calculate higher Ackermann numbers efficiently and fast. Although showing the results will always be a problem.\n\n==[[:Category:MATLAB|MATLAB]][[Category:MATLAB]]==\n<lang MATLAB>function A = ackermannFunction(m,n)\n    if m == 0\n        A = n+1;\n    elseif (m > 0) && (n == 0)\n        A = ackermannFunction(m-1,1);\n    else\n        A = ackermannFunction( m-1,ackermannFunction(m,n-1) );\n    end\nend<\/lang>\n\n==[[:Category:Maxima|Maxima]][[Category:Maxima]]==\n<lang maxima>ackermann(m, n) := if integerp(m) and integerp(n) then ackermann[m, n] else 'ackermann(m, n)$\n\nackermann[m, n] := if m = 0 then n + 1\n                   elseif m = 1 then 2 + (n + 3) - 3\n                   elseif m = 2 then 2 * (n + 3) - 3\n                   elseif m = 3 then 2^(n + 3) - 3\n                   elseif n = 0 then ackermann[m - 1, 1]\n                   else ackermann[m - 1, ackermann[m, n - 1]]$\n\ntetration(a, n) := if integerp(n) then block([b: a], for i from 2 thru n do b: a^b, b) else 'tetration(a, n)$\n\n\/* this should evaluate to zero *\/\nackermann(4, n) - (tetration(2, n + 3) - 3);\nsubst(n = 2, %);\nev(%, nouns);<\/lang>\n\n==[[:Category:MAXScript|MAXScript]][[Category:MAXScript]]==\nUse with caution. Will cause a stack overflow for m > 3.\n<lang maxscript>fn ackermann m n =\n(\n    if m == 0 then\n    (\n        return n + 1\n    )\n    else if n == 0 then\n    (\n        ackermann (m-1) 1\n    )\n    else\n    (\n        ackermann (m-1) (ackermann m (n-1))\n    )\n)<\/lang>\n\n==[[:Category:ML\/I|ML\/I]][[Category:ML\/I]]==\nML\/I loves recursion, but runs out of its default amount of storage with larger numbers than those tested here!\n===Program===\n<lang ML\/I>MCSKIP \"WITH\" NL\n\"\" Ackermann function\n\"\" Will overflow when it reaches implementation-defined signed integer limit\nMCSKIP MT,<>\nMCINS %.\nMCDEF ACK WITHS ( , )\nAS <MCSET T1=%A1.\nMCSET T2=%A2.\nMCGO L1 UNLESS T1 EN 0\n%%T2.+1.MCGO L0\n%L1.MCGO L2 UNLESS T2 EN 0\nACK(%%T1.-1.,1)MCGO L0\n%L2.ACK(%%T1.-1.,ACK(%T1.,%%T2.-1.))>\n\"\" Macro ACK now defined, so try it out\na(0,0) => ACK(0,0)\na(0,1) => ACK(0,1)\na(0,2) => ACK(0,2)\na(0,3) => ACK(0,3)\na(0,4) => ACK(0,4)\na(0,5) => ACK(0,5)\na(1,0) => ACK(1,0)\na(1,1) => ACK(1,1)\na(1,2) => ACK(1,2)\na(1,3) => ACK(1,3)\na(1,4) => ACK(1,4)\na(2,0) => ACK(2,0)\na(2,1) => ACK(2,1)\na(2,2) => ACK(2,2)\na(2,3) => ACK(2,3)\na(3,0) => ACK(3,0)\na(3,1) => ACK(3,1)\na(3,2) => ACK(3,2)\na(4,0) => ACK(4,0)<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<lang ML\/I>a(0,0) => 1\na(0,1) => 2\na(0,2) => 3\na(0,3) => 4\na(0,4) => 5\na(0,5) => 6\na(1,0) => 2\na(1,1) => 3\na(1,2) => 4\na(1,3) => 5\na(1,4) => 6\na(2,0) => 3\na(2,1) => 5\na(2,2) => 7\na(2,3) => 9\na(3,0) => 5\na(3,1) => 13\na(3,2) => 29\na(4,0) => 13<\/lang>\n\n==[[:Category:Modula-2|Modula-2]][[Category:Modula-2]]==\n<lang modula2>MODULE ackerman;\n\nIMPORT  ASCII, NumConv, InOut;\n\nVAR     m, n            : LONGCARD;\n        string          : ARRAY [0..19] OF CHAR;\n        OK              : BOOLEAN;\n\nPROCEDURE Ackerman (x, y   : LONGCARD) : LONGCARD;\n\nBEGIN\n  IF    x = 0  THEN  RETURN  y + 1\n  ELSIF y = 0  THEN  RETURN  Ackerman (x - 1 , 1)\n  ELSE\n    RETURN  Ackerman (x - 1 , Ackerman (x , y - 1))\n  END\nEND Ackerman;\n\nBEGIN\n  FOR  m := 0  TO  3  DO\n    FOR  n := 0  TO  6  DO\n      NumConv.Num2Str (Ackerman (m, n), 10, string, OK);\n      IF  OK  THEN\n        InOut.WriteString (string)\n      ELSE\n        InOut.WriteString (\"* Error in number * \")\n      END;\n      InOut.Write (ASCII.HT)\n    END;\n    InOut.WriteLn\n  END;\n  InOut.WriteLn\nEND ackerman.<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div><pre>jan@Beryllium:~\/modula\/rosetta$ ackerman\n1       2       3       4       5       6       7\n2       3       4       5       6       7       8\n3       5       7       9       11      13      15\n5       13      29      61      125     253     509<\/pre>\n\n==[[:Category:Modula-3|Modula-3]][[Category:Modula-3]]==\nThe type CARDINAL is defined in Modula-3 as [0..LAST(INTEGER)], in other words, it can hold all positive integers.\n<lang modula3>MODULE Ack EXPORTS Main;\n\nFROM IO IMPORT Put;\nFROM Fmt IMPORT Int;\n\nPROCEDURE Ackermann(m, n: CARDINAL): CARDINAL =\n  BEGIN\n    IF m = 0 THEN \n      RETURN n + 1;\n    ELSIF n = 0 THEN\n      RETURN Ackermann(m - 1, 1);\n    ELSE\n      RETURN Ackermann(m - 1, Ackermann(m, n - 1));\n    END;\n  END Ackermann;\n\nBEGIN\n  FOR m := 0 TO 3 DO\n    FOR n := 0 TO 6 DO\n      Put(Int(Ackermann(m, n)) & \" \");\n    END;\n    Put(\"\\n\");\n  END;\nEND Ack.<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>1 2 3 4 5 6 7 \n2 3 4 5 6 7 8 \n3 5 7 9 11 13 15 \n5 13 29 61 125 253 509 <\/pre>\n\n==[[:Category:MUMPS|MUMPS]][[Category:MUMPS]]==\n<lang MUMPS>Ackermann(m,n)\t;\n\tIf m=0 Quit n+1\n\tIf m>0,n=0 Quit $$Ackermann(m-1,1)\n\tIf m>0,n>0 Quit $$Ackermann(m-1,$$Ackermann(m,n-1))\n\tSet $Ecode=\",U13-Invalid parameter for Ackermann: m=\"_m_\", n=\"_n_\",\"\n\nWrite $$Ackermann(1,8) ; 10\nWrite $$Ackermann(2,8) ; 19\nWrite $$Ackermann(3,5) ; 253<\/lang>\n\n==[[:Category:Nial|Nial]][[Category:Nial]]==\n<lang nial>ack is fork [\n   = [0 first, first], +[last, 1 first],\n   = [0 first, last], ack [ -[first, 1 first], 1 first],\n   ack[ -[first,1 first], ack[first, -[last,1 first]]]\n]<\/lang>\n\n==[[:Category:Nimrod|Nimrod]][[Category:Nimrod]]==\n<lang nimrod>proc Ackermann(m, n: int64): int64 =\n  if m == 0:\n    result = n + 1\n  elif n == 0:\n    result = Ackermann(m - 1, 1)\n  else:\n    result = Ackermann(m - 1, Ackermann(m, n - 1))<\/lang>\n\n==[[:Category:OCaml|OCaml]][[Category:OCaml]]==\n<lang ocaml>let rec a m n =\n  if m=0 then (n+1) else\n  if n=0 then (a (m-1) 1) else\n  (a (m-1) (a m (n-1)))<\/lang>\nor:\n<lang ocaml>let rec a = function\n  | 0, n -> (n+1)\n  | m, 0 -> a(m-1, 1)\n  | m, n -> a(m-1, a(m, n-1))<\/lang>\nwith memoization using an hash-table:\n<lang ocaml>let h = Hashtbl.create 4001\n\nlet a m n =\n  try Hashtbl.find h (m, n)\n  with Not_found ->\n    let res = a (m, n) in\n    Hashtbl.add h (m, n) res;\n    (res)<\/lang>\ntaking advantage of the memoization we start calling small values of '''m''' and '''n''' in order to reduce the recursion call stack:\n<lang ocaml>let a m n =\n  for _m = 0 to m do\n    for _n = 0 to n do\n      ignore(a _m _n);\n    done;\n  done;\n  (a m n)<\/lang>\n=== Arbitrary precision ===\nWith arbitrary-precision integers ([http:\/\/caml.inria.fr\/pub\/docs\/manual-ocaml\/libref\/Big_int.html Big_int module]):\n<lang ocaml>open Big_int\nlet one  = unit_big_int\nlet zero = zero_big_int\nlet succ = succ_big_int\nlet pred = pred_big_int\nlet eq = eq_big_int\n\nlet rec a m n =\n  if eq m zero then (succ n) else\n  if eq n zero then (a (pred m) one) else\n  (a (pred m) (a m (pred n)))<\/lang>\ncompile with:\n ocamlopt -o acker nums.cmxa acker.ml\n=== Tail-Recursive ===\nHere is a [[:Category:Recursion|tail-recursive]] version:\n<lang ocaml>let rec find_option h v =\n  try Some(Hashtbl.find h v)\n  with Not_found -> None\n\nlet rec a bounds caller todo m n =\n  match m, n with\n  | 0, n ->\n      let r = (n+1) in\n      ( match todo with\n        | [] -> r\n        | (m,n)::todo ->\n            List.iter (fun k ->\n              if not(Hashtbl.mem bounds k)\n              then Hashtbl.add bounds k r) caller;\n            a bounds [] todo m n )\n\n  | m, 0 ->\n      a bounds caller todo (m-1) 1\n\n  | m, n ->\n      match find_option bounds (m, n-1) with\n      | Some a_rec ->\n          let caller = (m,n)::caller in\n          a bounds caller todo (m-1) a_rec\n      | None ->\n          let todo = (m,n)::todo\n          and caller = [(m, n-1)] in\n          a bounds caller todo m (n-1)\n\nlet a = a (Hashtbl.create 42 (* arbitrary *) ) [] [] ;;<\/lang>\nThis one uses the arbitrary precision, the tail-recursion, and the optimisation explain on the Wikipedia page about <tt>(m,n) = (3,_)<\/tt>.\n<lang ocaml>open Big_int\nlet one  = unit_big_int\nlet zero = zero_big_int\nlet succ = succ_big_int\nlet pred = pred_big_int\nlet add = add_big_int\nlet sub = sub_big_int\nlet eq = eq_big_int\nlet three = succ(succ one)\nlet power = power_int_positive_big_int\n\nlet eq2 (a1,a2) (b1,b2) =\n  (eq a1 b1) && (eq a2 b2)\n\nmodule H = Hashtbl.Make\n  (struct\n     type t = Big_int.big_int * Big_int.big_int\n     let equal = eq2\n     let hash (x,y) = Hashtbl.hash\n       (Big_int.string_of_big_int x ^ \",\" ^\n          Big_int.string_of_big_int y)\n       (* probably not a very good hash function *)\n   end)\n\nlet rec find_option h v =\n  try Some (H.find h v)\n  with Not_found -> None\n\nlet rec a bounds caller todo m n =\n  let may_tail r =\n    let k = (m,n) in\n    match todo with\n    | [] -> r\n    | (m,n)::todo ->\n        List.iter (fun k ->\n                     if not (H.mem bounds k)\n                     then H.add bounds k r) (k::caller);\n        a bounds [] todo m n\n  in\n  match m, n with\n  | m, n when eq m zero ->\n      let r = (succ n) in\n      may_tail r\n \n  | m, n when eq n zero ->\n      let caller = (m,n)::caller in\n      a bounds caller todo (pred m) one\n \n  | m, n when eq m three ->\n      let r = sub (power 2 (add n three)) three in\n      may_tail r\n\n  | m, n ->\n      match find_option bounds (m, pred n) with\n      | Some a_rec ->\n          let caller = (m,n)::caller in\n          a bounds caller todo (pred m) a_rec\n      | None ->\n          let todo = (m,n)::todo in\n          let caller = [(m, pred n)] in\n          a bounds caller todo m (pred n)\n \nlet a = a (H.create 42 (* arbitrary *)) [] [] ;;\n\nlet () =\n  let m, n =\n    try\n      big_int_of_string Sys.argv.(1),\n      big_int_of_string Sys.argv.(2)\n    with _ ->\n      Printf.eprintf \"usage: %s <int> <int>\\n\" Sys.argv.(0);\n      exit 1\n  in\n  let r = a m n in\n  Printf.printf \"(a %s %s) = %s\\n\"\n      (string_of_big_int m)\n      (string_of_big_int n)\n      (string_of_big_int r);\n;;<\/lang>\n\n==[[:Category:Oberon-2|Oberon-2]][[Category:Oberon-2]]==\n<lang oberon2>MODULE ackerman;\n\nIMPORT  Out;\n\nVAR     m, n    : INTEGER;\n\nPROCEDURE Ackerman (x, y   : INTEGER) : INTEGER;\n\nBEGIN\n  IF    x = 0  THEN  RETURN  y + 1\n  ELSIF y = 0  THEN  RETURN  Ackerman (x - 1 , 1)\n  ELSE\n    RETURN  Ackerman (x - 1 , Ackerman (x , y - 1))\n  END\nEND Ackerman;\n\nBEGIN\n  FOR  m := 0  TO  3  DO\n    FOR  n := 0  TO  6  DO\n      Out.Int (Ackerman (m, n), 10);\n      Out.Char (9X)\n    END;\n    Out.Ln\n  END;\n  Out.Ln\nEND ackerman.<\/lang>\n\n==[[:Category:Octave|Octave]][[Category:Octave]]==\n<lang octave>function r = ackerman(m, n)\n  if ( m == 0 )\n    r = n + 1;\n  elseif ( n == 0 )\n    r = ackerman(m-1, 1);\n  else\n    r = ackerman(m-1, ackerman(m, n-1));\n  endif\nendfunction\n\nfor i = 0:3\n  disp(ackerman(i, 4));\nendfor<\/lang>\n\n==[[:Category:Oz|Oz]][[Category:Oz]]==\nOz has arbitrary precision integers.\n<lang oz>declare\n\n  fun {Ack M N}\n     if     M == 0 then N+1\n     elseif N == 0 then {Ack M-1 1}\n     else               {Ack M-1 {Ack M N-1}}\n     end\n  end\n\nin\n\n  {Show {Ack 3 7}}<\/lang>\n\n==[[:Category:PARI\/GP|PARI\/GP]][[Category:PARI\/GP]]==\nNaive implementation.\n<lang parigp>A(m,n)={\n  if(m,\n    if(n,\n      A(m-1, A(m,n-1))\n    ,\n      A(m-1,1)\n    )\n  ,\n    n+1\n  )\n};<\/lang>\n\n==[[:Category:Pascal|Pascal]][[Category:Pascal]]==\n<lang pascal>Program Ackerman;\n\nfunction ackermann(m, n: Integer) : Integer;\nbegin\n   if m = 0 then\n      ackermann := n+1\n   else if n = 0 then\n      ackermann := ackermann(m-1, 1)\n   else\n      ackermann := ackermann(m-1, ackermann(m, n-1));\nend;\n\nvar\n   m, n\t: Integer;\n\nbegin\n   for n := 0 to 6 do\n      for m := 0 to 3 do\n\t WriteLn('A(', m, ',', n, ') = ', ackermann(m,n));\nend.<\/lang>\n\n==[[:Category:Perl|Perl]][[Category:Perl]]==\nWe memoize calls to ''A'' to make ''A''(2, ''n'') and ''A''(3, ''n'') feasible for larger values of ''n''.\n<lang perl>{\n    my @memo;\n    sub A {\n        my( $m, $n ) = @_;\n        $memo[ $m ][ $n ] and return $memo[ $m ][ $n ];\n        $m or return $n + 1;\n        return $memo[ $m ][ $n ] = (\n            $n\n               ? A( $m - 1, A( $m, $n - 1 ) )\n               : A( $m - 1, 1 )\n        );\n    }\n}<\/lang>\n\n==[[:Category:Perl 6|Perl 6]][[Category:Perl 6]]==\nAn implementation using ternary chaining:\n<lang perl6>sub A(Int $m, Int $n) {\n\n\t$m == 0  ??    $n + 1                   !! \n\t$n == 0  ??  A($m - 1, 1            )   !!\n\t             A($m - 1, A($m, $n - 1));\n\n}<\/lang>\nAn implementation using multiple dispatch:\n<lang perl6>multi sub A(0,      Int $n) { $n + 1                   }\nmulti sub A(Int $m, 0     ) { A($m - 1, 1)             }\nmulti sub A(Int $m, Int $n) { A($m - 1, A($m, $n - 1)) }<\/lang>\nNote that in either case, Int is defined to be arbitrary precision in Perl&nbsp;6.\n\n==[[:Category:PHP|PHP]][[Category:PHP]]==\n<lang php>function ackermann( $m , $n )\n{\n    if ( $m==0 )\n    {\n        return $n + 1;\n    }\n    elseif ( $n==0 )\n    {\n        return ackermann( $m-1 , 1 );\n    }\n    return ackermann( $m-1, ackermann( $m , $n-1 ) );\n}\n\necho ackermann( 3, 4 );\n\/\/ prints 125<\/lang>\n\n==[[:Category:PicoLisp|PicoLisp]][[Category:PicoLisp]]==\n<lang PicoLisp>(de ack (X Y)\n   (cond\n      ((=0 X) (inc Y))\n      ((=0 Y) (ack (dec X) 1))\n      (T (ack (dec X) (ack X (dec Y)))) ) )<\/lang>\n\n==[[:Category:Pike|Pike]][[Category:Pike]]==\n<lang pike>int main(){\n   write(ackermann(3,4) + \"\\n\");\n}\n \nint ackermann(int m, int n){\n   if(m == 0){\n      return n + 1;\n   } else if(n == 0){\n      return ackermann(m-1, 1);\n   } else {\n      return ackermann(m-1, ackermann(m, n-1));\n   }\n}<\/lang>\n\n==[[:Category:PL\/I|PL\/I]][[Category:PL\/I]]==\n<lang PL\/I>Ackerman: procedure (m, n) returns (fixed (30)) recursive;\n   declare (m, n) fixed (30);\n   if m = 0 then return (n+1);\n   else if m > 0 & n = 0 then return (Ackerman(m-1, 1));\n   else if m > 0 & n > 0 then return (Ackerman(m-1, Ackerman(m, n-1)));\n   return (0);\nend Ackerman;<\/lang>\n\n==[[:Category:PostScript|PostScript]][[Category:PostScript]]==\n<lang postscript>\/ackermann{\n\/n exch def\n\/m exch def %PostScript takes arguments in the reverse order as specified in the function definition\nm 0 eq{\nn 1 add\n}if\nm 0 gt n 0 eq and\n{\nm 1 sub 1 ackermann\n}if\nm 0 gt n 0 gt and{\nm 1 sub m n 1 sub ackermann ackermann\n}if\n}def<\/lang>\n<div class=\"examplemeta libheader\">'''Library:''' [[SMW::off]][[:Category:initlib|initlib]][[Category:initlib]][[SMW::on]]<\/div>\n<lang postscript>\/A {\n[\/.m \/.n] let\n{\n    {.m 0 eq} {.n succ} is?\n    {.m 0 gt .n 0 eq and} {.m pred 1 A} is?\n    {.m 0 gt .n 0 gt and} {.m pred .m .n pred A A} is?\n} cond\nend}.<\/lang>\n\n==[[:Category:PowerBASIC|PowerBASIC]][[Category:PowerBASIC]]==\n<lang powerbasic>FUNCTION PBMAIN () AS LONG\n    DIM m AS QUAD, n AS QUAD\n\n    m = ABS(VAL(INPUTBOX$(\"Enter a whole number.\")))\n    n = ABS(VAL(INPUTBOX$(\"Enter another whole number.\")))\n\n    MSGBOX STR$(Ackermann(m, n))\nEND FUNCTION\n\nFUNCTION Ackermann (m AS QUAD, n AS QUAD) AS QUAD\n    IF 0 = m THEN\n        FUNCTION = n + 1\n    ELSEIF 0 = n THEN\n        FUNCTION = Ackermann(m - 1, 1)\n    ELSE    ' m > 0; n > 0\n        FUNCTION = Ackermann(m - 1, Ackermann(m, n - 1))\n    END IF\nEND FUNCTION<\/lang>\n\n==[[:Category:PowerShell|PowerShell]][[Category:PowerShell]]==\n<div class=\"examplemeta translation\">'''Translation of''': [[Ackermann function#PHP|PHP]]<\/div>\n<lang powershell>function ackermann ([long] $m, [long] $n) {\n    if ($m -eq 0) {\n        return $n + 1\n    }\n    \n    if ($n -eq 0) {\n        return (ackermann ($m - 1) 1)\n    }\n    \n    return (ackermann ($m - 1) (ackermann $m ($n - 1)))\n}<\/lang>\nBuilding an example table (takes a while to compute, though, especially for the last three numbers; also it fails with the last line in Powershell v1 since the maximum recursion depth is only 100 there):\n<lang powershell>foreach ($m in 0..3) {\n    foreach ($n in 0..6) {\n        Write-Host -NoNewline (\"{0,5}\" -f (ackermann $m $n))\n    }\n    Write-Host\n}<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>    1    2    3    4    5    6    7\n    2    3    4    5    6    7    8\n    3    5    7    9   11   13   15\n    5   13   29   61  125  253  509<\/pre>\n\n==[[:Category:Prolog|Prolog]][[Category:Prolog]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[SWI Prolog]][[SMW::on]]<\/div>\n<lang prolog>ack(0, N, Ans) :- Ans is N+1.\nack(M, 0, Ans) :- M>0, X is M-1, ack(X, 1, Ans).\nack(M, N, Ans) :- M>0, N>0, X is M-1, Y is N-1, ack(M, Y, Ans2), ack(X, Ans2, Ans).<\/lang>\n\n==[[:Category:Pure|Pure]][[Category:Pure]]==\n<lang pure>A 0 n = n+1;\nA m 0 = A (m-1) 1 if (m > 0);\nA m n = A (m-1) (A m (n-1)) if (m > 0) and (n > 0);<\/lang>\n\n==[[:Category:PureBasic|PureBasic]][[Category:PureBasic]]==\n<lang PureBasic>Procedure.q Ackermann(m, n)\n  If m = 0\n    ProcedureReturn n + 1\n  ElseIf  n = 0\n    ProcedureReturn Ackermann(m - 1, 1)\n  Else\n    ProcedureReturn Ackermann(m - 1, Ackermann(m, n - 1))\n  EndIf\nEndProcedure\n\nDebug Ackermann(3,4)<\/lang>\n\n==[[:Category:Purity|Purity]][[Category:Purity]]==\n<lang Purity>data Iter = f => FoldNat <const $f One, $f> \ndata Ackermann = FoldNat <const Succ, Iter><\/lang>\n\n==[[:Category:Python|Python]][[Category:Python]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Python]] version 2.5[[SMW::on]]<\/div>\n<lang python>def ack1(M, N):\n   return (N + 1) if M == 0 else (\n      ack1(M-1, 1) if N == 0 else ack1(M-1, ack1(M, N-1)))<\/lang>\nAnother version:\n<lang python>def ack2(M, N):\n    if M == 0:\n        return N + 1\n    elif N == 0:\n        return ack1(M - 1, 1)\n    else:\n        return ack1(M - 1, ack1(M, N - 1))<\/lang>\n<div>\n;Example of use<nowiki>:<\/nowiki><\/div>\n<lang python>>>> import sys\n>>> sys.setrecursionlimit(3000)\n>>> ack1(0,0)\n1\n>>> ack1(3,4)\n125\n>>> ack2(0,0)\n1\n>>> ack2(3,4)\n125<\/lang>\nFrom the Mathematica ack3 example:\n<lang python>def ack2(M, N):\n   return (N + 1)   if M == 0 else (\n          (N + 2)   if M == 1 else (\n          (2*N + 3) if M == 2 else (\n          (8*(2**N - 1) + 5) if M == 3 else (\n          ack2(M-1, 1) if N == 0 else ack2(M-1, ack2(M, N-1))))))<\/lang>\nResults confirm those of Mathematica for ack(4,1) and ack(4,2)\n\n==[[:Category:R|R]][[Category:R]]==\n<lang R>ackermann <- function(m, n) {\n  if ( m == 0 ) {\n    n+1\n  } else if ( n == 0 ) {\n    ackermann(m-1, 1)\n  } else {\n    ackermann(m-1, ackermann(m, n-1))\n  }\n}<\/lang>\n<lang R>for ( i in 0:3 ) {\n  print(ackermann(i, 4))\n}<\/lang>\n\n==[[:Category:REBOL|REBOL]][[Category:REBOL]]==\n<pre>ackermann: func [m n] [\n    case [\n        m = 0 [n + 1]\n        n = 0 [ackermann m - 1 1]\n        true [ackermann m - 1 ackermann m n - 1]\n    ]\n]<\/pre>\n\n==[[:Category:REXX|REXX]][[Category:REXX]]==\n===version 1===\n<lang rexx>ackermann: procedure;   parse arg m,n\n\nif m==0 then return n+1\nif n==0 then return ackermann(m-1,1)\n             return ackermann(m-1,ackermann(m,n-1))<\/lang>\n===version 2===\n<lang rexx>\/*REXX program calculates\/shows some values for the Ackermann function. *\/\n\n                     \/*Note: the Ackermann function (as implemented) is *\/\n                     \/*      higly recursive and is limited by the      *\/\n                     \/*      biggest number that can have \"1\" added to  *\/\n                     \/*      a number (successfully, accurately).       *\/\nhigh=24\n         do j=0 to 3;   say\n              do k=0 to high%(max(1,j))\n              call Ackermann_tell j,k\n              end   \/*k*\/\n         end        \/*j*\/\nexit\n\/*\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500ACKERMANN_TELL subroutine (echo). *\/\nackermann_tell: parse arg mm,nn;    calls=0   \/*display an echo message.*\/\nnnn=right(nn,length(high))\nsay 'Ackermann('mm\",\"nnn')='right(ackermann(mm,nn),digits()),\n                             left('',12) 'calls='right(calls,digits()%2)\nreturn\n\/*\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500ACKERMANN subroutine (recusive).  *\/\nackermann: procedure expose calls       \/*compute the Ackerman function.*\/\nparse arg m,n;      calls=calls+1\nif m==0 then return n+1\nif n==0 then return ackermann(m-1,1)\nif m==2 then return n*2+3\n             return ackermann(m-1,ackermann(m,n-1))<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre style=\"height:30ex;overflow:scroll\">\nAckermann(0, 0)=        1              calls=   1\nAckermann(0, 1)=        2              calls=   1\nAckermann(0, 2)=        3              calls=   1\nAckermann(0, 3)=        4              calls=   1\nAckermann(0, 4)=        5              calls=   1\nAckermann(0, 5)=        6              calls=   1\nAckermann(0, 6)=        7              calls=   1\nAckermann(0, 7)=        8              calls=   1\nAckermann(0, 8)=        9              calls=   1\nAckermann(0, 9)=       10              calls=   1\nAckermann(0,10)=       11              calls=   1\nAckermann(0,11)=       12              calls=   1\nAckermann(0,12)=       13              calls=   1\nAckermann(0,13)=       14              calls=   1\nAckermann(0,14)=       15              calls=   1\nAckermann(0,15)=       16              calls=   1\nAckermann(0,16)=       17              calls=   1\nAckermann(0,17)=       18              calls=   1\nAckermann(0,18)=       19              calls=   1\nAckermann(0,19)=       20              calls=   1\nAckermann(0,20)=       21              calls=   1\nAckermann(0,21)=       22              calls=   1\nAckermann(0,22)=       23              calls=   1\nAckermann(0,23)=       24              calls=   1\nAckermann(0,24)=       25              calls=   1\n\nAckermann(1, 0)=        2              calls=   2\nAckermann(1, 1)=        3              calls=   4\nAckermann(1, 2)=        4              calls=   6\nAckermann(1, 3)=        5              calls=   8\nAckermann(1, 4)=        6              calls=  10\nAckermann(1, 5)=        7              calls=  12\nAckermann(1, 6)=        8              calls=  14\nAckermann(1, 7)=        9              calls=  16\nAckermann(1, 8)=       10              calls=  18\nAckermann(1, 9)=       11              calls=  20\nAckermann(1,10)=       12              calls=  22\nAckermann(1,11)=       13              calls=  24\nAckermann(1,12)=       14              calls=  26\nAckermann(1,13)=       15              calls=  28\nAckermann(1,14)=       16              calls=  30\nAckermann(1,15)=       17              calls=  32\nAckermann(1,16)=       18              calls=  34\nAckermann(1,17)=       19              calls=  36\nAckermann(1,18)=       20              calls=  38\nAckermann(1,19)=       21              calls=  40\nAckermann(1,20)=       22              calls=  42\nAckermann(1,21)=       23              calls=  44\nAckermann(1,22)=       24              calls=  46\nAckermann(1,23)=       25              calls=  48\nAckermann(1,24)=       26              calls=  50\n\nAckermann(2, 0)=        3              calls=   5\nAckermann(2, 1)=        5              calls=   1\nAckermann(2, 2)=        7              calls=   1\nAckermann(2, 3)=        9              calls=   1\nAckermann(2, 4)=       11              calls=   1\nAckermann(2, 5)=       13              calls=   1\nAckermann(2, 6)=       15              calls=   1\nAckermann(2, 7)=       17              calls=   1\nAckermann(2, 8)=       19              calls=   1\nAckermann(2, 9)=       21              calls=   1\nAckermann(2,10)=       23              calls=   1\nAckermann(2,11)=       25              calls=   1\nAckermann(2,12)=       27              calls=   1\n\nAckermann(3, 0)=        5              calls=   2\nAckermann(3, 1)=       13              calls=   4\nAckermann(3, 2)=       29              calls=   6\nAckermann(3, 3)=       61              calls=   8\nAckermann(3, 4)=      125              calls=  10\nAckermann(3, 5)=      253              calls=  12\nAckermann(3, 6)=      509              calls=  14\nAckermann(3, 7)=     1021              calls=  16\nAckermann(3, 8)=     2045              calls=  18\n<\/pre>\n===version 3===\nThis REXX version takes advantage that some of the lower Ackermann numbers have direct formulas.\n<br><br>If the '''NUMERIC DIGITS 100''' were to be increased to '''20,000''', then '''Ackermann(4,2)''' would be presented with the full 19,729 digits. \n<lang rexx>\/*REXX program calculates\/shows some values for the Ackermann function. *\/\n\n                     \/*Note: the Ackermann function (as implemented) is *\/\n                     \/*      higly recursive and is limited by the      *\/\n                     \/*      biggest number that can have \"1\" added to  *\/\n                     \/*      a number (successfully, accurately).       *\/\n\nnumeric digits 100        \/*have REXX to use up to  100  digit integers.*\/\n\n                          \/*When REXX raises a number to a power  (via  *\/\n                          \/*  the   **  operator), the power must be an *\/\n                          \/*  integer  (positive,  zero,  or negative). *\/\n\n       do j=0 to 4        \/*Ackermann(5,1) is a bit impractical to calc.*\/\n       say                \/*display a blank (separator) line.           *\/\n             do k=0 to 15\n             call Ackermann_tell j,k\n             if j==4 & k==2 then leave    \/*no sense in going overboard.*\/\n             end   \/*k*\/\n       end         \/*j*\/\nexit\n\/*\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500ACKERMANN_TELL subroutine (echo). *\/\nackermann_tell: parse arg mm,nn               \/*display an echo message.*\/\nsay '\u2500\u2500\u2500 Ackermann('mm\",\"right(nn,2)')='ackermann(mm,nn)\nreturn\n\/*\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500ACKERMANN subroutine (recusive).  *\/\nackermann: procedure                    \/*compute the Ackerman function.*\/\nparse arg m,n\nif m==0 then return n+1\nif m==1 then return n+2\nif m==2 then return n+n+3\nif m==3 then return 2**(n+3)-3\nif m==4 then do;  a=2;         do  (n+3) - 1       \/*ugh, heavy lifting.*\/\n                               a=2**a\n                               end\n             return a-3\n             end\nif n==0 then return ackermann(m-1,1)\n             return ackermann(m-1,ackermann(m,n-1))<\/lang>\n<div>\n;Selected output<nowiki>:<\/nowiki><\/div>\n<pre>\n\u2500\u2500\u2500 Ackermann(0, 0)=1\n\u2500\u2500\u2500 Ackermann(0, 1)=2\n\u2500\u2500\u2500 Ackermann(0, 2)=3\n\u2026\n\u2500\u2500\u2500 Ackermann(3,12)=32765\n\u2500\u2500\u2500 Ackermann(3,13)=65533\n\u2500\u2500\u2500 Ackermann(3,14)=131069\n\u2500\u2500\u2500 Ackermann(3,15)=262141\n\n\u2500\u2500\u2500 Ackermann(4, 0)=13\n\u2500\u2500\u2500 Ackermann(4, 1)=65533\n\u2500\u2500\u2500 Ackermann(4, 2)=2.003529930406846464979072351560255750447825475569751419265016973710894059556311453089506130880933368E+19728\n<\/pre>\n\n==[[:Category:Ruby|Ruby]][[Category:Ruby]]==\n<div class=\"examplemeta translation\">'''Translation of''': [[Ackermann function#Ada|Ada]]<\/div>\n<lang ruby>def ack(m, n)\n  if m == 0\n    n + 1\n  elsif n == 0\n    ack(m-1, 1)\n  else\n    ack(m-1, ack(m, n-1))\n  end\nend<\/lang>\nExample:\n<lang ruby>(0..3).each do |m|\n  (0..6).each { |n| print ack(m, n), ' ' }\n  puts\nend<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre> 1 2 3 4 5 6 7 \n 2 3 4 5 6 7 8 \n 3 5 7 9 11 13 15 \n 5 13 29 61 125 253 509<\/pre>\n\n==[[:Category:Run BASIC|Run BASIC]][[Category:Run BASIC]]==\n<lang runbasic>print ackermann(1, 2)\n \nfunction ackermann(m, n)\n   if (m < 0) or (n < 0)  then exit function\n   if (m = 0)             then ackermann = (n + 1)\n   if (m > 0) and (n = 0) then ackermann = ackermann((m - 1), 1)\n   if (m > 0) and (n > 0) then ackermann = ackermann((m - 1), ackermann(m, (n - 1)))\nend function<\/lang>\n\n==[[:Category:Sather|Sather]][[Category:Sather]]==\n<lang sather>class MAIN is\n\n  ackermann(m, n:INT):INT\n    pre m >= 0 and n >= 0\n  is\n    if m = 0 then return n + 1; end;\n    if n = 0 then return ackermann(m-1, 1); end;\n    return ackermann(m-1, ackermann(m, n-1));\n  end;\n\n  main is\n    n, m :INT;\n    loop n := 0.upto!(6);\n      loop m := 0.upto!(3);\n        #OUT + \"A(\" + m + \", \" + n + \") = \" + ackermann(m, n) + \"\\n\";\n      end;\n    end; \n  end;\nend;<\/lang>\nInstead of <code>INT<\/code>, the class <code>INTI<\/code> could be used, even though we need to use a workaround since in the GNU Sather v1.2.3 compiler the INTI literals are not implemented yet.\n<lang sather>class MAIN is\n\n  ackermann(m, n:INTI):INTI is\n    zero ::= 0.inti; -- to avoid type conversion each time\n    one  ::= 1.inti;\n    if m = zero then return n + one; end;\n    if n = zero then return ackermann(m-one, one); end;\n    return ackermann(m-one, ackermann(m, n-one));\n  end;\n\n  main is\n    n, m :INT;\n    loop n := 0.upto!(6);\n      loop m := 0.upto!(3);\n        #OUT + \"A(\" + m + \", \" + n + \") = \" + ackermann(m.inti, n.inti) + \"\\n\";\n      end;\n    end; \n  end;\nend;<\/lang>\n\n==[[:Category:Scala|Scala]][[Category:Scala]]==\n<lang scala>def ack(m: BigInt, n: BigInt): BigInt = {\n  if (m==0) n+1\n  else if (n==0) ack(m-1, 1)\n  else ack(m-1, ack(m, n-1))\n}<\/lang>\n<div>\n;Example<nowiki>:<\/nowiki><\/div>\n<lang scala>scala> for ( m <- 0 to 3; n <- 0 to 6 ) yield ack(m,n)\nres0: Seq.Projection[BigInt] = RangeG(1, 2, 3, 4, 5, 6, 7, 2, 3, 4, 5, 6, 7, 8, 3, 5, 7, 9, 11, 13, 15, 5, 13, 29, 61, 125, 253, 509)<\/lang>\n\n==[[:Category:Scheme|Scheme]][[Category:Scheme]]==\n<lang scheme>(define (A m n)\n    (cond\n        ((= m 0) (+ n 1))\n        ((= n 0) (A (- m 1) 1))\n        (else (A (- m 1) (A m (- n 1))))))<\/lang>\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Racket]][[SMW::on]]<\/div> (moved from the Racket language entry, may be redundant) \n<lang scheme>#lang racket\n\n(define (ackermann m n)\n    (cond\n      ((zero? m) (add1 n))\n      ((and (> m 0) (zero? n)) (ackermann (sub1 m) 1))\n      ((and (> m 0) (> n 0)) (ackermann (sub1 m) (ackermann m (sub1 n))))))<\/lang>\n\n==[[:Category:Seed7|Seed7]][[Category:Seed7]]==\n<lang seed7>const func integer: ackermann (in integer: m, in integer: n) is func\n  result\n    var integer: result is 0;\n  begin\n    if m = 0 then\n      result := succ(n);\n    elsif n = 0 then\n      result := ackermann(pred(m), 1);\n    else\n      result := ackermann(pred(m), ackermann(m, pred(n)));\n    end if;\n  end func;<\/lang>\nOriginal source: [http:\/\/seed7.sourceforge.net\/algorith\/math.htm#ackermann]\n\n==[[:Category:SETL|SETL]][[Category:SETL]]==\n<lang SETL>program ackermann;\n\n(for m in [0..3])\n  print(+\/ [rpad('' + ack(m, n), 4): n in [0..6]]);\nend;\n\nproc ack(m, n);\n  return {[0,n+1]}(m) ? ack(m-1, {[0,1]}(n) ? ack(m, n-1));\nend proc;\n\nend program;<\/lang>\n\n==[[:Category:Slate|Slate]][[Category:Slate]]==\n<lang slate>m@(Integer traits) ackermann: n@(Integer traits)\n[\n  m isZero\n    ifTrue: [n + 1]\n    ifFalse:\n      [n isZero\n\t ifTrue: [m - 1 ackermann: n]\n\t ifFalse: [m - 1 ackermann: (m ackermann: n - 1)]]\n].<\/lang>\n\n==[[:Category:Smalltalk|Smalltalk]][[Category:Smalltalk]]==\n<lang smalltalk>|ackermann|\nackermann := [ :n :m |\n  (n = 0) ifTrue: [ (m + 1) ]\n          ifFalse: [\n           (m = 0) ifTrue: [ ackermann value: (n-1) value: 1 ]\n                   ifFalse: [\n                        ackermann value: (n-1)\n                                  value: ( ackermann value: n\n                                                     value: (m-1) )\n                   ]\n          ]\n].\n\n(ackermann value: 0 value: 0) displayNl.\n(ackermann value: 3 value: 4) displayNl.<\/lang>\n\n==[[:Category:SNOBOL4|SNOBOL4]][[Category:SNOBOL4]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Macro Spitbol]][[SMW::on]]<\/div>\nBoth Snobol4+ and CSnobol stack overflow, at ack(3,3) and ack(3,4), respectively.\n<lang SNOBOL4>define('ack(m,n)') :(ack_end)\nack     ack = eq(m,0) n + 1 :s(return)\n        ack = eq(n,0) ack(m - 1,1) :s(return)\n        ack = ack(m - 1,ack(m,n - 1)) :(return)\nack_end\n\n*       # Test and display ack(0,0) .. ack(3,6)\nL1      str = str ack(m,n) ' '\n        n = lt(n,6) n + 1 :s(L1)\n        output = str; str = ''\n        n = 0; m = lt(m,3) m + 1 :s(L1)\nend<\/lang>       \n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>1 2 3 4 5 6 7\n2 3 4 5 6 7 8\n3 5 7 9 11 13 15\n5 13 29 61 125 253 509<\/pre>\n\n==[[:Category:SNUSP|SNUSP]][[Category:SNUSP]]==\n<lang snusp>   \/==!\/==atoi=@@@-@-----#\n   |   |                          Ackermann function\n   |   |       \/=========\\!==\\!====\\  recursion:\n$,@\/>,@\/==ack=!\\?\\<+#    |   |     |   A(0,j) -> j+1\n j   i           \\<?\\+>-@\/#  |     |   A(i,0) -> A(i-1,1)\n                    \\@\\>@\\->@\/@\\<-@\/#  A(i,j) -> A(i-1,A(i,j-1))\n                      |  |     |\n            #      #  |  |     |             \/+<<<-\\  \n            \/-<<+>>\\!=\/  \\=====|==!\/========?\\>>>=?\/<<#\n            ?      ?           |   \\<<<+>+>>-\/\n            \\>>+<<-\/!==========\/\n            #      #<\/lang>\nOne could employ [[:Category:Recursion|tail recursion]] elimination by replacing \"@\/#\" with \"\/\" in two places above.\n\n==[[:Category:Standard ML|Standard ML]][[Category:Standard ML]]==\n<lang sml>fun a (0, n) = n+1\n  | a (m, 0) = a (m-1, 1)\n  | a (m, n) = a (m-1, a (m, n-1))<\/lang>\n\n==[[:Category:Tcl|Tcl]][[Category:Tcl]]==\n===Simple===\n<div class=\"examplemeta translation\">'''Translation of''': [[Ackermann function#Ruby|Ruby]]<\/div>\n<lang tcl>proc ack {m n} {\n    if {$m == 0} {\n        expr {$n + 1}\n    } elseif {$n == 0} {\n        ack [expr {$m - 1}] 1\n    } else {\n        ack [expr {$m - 1}] [ack $m [expr {$n - 1}]]\n    }\n}<\/lang>\n===With Tail Recursion===\nWith Tcl 8.6, this version is preferred (though the language supports tailcall optimization, it does not apply it automatically in order to preserve stack frame semantics):\n<lang tcl>proc ack {m n} {\n    if {$m == 0} {\n        expr {$n + 1}\n    } elseif {$n == 0} {\n        tailcall ack [expr {$m - 1}] 1\n    } else {\n        tailcall ack [expr {$m - 1}] [ack $m [expr {$n - 1}]]\n    }\n}<\/lang>\n===To Infinity\u2026 and Beyond!===\nIf we want to explore the higher reaches of the world of Ackermann's function, we need techniques to really cut the amount of computation being done.\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Tcl]] version 8.6[[SMW::on]]<\/div>\n<lang tcl>package require Tcl 8.6\n\n# A memoization engine, from http:\/\/wiki.tcl.tk\/18152\noo::class create cache {\n    filter Memoize\n    variable ValueCache\n    method Memoize args {\n        # Do not filter the core method implementations\n        if {[lindex [self target] 0] eq \"::oo::object\"} {\n            return [next {*}$args]\n        }\n\n        # Check if the value is already in the cache\n        set key [self target],$args\n        if {[info exist ValueCache($key)]} {\n            return $ValueCache($key)\n        }\n\n        # Compute value, insert into cache, and return it\n        return [set ValueCache($key) [next {*}$args]]\n    }\n    method flushCache {} {\n        unset ValueCache\n        # Skip the cacheing\n        return -level 2 \"\"\n    }\n}\n\n# Make an object, attach the cache engine to it, and define ack as a method\noo::object create cached\noo::objdefine cached {\n    mixin cache\n    method ack {m n} {\n        if {$m==0} {\n            expr {$n+1}\n        } elseif {$m==1} {\n            # From the Mathematica version\n            expr {$m+2}\n        } elseif {$m==2} {\n            # From the Mathematica version\n            expr {2*$n+3}\n        } elseif {$m==3} {\n            # From the Mathematica version\n            expr {8*(2**$n-1)+5}\n        } elseif {$n==0} {\n            tailcall my ack [expr {$m-1}] 1\n        } else {\n            tailcall my ack [expr {$m-1}] [my ack $m [expr {$n-1}]]\n        }\n    }\n}\n\n# Some small tweaks...\ninterp recursionlimit {} 100000\ninterp alias {} ack {} cacheable ack<\/lang>\nBut even with all this, you still run into problems calculating <math>\\mathit{ack}(4,3)<\/math> as that's kind-of large\u2026\n\n==[[:Category:TSE SAL|TSE SAL]][[Category:TSE SAL]]==\n<lang TSESAL>\/\/ library: math: get: ackermann: recursive <description><\/description> <version>1.0.0.0.5<\/version> <version control><\/version control> (filenamemacro=getmaare.s) [kn, ri, tu, 27-12-2011 14:46:59]\nINTEGER PROC FNMathGetAckermannRecursiveI( INTEGER mI, INTEGER nI )\n IF ( mI == 0 )\n  RETURN( nI + 1 )\n ENDIF\n IF ( nI == 0 )\n  RETURN( FNMathGetAckermannRecursiveI( mI - 1, 1 ) )\n ENDIF\n RETURN( FNMathGetAckermannRecursiveI( mI - 1, FNMathGetAckermannRecursiveI( mI, nI - 1 ) ) )\nEND\n\nPROC Main()\nSTRING s1[255] = \"2\"\nSTRING s2[255] = \"3\"\nIF ( NOT ( Ask( \"math: get: ackermann: recursive: m = \", s1, _EDIT_HISTORY_ ) ) AND ( Length( s1 ) > 0 ) ) RETURN() ENDIF\nIF ( NOT ( Ask( \"math: get: ackermann: recursive: n = \", s2, _EDIT_HISTORY_ ) ) AND ( Length( s2 ) > 0 ) ) RETURN() ENDIF\n Message( FNMathGetAckermannRecursiveI( Val( s1 ), Val( s2 ) ) ) \/\/ gives e.g. 9\nEND<\/lang>\n\n==[[:Category:TI-89 BASIC|TI-89 BASIC]][[Category:TI-89 BASIC]]==\n<lang ti89b>Define A(m,n) = when(m=0, n+1, when(n=0, A(m-1,1), A(m-1, A(m, n-1))))<\/lang>\n\n==[[:Category:UNIX Shell|UNIX Shell]][[Category:UNIX Shell]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Bash]][[SMW::on]]<\/div>\n<lang bash>ack() {\n  local m=$1\n  local n=$2\n  if [ $m -eq 0 ]; then\n    echo -n $((n+1))\n  elif [ $n -eq 0 ]; then\n    ack $((m-1)) 1\n  else\n    ack $((m-1)) $(ack $m $((n-1)))\n  fi\n}<\/lang>\nExample:\n<lang bash>for ((m=0;m<=3;m++)); do\n  for ((n=0;n<=6;n++)); do\n    ack $m $n\n    echo -n \" \"\n  done\n  echo\ndone<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>1 2 3 4 5 6 7\n2 3 4 5 6 7 8\n3 5 7 9 11 13 15\n5 13 29 61 125 253 509<\/pre>\n\n==[[:Category:Ursala|Ursala]][[Category:Ursala]]==\nAnonymous recursion is the usual way of doing things like this.\n<lang Ursala>#import std\n#import nat\n\nackermann = \n\n~&al^?\\successor@ar ~&ar?(\n   ^R\/~&f ^\/predecessor@al ^|R\/~& ^|\/~& predecessor,\n   ^|R\/~& ~&\\1+ predecessor@l)<\/lang>\ntest program for the first 4 by 7 numbers:\n<lang Ursala>#cast %nLL\n\ntest = block7 ackermann*K0 iota~~\/4 7<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>\n<\n   <1,2,3,4,5,6,7>,\n   <2,3,4,5,6,7,8>,\n   <3,5,7,9,11,13,15>,\n   <5,13,29,61,125,253,509>><\/pre>\n\n==[[:Category:V|V]][[Category:V]]==\n<div class=\"examplemeta translation\">'''Translation of''': [[Ackermann function#Joy|Joy]]<\/div>\n<lang v>[ack\n       [ [pop zero?] [popd succ]\n         [zero?]     [pop pred 1 ack]\n         [true]      [[dup pred swap] dip pred ack ack ]\n       ] when].<\/lang>\nusing destructuring view\n<lang v>[ack\n       [ [pop zero?] [ [m n : [n succ]] view i]\n         [zero?]     [ [m n : [m pred 1 ack]] view i]\n         [true]      [ [m n : [m pred m n pred ack ack]] view i]\n       ] when].<\/lang>\n\n==[[:Category:VBScript|VBScript]][[Category:VBScript]]==\nBased on BASIC version. Uncomment all the lines referring to <code>depth<\/code> and see just how deep the recursion goes.\n;Implementation\n<lang vb>option explicit\n'~ dim depth\nfunction ack(m, n)\n\t'~ wscript.stdout.write depth & \" \"\n\tif m = 0 then \n\t\t'~ depth = depth + 1\n\t\tack = n + 1\n\t\t'~ depth = depth - 1\n\telseif m > 0 and n = 0 then\n\t\t'~ depth = depth + 1\n\t\tack = ack(m - 1, 1)\n\t\t'~ depth = depth - 1\n\t'~ elseif m > 0 and n > 0 then\n\telse\n\t\t'~ depth = depth + 1\n\t\tack = ack(m - 1, ack(m, n - 1))\n\t\t'~ depth = depth - 1\n\tend if\n\t\nend function<\/lang>\n;Invocation\n<lang vb>wscript.echo ack( 1, 10 )\n'~ depth = 0\nwscript.echo ack( 2, 1 )\n'~ depth = 0\nwscript.echo ack( 4, 4 )<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>\n12\n5\nC:\\foo\\ackermann.vbs(16, 3) Microsoft VBScript runtime error: Out of stack space: 'ack'\n<\/pre>\n\n==[[:Category:XPL0|XPL0]][[Category:XPL0]]==\n<lang XPL0>include c:\\cxpl\\codes;\n\nfunc Ackermann(M, N);\nint M, N;\n[if M=0 then return N+1;\n if N=0 then return Ackermann(M-1, 1);\nreturn Ackermann(M-1, Ackermann(M, N-1));\n]; \\Ackermann\n\nint M, N;\n[for M:= 0 to 3 do\n    [for N:= 0 to 7 do\n        [IntOut(0, Ackermann(M, N));  ChOut(0,9\\tab\\)];\n    CrLf(0);\n    ];\n]<\/lang>\nRecursion overflows the stack if either M or N is extended by a single count.\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>\n1       2       3       4       5       6       7       8       \n2       3       4       5       6       7       8       9       \n3       5       7       9       11      13      15      17      \n5       13      29      61      125     253     509     1021    \n<\/pre>\n\n==[[:Category:Yorick|Yorick]][[Category:Yorick]]==\n<lang yorick>func ack(m, n) {\n    if(m == 0)\n        return n + 1;\n    else if(n == 0)\n        return ack(m - 1, 1);\n    else\n        return ack(m - 1, ack(m, n - 1));\n}<\/lang>\nExample invocation:\n<lang yorick>for(m = 0; m <= 3; m++) {\n    for(n = 0; n <= 6; n++)\n        write, format=\"%d \", ack(m, n);\n    write, \"\";\n}<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>1 2 3 4 5 6 7  \n2 3 4 5 6 7 8  \n3 5 7 9 11 13 15  \n5 13 29 61 125 253 509<\/pre>\n\n[[Category:LaTeX\/Omit]]\n[[Category:Make\/Omit]]\n[[Category:PlainTeX\/Omit]]"}]}}}}