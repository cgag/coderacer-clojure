{"query-continue":{"search":{"gsroffset":1},"revisions":{"rvstartid":136497}},"query":{"pages":{"3114":{"pageid":3114,"ns":0,"title":"Align columns","revisions":[{"*":"<div class=\"infobox\" style=\"width: 2in\">[[File:Rcode-button-task-crushed.png|64px|left|alt=Task|link=Category:Solutions by Programming Task]]'''Align columns'''<br\/>\nYou are encouraged to [[Rosetta Code:Solve a Task|solve this task]] according to the task description, using any language you may know.[[Category:Programming Tasks]][[Category:Text processing]]<\/div>\nGiven a text file of many lines, where fields within a line \nare delineated by a single 'dollar' character, write a program\nthat aligns each column of fields by ensuring that words in each \ncolumn are separated by at least one space.\nFurther, allow for each word in a column to be either left \njustified, right justified, or center justified within its column.\n\n<br clear=all>Use the following text to test your programs:\n<pre>Given$a$text$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$'dollar'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.<\/pre>\n\nNote that:\n# The example input texts lines may, or may not, have trailing dollar characters.\n# All columns should share the same alignment.\n# Consecutive space characters produced adjacent to the end of lines are insignificant for the purposes of the task.\n# Output text will be viewed in a mono-spaced font on a plain text editor or basic terminal.\n# The minimum space between columns should be computed from the text and not hard-coded.\n# It is ''not'' a requirement to add separating characters between or around columns.\n\n==[[:Category:ABAP|ABAP]][[Category:ABAP]]==\n<lang ABAP>report z_align no standard page header.\nstart-of-selection.\n\ndata: lt_strings type standard table of string,\n      lv_strings type string.\nappend: 'Given$a$text$file$of$many$lines,$where$fields$within$a$line$' to lt_strings,\n        'are$delineated$by$a$single$''dollar''$character,$write$a$program' to lt_strings,\n        'that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$' to lt_strings,\n        'column$are$separated$by$at$least$one$space.' to lt_strings,\n        'Further,$allow$for$each$word$in$a$column$to$be$either$left$' to lt_strings,\n        'justified,$right$justified,$or$center$justified$within$its$column.' to lt_strings.\ntypes ty_strings type standard table of string.\n\nperform align_col using 'LEFT' lt_strings.\nskip.\nperform align_col using 'RIGHT' lt_strings.\nskip.\nperform align_col using 'CENTER' lt_strings.\n\n\nform align_col using iv_just type string iv_strings type ty_strings.\n  constants: c_del value '$'.\n  data: lv_string type string,\n        lt_strings type table of string,\n        lt_tables like table of lt_strings,\n        lv_first type string,\n        lv_second type string,\n        lv_longest type i value 0,\n        lv_off type i value 0,\n        lv_len type i.\n  \" Loop through the supplied text. It is expected at the input is a table of strings, with each\n  \" entry in the table representing a new line of the input.\n  loop at iv_strings into lv_string.\n    \" Split the current line at the delimiter.\n    split lv_string at c_del into lv_first lv_second.\n    \" Loop through the line splitting at every delimiter.\n    do.\n      append lv_first to lt_strings.\n      lv_len = strlen( lv_first ).\n      \" Check if the length of the new string is greater than the currently stored length.\n      if lv_len > lv_longest.\n        lv_longest = lv_len.\n      endif.\n      if lv_second na c_del.\n        \" Check if the string is longer than the recorded maximum.\n        lv_len = strlen( lv_second ).\n        if lv_len > lv_longest.\n          lv_longest = lv_len.\n        endif.\n        append lv_second to lt_strings.\n        exit.\n      endif.\n      split lv_second at c_del into lv_first lv_second.\n    enddo.\n\n    append lt_strings to lt_tables.\n    clear lt_strings.\n  endloop.\n\n  \" Loop through each line of input.\n  loop at lt_tables into lt_strings.\n    \" Loop through each word in the line (Separated by specified delimiter).\n    loop at lt_strings into lv_string.\n      lv_off = ( sy-tabix - 1 ) * ( lv_longest + 2 ).\n      case iv_just.\n        when 'LEFT'.\n          write : at (lv_longest) lv_string left-justified.\n        when 'RIGHT'.\n          write at (lv_longest) lv_string right-justified.\n        when 'CENTER'.\n          write at (lv_longest) lv_string centered.\n      endcase.\n    endloop.\n    skip.\n    sy-linno = sy-linno - 1.\n  endloop.\nendform.<\/lang>\n\n<pre style=\"height:15ex;overflow:scroll\">Given      a          text       file       of         many       lines,     where      fields     within     a          line\nare        delineated by         a          single     'dollar'   character, write      a          program\nthat       aligns     each       column     of         fields     by         ensuring   that       words      in         each\ncolumn     are        separated  by         at         least      one        space.\nFurther,   allow      for        each       word       in         a          column     to         be         either     left\njustified, right      justified, or         center     justified  within     its        column.\n\n     Given          a       text       file         of       many     lines,      where     fields     within          a       line\n       are delineated         by          a     single   'dollar' character,      write          a    program\n      that     aligns       each     column         of     fields         by   ensuring       that      words         in       each\n    column        are  separated         by         at      least        one     space.\n  Further,      allow        for       each       word         in          a     column         to         be     either       left\njustified,      right justified,         or     center  justified     within        its    column.\n\n  Given        a         text       file        of        many      lines,     where      fields     within       a         line\n   are     delineated     by         a        single    'dollar'  character,   write        a       program\n   that      aligns      each      column       of       fields       by      ensuring     that      words        in        each\n  column      are     separated      by         at       least       one       space.\n Further,    allow       for        each       word        in         a        column       to         be       either      left\njustified,   right    justified,     or       center   justified    within      its      column.<\/pre>\n\n==[[:Category:Ada|Ada]][[Category:Ada]]==\n<div class=\"examplemeta libheader\">'''Library:''' [[SMW::off]][[:Category:Simple components for Ada|Simple components for Ada]][[Category:Simple components for Ada]][[SMW::on]]<\/div>\n<lang ada>with Ada.Characters.Latin_1;  use Ada.Characters.Latin_1;\nwith Ada.Text_IO;             use Ada.Text_IO;\nwith Strings_Edit;            use Strings_Edit; \n\nprocedure Column_Aligner is\n   Text : constant String :=\n      \"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\" & NUL &\n      \"are$delineated$by$a$single$'dollar'$character,$write$a$program\" & NUL &\n      \"that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\" & NUL &\n      \"column$are$separated$by$at$least$one$space.\" & NUL &\n      \"Further,$allow$for$each$word$in$a$column$to$be$either$left$\" & NUL &\n      \"justified,$right$justified,$or$center$justified$within$its$column.\" & NUL;\n   File    : File_Type;\n   Width   : array (1..1_000) of Natural := (others => 0);\n   Line    : String (1..200);\n   Column  : Positive := 1;\n   Start   : Positive := 1;\n   Pointer : Positive;\nbegin\n   Create (File, Out_File, \"columned.txt\");\n      -- Determining the widths of columns\n   for I in Text'Range loop\n      case Text (I) is\n         when '$' | NUL =>\n            Width (Column) := Natural'Max (Width (Column), I - Start + 1);\n            Start  := I + 1;\n            if Text (I) = NUL then\n               Column := 1;\n            else\n               Column := Column + 1;\n            end if;\n         when others =>\n            null;\n      end case;\n   end loop;\n      -- Formatting\n   for Align in Alignment loop\n      Column  := 1;\n      Start   := 1;\n      Pointer := 1;\n      for I in Text'Range loop\n         case Text (I) is\n            when '$' | NUL =>\n               Put -- Formatted output of a word\n               (  Destination => Line,\n                  Pointer     => Pointer,\n                  Value       => Text (Start..I - 1),\n                  Field       => Width (Column),\n                  Justify     => Align\n               );\n               Start  := I + 1;\n               if Text (I) = NUL then\n                  Put_Line (File, Line (1..Pointer - 1));\n                  Pointer := 1;\n                  Column := 1;\n               else\n                  Column := Column + 1;\n               end if;\n            when others =>\n               null;\n         end case;\n      end loop;\n   end loop;\n   Close (File);\nend Column_Aligner;<\/lang>\nFormatted file sample:\n<pre style=\"height:15ex;overflow:scroll\">\nGiven      a          text       file   of     many      lines,     where    fields  within  a      line  \nare        delineated by         a      single 'dollar'  character, write    a       program \nthat       aligns     each       column of     fields    by         ensuring that    words   in     each  \ncolumn     are        separated  by     at     least     one        space.   \nFurther,   allow      for        each   word   in        a          column   to      be      either left  \njustified, right      justified, or     center justified within     its      column. \n      Given          a       text   file     of      many     lines,    where  fields  within      a line \n        are delineated         by      a single  'dollar' character,    write       a program\n       that     aligns       each column     of    fields         by ensuring    that   words     in each \n     column        are  separated     by     at     least        one   space.\n   Further,      allow        for   each   word        in          a   column      to      be either left \n justified,      right justified,     or center justified     within      its column.\n   Given        a        text     file    of      many     lines,     where   fields  within    a   line  \n    are    delineated     by        a   single  'dollar' character,   write     a    program \n   that      aligns      each    column   of     fields      by     ensuring   that   words    in   each  \n  column       are     separated   by     at     least       one     space.  \n Further,     allow       for     each   word      in         a      column     to      be   either left  \njustified,    right   justified,   or   center justified   within      its   column. \n<\/pre>\n==[[:Category:ALGOL 68|ALGOL 68]][[Category:ALGOL 68]]==\n<lang algol68>STRING nl = REPR 10;\nSTRING text in list := \"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\"+nl+\n  \"are$delineated$by$a$single$'dollar'$character,$write$a$program\"+nl+\n  \"that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\"+nl+\n  \"column$are$separated$by$at$least$one$space.\"+nl+\n  \"Further,$allow$for$each$word$in$a$column$to$be$either$left$\"+nl+\n  \"justified,$right$justified,$or$center$justified$within$its$column.\";\n\nMODE PAGE = FLEX[0,0]STRING;\nPAGE page;\n\nPROC flex page = (PAGE in page, INT row, col)PAGE:(\n  HEAP FLEX[row, col]STRING out page;\n  out page[:1 UPB in page, :2 UPB in page] := in page;\n  FOR r TO row DO\n    FOR c FROM 2 UPB in page + 1 TO col DO out page[r,c]:=\"\" OD\n  OD;\n  FOR r FROM 1 UPB in page + 1 TO row DO\n    FOR c FROM 1 TO col DO out page[r,c]:=\"\" OD\n  OD;\n  out page\n);\n\nFILE text in file; \nassociate(text in file, text in list);\nmake term(text in file, \"$\");\n\non physical file end(text in file, (REF FILE skip)BOOL: stop iteration);\non logical file end(text in file, (REF FILE skip)BOOL: stop iteration);\nFOR row DO\n  on line end(text in file, (REF FILE skip)BOOL: stop iteration);\n  FOR col DO\n    STRING tok;\n    getf(text in file, ($gx$,tok));\n    IF row > 1 UPB page THEN page := flex page(page, row, 2 UPB page) FI; \n    IF col > 2 UPB page THEN page := flex page(page, 1 UPB page, col) FI; \n    page[row,col]:=tok\n  OD;\n  stop iteration: \n    SKIP\nOD;\nstop iteration: \n  SKIP;\n\nBEGIN\n  PROC aligner = (PAGE in page, PROC (STRING,INT)STRING aligner)VOID:(\n    PAGE page := in page;\n    [2 UPB page]INT max width;\n    FOR col TO 2 UPB page DO\n      INT max len:=0; FOR row TO UPB page DO IF UPB page[row,col]>max len THEN max len:=UPB page[row,col] FI OD;\n      FOR row TO UPB page DO page[row,col] := aligner(page[row,col], maxlen) OD\n    OD;\n    printf(($n(UPB page)(n(2 UPB page -1)(gx)gl)$,page))\n  );\n\n  PROC left = (STRING in, INT len)STRING: in + \" \"*(len - UPB in),\n       right = (STRING in, INT len)STRING: \" \"*(len - UPB in) + in,\n       centre = (STRING in, INT len)STRING: ( INT pad=len-UPB in;  pad%2*\" \"+ in + (pad-pad%2)*\" \" );\n  \n  []STRUCT(STRING name, PROC(STRING,INT)STRING align) aligners = ((\"Left\",left), (\"Left\",right), (\"Centre\",centre));\n  \n  FOR index TO UPB aligners DO \n    print((new line, \"# \",name OF aligners[index],\" Column-aligned output:\",new line));\n    aligner(page, align OF aligners[index]) \n  OD\nEND<\/lang>\n\n==[[:Category:AutoHotkey|AutoHotkey]][[Category:AutoHotkey]]==\n\n<lang AutoHotkey>lines = \n(\n|$|$|$|$|$|$|$|$|$|$|$|\nGiven$a$text$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$'dollar'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.\n)\n\nClipboard := ColumnJustify(lines, \"l\")\n\nMsgBox, , Column Justify, The clipboard now contains the justified text. Paste it into a text editor to see it.\n\nColumnJustify(lines, lcr = \"l\", del=\"$\")\n{\n  Loop, Parse, lines, `n, `r\n    Loop, Parse, A_LoopField, %del%\n    {\n      If ((t := StrLen(A_LoopField)) > c%A_Index% )\n        c%A_Index% :=  t\n      If (t > max)\n        max := t\n    }\n  blank := Fill( \" \", max )\n  If (lcr = \"l\") ;left-justify\n    Loop, Parse, lines, `n, `r\n      Loop, Parse, A_LoopField, %del%\n        out .= (A_Index = 1 ? \"`n\" : \" \") SubStr(A_LoopField blank, 1, c%A_Index%)\n  Else If (lcr = \"r\") ;right-justify\n    Loop, Parse, lines, `n, `r\n      Loop, Parse, A_LoopField, %del%\n        out .= (A_Index = 1 ? \"`n\" : \" \") SubStr(blank A_LoopField, -c%A_Index%+1)\n  Else If (lcr = \"c\") ;center-justify\n    Loop, Parse, lines, `n, `r\n      Loop, Parse, A_LoopField, %del%\n        out .= (A_Index = 1 ? \"`n\" : \" \") SubStr(blank A_LoopField blank\n          , (Ceil((max * 2 + StrLen(A_LoopField))\/2) - Ceil(c%A_Index%\/2) + 1)\n          , c%A_Index%)\n  return SubStr(out, 2)\n}\n\nFill(chr, len)\n{\n  static y\n  if !y\n    VarSetCapacity(x, 64), VarSetCapacity(x, 0), y := True\n  return x, VarSetCapacity(x, len, Asc(chr))\n}<\/lang>\n\n==[[:Category:AWK|AWK]][[Category:AWK]]==\n\n<lang awk>BEGIN {\n  FS=\"$\"\n  lcounter = 1\n  maxfield = 0\n  # justistification; pick up one\n  #justify = \"left\"\n  justify = \"center\"\n  #justify = \"right\"\n}\n{\n  if ( NF > maxfield ) maxfield = NF;\n  for(i=1; i <= NF; i++) {\n    line[lcounter,i] = $i\n    if ( longest[i] == \"\" ) longest[i] = 0;\n    if ( length($i) > longest[i] ) longest[i] = length($i);\n  }\n  lcounter++\n}\nEND {\n  just = (justify == \"left\") ? \"-\" : \"\"\n  for(i=1; i <= NR; i++) {\n    for(j=1; j <= maxfield; j++) {\n      if ( justify != \"center\" ) {\n\ttemplate = \"%\" just longest[j] \"s \"\n      } else {\n\tv = int((longest[j] - length(line[i,j]))\/2)\n\trt = \"%\" v+1 \"s%%-%ds\"\n\ttemplate = sprintf(rt, \"\", longest[j] - v)\n      }\n      printf(template, line[i,j])\n    }\n    print \"\"\n  }\n}<\/lang>\n\n==[[:Category:BBC BASIC|BBC BASIC]][[Category:BBC BASIC]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[BBC BASIC for Windows]][[SMW::on]]<\/div>\n<lang bbcbasic>      DATA 6\n      DATA \"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\"\n      DATA \"are$delineated$by$a$single$'dollar'$character,$write$a$program\"\n      DATA \"that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\"\n      DATA \"column$are$separated$by$at$least$one$space.\"\n      DATA \"Further,$allow$for$each$word$in$a$column$to$be$either$left$\"\n      DATA \"justified,$right$justified,$or$center$justified$within$its$column.\"\n      \n      REM First find the maximum length of a 'word':\n      max% = 0\n      READ nlines%\n      FOR Line% = 1 TO nlines%\n        READ text$\n        REPEAT\n          word$ = FNword(text$, \"$\")\n          IF LEN(word$) > max% THEN max% = LEN(word$)\n        UNTIL word$ = \"\"\n      NEXT Line%\n      @% = max% : REM set column width\n      \n      REM Now display the aligned text:\n      RESTORE\n      READ nlines%\n      FOR Line% = 1 TO nlines%\n        READ text$\n        REPEAT\n          word$ = FNword(text$, \"$\")\n          PRINT FNjustify(word$, max%, \"left\"),;\n        UNTIL word$ = \"\"\n        PRINT\n      NEXT Line%\n      \n      END\n      \n      DEF FNword(text$, delim$)\n      PRIVATE delim%\n      LOCAL previous%\n      IF delim% = 0 THEN\n        previous% = 1\n      ELSE\n        previous% = delim% + LEN(delim$)\n      ENDIF\n      delim% = INSTR(text$+delim$, delim$, previous%)\n      IF delim% = 0 THEN\n        = \"\"\n      ELSE\n        = MID$(text$, previous%, delim%-previous%) + \" \"\n      ENDIF\n      \n      DEF FNjustify(word$, field%, mode$)\n      IF word$ = \"\" THEN = \"\"\n      CASE mode$ OF\n        WHEN \"center\": = STRING$((field%-LEN(word$)) DIV 2, \" \") + word$\n        WHEN \"right\": = STRING$(field%-LEN(word$), \" \") + word$\n      ENDCASE\n      = word$<\/lang>\n\n==[[:Category:C|C]][[Category:C]]==\nSee [[Column Aligner\/C]]\n\n==[[:Category:C++|C++]][[Category:C++]]==\nSee [[Column Aligner\/C++]]\n\n==<span id=\"C sharp\">[[:Category:C sharp|C#]]<\/span>[[Category:C sharp]]==\nUses a delegate, which were added to the language in C# 2, to define left-, right-, or center-justified.\n\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[C sharp|C#]] version 2+[[SMW::on]]<\/div>\n\n<lang csharp>using System;\nclass ColumnAlignerProgram\n{\n    delegate string Justification(string s, int width);\n\n    static string[] AlignColumns(string[] lines, Justification justification)\n    {\n        const char Separator = '$';\n        \/\/ build input table and calculate columns count\n        string[][] table = new string[lines.Length][];\n        int columns = 0;\n        for (int i = 0; i < lines.Length; i++)\n        {\n            string[] row = lines[i].TrimEnd(Separator).Split(Separator);\n            if (columns < row.Length) columns = row.Length;\n            table[i] = row;\n        }\n        \/\/ create formatted table\n        string[][] formattedTable = new string[table.Length][];\n        for (int i = 0; i < formattedTable.Length; i++)\n        {\n            formattedTable[i] = new string[columns];\n        }\n        for (int j = 0; j < columns; j++)\n        {\n            \/\/ get max column width\n            int columnWidth = 0;\n            for (int i = 0; i < table.Length; i++)\n            {\n                if (j < table[i].Length && columnWidth < table[i][j].Length)\n                    columnWidth = table[i][j].Length;\n            }\n            \/\/ justify column cells\n            for (int i = 0; i < formattedTable.Length; i++)\n            {\n                if (j < table[i].Length)\n                    formattedTable[i][j] = justification(table[i][j], columnWidth);\n                else \n                    formattedTable[i][j] = new String(' ', columnWidth);\n            }\n        }\n        \/\/ create result\n        string[] result = new string[formattedTable.Length];\n        for (int i = 0; i < result.Length; i++)\n        {\n            result[i] = String.Join(\" \", formattedTable[i]);\n        }\n        return result;\n    }\n\n    static string JustifyLeft(string s, int width) { return s.PadRight(width); }\n    static string JustifyRight(string s, int width) { return s.PadLeft(width); }\n    static string JustifyCenter(string s, int width) \n    { \n        return s.PadLeft((width + s.Length) \/ 2).PadRight(width); \n    }\n\n    static void Main()\n    {\n        string[] input = {    \n            \"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\",\n            \"are$delineated$by$a$single$'dollar'$character,$write$a$program\",\n            \"that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\",\n            \"column$are$separated$by$at$least$one$space.\",\n            \"Further,$allow$for$each$word$in$a$column$to$be$either$left$\",\n            \"justified,$right$justified,$or$center$justified$within$its$column.\",\n        };\n\n        foreach (string line in AlignColumns(input, JustifyCenter))\n        {\n            Console.WriteLine(line);\n        }\n    }\n}<\/lang>\n\nOutput (centered):\n\n<pre>\n  Given        a         text     file    of     many      lines,    where   fields  within    a    line\n   are     delineated     by       a    single 'dollar'  character,  write      a    program            \n   that      aligns      each    column   of    fields       by     ensuring  that    words    in   each\n  column      are     separated    by     at     least      one      space.                             \n Further,    allow       for      each   word     in         a       column    to      be    either left\njustified,   right    justified,   or   center justified   within     its    column.                    \n<\/pre>\n\n==[[:Category:Clojure|Clojure]][[Category:Clojure]]==\n<lang Clojure>\n(ns rosettacode.align-columns\n  (:require [clojure.contrib.string :as str]))\n\n(def data \"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$'dollar'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.\")\n\n(def table (map #(str\/split #\"\\$\" %) (str\/split-lines data)))\n\n(defn col-width [n table] (reduce max (map #(try (count (nth % n))\n                                               (catch Exception _  0))\n                                           table)))\n(defn spaces [n] (str\/repeat n \" \"))\n(defn add-padding\n  \"if the string is too big turncate it, else return a string with padding\"\n  [string width justification]\n  (if (>= (count string) width) (str\/take width string)\n      (let [pad-len (int (- width (count string))) ;we don't want rationals\n            half-pad-len (int (\/ pad-len 2))]\n        (case justification\n              :right (str (spaces pad-len) string)\n              :left  (str string (spaces pad-len))\n              :center (str (spaces half-pad-len) string (spaces (- pad-len half-pad-len)))))))\n\n(defn aligned-table\n  \"get the width of each column, then generate a new table with propper padding for eath item\"\n  ([table justification]\n  (let [col-widths (map #(+ 2 (col-width % table)) (range (count(first table))))]\n    (map\n     (fn [row] (map #(add-padding %1 %2 justification) row col-widths))\n     table))))\n\n(defn print-table\n  [table]\n  (do (println)\n      (print (str\/join \"\" (flatten (interleave table (repeat \"\\n\")))))))\n\n(print-table (aligned-table table :center))\n<\/lang>\n\n==[[:Category:CoffeeScript|CoffeeScript]][[Category:CoffeeScript]]==\n<lang coffeescript>\npad = (n) ->\n  s = ''\n  while n > 0\n    s += ' '\n    n -= 1\n  s\n\nalign = (input, alignment = 'center') ->\n  tokenized_lines = (line.split '$' for line in input)\n  col_widths = {}\n  for line in tokenized_lines\n    for token, i in line\n      if !col_widths[i]? or token.length > col_widths[i]\n        col_widths[i] = token.length\n  padders =\n    center: (s, width) ->\n      excess = width - s.length\n      left = Math.floor excess \/ 2\n      right = excess - left\n      pad(left) + s + pad(right)\n      \n    right: (s, width) ->\n      excess = width - s.length\n      pad(excess) + s\n      \n    left: (s, width) ->\n      excess = width - s.length\n      s + pad(excess)\n\n  padder = padders[alignment]\n        \n  for line in tokenized_lines\n    padded_tokens = (padder(token, col_widths[i]) for token, i in line)\n    console.log padded_tokens.join ' '\n  \n\ninput = [ \n  \"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\"\n  \"are$delineated$by$a$single$'dollar'$character,$write$a$program\"\n  \"that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\"\n  \"column$are$separated$by$at$least$one$space.\"\n  \"Further,$allow$for$each$word$in$a$column$to$be$either$left$\"\n  \"justified,$right$justified,$or$center$justified$within$its$column.\" \n]\n\nfor alignment in ['center', 'right', 'left']\n  console.log \"\\n----- #{alignment}\"\n  align input, alignment\n<\/lang>\noutput\n<lang>\n> coffee align_columns.coffee \n\n----- center\n  Given        a         text     file    of     many      lines,    where   fields  within    a    line \n   are     delineated     by       a    single 'dollar'  character,  write      a    program\n   that      aligns      each    column   of    fields       by     ensuring  that    words    in   each \n  column      are     separated    by     at     least      one      space. \n Further,    allow       for      each   word     in         a       column    to      be    either left \njustified,   right    justified,   or   center justified   within     its    column.\n\n----- right\n     Given          a       text   file     of      many     lines,    where  fields  within      a line \n       are delineated         by      a single  'dollar' character,    write       a program\n      that     aligns       each column     of    fields         by ensuring    that   words     in each \n    column        are  separated     by     at     least        one   space.\n  Further,      allow        for   each   word        in          a   column      to      be either left \njustified,      right justified,     or center justified     within      its column.\n\n----- left\nGiven      a          text       file   of     many      lines,     where    fields  within  a      line \nare        delineated by         a      single 'dollar'  character, write    a       program\nthat       aligns     each       column of     fields    by         ensuring that    words   in     each \ncolumn     are        separated  by     at     least     one        space.  \nFurther,   allow      for        each   word   in        a          column   to      be      either left \njustified, right      justified, or     center justified within     its      column.\n<\/lang>\n\n\n==[[:Category:Common Lisp|Common Lisp]][[Category:Common Lisp]]==\n<lang lisp>(defun nonempty (seq)\n  (position-if (lambda (x) (declare (ignore x)) t) seq))\n\n(defun split (delim seq)\n\"Splits seq on delim into a list of subsequences. Trailing empty\nsubsequences are removed.\"\n  (labels\n      ((f (seq &aux (pos (position delim seq)))\n          (if pos\n            (cons\n              (subseq seq 0 pos)\n              (f (subseq seq (1+ pos))))\n            (list seq))))\n    (let*\n        ((list (f seq))\n         (end (position-if #'nonempty list :from-end t)))\n      (subseq list 0 (1+ end)))))\n\n(defun lengthen (list minlen filler-elem &aux (len (length list)))\n\"Destructively pads list with filler-elem up to minlen.\"\n  (if (< len minlen)\n    (nconc list (make-list\n      (- minlen len) :initial-element filler-elem))\n    list))\n\n(defun align-columns (text &key (align :left) &aux\n    (fmtmod (case align\n      (:left \"@\")\n      (:right \":\")\n      (:center \"@:\")\n      (t (error \"Invalid alignment.\"))))\n    (fields (mapcar\n      (lambda (line) (split #\\$ line))\n      (split #\\Newline text)))\n    (mostcols (loop for l in fields maximize (length l)))\n    widest)\n  (setf fields (mapcar\n    (lambda (l) (lengthen l mostcols \"\"))\n    fields))\n  (setf widest (loop\n    for col below (length (first fields))\n    collect (loop\n      for row in fields maximize (length (elt row col)))))\n  (format nil\n    (with-output-to-string (s)\n      (princ \"~{~{\" s)\n      (dolist (w widest)\n        (format s \"~~~d~a<~~a~~>\" (1+ w) fmtmod))\n      (princ \"~}~%~}\" s))\n    fields))<\/lang>\n\n==[[:Category:D|D]][[Category:D]]==\n<lang d>import std.stdio, std.string, std.algorithm, std.array;\n\nvoid main() {\n    immutable T =\n\"Given$a$txt$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$'dollar'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.\";\n\n    const P = array(map!q{ a.chomp(\"$\").split(\"$\") }(splitLines(T)));\n\n    int[int] maxWidths;\n    foreach (line; P)\n        foreach (i, word; line)\n            maxWidths[i] = max(maxWidths.get(i, 0), word.length);\n\n    foreach (i, justify; [&leftJustify!string, &center!string,\n                          &rightJustify!string]) {\n        writeln([\"Left\", \"Center\", \"Right\"][i],\n                \" column-aligned output:\\n\");\n        foreach (line; P) {\n            foreach (j, word; line)\n                \/\/write(word.justify(maxWidths[j]), \" \");\n                write(justify(word, maxWidths[j]), \" \");\n            writeln();\n        }\n\n        writeln(\"- \".replicate(52));\n    }\n}<\/lang>\nOutput:\n<pre>Left column-aligned output:\n\nGiven      a          txt        file   of     many      lines,     where    fields  within  a      line \nare        delineated by         a      single 'dollar'  character, write    a       program \nthat       aligns     each       column of     fields    by         ensuring that    words   in     each \ncolumn     are        separated  by     at     least     one        space.   \nFurther,   allow      for        each   word   in        a          column   to      be      either left \njustified, right      justified, or     center justified within     its      column. \n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \nCenter column-aligned output:\n\n  Given        a         txt      file    of     many      lines,    where   fields  within    a    line \n   are     delineated     by       a    single 'dollar'  character,  write      a    program \n   that      aligns      each    column   of    fields       by     ensuring  that    words    in   each \n  column      are     separated    by     at     least      one      space.  \n Further,    allow       for      each   word     in         a       column    to      be    either left \njustified,   right    justified,   or   center justified   within     its    column. \n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \nRight column-aligned output:\n\n     Given          a        txt   file     of      many     lines,    where  fields  within      a line \n       are delineated         by      a single  'dollar' character,    write       a program \n      that     aligns       each column     of    fields         by ensuring    that   words     in each \n    column        are  separated     by     at     least        one   space. \n  Further,      allow        for   each   word        in          a   column      to      be either left \njustified,      right justified,     or center justified     within      its column. \n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <\/pre>\n\n==[[:Category:Delphi|Delphi]][[Category:Delphi]]==\n<div class=\"examplemeta libheader\">'''Library:''' [[SMW::off]][[:Category:Delphi StdCtrls, Classes, SysUtils, StrUtils, Contnrs|Delphi StdCtrls, Classes, SysUtils, StrUtils, Contnrs]][[Category:Delphi StdCtrls, Classes, SysUtils, StrUtils, Contnrs]][[SMW::on]]<\/div>\n<lang Delphi>\nUSES\n   StdCtrls, Classes, SysUtils, StrUtils, Contnrs;\n\nprocedure AlignByColumn(Output: TMemo; Align: TAlignment);\nconst\n   TextToAlign =\n   'Given$a$text$file$of$many$lines,$where$fields$within$a$line$'#$D#$A +\n   'are$delineated$by$a$single$''dollar''$character,$write$a$program'#$D#$A +\n   'that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$'#$D#$A +\n   'column$are$separated$by$at$least$one$space.'#$D#$A +\n   'Further,$allow$for$each$word$in$a$column$to$be$either$left$'#$D#$A +\n   'justified,$right$justified,$or$center$justified$within$its$column.';\nvar\n   TextLine, TempTString: TStringlist;\n   TextLines: TObjectList;\n   MaxLength, i, j: Byte;\n   OutPutString, EmptyString, Item: String;\nbegin\n   TRY\n      MaxLength := 0;\n      TextLines := TObjectList.Create(True);\n      TextLine := TStringList.Create;\n      TextLine.text := TextToAlign;\n      for i:= 0 to TextLine.Count - 1 do\n      begin\n         TempTString := TStringlist.create;\n         TempTString.text :=AnsiReplaceStr(TextLine[i], '$', #$D#$A);\n         TextLines.Add(TempTString);\n      end;\n      for i := 0 to TextLines.Count - 1 do\n         for j := 0 to TStringList(TextLines.Items[i]).Count - 1 do\n            If Length(TStringList(TextLines.Items[i])[j]) > MaxLength then\n               MaxLength := Length(TStringList(TextLines.Items[i])[j]);\n      If MaxLength > 0 then\n         MaxLength := MaxLength + 2; \/\/ Add to empty spaces to it\n      for i := 0 to TextLines.Count - 1 do\n      begin\n         OutPutString := '';\n         for j := 0 to TStringList(TextLines.Items[i]).Count - 1 do\n         begin\n            EmptyString := StringOfChar(' ', MaxLength);\n            Item := TStringList(TextLines.Items[i])[j];\n            case Align of\n               taLeftJustify: Move(Item[1], EmptyString[2], Length(Item));\n               taRightJustify: Move(Item[1], EmptyString[MaxLength - Length(Item) + 1], Length(Item));\n               taCenter: Move(Item[1], EmptyString[(MaxLength - Length(Item) + 1) div 2 + 1], Length(Item));\n            end;\n            OutPutString := OutPutString + EmptyString;\n         end;\n         Output.Lines.Add(OutPutString);\n      end;\n   FINALLY\n      FreeAndNil(TextLine);\n      FreeAndNil(TextLines);\n   END;\nend;\n<\/lang>\n\n==[[:Category:E|E]][[Category:E]]==\n\n<lang e>pragma.enable(\"accumulator\")\n\ndef left(width, word) {\n  return word + \" \" * (width - word.size())\n}\n\ndef center(width, word) {\n  def leftCount := (width - word.size()) \/\/ 2\n  return \" \" * leftCount + word + \" \" * (width - word.size() - leftCount)\n}\n\ndef right(width, word) {\n  return \" \" * (width - word.size()) + word\n}\n\ndef alignColumns(align, text) {\n    def split := accum [] for line in text.split(\"\\n\") { _.with(line.split(\"$\")) }\n    var widths := []\n    for line in split {\n      for i => word in line {\n        widths with= (i, widths.fetch(i, fn{0}).max(word.size()))\n      }\n    }\n    return accum \"\" for line in split { \n      _ + accum \"\" for i => word in line {\n        _ + align(widths[i] + 1, word)\n      } + \"\\n\"\n    }\n}<\/lang>\n\n<lang e>? def text := \"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$'dollar'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.\"; null\n\n? println(alignColumns(left, text))\nGiven      a          text       file   of     many      lines,     where    fields  within  a      line  \nare        delineated by         a      single 'dollar'  character, write    a       program \nthat       aligns     each       column of     fields    by         ensuring that    words   in     each  \ncolumn     are        separated  by     at     least     one        space.   \nFurther,   allow      for        each   word   in        a          column   to      be      either left  \njustified, right      justified, or     center justified within     its      column. \n\n? println(alignColumns(center, text))\n   Given        a        text     file    of      many     lines,     where   fields  within    a   line  \n    are    delineated     by        a   single  'dollar' character,   write     a    program \n   that      aligns      each    column   of     fields      by     ensuring   that   words    in   each  \n  column       are     separated   by     at     least       one     space.  \n Further,     allow       for     each   word      in         a      column     to      be   either left  \njustified,    right   justified,   or   center justified   within      its   column. \n\n? println(alignColumns(right, text))\n      Given          a       text   file     of      many     lines,    where  fields  within      a line \n        are delineated         by      a single  'dollar' character,    write       a program\n       that     aligns       each column     of    fields         by ensuring    that   words     in each \n     column        are  separated     by     at     least        one   space.\n   Further,      allow        for   each   word        in          a   column      to      be either left \n justified,      right justified,     or center justified     within      its column.<\/lang>\n\n==[[:Category:Erlang|Erlang]][[Category:Erlang]]==\n<lang Erlang>\n-module (align_columns).                                                                                                                                                       \n                                                                                                                                                                               \n-export([align_left\/0, align_right\/0, align_center\/0]).                                                                                                                        \n-define (Lines,                                                                                                                                                                \n         [\"Given\\$a\\$text\\$file\\$of\\$many\\$lines\\$where\\$fields\\$within\\$a\\$line\\$\",                                                                                           \n          \"are\\$delineated\\$by\\$a\\$single\\$'dollar'\\$character,\\$write\\$a\\$program\",                                                                                           \n          \"that\\$aligns\\$each\\$column\\$of\\$fields\\$by\\$ensuring\\$that\\$words\\$in\\$each\\$\",                                                                                     \n          \"column\\$are\\$separated\\$by\\$at\\$least\\$one\\$space.\",                                                                                                                \n          \"Further,\\$allow\\$for\\$each\\$word\\$in\\$a\\$column\\$to\\$be\\$either\\$left\\$\",                                                                                           \n          \"justified,\\$right\\$justified,\\$or\\$center\\$justified\\$within\\$its\\$column.\"].                                                                                       \n                                                                                                                                                                               \nalign_left()-> align_columns(left).                                                                                                                                            \nalign_right()-> align_columns(right).                                                                                                                                          \nalign_center()-> align_columns(centre).                                                                                                                                        \nalign_columns(Alignment) ->                                                                                                                                                    \n    Words = [ string:tokens(Line, \"\\$\") || Line <- ?Lines ],                                                                                                                   \n    Words_length  = lists:foldl( fun max_length\/2, [], Words),                                                                                                                 \n    Result = [prepare_line(Words_line, Words_length, Alignment)                                                                                                                \n              || Words_line <- Words],                                                                                                                                         \n                                                                                                                                                                               \n    [ io:fwrite(\"~s~n\", [lists:flatten(Line)]) || Line <- Result],                                                                                                             \n    ok.                                                                                                                                                                        \n                                                                                                                                                                               \nmax_length(Words_of_a_line, Acc_maxlength) ->                                                                                                                                  \n    Line_lengths = [length(W) || W <- Words_of_a_line ],                                                                                                                       \n    Max_nb_of_length = lists:max([length(Acc_maxlength), length(Line_lengths)]),                                                                                               \n    Line_lengths_prepared = adjust_list (Line_lengths, Max_nb_of_length, 0),                                                                                                   \n    Acc_maxlength_prepared = adjust_list(Acc_maxlength, Max_nb_of_length, 0),                                                                                                  \n    Two_lengths =lists:zip(Line_lengths_prepared, Acc_maxlength_prepared),                                                                                                     \n    [ lists:max([A, B]) || {A, B} <- Two_lengths].                                                                                                                             \nadjust_list(L, Desired_length, Elem) ->                                                                                                                                        \n    L++lists:duplicate(Desired_length - length(L), Elem).                                                                                                                      \n                                                                                                                                                                               \nprepare_line(Words_line, Words_length, Alignment) ->                                                                                                                           \n    All_words = adjust_list(Words_line, length(Words_length), \"\"),                                                                                                             \n    Zipped = lists:zip (All_words, Words_length),                                                                                                                              \n    [ apply(string, Alignment, [Word, Length + 1, $\\s])                                                                                                                        \n      || {Word, Length} <- Zipped].                                                                                                                                            \n \n=== Output\n\n\n1> c(align_columns).\n{ok,align_columns}\n2> align_columns:align_center().\n   Given        a        text     file    of      many      lines     where   fields  within    a   line \n    are    delineated     by        a   single  'dollar' character,   write     a    program             \n   that      aligns      each    column   of     fields      by     ensuring   that   words    in   each \n  column       are     separated   by     at     least       one     space.                              \n Further,     allow       for     each   word      in         a      column     to      be   either left \njustified,    right   justified,   or   center justified   within      its   column.                     \nok\n3> align_columns:align_left().  \nGiven      a          text       file   of     many      lines      where    fields  within  a      line \nare        delineated by         a      single 'dollar'  character, write    a       program             \nthat       aligns     each       column of     fields    by         ensuring that    words   in     each \ncolumn     are        separated  by     at     least     one        space.                               \nFurther,   allow      for        each   word   in        a          column   to      be      either left \njustified, right      justified, or     center justified within     its      column.                     \nok\n4> align_columns:align_right().\n      Given          a       text   file     of      many      lines    where  fields  within      a line\n        are delineated         by      a single  'dollar' character,    write       a program            \n       that     aligns       each column     of    fields         by ensuring    that   words     in each\n     column        are  separated     by     at     least        one   space.                            \n   Further,      allow        for   each   word        in          a   column      to      be either left\n justified,      right justified,     or center justified     within      its column.                    \nok\n\n\n<\/lang>\n\n==[[:Category:Euphoria|Euphoria]][[Category:Euphoria]]==\n<lang euphoria>constant data = {\n    \"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\",\n    \"are$delineated$by$a$single$'dollar'$character,$write$a$program\",\n    \"that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\",\n    \"column$are$separated$by$at$least$one$space.\",\n    \"Further,$allow$for$each$word$in$a$column$to$be$either$left$\",\n    \"justified,$right$justified,$or$center$justified$within$its$column.\"\n}\n\nfunction split(sequence s, integer c)\n    sequence out\n    integer first, delim\n    out = {}\n    first = 1\n    while first<=length(s) do\n        delim = find_from(c,s,first)\n        if delim = 0 then\n            delim = length(s)+1\n        end if\n        out = append(out,s[first..delim-1])\n        first = delim + 1\n    end while\n    return out\nend function\n\nfunction align(sequence s, integer width, integer alignment)\n    integer n\n    n = width - length(s)\n    if n <= 0 then\n        return s\n    elsif alignment < 0 then\n        return s & repeat(' ', n)\n    elsif alignment > 0 then\n        return repeat(' ', n) & s\n    else\n        return repeat(' ', floor(n\/2)) & s & repeat(' ', floor(n\/2+0.5))\n    end if\nend function\n\ninteger maxlen\nsequence lines\nmaxlen = 0\nlines = repeat(0,length(data))\nfor i = 1 to length(data) do\n    lines[i] = split(data[i],'$')\n    for j = 1 to length(lines[i]) do\n        if length(lines[i][j]) > maxlen then\n            maxlen = length(lines[i][j])\n        end if\n    end for\nend for\n\nfor a = -1 to 1 do\n    for i = 1 to length(lines) do\n        for j = 1 to length(lines[i]) do\n            puts(1, align(lines[i][j],maxlen,a) & ' ')\n        end for\n        puts(1,'\\n')\n    end for\n    puts(1,'\\n')\nend for<\/lang>\n\nOutput:\n<pre>Given      a          text       file       of         many       lines,     where      fields     within     a          line       \nare        delineated by         a          single     'dollar'   character, write      a          program    \nthat       aligns     each       column     of         fields     by         ensuring   that       words      in         each       \ncolumn     are        separated  by         at         least      one        space.     \nFurther,   allow      for        each       word       in         a          column     to         be         either     left       \njustified, right      justified, or         center     justified  within     its        column.    \n\n  Given        a         text       file        of        many      lines,     where      fields     within       a         line    \n   are     delineated     by         a        single    'dollar'  character,   write        a       program   \n   that      aligns      each      column       of       fields       by      ensuring     that      words        in        each    \n  column      are     separated      by         at       least       one       space.   \n Further,    allow       for        each       word        in         a        column       to         be       either      left    \njustified,   right    justified,     or       center   justified    within      its      column.   \n\n     Given          a       text       file         of       many     lines,      where     fields     within          a       line \n       are delineated         by          a     single   'dollar' character,      write          a    program \n      that     aligns       each     column         of     fields         by   ensuring       that      words         in       each \n    column        are  separated         by         at      least        one     space. \n  Further,      allow        for       each       word         in          a     column         to         be     either       left \njustified,      right justified,         or     center  justified     within        its    column. \n\n<\/pre>\n\n==[[:Category:Factor|Factor]][[Category:Factor]]==\n<lang factor>USING: fry io kernel math math.functions math.order sequences\nsplitting strings ;\nIN: rosetta.column-aligner\n\nCONSTANT: example-text \"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$'dollar'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.\"\n\n: split-and-pad ( text -- lines )\n    \"\\n\" split [ \"$\" split harvest ] map\n    dup [ length ] [ max ] map-reduce\n    '[ _ \"\" pad-tail ] map ;\n\n: column-widths ( columns -- widths )\n    [ [ length ] [ max ] map-reduce ] map ;\n\nSINGLETONS: +left+ +middle+ +right+ ;\n\nGENERIC: align-string ( str n alignment -- str' )\n\nM: +left+ align-string  drop CHAR: space pad-tail ;\nM: +right+ align-string drop CHAR: space pad-head ;\n\nM: +middle+ align-string\n    drop\n    over length - 2 \/\n    [ floor CHAR: space <string> ]\n    [ ceiling CHAR: space <string> ] bi surround ;\n\n: align-columns ( columns alignment -- columns' )\n    [ dup column-widths ] dip '[\n        [ _ align-string ] curry map\n    ] 2map ;\n\n: print-aligned ( text alignment -- )\n    [ split-and-pad flip ] dip align-columns flip\n    [ [ write \" \" write ] each nl ] each ;<\/lang>\n\n example-text { +left+ +middle+ +right+ } [ print-aligned ] with each\n\n==[[:Category:Forth|Forth]][[Category:Forth]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[GNU Forth]][[SMW::on]]<\/div>\n<lang forth>\\ align columns\n\n: split ( addr len char -- addr len1 addr len-len1 )\n  >r 2dup r> scan 2swap 2 pick - ;\n\nvariable column\n\n: for-each-line ( file len xt -- )\n  >r begin #lf split r@ execute 1 \/string dup 0<= until 2drop rdrop ;\n\n: for-each-field ( line len xt -- )\n  0 column !\n  >r begin '$ split r@ execute 1 column +! 1 \/string dup 0<= until 2drop rdrop ;\n\n0 value num-columns\n\n: count-columns ( line len -- )\n  ['] 2drop for-each-field\n  num-columns column @ max to num-columns ;\n: find-num-columns ( file len -- )\n  0 to num-columns\n  ['] count-columns for-each-line ;\n\n0 value column-widths\n\n: column-width ( field len -- )\n  column-widths column @ + c@\n  max\n  column-widths column @ + c!\n  drop ;\n: measure-widths ( line len -- )\n  ['] column-width for-each-field ;\n: find-column-widths ( file len -- )\n  num-columns allocate throw to column-widths\n  column-widths num-columns erase\n  ['] measure-widths for-each-line ;\n\n\\ type aligned, same naming convention as standard numeric U.R, .R\n: type.l ( addr len width -- )\n  over -               >r type r>       spaces ;\n: type.c ( addr len width -- )\n  over - dup 2\/ spaces >r type r> 1+ 2\/ spaces ;\n: type.r ( addr len width -- )\n  over -        spaces    type ;\n\ndefer type.aligned\n\n: print-field ( field len -- )\n  column-widths column @ + c@ type.aligned space ;\n: print-line   ( line len -- ) cr ['] print-field for-each-field ;\n: print-fields ( file len -- )    ['] print-line  for-each-line ;\n\n\n\\ read file\ns\" columns.txt\" slurp-file  ( file len )\n\n\\  scan once to determine num-columns\n2dup find-num-columns\n\n\\  scan again to determine column-widths\n2dup find-column-widths\n\n\\  print columns, once for each alignment type\n' type.l is type.aligned  2dup print-fields cr\n' type.c is type.aligned  2dup print-fields cr\n' type.r is type.aligned  2dup print-fields cr\n\n\\ cleanup\nnip free throw\ncolumn-widths free throw<\/lang>\n==[[:Category:Go|Go]][[Category:Go]]==\n<lang go>package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n)\n\nconst text = `Given$a$text$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$'dollar'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.`\n\ntype formatter struct {\n    text  [][]string\n    width []int\n}\n\nfunc newFormatter(text string) *formatter {\n    var f formatter\n    for _, line := range strings.Split(text, \"\\n\") {\n        words := strings.Split(line, \"$\")\n        for words[len(words)-1] == \"\" {\n            words = words[:len(words)-1]\n        }\n        f.text = append(f.text, words)\n        for i, word := range words {\n            if i == len(f.width) {\n                f.width = append(f.width, len(word))\n            } else if len(word) > f.width[i] {\n                f.width[i] = len(word)\n            }\n        }\n    }\n    return &f\n}\n\nconst (\n    left = iota\n    middle\n    right\n)\n\nfunc (f formatter) print(j int) {\n    for _, line := range f.text {\n        for i, word := range line {\n            fmt.Printf(\"%-*s \", f.width[i], fmt.Sprintf(\"%*s\",\n                len(word)+(f.width[i]-len(word))*j\/2, word))\n        }\n        fmt.Println(\"\")\n    }\n    fmt.Println(\"\")\n}\n\nfunc main() {\n    f := newFormatter(text)\n    f.print(left)\n    f.print(middle)\n    f.print(right)\n}<\/lang>\n<pre>\nGiven      a          text       file   of     many      lines,     where    fields  within  a      line\nare        delineated by         a      single 'dollar'  character, write    a       program\nthat       aligns     each       column of     fields    by         ensuring that    words   in     each\ncolumn     are        separated  by     at     least     one        space.\nFurther,   allow      for        each   word   in        a          column   to      be      either left\njustified, right      justified, or     center justified within     its      column.\n\n  Given        a         text     file    of     many      lines,    where   fields  within    a    line\n   are     delineated     by       a    single 'dollar'  character,  write      a    program\n   that      aligns      each    column   of    fields       by     ensuring  that    words    in   each\n  column      are     separated    by     at     least      one      space.\n Further,    allow       for      each   word     in         a       column    to      be    either left\njustified,   right    justified,   or   center justified   within     its    column.\n\n     Given          a       text   file     of      many     lines,    where  fields  within      a line\n       are delineated         by      a single  'dollar' character,    write       a program\n      that     aligns       each column     of    fields         by ensuring    that   words     in each\n    column        are  separated     by     at     least        one   space.\n  Further,      allow        for   each   word        in          a   column      to      be either left\njustified,      right justified,     or center justified     within      its column.\n<\/pre>\n\n==[[:Category:Groovy|Groovy]][[Category:Groovy]]==\nSolution:\n<lang groovy>def alignColumns = { align, rawText ->\n    def lines = rawText.tokenize('\\n')\n    def words = lines.collect { it.tokenize(\/\\$\/) }\n    def maxLineWords = words.collect {it.size()}.max()\n    words = words.collect { line -> line + [''] * (maxLineWords - line.size()) }\n    def columnWidths = words.transpose().collect{ column -> column.collect { it.size() }.max() }\n\n    def justify = [   Right  : { width, string -> string.padLeft(width) },\n                            Left   : { width, string -> string.padRight(width) },\n                            Center : { width, string -> string.center(width) }      ]\n    def padAll = { pad, colWidths, lineWords -> [colWidths, lineWords].transpose().collect { pad(it) + ' ' } }\n\n    words.each { padAll(justify[align], columnWidths, it).each { print it }; println() }\n}<\/lang>\n\nTest Program:\n<lang groovy>def rawTextInput = '''Given$a$text$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$'dollar'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.'''\n\n['Left', 'Center', 'Right'].each { align -> \n    println \"${align} Justified:\"\n    alignColumns(align, rawTextInput)\n    println()\n}<\/lang>\n\nOutput:\n<pre style=\"height:25ex;overflow:scroll\">Left Justified:\nGiven      a          text       file   of     many      lines,     where    fields  within  a      line \nare        delineated by         a      single 'dollar'  character, write    a       program             \nthat       aligns     each       column of     fields    by         ensuring that    words   in     each \ncolumn     are        separated  by     at     least     one        space.                               \nFurther,   allow      for        each   word   in        a          column   to      be      either left \njustified, right      justified, or     center justified within     its      column.                     \n\nCenter Justified:\n  Given        a         text     file    of     many      lines,    where   fields  within    a    line \n   are     delineated     by       a    single 'dollar'  character,  write      a    program             \n   that      aligns      each    column   of    fields       by     ensuring  that    words    in   each \n  column      are     separated    by     at     least      one      space.                              \n Further,    allow       for      each   word     in         a       column    to      be    either left \njustified,   right    justified,   or   center justified   within     its    column.                     \n\nRight Justified:\n     Given          a       text   file     of      many     lines,    where  fields  within      a line \n       are delineated         by      a single  'dollar' character,    write       a program             \n      that     aligns       each column     of    fields         by ensuring    that   words     in each \n    column        are  separated     by     at     least        one   space.                             \n  Further,      allow        for   each   word        in          a   column      to      be either left \njustified,      right justified,     or center justified     within      its column.<\/pre>\n\n==[[:Category:Haskell|Haskell]][[Category:Haskell]]==\n<lang haskell>import Data.List\nimport Control.Monad\nimport Control.Arrow\n\ndat = \"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\\n\" ++\n      \"are$delineated$by$a$single$'dollar'$character,$write$a$program\\n\" ++\n      \"that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\\n\" ++\n      \"column$are$separated$by$at$least$one$space.\\n\" ++\n      \"Further,$allow$for$each$word$in$a$column$to$be$either$left$\\n\" ++\n      \"justified,$right$justified,$or$center$justified$within$its$column.\\n\"\n\nbrkdwn = takeWhile (not.null) . unfoldr (Just . second (drop 1) . span ('$'\/=))\n\nformat j ls = map (unwords. zipWith align colw) rows  \n  where\n    rows = map brkdwn $ lines ls\n    colw = map (maximum. map length) . transpose $ rows\n    align cw w =\n      case j of\n        'c' -> (replicate l ' ') ++ w ++ (replicate r ' ')\n        'r' -> (replicate dl ' ') ++ w\n        'l' -> w ++ (replicate dl ' ')\n        where\n           dl = cw-length w\n           (l,r) = (dl `div` 2, dl-l)<\/lang>\noutput example:\n<pre>\n*Main> mapM_ putStrLn $ format 'c' dat\n  Given        a         text     file    of     many      lines,    where   fields  within    a    line\n   are     delineated     by       a    single 'dollar'  character,  write      a    program\n   that      aligns      each    column   of    fields       by     ensuring  that    words    in   each\n  column      are     separated    by     at     least      one      space.\n Further,    allow       for      each   word     in         a       column    to      be    either left\njustified,   right    justified,   or   center justified   within     its    column.\n<\/pre>\n\n==[[:Category:HicEst|HicEst]][[Category:HicEst]]==\nA file opened with a Format option describing the column format(s) can be addressed like a standard in-memory array. In addition the DLG function ([http:\/\/www.HicEst.com\/MatrixExplorer.htm MatrixExplorer]) allows this text\/numeric file to be edited or visualized in many ways, but string columns are always left adjusted while numeric columns are right adjusted. Export is possible.\n<lang HicEst>\nCHARACTER Fnam = \"\\HicEst\\Rosetta\\Align columns.txt\"\n\n   OPEN(FIle=Fnam, Format=\"12$\", LENgth=rows)\n! call the DLG function in MatrixExplorer mode:\n   DLG(Edit=Fnam, Format='12A10') ! left adjusted, 12 columns, 10 spaces each\n\n! or the standard way:\n   CALL Align( \"LLLLLLLLLLL \", Fnam, rows)   ! left   align\n   CALL Align( \"CCCCCCCCCCC \", Fnam, rows)   ! center align\n   CALL Align( \"RRRRRRRRRRR \", Fnam, rows)   ! right  align\nEND\n\nSUBROUTINE Align(picture, filename, rows)\n   CHARACTER picture, filename\n   CHARACTER out*400, txt*20\n\n   W = LEN(picture)\n   DO i = 1, rows\n     out = \" \"\n     DO j = 0, 100\n       txt = filename(i, j+1, *9) ! on error branch to label 9\n       WRITE(Text=out(j*W+1 : ), Format=picture) txt\n     ENDDO\n 9 CONTINUE\n   WRITE() out\n   ENDDO\nEND<\/lang>\n<pre>Given       a           text        file        of          many        lines,      where       fields      within      a           line\nare         delineated  by          a           single      'dollar'    character,  write       a           program\nthat        aligns      each        column      of          fields      by          ensuring    that        words       in          each\ncolumn      are         separated   by          at          least       one         space.\nFurther,    allow       for         each        word        in          a           column      to          be          either      left\njustified,  right       justified,  or          center      justified   within      its         column.\n   Given         a         text        file         of         many       lines,       where      fields      within         a         line\n    are     delineated      by           a        single     'dollar'   character,     write         a        program\n   that       aligns       each       column        of        fields        by       ensuring      that        words        in         each\n  column        are      separated      by          at         least        one       space.\n Further,      allow        for        each        word         in           a        column        to          be        either       left\njustified,     right    justified,      or        center     justified    within        its       column.\n      Given           a        text        file          of        many      lines,       where      fields      within           a        line\n        are  delineated          by           a      single    'dollar'  character,       write           a     program\n       that      aligns        each      column          of      fields          by    ensuring        that       words          in        each\n     column         are   separated          by          at       least         one      space.\n   Further,       allow         for        each        word          in           a      column          to          be      either        left\n justified,       right  justified,          or      center   justified      within         its     column.<\/pre>\n\n==[[:Category:Icon|Icon]][[Category:Icon]] and [[:Category:Unicon|Unicon]][[Category:Unicon]]==\nAn argument of <tt>left<\/tt>, <tt>center<\/tt>, or <tt>right<\/tt> controls the\ncolumn alignment.  The default is left-alignment.\n<lang icon>global width\n\nprocedure main(args)\n    lines := []\n    width := 0\n    format := left\n    match(\"left\"|\"right\"|\"center\", format <- !args)\n    every put(lines,prepare(!&input))\n    display(lines, proc(format,3))\nend\n\nprocedure prepare(lines)\n    line := []\n    lines ? {\n        while (not pos(0)) & (field := tab(upto('$')|0)) do {\n            put(line, field)\n            width <:= *field\n            move(1)\n            }\n        }\n    return line\nend\n\nprocedure display(lines, format)\n    width +:= 1\n    every line := !lines do {\n        every writes(format(!line, width))\n        write()\n        }\nend<\/lang>\n\nSample run:\n<pre>->align right <align.txt\n      Given          a       text       file         of       many     lines,      where     fields     within          a       line\n        are delineated         by          a     single   'dollar' character,      write          a    program\n       that     aligns       each     column         of     fields         by   ensuring       that      words         in       each\n     column        are  separated         by         at      least        one     space.\n   Further,      allow        for       each       word         in          a     column         to         be     either       left\n justified,      right justified,         or     center  justified     within        its    column.\n-><\/pre>\n\n==[[:Category:J|J]][[Category:J]]==\n'''Solution'''\n<lang j>'LEFT CENTER RIGHT'=: i.3                NB. justification constants\n \nNB.* alignCols v Format delimited text in justified columns\nNB. y:          text to format\nNB.                 rows marked by last character in text\nNB.                 columns marked by $\nNB. optional x: justification. Default is LEFT\nNB. result:     text table\nalignCols=: verb define\n  LEFT alignCols y                       NB. default\n:\n  global=. dyad def'9!:x y'each\n  oldbox=. 6 16 global '';''             NB. save settings\n  7 17 global (11#' ');,~x               NB. apply new settings\n  result=. _2{:\\ \": <;._2 @:,&'$';._2 y  NB. parse & format text\n  7 17 global oldbox                     NB. restore settings\n  result\n)<\/lang>\n\n'''Example''':\n<lang j>   text=: noun define\nGiven$a$text$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$'dollar'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.\n)\n\n   alignCols text           NB. default justification\n Given      a          text       file   of     many      lines,     where    fields  within  a      line  \n are        delineated by         a      single 'dollar'  character, write    a       program              \n that       aligns     each       column of     fields    by         ensuring that    words   in     each  \n column     are        separated  by     at     least     one        space.                                \n Further,   allow      for        each   word   in        a          column   to      be      either left  \n justified, right      justified, or     center justified within     its      column.                      \n\n   CENTER alignCols text    NB. specify desired justification as left argument\n   Given        a         text     file    of     many      lines,    where   fields  within    a    line  \n    are     delineated     by       a    single 'dollar'  character,  write      a    program              \n    that      aligns      each    column   of    fields       by     ensuring  that    words    in   each  \n   column      are     separated    by     at     least      one      space.                               \n  Further,    allow       for      each   word     in         a       column    to      be    either left  \n justified,   right    justified,   or   center justified   within     its    column.<\/lang>\n\n==[[:Category:JavaScript|JavaScript]][[Category:JavaScript]]==\n<lang JavaScript>\nvar justification=\"center\",\ninput=[\"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\",\n\"are$delineated$by$a$single$'dollar'$character,$write$a$program\",\n\"that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\",\n\"column$are$separated$by$at$least$one$space.\",\n\"Further,$allow$for$each$word$in$a$column$to$be$either$left$\",\n\"justified,$right$justified,$or$center$justified$within$its$column.\"],\nx,y,cols,max,cols=0,diff,left,right\n\nString.prototype.repeat=function(n){return new Array(1 + parseInt(n)).join(this);}\n\nfor(x=0;x<input.length;x++) {\n input[x]=input[x].split(\"$\");\n if(input[x].length>cols) cols=input[x].length;\n}\nfor(x=0;x<cols;x++) {\n max=0;\n for(y=0;y<input.length;y++) if(input[y][x]&&max<input[y][x].length) max=input[y][x].length;\n for(y=0;y<input.length;y++) \n  if(input[y][x]) {\n   diff=(max-input[y][x].length)\/2;\n   left=\" \".repeat(Math.floor(diff));\n   right=\" \".repeat(Math.ceil(diff));\n   if(justification==\"left\") {right+=left;left=\"\"}\n   if(justification==\"right\") {left+=right;right=\"\"}\n   input[y][x]=left+input[y][x]+right;\n  }\n}\nfor(x=0;x<input.length;x++) input[x]=input[x].join(\" \");\ninput=input.join(\"\\n\");\ndocument.write(input);<\/lang>\n\n==[[:Category:Liberty BASIC|Liberty BASIC]][[Category:Liberty BASIC]]==\n<lang lb>mainwin 140 32\n\n    CRLF$  =chr$( 13)\n    maxlen =0\n\n    read y\n\n    Dim txt$( y)\n\n    For i =1 To y\n        Read i$\n        print i$\n        if right$( i$, 1) <>\"$\" then i$ =i$ +\"$\"\n        txt$( i) =i$\n        x  =max( CountDollars( txt$( i)), x)\n    Next i\n\n    print x\n\n    Dim matrix$( x, y)\n\n    Print CRLF$; \"  ---- Left ----\"\n    For yy =1 To y\n        For xx =1 To x\n            matrix$( xx, yy) =word$( txt$( yy), xx, \"$\")\n            print matrix$( xx, yy), \"|\";\n            maxlen           =max( maxlen, Len( matrix$( xx, yy)))\n        Next xx\n        print \"\"\n    Next yy\n\n    Print CRLF$; \"  ---- Right ----\"\n    For yy =1 To y\n        For xx =1 To x\n            Print right$( \"                    \" +matrix$( xx, yy), maxlen +1); \"|\";\n            '   will truncate column words longer than 20. Change to use maxlen....\n        Next xx\n        Print \"\"\n    Next yy\n\n    Print CRLF$ +\"  ---- Center ----\"\n    For yy =1 to y\n        For xx =1 to x\n            wordLen     =Len( matrix$( xx, yy))\n            padNeeded   =maxlen -wordLen +4\n            LeftSpaces  =padNeeded \/2\n\n            if LeftSpaces =int( LeftSpaces) then\n                RightSpaces =LeftSpaces\n            else\n                RightSpaces =LeftSpaces -1\n            end if\n\n            Print space$( LeftSpaces); matrix$( xx, yy); space$( RightSpaces); \"|\";\n        Next xx\n        Print \"\"\n    Next yy\n\n    wait\n\n    Data  6\n\n    Data \"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\"\n    Data \"are$delineated$by$a$single$'dollar'$character,$write$a$program\"\n    Data \"that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\"\n    Data \"column$are$separated$by$at$least$one$space.\"\n    Data \"Further,$allow$for$each$word$in$a$column$to$be$either$left$\"\n    Data \"justified,$right$justified,$or$center$justified$within$its$column.\"\n\n    function CountDollars( src$)\n        c =0\n        for j =1 to len( src$)\n            if mid$( src$, j, 1) =\"$\" then c =c +1\n        next j\n        CountDollars =c\n    end function\n\n    end<\/lang>\n\n==[[:Category:Lua|Lua]][[Category:Lua]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Lua]] version 5.1[[SMW::on]]<\/div>\n\n<lang lua>\nlocal tWord = {}        -- word table\nlocal tColLen = {}      -- maximum word length in a column\nlocal rowCount = 0      -- row counter\n--store maximum column lengths at 'tColLen'; save words into 'tWord' table\nlocal function readInput(pStr)\n    for line in pStr:gmatch(\"([^\\n]+)[\\n]-\") do  -- read until '\\n' character\n        rowCount = rowCount + 1\n        tWord[rowCount] = {}                     -- create new row\n        local colCount = 0\n        for word in line:gmatch(\"[^$]+\") do      -- read non '$' character\n            colCount = colCount + 1\n            tColLen[colCount] = math.max((tColLen[colCount] or 0), #word)   -- store column length\n            tWord[rowCount][colCount] = word                                -- store words\n        end--for word\n    end--for line\nend--readInput\n--repeat space to align the words in the same column\nlocal align = {\n    [\"left\"] = function (pWord, pColLen)\n        local n = (pColLen or 0) - #pWord + 1\n        return pWord .. (\" \"):rep(n)\n    end;--[\"left\"]\n    [\"right\"] = function (pWord, pColLen)\n        local n = (pColLen or 0) - #pWord + 1\n        return (\" \"):rep(n) .. pWord\n    end;--[\"right\"]\n    [\"center\"] = function (pWord, pColLen)\n        local n = (pColLen or 0) - #pWord + 1\n        local n1 = math.floor(n\/2)\n        return (\" \"):rep(n1) .. pWord .. (\" \"):rep(n-n1)\n    end;--[\"center\"]\n}\n--word table padder\nlocal function padWordTable(pAlignment)\n    local alignFunc = align[pAlignment]                         -- selecting the spacer function\n    for rowCount, tRow in ipairs(tWord) do\n        for colCount, word in ipairs(tRow) do\n            tRow[colCount] = alignFunc(word, tColLen[colCount]) -- save the padded words into the word table\n        end--for colCount, word\n    end--for rowCount, tRow\nend--padWordTable\n--main interface\n--------------------------------------------------[]\nfunction alignColumn(pStr, pAlignment, pFileName)\n--------------------------------------------------[]\n    readInput(pStr)                           -- store column lengths and words\n    padWordTable(pAlignment or \"left\")        -- pad the stored words\n    local output = \"\"\n    for rowCount, tRow in ipairs(tWord) do\n        local line = table.concat(tRow)       -- concatenate words in one row\n        print(line)                           -- print the line\n        output = output .. line .. \"\\n\"       -- concatenate the line for output, add line break\n    end--for rowCount, tRow\n    if (type(pFileName) == \"string\") then\n        local file = io.open(pFileName, \"w+\")\n        file:write(output)                    -- write output to file\n        file:close()\n    end--if type(pFileName)\n    return output\nend--alignColumn\n<\/lang>\n\nUsage Example:\n\n<lang lua>\ninput =\n[[Given$a$text$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$'dollar'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.]]\n\n\noutputLeft = alignColumn(input)\noutputRight = alignColumn(input, \"right\")\nalignColumn(input, \"center\", \"output.txt\")\n<\/lang>\n\n==[[:Category:Mathematica|Mathematica]][[Category:Mathematica]]==\n<lang Mathematica>TableForm[StringSplit[StringSplit[a,\"\\n\"],\"$\"],TableAlignments -> Center]<\/lang>\nOutput with example text :\n[[File:centeredtext.png]]\n\n==[[:Category:ML\/I|ML\/I]][[Category:ML\/I]]==\nIn this example, ML\/I reads its macros first, then switches input to the file containing the data to be formatted. Output is to 'standard output' or similar. Note the presetting of P102 to indicate the alignment required.\n\n<lang ML\/I>MCSKIP \"WITH\" NL\n\"\" Align columns - assumes macros on input stream 1, data on stream 2\nMCPVAR 102\n\"\" Set P102 to alignment required:\n\"\"   1 = centre\n\"\"   2 = left\n\"\"   3 = right\nMCSET P102 = 1\nMCSKIP MT,<>\nMCINS %.\nMCSKIP SL WITH *\n\"\" Assume no more than 100 columns - P101 used for max number of fields\n\"\" Set P variables 1-101 to 0\nMCDEF ZEROPS WITHS NL AS <MCSET T1=1\n%L1.MCSET PT1=0\nMCSET T1=T1+1\nMCGO L1 UNLESS T1 EN 102\n>\nZEROPS\n\"\" First pass - macro to accumulate max columns, and max widths\nMCDEF SL N1 OPT $ N1 OR $ WITHS NL OR SPACE WITHS NL OR NL ALL\nAS <MCGO L3 UNLESS T1 GR P101\nMCSET P101=T1\n%L3.MCSET T2=1\n%L1.MCGO L0 IF T2 GR T1\nMCSET T3=MCLENG(%WBT2.)\nMCGO L2 UNLESS T3 GR PT2\nMCSET PT2=T3\n%L2.MCSET T2=T2+1\nMCGO L1\n>\nMCSET S1=1\n*MCSET S10=2\n*MCSET S1=0\nMCSET S4=1\n\"\"MCNOTE Max field is %P101.\n\"\"MCDEF REP NL AS <MCSET T1=1\n\"\"%L1.%PT1. MCSET T1=T1+1\n\"\"MCGO L1 UNLESS T1 GR P101\n\"\">\n\"\"REP\nMCDEF SL N1 OPT $ N1 OR $ WITHS NL OR SPACE WITHS NL OR NL ALL\nAS <MCSET T2=1\n%L5.MCGO L6 IF T2 GR T1\nMCGO LP102\n%L1.MCSET T3=%%%PT2.-MCLENG(%WBT2.).\/2.\nMCGO L7 IF T3 EN 0\nMCSUB(<                            >,1,T3)%L7.%WBT2.\"\"\nMCSUB(<                            >,1,PT2-T3-MCLENG(%WBT2.)+1)MCGO L4\n%L2.MCSUB(%WBT2.<                              >,1,PT2)MCGO L4\n%L3.MCSUB(<                              >%WBT2.,1-PT2,0)\"\"\n%L4. MCSET T2=T2+1\nMCGO L5\n%L6.\n>\nMCSET S1=1\n*MCSET S10=102<\/lang>\n\n==[[:Category:MUMPS|MUMPS]][[Category:MUMPS]]==\n<lang MUMPS>columns(how)\t; how = \"Left\", \"Center\" or \"Right\"\n\tNew col,half,ii,max,spaces,word\n\tSet ii=0\n\tSet ii=ii+1,line(ii)=\"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\"\n\tSet ii=ii+1,line(ii)=\"are$delineated$by$a$single$'dollar'$character,$write$a$program\"\n\tSet ii=ii+1,line(ii)=\"that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\"\n\tSet ii=ii+1,line(ii)=\"column$are$separated$by$at$least$one$space.\"\n\tSet ii=ii+1,line(ii)=\"Further,$allow$for$each$word$in$a$column$to$be$either$left$\"\n\tSet ii=ii+1,line(ii)=\"justified,$right$justified,$or$center$justified$within$its$column.\"\n\tSet ii=\"\" For  Set ii=$Order(line(ii)) Quit:ii=\"\"  Do\n\t. For col=1:1:$Length(line(ii),\"$\") Do\n\t. . Set max=$Length($Piece(line(ii),\"$\",col))\n\t. . Set:max>$Get(max(col)) max(col)=max\n\t. . Quit\n\t. Quit\n\tSet ii=\"\" For  Set ii=$Order(line(ii)) Quit:ii=\"\"  Do\n\t. Write ! For col=1:1:$Length(line(ii),\"$\") Do:$Get(max(col))\n\t. . Set word=$Piece(line(ii),\"$\",col)\n\t. . Set spaces=$Justify(\"\",max(col)-$Length(word))\n\t. . If how=\"Left\" Write word,spaces,\" \" Quit\n\t. . If how=\"Right\" Write spaces,word,\" \" Quit\n\t. . Set half=$Length(spaces)\\2\n\t. . Write $Extract(spaces,1,half),word,$Extract(spaces,half+1,$Length(spaces)),\" \"\n\t. . Quit\n\t. Quit\n\tWrite !\n\tQuit\nDo columns(\"Left\")\n\nGiven      a          text       file   of     many      lines,     where    fields  within  a      line\nare        delineated by         a      single 'dollar'  character, write    a       program\nthat       aligns     each       column of     fields    by         ensuring that    words   in     each\ncolumn     are        separated  by     at     least     one        space.\nFurther,   allow      for        each   word   in        a          column   to      be      either left\njustified, right      justified, or     center justified within     its      column.\n\nDo columns(\"Center\")\n\n  Given        a         text     file    of     many      lines,    where   fields  within    a    line\n   are     delineated     by       a    single 'dollar'  character,  write      a    program\n   that      aligns      each    column   of    fields       by     ensuring  that    words    in   each\n  column      are     separated    by     at     least      one      space.\n Further,    allow       for      each   word     in         a       column    to      be    either left\njustified,   right    justified,   or   center justified   within     its    column.\n\nDo columns(\"Right\")\n\n     Given          a       text   file     of      many     lines,    where  fields  within      a line\n       are delineated         by      a single  'dollar' character,    write       a program\n      that     aligns       each column     of    fields         by ensuring    that   words     in each\n    column        are  separated     by     at     least        one   space.\n  Further,      allow        for   each   word        in          a   column      to      be either left\njustified,      right justified,     or center justified     within      its column.<\/lang>\n\n\n==[[:Category:OCaml|OCaml]][[Category:OCaml]]==\n<lang ocaml>#load \"str.cma\"\nopen Str\n\nlet input = \"\\\nGiven$a$text$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$'dollar'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.\"\n\nlet () =\n  let lines = split (regexp_string \"\\n\") input in\n  let fields_l = List.map (split (regexp_string \"$\")) lines in\n  let fields_l = List.map Array.of_list fields_l in\n  let n = (* number of columns *)\n    List.fold_left\n      (fun n fields -> max n (Array.length fields))\n      0 fields_l\n  in\n  let pads = Array.make n 0 in\n  List.iter (\n    (* calculate the max padding for each column *)\n    Array.iteri\n      (fun i word -> pads.(i) <- max pads.(i) (String.length word))\n  ) fields_l;\n\n  let print f =\n    List.iter (fun fields ->\n      Array.iteri (fun i word ->\n        f word (pads.(i) - (String.length word))\n      ) fields;\n      print_newline()\n    ) fields_l;\n  in\n\n  (* left column-aligned output *)\n  print (fun word pad ->\n    let spaces = String.make pad ' ' in\n    Printf.printf \"%s%s \" word spaces);\n\n  (* right column-aligned output *)\n  print (fun word pad ->\n    let spaces = String.make pad ' ' in\n    Printf.printf \"%s%s \" spaces word);\n\n  (* center column-aligned output *)\n  print (fun word pad ->\n    let pad1 = pad \/ 2 in\n    let pad2 = pad - pad1 in\n    let sp1 = String.make pad1 ' ' in\n    let sp2 = String.make pad2 ' ' in\n    Printf.printf \"%s%s%s \" sp1 word sp2);\n;;<\/lang>\n\n==[[:Category:OpenEdge\/Progress|OpenEdge\/Progress]][[Category:OpenEdge\/Progress]]==\n<lang progress>FUNCTION alignColumns RETURNS CHAR (\n   i_c      AS CHAR,\n   i_calign AS CHAR\n):\n\n   DEF VAR ipass     AS INT.\n   DEF VAR iline     AS INT.\n   DEF VAR icol      AS INT.\n   DEF VAR iwidth    AS INT EXTENT.\n   DEF VAR cword     AS CHAR.\n   DEF VAR cspace    AS CHAR.\n   DEF VAR cresult   AS CHAR.\n\n   EXTENT( iwidth ) = NUM-ENTRIES( ENTRY( 1, i_c, \"~n\" ), \"$\" ).\n\n   DO ipass = 0 TO 1:\n      DO iline = 1 TO NUM-ENTRIES( i_c, \"~n\" ):\n         DO icol = 1 TO NUM-ENTRIES( ENTRY( iline, i_c, \"~n\" ), \"$\" ):\n            cword = ENTRY( icol, ENTRY( iline, i_c, \"~n\" ), \"$\" ).\n            IF ipass = 0 THEN\n               iwidth = MAXIMUM( LENGTH( cword ), iwidth[ icol ] ).\n            ELSE DO:\n               cspace = FILL( \" \", iwidth[ icol ] - LENGTH( cword ) ).\n               CASE i_calign:\n                  WHEN \"left\"    THEN cresult = cresult + cword + cspace.\n                  WHEN \"right\"   THEN cresult = cresult + cspace + cword.\n                  WHEN \"center\"  THEN DO:\n                     cword = FILL( \" \", INTEGER( LENGTH( cspace ) \/ 2 ) ) + cword.\n                     cresult = cresult + cword + FILL( \" \", iwidth[icol] - LENGTH( cword ) ).\n                  END.\n               END CASE. \/* i_calign *\/\n               cresult = cresult + \" \".\n            END.\n         END. \/* DO icol = 1 TO ... *\/\n         IF ipass = 1 THEN\n            cresult = cresult + \"~n\".\n      END. \/* DO iline = 1 TO ... *\/\n   END. \/* DO ipass = 0 TO 1 *\/\n\n   RETURN cresult.\n\nEND FUNCTION.\n\nDEF VAR cc AS CHAR.\n\ncc =  SUBSTITUTE(\n         \"&1~n&2~n&3~n&4~n&5~n&6\",\n         \"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\",\n         \"are$delineated$by$a$single$'dollar'$character,$write$a$program\",\n         \"that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\",\n         \"column$are$separated$by$at$least$one$space.\",\n         \"Further,$allow$for$each$word$in$a$column$to$be$either$left$\",\n         \"justified,$right$justified,$or$center$justified$within$its$column.\"\n      ).\n\nMESSAGE\n   alignColumns( cc, \"left\" )    SKIP\n   alignColumns( cc, \"right\" )   SKIP\n   alignColumns( cc, \"center\" )\nVIEW-AS ALERT-BOX.<\/lang>\n\nOutput:\n\n<pre>\n---------------------------\nMessage\n---------------------------\nGiven      a          text       file       of         many       lines,     where      fields     within     a          line                  \nare        delineated by         a          single     'dollar'   character, write      a          program    \nthat       aligns     each       column     of         fields     by         ensuring   that       words      in         each                  \ncolumn     are        separated  by         at         least      one        space.     \nFurther,   allow      for        each       word       in         a          column     to         be         either     left                  \njustified, right      justified, or         center     justified  within     its        column.    \n\n     Given          a       text       file         of       many     lines,      where     fields     within          a       line            \n       are delineated         by          a     single   'dollar' character,      write          a    program \n      that     aligns       each     column         of     fields         by   ensuring       that      words         in       each            \n    column        are  separated         by         at      least        one     space. \n  Further,      allow        for       each       word         in          a     column         to         be     either       left            \njustified,      right justified,         or     center  justified     within        its    column. \n\n   Given        a        text       file        of        many      lines,      where     fields     within        a        line               \n    are    delineated     by          a       single    'dollar'  character,    write        a       program  \n   that      aligns      each      column       of       fields       by      ensuring     that       words       in        each               \n  column       are     separated     by         at        least       one      space.   \n Further,     allow       for       each       word        in          a       column       to         be       either      left               \njustified,    right   justified,     or       center    justified   within       its      column.  \n---------------------------\nOK   \n---------------------------<\/pre>\n\n==[[:Category:Oz|Oz]][[Category:Oz]]==\n<lang oz>declare\n  %% Lines: list of strings\n  %% Alignment: function like fun {Left Txt ExtraSpace} ... end\n  %% Returns: list of aligned (virtual) strings\n  fun {Align Lines Alignment}\n     ParsedLines = {Map Lines ParseLine}\n     NumColumns = {Maximum {Map ParsedLines Record.width}}\n     %% maps column index to column width:\n     WidthOfColumn = {Record.map {TupleRange NumColumns}\n                      fun {$ ColumnIndex}\n                         fun {LengthOfThisColumn ParsedLine}\n                            {Length {CondSelect ParsedLine ColumnIndex nil}}\n                         end\n                      in\n                         {Maximum {Map ParsedLines LengthOfThisColumn}}\n                      end}\n  in\n     {Map ParsedLines\n      fun {$ Columns}\n         {Record.mapInd Columns\n          fun {$ ColumnIndex ColumnText}\n             Extra = WidthOfColumn.ColumnIndex - {Length ColumnText}\n          in\n             {Alignment ColumnText Extra}#\" \"\n          end}\n      end}\n  end\n\n  %% A parsed line is a tuple of columns.\n  %% \"a$b$c\" -> '#'(1:\"a\" 2:\"b\" 3:\"c\")\n  fun {ParseLine Line}\n     {List.toTuple '#' {String.tokens Line &$}}\n  end\n\n  %% possible alignments:\n  \n  fun {Left Txt Extra}\n     Txt#{Spaces Extra}\n  end\n\n  fun {Right Txt Extra}\n     {Spaces Extra}#Txt\n  end\n\n  fun {Center Txt Extra}\n     Half = Extra div 2\n  in\n     {Spaces Half}#Txt#{Spaces Half + Extra mod 2}\n  end\n\n  %% helpers:\n  \n  %% 3 -> unit(1 2 3)\n  fun {TupleRange Max}\n     {List.toTuple unit {List.number 1 Max 1}}\n  end\n\n  fun {Maximum X|Xr}\n     {FoldL Xr Value.max X}\n  end\n\n  fun {Spaces N}\n     case N of 0 then nil\n     else & |{Spaces N-1}\n     end   \n  end\n\n  Lines = [\"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\"\n           \"are$delineated$by$a$single$'dollar'$character,$write$a$program\"\n           \"that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\"\n           \"column$are$separated$by$at$least$one$space.\"\n           \"Further,$allow$for$each$word$in$a$column$to$be$either$left$\"\n           \"justified,$right$justified,$or$center$justified$within$its$column.\"]\nin\n  {ForAll {Align Lines Left} System.showInfo}<\/lang>\n\n==[[:Category:Pascal|Pascal]][[Category:Pascal]]==\nSee [[Align_columns#Delphi | Delphi]]\n\n==[[:Category:Perl|Perl]][[Category:Perl]]==\n<lang Perl>#\/usr\/bin\/perl -w\nuse strict ;\n\ndie \"Call : perl columnaligner.pl <inputfile> <printorientation>!\\n\" unless\n   @ARGV == 2 ; #$ARGV[ 0 ] contains example file , $ARGV[1] any of 'left' , 'right' or 'center'\ndie \"last argument must be one of center, left or right!\\n\" unless\n   $ARGV[ 1 ] =~ \/center|left|right\/ ;\nsub printLines( $$$ ) ;\nopen INFILE , \"<\" , \"$ARGV[ 0 ]\" or die \"Can't open $ARGV[ 0 ]!\\n\" ;\nmy @lines = <INFILE> ;\nclose INFILE ;\nchomp @lines ;\nmy @fieldwidths = map length, split \/\\$\/ , $lines[ 0 ] ;\nforeach my $i ( 1..$#lines ) {\n   my @words = split \/\\$\/ , $lines[ $i ] ;\n   foreach my $j ( 0..$#words ) {\n      if ( $j <= $#fieldwidths ) {\n         if ( length $words[ $j ] > $fieldwidths[ $j ] ) {\n               $fieldwidths[ $j ] = length $words[ $j ] ;\n         }\n      }\n      else {\n         push @fieldwidths, length $words[ $j ] ;\n      }\n   }\n}\nprintLine( $_ , $ARGV[ 1 ] , \\@fieldwidths ) foreach @lines ;\n##################################################################    ####\nsub printLine {\n   my $line = shift ;\n   my $orientation = shift ;\n   my $widthref = shift ;\n   my @words = split \/\\$\/, $line ;\n   foreach my $k ( 0..$#words ) {\n      my $printwidth = $widthref->[ $k ] + 1 ;\n      if ( $orientation eq 'center' ) {\n         $printwidth++ ;\n      }\n      if ( $orientation eq 'left' ) {\n         print $words[ $k ] ;\n         print \" \" x ( $printwidth - length $words[ $k ] ) ;\n      }\n      elsif ( $orientation eq 'right' ) {\n         print \" \" x ( $printwidth - length $words[ $k ] ) ;\n         print $words[ $k ] ;\n      }\n      elsif ( $orientation eq 'center' ) {\n         my $left = int( ( $printwidth - length $words[ $k ] )     \/ 2 ) ;\n         my $right = $printwidth - length( $words[ $k ] ) - $left      ;\n         print \" \" x $left ;\n         print $words[ $k ] ;\n         print \" \" x $right ;\n      }\n   }\n   print \"\\n\" ;\n}<\/lang>\na shorter solution\n<lang perl>use List::Util qw(max);\n\nsub columns {\n    my @lines = map [split \/\\$\/] => split \/\\n\/ => shift;\n    my $pos = {qw\/left 0 center 1 right 2\/}->{+shift};\n    for my $col (0 .. max map {$#$_} @lines) {\n        my $max = max my @widths = map {length $_->[$col]} @lines;\n        for my $row (0 .. $#lines) {\n            my @pad = map {' ' x $_, ' ' x ($_ + 0.5)} ($max - $widths[$row]) \/ 2;\n            for ($lines[$row][$col])\n                {$_ = join '' => @pad[0 .. $pos-1], $_, @pad[$pos .. $#pad]}\n        }\n    }\n    join '' => map {\"@$_\\n\"} @lines\n}\n\nprint columns <<'END', $_ for qw(left right center);\nGiven$a$text$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$'dollar'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.\nEND<\/lang>\n\n==[[:Category:Perl 6|Perl 6]][[Category:Perl 6]]==\n<lang Perl 6>###to be called with perl6 columnaligner.pl <orientation>(left, center , right )\n###with left as default\nmy $fh = open  \"example.txt\" , :r  or die \"Can't read text file!\\n\" ;\nmy @filelines = $fh.lines ;\nclose $fh ;\nmy @maxcolwidths ; #array of the longest words per column\n#########fill the array with values#####################\nfor @filelines -> $line {\n   my @words = $line.split( \"\\$\" ) ;\n   for 0..@words.elems - 1 -> $i {\n      if @maxcolwidths[ $i ] {\n\t if @words[ $i ].chars > @maxcolwidths[$i] {\n\t    @maxcolwidths[ $i ] = @words[ $i ].chars ;\n\t }\n      }\n      else {\n\t @maxcolwidths.push( @words[ $i ].chars ) ;\n      }\n   }\n}\nmy $justification = @*ARGS[ 0 ] || \"left\" ;\n##print lines , $gap holds the number of spaces, 1 to be added \n##to allow for space preceding or following longest word\nfor @filelines -> $line {\n   my @words = $line.split( \"\\$\" ) ;\n   for 0 ..^ @words -> $i {\n      my $gap =  @maxcolwidths[$i] - @words[$i].chars + 1 ;\n      if $justification eq \"left\" {\n\t print @words[ $i ] ~ \" \" x $gap ;\n      } elsif $justification eq \"right\" {\n\t print  \" \" x $gap ~ @words[$i] ;\n      } elsif $justification eq \"center\" {\n\t $gap = ( @maxcolwidths[ $i ] + 2 - @words[$i].chars ) div 2 ;\n\t print \" \" x $gap ~ @words[$i] ~ \" \" x $gap ;\n      }\n   }\n   say ''; #for the newline\n}<\/lang>\n\nOr another way. To be called exactly as the first script.\n<lang Perl 6>my @lines = slurp(\"example.txt\").lines;\nmy @widths;\n\nfor @lines { for .split('$').kv { @widths[$^key] max= $^word.chars; } }\nfor @lines { say .split('$').kv.map: { (align @widths[$^key], $^word) ~ \" \"; } }\n\nsub align($column_width, $word, $aligment = @*ARGS[0]) {\n        my $lr = $column_width - $word.chars;\n        my $c  = $lr \/ 2;\n        given ($aligment) {\n                when \"center\" { \" \" x $c.ceiling ~ $word ~ \" \" x $c.floor }\n                when \"right\"  { \" \" x $lr        ~ $word                  }\n                default       {                    $word ~ \" \" x $lr      }\n        }\n}<\/lang>\n\n==[[:Category:PHP|PHP]][[Category:PHP]]==\n<lang php><?php\n$j2justtype = array('L' => STR_PAD_RIGHT,\n                    'R' => STR_PAD_LEFT,\n                    'C' => STR_PAD_BOTH);\n \n\/**\n Justify columns of textual tabular input where the record separator is the newline\n and the field separator is a 'dollar' character.\n justification can be L, R, or C; (Left, Right, or Centered).\n \n Return the justified output as a string\n*\/\nfunction aligner($str, $justification = 'L') {\n  global $j2justtype;\n  assert(array_key_exists($justification, $j2justtype));\n  $justtype = $j2justtype[$justification];\n\n  $fieldsbyrow = array();\n  foreach (explode(\"\\n\", $str) as $line)\n    $fieldsbyrow[] = explode('$', $line);\n  $maxfields = max(array_map('count', $fieldsbyrow));\n\n  foreach (range(0, $maxfields-1) as $col) {\n    $maxwidth = 0;\n    foreach ($fieldsbyrow as $fields)\n      $maxwidth = max($maxwidth, strlen($fields[$col]));\n    foreach ($fieldsbyrow as &$fields)\n      $fields[$col] = str_pad($fields[$col], $maxwidth, ' ', $justtype);\n    unset($fields); \/\/ see http:\/\/bugs.php.net\/29992\n  }\n  $result = '';\n  foreach ($fieldsbyrow as $fields)\n    $result .= implode(' ', $fields) . \"\\n\";\n  return $result;\n}\n\n$textinfile = 'Given$a$text$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$\\'dollar\\'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.';\n \nforeach (array('L', 'R', 'C') as $j)\n  echo aligner($textinfile, $j);\n\n?><\/lang>\n\n==[[:Category:PicoLisp|PicoLisp]][[Category:PicoLisp]]==\n<lang PicoLisp>(let Sizes NIL                         # Build a list of sizes\n   (let Lines                          # and of lines\n      (make\n         (in \"input.txt\"                     # Reading input file\n            (while (split (line) \"$\")        # delimited by '$'\n               (let (L (link (mapcar pack @))  S Sizes)\n                  (setq Sizes                   # Maintain sizes\n                     (make\n                        (while (or L S)\n                           (link\n                              (max\n                                 (inc (length (pop 'L)))\n                                 (pop 'S) ) ) ) ) ) ) ) ) )\n      (for L Lines                                 # Print lines\n         (prinl (apply align L (mapcar - Sizes))) )   # left aligned\n      (prinl)\n      (for L Lines\n         (prinl (apply align L Sizes)) )              # right aligned\n      (prinl)\n      (for L Lines\n         (prinl (apply center L Sizes)) ) ) )         # and centered<\/lang>\nOutput:\n<pre>Given      a          text       file   of     many      lines,     where    fields  within  a      line  \nare        delineated by         a      single 'dollar'  character, write    a       program              \nthat       aligns     each       column of     fields    by         ensuring that    words   in     each  \ncolumn     are        separated  by     at     least     one        space.                                \nFurther,   allow      for        each   word   in        a          column   to      be      either left  \njustified, right      justified, or     center justified within     its      column.                      \n\n      Given          a       text   file     of      many     lines,    where  fields  within      a line \n        are delineated         by      a single  'dollar' character,    write       a program             \n       that     aligns       each column     of    fields         by ensuring    that   words     in each \n     column        are  separated     by     at     least        one   space.                             \n   Further,      allow        for   each   word        in          a   column      to      be either left \n justified,      right justified,     or center justified     within      its column.                     \n\n   Given        a        text     file    of      many     lines,     where   fields  within    a   line \n    are    delineated     by        a   single  'dollar' character,   write     a    program             \n   that      aligns      each    column   of     fields      by     ensuring   that   words    in   each \n  column       are     separated   by     at     least       one     space.                              \n Further,     allow       for     each   word      in         a      column     to      be   either left \njustified,    right   justified,   or   center justified   within      its   column.                     <\/pre>\n\n==[[:Category:PL\/I|PL\/I]][[Category:PL\/I]]==\n<lang PL\/I>\ndeclare text character (300) varying;\ndeclare word character (20) varying;\ndeclare justification character (1);\ndeclare k fixed binary;\ndeclare input file, output file output;\n\nopen file (input)  title ( '\/CENTER.DAT,type(text),recsize(1000)' );\nopen file (output) title ( '\/OUT.TXT,type(text),recsize(1000)' );\non endfile (input) stop;\n\ndisplay ('Specify whether justification is left, centered, or right');\ndisplay ('Reply with a single letter: L, C, or R');\nget edit (justification) (A(1));\n\ndo forever;\n   get file (input) edit (text) (L);\n   put skip list (text);\n   text = trim(text, '$', '$');\n   do until (k = 0);\n      k = index(text, '$');\n      if k = 0 then \/* last word in line *\/\n         word = text;\n      else\n         do;\n            word = substr(text, 1, k-1);\n            text = substr(text, k);\n            text = trim(text, '$');\n         end;\n      select (justification);\n         when ('C', 'c') word = center(word, maxlength(word));\n         when ('R', 'r') word = right (word, maxlength(word));\n         otherwise ; \/* The default is left adjusted. *\/\n      end;\n      put file (output) edit (word) (a(maxlength(word)));\n   end;\n   put file (output) skip;\nend;\n<\/lang>\n\n\n==[[:Category:Prolog|Prolog]][[Category:Prolog]]==\nWorks with SWI-Prolog.\n<lang Prolog>aligner :-\n\tL =\"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$'dollar'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.\",\n\n\t% read the lines and the words\n\t% compute the length of the longuest word.\n\t% LP is the list of lines, \n\t% each line is a list of words\n\tparse(L, 0, N, LP, []),\n\n\t% we need to add 1 to aligned\n\tN1 is N+1,\n\t% words will be left aligned\n\tsformat(AL, '~~w~~t~~~w|', [N1]),\n\t% words will be centered\n\tsformat(AC, '~~t~~w~~t~~~w|', [N1]),\n\t% words will be right aligned\n\tsformat(AR, '~~t~~w~~~w|', [N1]),\n\n\twrite('Left justified :'), nl,\n\tmaplist(affiche(AL), LP), nl,\n\twrite('Centered justified :'), nl,\n\tmaplist(affiche(AC), LP), nl,\n\twrite('Right justified :'), nl,\n\tmaplist(affiche(AR), LP), nl.\n\naffiche(F, L) :-\n\tmaplist(my_format(F), L),\n\tnl.\n\nmy_format(_F, [13]) :-\n\tnl.\n\nmy_format(F, W) :-\n\tstring_to_atom(W,AW),\n\tsformat(AF, F, [AW]),\n\twrite(AF).\n\n\nparse([], Max, Max) --> [].\n\nparse(T, N, Max) -->\n\t{ parse_line(T, 0, N1, T1, L, []),\n\t  (   N1 > N -> N2 = N1; N2 = N)},\n\t[L],\n\tparse(T1, N2, Max).\n\nparse_line([], NF, NF, []) --> [].\n\nparse_line([H|TF], NF, NF, TF) -->\n\t{code_type(H, end_of_line), !},\n\t[].\n\n\nparse_line(T, N, NF, TF) -->\n\t{ parse_word(T, 0, N1, T1, W, []),\n\t  (   N1 > N -> N2 = N1; N2 = N)},\n\t[W],\n\tparse_line(T1, N2, NF, TF).\n\n% 36 is the code of '$'\nparse_word([36|T], N, N, T) -->\n\t{!},\n\t[].\n\nparse_word([H|T], N, N, [H|T]) -->\n\t{code_type(H, end_of_line), !},\n\t[].\n\nparse_word([], N, N, []) --> [].\n\nparse_word([H|T], N1, NF, TF) -->\n\t[H],\n\t{N2 is  N1 + 1},\n\tparse_word(T, N2, NF, TF).\n<\/lang>\n\nOutput :\n<FONT SIZE=\"2\"><pre> ?- aligner.\nLeft justified :\nGiven      a          text       file       of         many       lines,     where      fields     within     a          line       \nare        delineated by         a          single     'dollar'   character, write      a          program    \nthat       aligns     each       column     of         fields     by         ensuring   that       words      in         each       \ncolumn     are        separated  by         at         least      one        space.     \nFurther,   allow      for        each       word       in         a          column     to         be         either     left       \njustified, right      justified, or         center     justified  within     its        column.    \n\nCentered justified :\n   Given        a        text       file        of        many      lines,      where     fields     within        a        line    \n    are    delineated     by          a       single    'dollar'  character,    write        a       program  \n   that      aligns      each      column       of       fields       by      ensuring     that       words       in        each    \n  column       are     separated     by         at        least       one      space.   \n Further,     allow       for       each       word        in          a       column       to         be       either      left    \njustified,    right   justified,     or       center    justified   within       its      column.  \n\nRight justified :\n      Given          a       text       file         of       many     lines,      where     fields     within          a       line\n        are delineated         by          a     single   'dollar' character,      write          a    program\n       that     aligns       each     column         of     fields         by   ensuring       that      words         in       each\n     column        are  separated         by         at      least        one     space.\n   Further,      allow        for       each       word         in          a     column         to         be     either       left\n justified,      right justified,         or     center  justified     within        its    column.\n\ntrue .<\/pre><\/FONT>\n\n==[[:Category:PureBasic|PureBasic]][[Category:PureBasic]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[PureBasic]] version 4.41[[SMW::on]]<\/div> \n<lang PureBasic>Declare max(a,b)\n\nIf OpenConsole()\n  Define a, i, x, y, maxlen\n  Dim txt.s(0)\n  Restore lines             ; Get address of the first data block \n  Read.i  a\n  ReDim txt(a)\n  For i=0 To a              ; Read the raw data lines\n    Read.s txt(i)\n    txt(i)=Trim(txt(i),\"$\") ; Remove any bad '$' that may be useless in the end...\n    x=max(CountString(txt(i),\"$\"),x)\n  Next\n  y=a\n  Dim matrix.s(x,y)         ; Set up a nice matrix to work with, each word cleanly separated\n  For x=0 To ArraySize(matrix(),1)\n    For y=0 To ArraySize(matrix(),2)\n      matrix(x,y)=StringField(txt(y),x+1,\"$\")\n      maxlen=max(maxlen,Len(matrix(x,y)))\n    Next\n  Next\n  If maxlen%2\n    maxlen+1                ; Just to make sure that 'centered' output looks nice....\n  EndIf\n  \n  PrintN(#CRLF$+\"---- Right ----\")\n  For y=0 To ArraySize(matrix(),2)\n    For x=0 To ArraySize(matrix(),1)\n      Print(RSet(matrix(x,y),maxlen+1))\n    Next\n    PrintN(\"\")\n  Next\n  \n  PrintN(#CRLF$+\"---- Left ----\")\n  For y=0 To ArraySize(matrix(),2)\n    For x=0 To ArraySize(matrix(),1)\n      Print(LSet(matrix(x,y),maxlen+1))\n    Next\n    PrintN(\"\")\n  Next\n  \n  PrintN(#CRLF$+\"---- Center ----\")\n  For y=0 To ArraySize(matrix(),2)\n    For x=0 To ArraySize(matrix(),1)\n      a=maxlen-Len(matrix(x,y))\n      Print(LSet(RSet(matrix(x,y),maxlen-a\/2),maxlen))\n    Next\n    PrintN(\"\")\n  Next\n  \n  PrintN(#CRLF$+#CRLF$+\"Press ENTER to quit.\"): Input()\n  CloseConsole()\nEndIf\n\n\nProcedure max(x,y)\n  If x>=y\n    ProcedureReturn x\n  Else\n    ProcedureReturn y\n  EndIf\nEndProcedure\n\n\nDataSection\nlines:\n  Data.i  5 ; e.g. 6-1 since first line is equal to 'zero'.\ntext:\n  Data.s \"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\"\n  Data.s \"are$delineated$by$a$single$'dollar'$character,$write$a$program\"\n  Data.s \"that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\"\n  Data.s \"column$are$separated$by$at$least$one$space.\"\n  Data.s \"Further,$allow$for$each$word$in$a$column$oo$be$either$left$\"\n  Data.s \"justified,$right$justified,$or$center$justified$within$its$column.\"\nEndDataSection<\/lang>\n\n==[[:Category:Python|Python]][[Category:Python]]==\n<lang python>from StringIO import StringIO\n \ntextinfile = '''Given$a$text$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$'dollar'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.'''\n \nj2justifier = dict(L=str.ljust, R=str.rjust, C=str.center)\n \ndef aligner(infile, justification = 'L'):\n  ''' \\\n  Justify columns of textual tabular input where the row separator is the newline\n  and the field separator is a 'dollar' character.\n  justification can be L, R, or C; (Left, Right, or Centered).\n \n  Return the justified output as a string\n  '''\n  assert justification in j2justifier, \"justification can be L, R, or C; (Left, Right, or Centered).\"\n  justifier = j2justifier[justification]\n \n  fieldsbyrow= [line.strip().split('$') for line in infile]\n  # pad to same number of fields per row\n  maxfields = max(len(row) for row in fieldsbyrow)\n  fieldsbyrow = [fields + ['']*(maxfields - len(fields))\n                    for fields in fieldsbyrow]\n  # rotate\n  fieldsbycolumn = zip(*fieldsbyrow)\n  # calculate max fieldwidth per column\n  colwidths = [max(len(field) for field in column)\n               for column in fieldsbycolumn]\n  # pad fields in columns to colwidth with spaces\n  fieldsbycolumn = [ [justifier(field, width) for field in column]\n                     for width, column in zip(colwidths, fieldsbycolumn) ]\n  # rotate again\n  fieldsbyrow = zip(*fieldsbycolumn)\n \n  return \"\\n\".join( \" \".join(row) for row in fieldsbyrow)\n \n \nfor align in 'Left Right Center'.split():\n  infile = StringIO(textinfile)\n  print \"\\n# %s Column-aligned output:\" % align\n  print aligner(infile, align[0])<\/lang>\n\nExample output:\n<pre>\n# Left Column-aligned output:\nGiven      a          text       file   of     many      lines,     where    fields  within  a      line \nare        delineated by         a      single 'dollar'  character, write    a       program             \nthat       aligns     each       column of     fields    by         ensuring that    words   in     each \ncolumn     are        separated  by     at     least     one        space.                               \nFurther,   allow      for        each   word   in        a          column   to      be      either left \njustified, right      justified, or     center justified within     its      column.                     \n\n# Right Column-aligned output:\n     Given          a       text   file     of      many     lines,    where  fields  within      a line \n       are delineated         by      a single  'dollar' character,    write       a program             \n      that     aligns       each column     of    fields         by ensuring    that   words     in each \n    column        are  separated     by     at     least        one   space.                             \n  Further,      allow        for   each   word        in          a   column      to      be either left \njustified,      right justified,     or center justified     within      its column.                     \n\n# Center Column-aligned output:\n  Given        a         text     file    of      many     lines,    where    fields  within   a    line \n   are     delineated     by       a    single  'dollar' character,  write      a    program             \n   that      aligns      each    column   of     fields      by     ensuring   that   words    in   each \n  column      are     separated    by     at     least      one      space.                              \n Further,    allow       for      each   word      in        a       column     to      be   either left \njustified,   right    justified,   or   center justified   within     its    column.                     <\/pre>\n\n===Alternative version===\n<div class=\"examplemeta translation\">'''Translation of''': [[Align columns#D|D]]<\/div>\n<lang python>txt = \"\"\"Given$a$txt$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$'dollar'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.\"\"\"\n\nparts = [line.rstrip(\"$\").split(\"$\") for line in txt.splitlines()]\n\nmax_widths = {}\nfor line in parts:\n    for i, word in enumerate(line):\n        max_widths[i] = max(max_widths.get(i, 0), len(word))\n\nfor i, justify in enumerate([str.ljust, str.center, str.rjust]):\n    print [\"Left\", \"Center\", \"Right\"][i], \" column-aligned output:\\n\"\n    for line in parts:\n        for j, word in enumerate(line):\n            print justify(word, max_widths[j]),\n        print\n    print \"- \" * 52<\/lang>\n\n==[[:Category:R|R]][[Category:R]]==\n<lang R># Read in text\nlines <- readLines(tc <- textConnection(\"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$'dollar'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.\")); close(tc)\n\n#Split words by the dollar\nwords <- strsplit(lines, \"\\\\$\")\n\n#Reformat\nmaxlen <- max(sapply(words, length))\nwords <- lapply(words, function(x) {length(x) <- maxlen; x})\nblock <- matrix(unlist(words), byrow=TRUE, ncol=maxlen)\nblock[is.na(block)] <- \"\"\nleftjust <- format(block)\nrightjust <- format(block, justify=\"right\")\ncentrejust <- format(block, justify=\"centre\")\n\n# Print\nprint0 <- function(x) invisible(apply(x, 1, function(x) cat(x, \"\\n\")))\nprint0(leftjust)\nprint0(rightjust)\nprint0(centrejust)<\/lang>\nRight justified output shown.\n<div style=\"width:full;overflow:scroll\"><pre>\n     Given          a       text       file         of       many     lines,      where     fields     within          a       line \n       are delineated         by          a     single   'dollar' character,      write          a    program                       \n      that     aligns       each     column         of     fields         by   ensuring       that      words         in       each \n    column        are  separated         by         at      least        one     space.                                             \n  Further,      allow        for       each       word         in          a     column         to         be     either       left \njustified,      right justified,         or     center  justified     within        its    column.                                  \n<\/pre><\/div>\n\n==[[:Category:REBOL|REBOL]][[Category:REBOL]]==\n<lang rebol>REBOL [\n\tTitle: \"Align Columns\"\n\tAuthor: oofoe\n\tDate: 2010-09-29\n\tURL: http:\/\/rosettacode.org\/wiki\/Align_columns\n]\n\nspecimen: {Given$a$text$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$'dollar'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.}\n\n; Parse specimen into data grid.\n\ndata: copy []\nforeach line parse specimen to-string lf [ ; Break into lines.\n\tappend\/only data parse line \"$\"        ; Break into columns.\n]\n\n; Compute independent widths for each column.\n\nwidths: copy []  insert\/dup widths 0 length? data\/1\nforeach line data [\n\tforall line [\n\t\ti: index? line\n\t\twidths\/:i: max widths\/:i length? line\/1\n\t]\n]\n\npad: func [n \/local x][x: copy \"\"  insert\/dup x \" \" n  x]\n\n; These formatting functions are passed as arguments to entable.\n\nright: func [n s][rejoin [pad n - length? s  s]]\n\nleft: func [n s][rejoin [s  pad n - length? s]]\n\ncentre: func [n s \/local h][\n\th: round\/down (n - length? s) \/ 2\n\trejoin [pad h  s  pad n - h - length? s]\n]\n\n; Display data as table.\n\nentable: func [data format] [\n\tforeach line data [\n\t\tforall line [\n\t\t\tprin rejoin [format  pick widths index? line  line\/1  \" \"]\n\t\t]\n\t\tprint \"\"\n\t]\n]\n\n; Format data table.\n\nforeach i [left centre right] [\n\tprint [\"^\/Align\" i \"...^\/\"]  entable data get i]\n<\/lang>\n\nSample output:\n\n<pre style=\"height:15ex;overflow:scroll\">Align left ...\n\nGiven      a          text       file   of     many      lines,     where    fields  within  a      line\nare        delineated by         a      single 'dollar'  character, write    a       program\nthat       aligns     each       column of     fields    by         ensuring that    words   in     each\ncolumn     are        separated  by     at     least     one        space.\nFurther,   allow      for        each   word   in        a          column   to      be      either left\njustified, right      justified, or     center justified within     its      column.\n\nAlign centre ...\n\n  Given        a         text     file    of     many      lines,    where   fields  within    a    line\n   are     delineated     by       a    single 'dollar'  character,  write      a    program\n   that      aligns      each    column   of    fields       by     ensuring  that    words    in   each\n  column      are     separated    by     at     least      one      space.\n Further,    allow       for      each   word     in         a       column    to      be    either left\njustified,   right    justified,   or   center justified   within     its    column.\n\nAlign right ...\n\n     Given          a       text   file     of      many     lines,    where  fields  within      a line\n       are delineated         by      a single  'dollar' character,    write       a program\n      that     aligns       each column     of    fields         by ensuring    that   words     in each\n    column        are  separated     by     at     least        one   space.\n  Further,      allow        for   each   word        in          a   column      to      be either left\njustified,      right justified,     or center justified     within      its column.\n<\/pre>\n\n==[[:Category:REXX|REXX]][[Category:REXX]]==\n===version 1===\n<lang rexx>\/*REXX*\/\nz.1 = \"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\"\nz.2 = \"are$delineated$by$a$single$'dollar'$character,$write$a$program\"\nz.3 = \"that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\"\nz.4 = \"column$are$separated$by$at$least$one$space.\"\nz.5 = \"Further,$allow$for$each$word$in$a$column$to$be$either$left$\"\nz.6 = \"justified,$right$justified,$or$center$justified$within$its$column.\"\n\nword. = \"\"\nwidth. = 0\nmaxcol = 0\ndo row = 1 to 6\n  line = z.row\n  do col = 1 by 1 until length(line) = 0\n    parse var line word.row.col \"$\" line\n    if length(word.row.col) > width.col then width.col = length(word.row.col)\n  end\n  if col > maxcol then maxcol = col\nend\n\nsay \"align left:\"\nsay\ndo row = 1 to 6\n  out = \"\"\n  do col = 1 to maxcol\n    out = out || left(word.row.col,width.col+1)\n  end\n  say out\nend\nsay\nsay \"align right:\"\nsay\ndo row = 1 to 6\n  out = \"\"\n  do col = 1 to maxcol\n    out = out || right(word.row.col,width.col+1)\n  end\n  say out\nend\nsay\nsay \"align center:\"\nsay\ndo row = 1 to 6\n  out = \"\"\n  do col = 1 to maxcol\n    out = out || center(word.row.col,width.col+1)\n  end\n  say out\nend<\/lang>\n===version 2===\n<lang rexx>\/*REXX program to display various alignments. *\/\ncols=0;   size=0;   wid.=0;   t.='';   @.=''\n\nt.1 = \"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\"\nt.2 = \"are$delineated$by$a$single$'dollar'$character,$write$a$program\"\nt.3 = \"that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\"\nt.4 = \"column$are$separated$by$at$least$one$space.\"\nt.5 = \"Further,$allow$for$each$word$in$a$column$to$be$either$left$\"\nt.6 = \"justified,$right$justified,$or$center$justified$within$its$column.\"\n\n  do r=1 while t.r\\==''\n  _=strip(t.r,,'$')\n                       do c=1 until _==''\n                       parse var _ @.r.c '$' _\n                       wid.c=max(wid.c,length(@.r.c))\n                       end   \/*c*\/\n  cols=max(cols,c)\n  end    \/*r*\/\n\nrows=r-1                                   \/*adjust ROWS, it's 1 too big*\/\n  do k=1 for cols;  size=size+wid.k;  end  \/*find width of biggest line.*\/\n\n  do j=1 for 3;  say\n  say center(word('left right center',j) \"aligned\",size+cols-1,\"=\")\n\n                 do r=1 for rows;   _=\n                       do c=1 for cols;  x=@.r.c\n                       if j==1 then _=_   left(x,wid.c)\n                       if j==2 then _=_  right(x,wid.c)\n                       if j==3 then _=_ centre(x,wid.c)\n                       end   \/*c*\/\n                 say substr(_,2)\n                 end         \/*r*\/\n  say\n  end   \/*j*\/<\/lang>\n'''output'''\n<pre style=\"height:30ex;overflow:scroll\">\n\n==============================================left aligned==============================================\nGiven      a          text       file   of     many      lines,     where    fields  within  a      line\nare        delineated by         a      single 'dollar'  character, write    a       program\nthat       aligns     each       column of     fields    by         ensuring that    words   in     each\ncolumn     are        separated  by     at     least     one        space.\nFurther,   allow      for        each   word   in        a          column   to      be      either left\njustified, right      justified, or     center justified within     its      column.\n\n\n=============================================right aligned==============================================\n     Given          a       text   file     of      many     lines,    where  fields  within      a line\n       are delineated         by      a single  'dollar' character,    write       a program\n      that     aligns       each column     of    fields         by ensuring    that   words     in each\n    column        are  separated     by     at     least        one   space.\n  Further,      allow        for   each   word        in          a   column      to      be either left\njustified,      right justified,     or center justified     within      its column.\n\n\n=============================================center aligned=============================================\n  Given        a         text     file    of     many      lines,    where   fields  within    a    line\n   are     delineated     by       a    single 'dollar'  character,  write      a    program\n   that      aligns      each    column   of    fields       by     ensuring  that    words    in   each\n  column      are     separated    by     at     least      one      space.\n Further,    allow       for      each   word     in         a       column    to      be    either left\njustified,   right    justified,   or   center justified   within     its    column.\n<\/pre>\n===version 3===\nNote: This version adds boxes around columns of output.\n<lang rexx>\/*REXX program to display various alignments.                           *\/\ncols=0;   parse var cols size 1 wid. t.               \/*initializations.*\/\n\nt.1 = \"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\"\nt.2 = \"are$delineated$by$a$single$'dollar'$character,$write$a$program\"\nt.3 = \"that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\"\nt.4 = \"column$are$separated$by$at$least$one$space.\"\nt.5 = \"Further,$allow$for$each$word$in$a$column$to$be$either$left$\"\nt.6 = \"justified,$right$justified,$or$center$justified$within$its$column.\"\n\n  do r=1 while t.r\\==''\n  t.r=translate(t.r,,'$')\n                           do c=1 until word(t.r,c)==''\n                           wid.c=max(wid.c,length(word(t.r,c)))\n                           end   \/*c*\/\n  cols=max(cols,c)\n  end   \/*r*\/\n\nrows=r-1                                   \/*adjust ROWS, it's 1 too big*\/\n\n  do k=1 for cols;  size=size+wid.k;  end  \/*find width of biggest line.*\/\n\n  do j=1 for 3;   say\n  say center(word('left right center',j) \"aligned\",size+cols,\"=\");   say\n\n                 do r=0 to rows;   _=;   !='\u2502';   if r==0 then !='\u252c'\n\n                       do c=1 for cols;   x=word(t.r,c)\n                       if r==0 then x=copies(\"\u2500\",wid.c+1)\n                               else x=word(t.r,c)\n                       if j==1 then _=_ || ! ||   left(x,wid.c)\n                       if j==2 then _=_ || ! ||  right(x,wid.c)\n                       if j==3 then _=_ || ! || centre(x,wid.c)\n                       end   \/*c*\/\n\n                 if r==0 then do;   _='\u250c'substr(_,2,length(_)-2)\"\u2510\"\n                                  bot='\u2514'substr(_,2,length(_)-2)\"\u2518\"\n                              end\n                 say _\n                 end         \/*r*\/\n\n  say translate(bot,'\u2534',\"\u252c\"); say; say\n  end   \/*j*\/<\/lang>\n'''output'''\n<pre style=\"height:30ex;overflow:scroll\">\n===============================================left aligned===============================================\n\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2510\n\u2502Given     \u2502a         \u2502text      \u2502file  \u2502of    \u2502many     \u2502lines,    \u2502where   \u2502fields \u2502within \u2502a     \u2502line\u2502\n\u2502are       \u2502delineated\u2502by        \u2502a     \u2502single\u2502'dollar' \u2502character,\u2502write   \u2502a      \u2502program\u2502      \u2502    \u2502\n\u2502that      \u2502aligns    \u2502each      \u2502column\u2502of    \u2502fields   \u2502by        \u2502ensuring\u2502that   \u2502words  \u2502in    \u2502each\u2502\n\u2502column    \u2502are       \u2502separated \u2502by    \u2502at    \u2502least    \u2502one       \u2502space.  \u2502       \u2502       \u2502      \u2502    \u2502\n\u2502Further,  \u2502allow     \u2502for       \u2502each  \u2502word  \u2502in       \u2502a         \u2502column  \u2502to     \u2502be     \u2502either\u2502left\u2502\n\u2502justified,\u2502right     \u2502justified,\u2502or    \u2502center\u2502justified\u2502within    \u2502its     \u2502column.\u2502       \u2502      \u2502    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2518\n\n\n\n==============================================right aligned===============================================\n\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2510\n\u2502     Given\u2502         a\u2502      text\u2502  file\u2502    of\u2502     many\u2502    lines,\u2502   where\u2502 fields\u2502 within\u2502     a\u2502line\u2502\n\u2502       are\u2502delineated\u2502        by\u2502     a\u2502single\u2502 'dollar'\u2502character,\u2502   write\u2502      a\u2502program\u2502      \u2502    \u2502\n\u2502      that\u2502    aligns\u2502      each\u2502column\u2502    of\u2502   fields\u2502        by\u2502ensuring\u2502   that\u2502  words\u2502    in\u2502each\u2502\n\u2502    column\u2502       are\u2502 separated\u2502    by\u2502    at\u2502    least\u2502       one\u2502  space.\u2502       \u2502       \u2502      \u2502    \u2502\n\u2502  Further,\u2502     allow\u2502       for\u2502  each\u2502  word\u2502       in\u2502         a\u2502  column\u2502     to\u2502     be\u2502either\u2502left\u2502\n\u2502justified,\u2502     right\u2502justified,\u2502    or\u2502center\u2502justified\u2502    within\u2502     its\u2502column.\u2502       \u2502      \u2502    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2518\n\n\n\n==============================================center aligned==============================================\n\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2510\n\u2502  Given   \u2502    a     \u2502   text   \u2502 file \u2502  of  \u2502  many   \u2502  lines,  \u2502 where  \u2502fields \u2502within \u2502  a   \u2502line\u2502\n\u2502   are    \u2502delineated\u2502    by    \u2502  a   \u2502single\u2502'dollar' \u2502character,\u2502 write  \u2502   a   \u2502program\u2502      \u2502    \u2502\n\u2502   that   \u2502  aligns  \u2502   each   \u2502column\u2502  of  \u2502 fields  \u2502    by    \u2502ensuring\u2502 that  \u2502 words \u2502  in  \u2502each\u2502\n\u2502  column  \u2502   are    \u2502separated \u2502  by  \u2502  at  \u2502  least  \u2502   one    \u2502 space. \u2502       \u2502       \u2502      \u2502    \u2502\n\u2502 Further, \u2502  allow   \u2502   for    \u2502 each \u2502 word \u2502   in    \u2502    a     \u2502 column \u2502  to   \u2502  be   \u2502either\u2502left\u2502\n\u2502justified,\u2502  right   \u2502justified,\u2502  or  \u2502center\u2502justified\u2502  within  \u2502  its   \u2502column.\u2502       \u2502      \u2502    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2518\n<\/pre>\n\n==[[:Category:Ruby|Ruby]][[Category:Ruby]]==\n<lang ruby>require 'stringio'\n\ntextinfile = <<END\nGiven$a$text$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$'dollar'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.\nEND\n\nJ2justifier = {'L' => String.instance_method(:ljust),\n               'R' => String.instance_method(:rjust),\n               'C' => String.instance_method(:center)}\n \n=begin\nJustify columns of textual tabular input where the record separator is the newline\nand the field separator is a 'dollar' character.\njustification can be L, R, or C; (Left, Right, or Centered).\n\nReturn the justified output as a string\n=end\ndef aligner(infile, justification = 'L')\n  justifier = J2justifier[justification]\n \n  fieldsbyrow = infile.map {|line| line.strip.split('$')}\n  # pad to same number of fields per record\n  maxfields = fieldsbyrow.map {|row| row.length}.max\n  fieldsbyrow.map! {|row|\n    row + ['']*(maxfields - row.length)\n  }\n  # calculate max fieldwidth per column\n  colwidths = fieldsbyrow.transpose.map {|column|\n    column.map {|field| field.length}.max\n  }\n  # pad fields in columns to colwidth with spaces\n  fieldsbyrow.map! {|row|\n    row.zip(colwidths).map {|field, width|\n      justifier.bind(field)[width]\n    }\n  }\n \n  fieldsbyrow.map {|row| row.join(\" \")}.join(\"\\n\")\nend\n\nfor align in %w{Left Right Center}\n  infile = StringIO.new(textinfile)\n  puts \"\\n# %s Column-aligned output:\" % align\n  puts aligner(infile, align[0..0])\nend<\/lang>\n\nExample output:\n<pre>\n# Left Column-aligned output:\nGiven      a          text       file   of     many      lines,     where    fields  within  a      line\nare        delineated by         a      single 'dollar'  character, write    a       program            \nthat       aligns     each       column of     fields    by         ensuring that    words   in     each\ncolumn     are        separated  by     at     least     one        space.                              \nFurther,   allow      for        each   word   in        a          column   to      be      either left\njustified, right      justified, or     center justified within     its      column.                    \n\n# Right Column-aligned output:\n     Given          a       text   file     of      many     lines,    where  fields  within      a line\n       are delineated         by      a single  'dollar' character,    write       a program            \n      that     aligns       each column     of    fields         by ensuring    that   words     in each\n    column        are  separated     by     at     least        one   space.                            \n  Further,      allow        for   each   word        in          a   column      to      be either left\njustified,      right justified,     or center justified     within      its column.                    \n\n# Center Column-aligned output:\n  Given        a         text     file    of     many      lines,    where   fields  within    a    line\n   are     delineated     by       a    single 'dollar'  character,  write      a    program            \n   that      aligns      each    column   of    fields       by     ensuring  that    words    in   each\n  column      are     separated    by     at     least      one      space.                             \n Further,    allow       for      each   word     in         a       column    to      be    either left\njustified,   right    justified,   or   center justified   within     its    column.                    \n<\/pre>\n\n==[[:Category:Run BASIC|Run BASIC]][[Category:Run BASIC]]==\n<lang Runbasic>theString$ = \"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\" _\n+ \"are$delineated$by$a$single$'dollar'$character,$write$a$program\" _\n+ \"that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\"_\n+ \"column$are$separated$by$at$least$one$space.\" _\n+ \"Further,$allow$for$each$word$in$a$column$to$be$either$left$\" _\n+ \"justified,$right$justified,$or$center$justified$within$its$column.\"\n\nx = shoTable(theString$,\"left\",6)\nx = shoTable(theString$,\"right\",6)\nx = shoTable(theString$,\"center\",6)\nend\n\nFUNCTION shoTable(theString$,align$,across)\nprint \"------------ align:\";align$;\" -- across:\";across;\" ------------\"\ndim siz(across)\nb$ = \"                                          \"\nwhile word$(theString$,i+1,\"$\") <> \"\"\n\tsiz(i mod across) = max(siz(i mod across),len(word$(theString$,i + 1,\"$\")))\n\ti = i + 1\nwend\nfor i = 0 to across - 1\n\tsiz(i) = siz(i) + 1\n\tif siz(i) and 1 then siz(i) = siz(i) + 1\nnext i\n\ni = 0\na$ = word$(theString$,i+1,\"$\")\nwhile a$ <> \"\"\n        s = siz(i mod across) - len(a$)\n\tif align$ = \"right\"   then a$ = left$(b$,s);a$\n\tif align$ = \"left\"    then a$ = a$;left$(b$,s)\n\tif align$ = \"center\"  then a$ = left$(b$,int(s \/ 2));a$;left$(b$,int(s \/ 2) + (s and 1))\n\tprint \"|\";a$;\n\ti  = i + 1\n\tif i mod across = 0 then print \"|\"\n\ta$ = word$(theString$,i+1,\"$\")\nwend\nprint\nend function<\/lang>Output:\n<pre style=\"height:15ex;overflow:scroll\">------------ align:left -- across:6 ------------\n|Given       |a           |text    |file        |of              |many      |\n|lines,      |where       |fields  |within      |a               |line      |\n|are         |delineated  |by      |a           |single          |'dollar'  |\n|character,  |write       |a       |programthat |aligns          |each      |\n|column      |of          |fields  |by          |ensuring        |that      |\n|words       |in          |each    |column      |are             |separated |\n|by          |at          |least   |one         |space.Further,  |allow     |\n|for         |each        |word    |in          |a               |column    |\n|to          |be          |either  |left        |justified,      |right     |\n|justified,  |or          |center  |justified   |within          |its       |\n|column.     \n------------ align:right -- across:6 ------------\n|       Given|           a|    text|        file|              of|      many|\n|      lines,|       where|  fields|      within|               a|      line|\n|         are|  delineated|      by|           a|          single|  'dollar'|\n|  character,|       write|       a| programthat|          aligns|      each|\n|      column|          of|  fields|          by|        ensuring|      that|\n|       words|          in|    each|      column|             are| separated|\n|          by|          at|   least|         one|  space.Further,|     allow|\n|         for|        each|    word|          in|               a|    column|\n|          to|          be|  either|        left|      justified,|     right|\n|  justified,|          or|  center|   justified|          within|       its|\n|     column.\n------------ align:center -- across:6 ------------\n|   Given    |     a      |  text  |    file    |       of       |   many   |\n|   lines,   |   where    | fields |   within   |       a        |   line   |\n|    are     | delineated |   by   |     a      |     single     | 'dollar' |\n| character, |   write    |   a    |programthat |     aligns     |   each   |\n|   column   |     of     | fields |     by     |    ensuring    |   that   |\n|   words    |     in     |  each  |   column   |      are       |separated |\n|     by     |     at     | least  |    one     | space.Further, |  allow   |\n|    for     |    each    |  word  |     in     |       a        |  column  |\n|     to     |     be     | either |    left    |   justified,   |  right   |\n| justified, |     or     | center | justified  |     within     |   its    |\n|  column.   <\/pre>\n\n==[[:Category:Scala|Scala]][[Category:Scala]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[scala]] version 2.8.0.r18997-b20091009021954[[SMW::on]]<\/div>\n\nFor Scala 2.7, change from fromPath to fromFile, and remove the extra parameter to Source's getLines.\n\n<lang scala>object ColumnAligner {\n  val eol = System.getProperty(\"line.separator\")\n  def getLines(filename: String) = scala.io.Source.fromPath(filename).getLines(eol)\n  def splitter(line: String) = line split '$'\n  def getTable(filename: String) = getLines(filename) map splitter\n  def fieldWidths(fields: Array[String]) = fields map (_ length)\n  def columnWidths(txt: Iterator[Array[String]]) = (txt map fieldWidths).toList.transpose map (_ max)\n\n  def alignField(alignment: Char)(width: Int)(field: String) = alignment match {\n    case 'l' | 'L' => \"%-\"+width+\"s\" format field\n    case 'r' | 'R' => \"%\"+width+\"s\" format field\n    case 'c' | 'C' => val padding = (width - field.length) \/ 2; \" \"*padding+\"%-\"+(width-padding)+\"s\" format field\n    case _ => throw new IllegalArgumentException\n  }\n\n  def align(aligners: List[String => String])(fields: Array[String]) =\n    aligners zip fields map Function.tupled(_ apply _)\n  \n  def alignFile(filename: String, alignment: Char) = {\n    def table = getTable(filename)\n    val aligners = columnWidths(table) map alignField(alignment)\n    table map align(aligners) map (_ mkString \" \")\n  }\n  \n  def printAlignedFile(filename: String, alignment: Char) {\n    alignFile(filename, alignment) foreach println\n  }\n}<\/lang>\n\nAnother take:\n\n<lang scala>def pad(s:String, i:Int, d:String) = {\n  val padsize = (i-s.length).max(0)\n  d match {\n    case \"left\" => s+\" \"*padsize\n    case \"right\" => \" \"*padsize+s\n    case \"center\" => \" \"*(padsize\/2) + s + \" \"*(padsize-padsize\/2)\n  }\n}\n \nval lines = scala.io.Source.fromFile(\"c:\\\\text.txt\").getLines.map(_.trim())\nval words = lines.map(_.split(\"\\\\$\").toList).toList\nval lens = words.map(l => l.map(_.length)).toList\n \nvar maxlens = Map[Int,Int]() withDefaultValue 0\nlens foreach (l =>\n  for(i <- (0 until l.length)){\n    maxlens += i -> l(i).max(maxlens(i))\n  }\n)\n  \nval padded = words map ( _.zipWithIndex.map{case(s,i)=>pad(s,maxlens(i),\"center\")+\" \"} )\npadded map (_.reduceLeft(_ + _)) foreach println<\/lang>\n\n==[[:Category:sed|sed]][[Category:sed]]==\nThe code allows to left (by default) or right justify colums. Centering is not supported. Requires about 2x<size of input> bytes of memory (each line duplicated).\n<lang sed>\n#!\/bin\/sed -nrf\n# Format: <master-pattern>\\n<line1>\\n<line1-as-pattern>\\n<line2>\\n<line2-as-pattern>...\n# After reading whole file <master-pattern> contains max number of fields of max width each.\n\n# If no $ at start or end of a line -- add them\n\/^\\$\/! s\/^\/$\/\n\/\\$$\/! s\/$\/$\/\n\n# First line saved as three lines in hold space:\n# <line1-as-pattern>\\n<line1>\\n<line1-as-pattern>\n1{\n h\n s\/[^$]\/ \/g\n H\n G\n x\n # Restart -- go to next line\n b\n}\n\n# For lines 2,3,...\nH\n# Current line -> pattern\n# (each character replaced by constant symbol (e.g. space) so that we can count them)\ns\/[^$]\/ \/g\nH\nG\n# Add two markers\ns\/\\$\/1$\/\ns\/(\\n[^$]*)\\$\/\\12$\/\n\n# Compare patterns\n:cmp\n\ts\/(1\\$([^$\\n]*)([^$\\n]*)[^2]*2\\$\\2)\/\\1\\3\/\n\t\/1\\$\\n\/ bout\n\t# Advance markers\n\ts\/1(\\$[^12$\\n]*)\/\\11\/\n\ts\/2(\\$[^12$\\n]*)\/\\12\/\n\t# Add one more field\n\t\/^[^2]*2\\$\\n\/{ s\/^([^2]*)2\\$\\n\/\\12$$\\n\/; }\nbcmp\n:out\n# Remove first line\ns\/[^\\n]*\\n\/\/\n# Remove 2$-marker\ns\/2\\$\/$\/\nx\n\n${\n# We are on the last line -- start printing\n\tx;\n\t# Add a line for aligned string\n\ts\/^\/\\n\/\n\t:nextline\n\t# Add marker again (only one this time)\n\ts\/\\$\/1$\/\n\t:align\n\t\t# 1. look up missing spaces,\n\t\t# 2. put first word of 2nd line before first newline adding missing spaces\n\t\t# 3. cut first word of 2nd and 3rd lines.\n\t\t# Replace \\5\\3 by \\3\\5 for RIGHT ALIGNMENT\n\t\ts\/(\\n[^\\n]*)1\\$([^$\\n]*)([^$\\n]*)\\$([^\\n]*\\n)\\$([^$\\n]*)([^\\n]*\\n)\\$\\2\\$\/\\5\\3 \\1$\\2\\31$\\4\\6$\/\n\ttalign\n\t# We ate 2nd and 3rd lines completely, except newlines -- remove them\n\ts\/\\$\\n\\$\\n\\$\\n\/$\\n\/\n\t# Print the first line in pattern space\n\tP\n\t# ... and remove it\n\ts\/^[^\\n]*\/\/\n\t# Remove marker\n\ts\/1\\$\/$\/\n\t# If no more lines -- exit\n\t\/\\$\\n\\$$\/q\n\tbnextline\n}\n<\/lang>\nExample:\n<pre>\n$ cat align.txt \nGiven$a$text$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$'dollar'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.\n$ .\/align-columns.sed align.txt \nGiven      a          text       file   of     many      lines,     where    fields  within  a      line \nare        delineated by         a      single 'dollar'  character, write    a       program \nthat       aligns     each       column of     fields    by         ensuring that    words   in     each \ncolumn     are        separated  by     at     least     one        space.   \nFurther,   allow      for        each   word   in        a          column   to      be      either left \njustified, right      justified, or     center justified within     its      column. \n<\/pre>\n==[[:Category:Seed7|Seed7]][[Category:Seed7]]==\n<lang seed7>$ include \"seed7_05.s7i\";\n\nconst array string: inputLines is [] (\n    \"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\",\n    \"are$delineated$by$a$single$'dollar'$character,$write$a$program\",\n    \"that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\",\n    \"column$are$separated$by$at$least$one$space.\",\n    \"Further,$allow$for$each$word$in$a$column$to$be$either$left$\",\n    \"justified,$right$justified,$or$center$justified$within$its$column.\");\n\nconst func array integer: computeColumnWidths (in array string: inputLines) is func\n  result\n    var array integer: columnWidths is 0 times 0;\n  local\n    var string: line is \"\";\n    var array string: lineFields is 0 times \"\";\n    var integer: index is 0;\n  begin\n    for line range inputLines do\n      lineFields := split(line, \"$\");\n      if length(lineFields) > length(columnWidths) then\n        columnWidths &:= (length(lineFields) - length(columnWidths)) times 0;\n      end if;\n      for index range 1 to length(lineFields) do\n        if length(lineFields[index]) > columnWidths[index] then\n          columnWidths[index] := length(lineFields[index]);\n        end if;\n      end for;\n    end for;\n  end func;\n\nconst func string: center (in string: stri, in integer: length) is\n  return (\"\" lpad (length - length(stri)) div 2 <& stri) rpad length;\n\nconst proc: main is func\n  local\n    var array integer: columnWidths is 0 times 0;\n    var string: line is \"\";\n    var array string: lineFields is 0 times \"\";\n    var integer: index is 0;\n  begin\n    columnWidths := computeColumnWidths(inputLines);\n    for line range inputLines do\n      lineFields := split(line, \"$\");\n      for index range 1 to length(lineFields) do\n        # write(lineFields[index] rpad columnWidths[index] <& \" \"); # Left justify\n        # write(lineFields[index] lpad columnWidths[index] <& \" \"); # Right justify\n        write(center(lineFields[index], columnWidths[index]) <& \" \");\n      end for;\n      writeln;\n    end for;\n  end func;<\/lang>\n\nOutput:\n<pre>\n  Given        a         text     file    of     many      lines,    where   fields  within    a    line  \n   are     delineated     by       a    single 'dollar'  character,  write      a    program \n   that      aligns      each    column   of    fields       by     ensuring  that    words    in   each  \n  column      are     separated    by     at     least      one      space.  \n Further,    allow       for      each   word     in         a       column    to      be    either left  \njustified,   right    justified,   or   center justified   within     its    column. \n<\/pre>\n\n==[[:Category:Shiny|Shiny]][[Category:Shiny]]==\n<lang shiny>text: 'Given$a$text$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$\\'dollar\\'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.'\n\nalign: action text; position;\n\n    # split text into 2D array of lines and words\n    lines : { for text.split ~\\$?\\r?\\n~ { for a.split '$' a end } end }\n\n    # calculate max required width for each column\n    widths: { for lines for a here[b]: a.length.max here[b]? ends }\n\n    spaces: action out (\"%%%ds\" in).format '' end\n\n    # formatting functions\n    left: action word; width;\n        pad: width-word.length\n        print \"%s%s \" word spaces pad\n    end\n    right: action word; width;\n        pad: width-word.length\n        print \"%s%s \" spaces pad word\n    end\n    center: action word; width;\n        pad: (width-word.length)\/2\n        print \"%s%s%s \" spaces pad.floor word spaces pad.ceil\n    end\n\n    if position.match ~^(left|center|right)$~ for lines\n        for a local[position] a widths[b] end say ''\n    ends say ''\nend\n\nalign text 'left'\nalign text 'center'\nalign text 'right'<\/lang>\n\n<pre>Given      a          text       file   of     many      lines,     where    fields  within  a      line \nare        delineated by         a      single 'dollar'  character, write    a       program \nthat       aligns     each       column of     fields    by         ensuring that    words   in     each \ncolumn     are        separated  by     at     least     one        space.   \nFurther,   allow      for        each   word   in        a          column   to      be      either left \njustified, right      justified, or     center justified within     its      column. \n\n  Given        a         text     file    of     many      lines,    where   fields  within    a    line \n   are     delineated     by       a    single 'dollar'  character,  write      a    program \n   that      aligns      each    column   of    fields       by     ensuring  that    words    in   each \n  column      are     separated    by     at     least      one      space.  \n Further,    allow       for      each   word     in         a       column    to      be    either left \njustified,   right    justified,   or   center justified   within     its    column. \n\n     Given          a       text   file     of      many     lines,    where  fields  within      a line \n       are delineated         by      a single  'dollar' character,    write       a program \n      that     aligns       each column     of    fields         by ensuring    that   words     in each \n    column        are  separated     by     at     least        one   space. \n  Further,      allow        for   each   word        in          a   column      to      be either left \njustified,      right justified,     or center justified     within      its column.<\/pre>\n\n==[[:Category:Tcl|Tcl]][[Category:Tcl]]==\n<lang tcl>package require Tcl 8.5\n\nset text {Given$a$text$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$'dollar'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.}\n\narray set max {}\nforeach line [split $text \\n] {\n    set col 0\n    set thisline [split $line \\$]\n    lappend words $thisline\n    foreach word $thisline {\n        set max([incr col]) [expr {[info exists max($col)]\n                                    ? max($max($col), [string length $word])\n                                    : [string length $word]\n                            }]\n    }\n}\n\nproc justify {word position width} {\n    switch -exact -- $position {\n        left {\n            return [format \"%-*s\" $width $word]\n        }\n        center {\n            set lpadw [expr {($width - [string length $word])\/2}]\n            return [format \"%s%-*s\" [string repeat \" \" $lpadw] [incr width -$lpadw] $word]\n        }\n        right {\n            return [format \"%*s\" $width $word]\n        }\n    }\n}\n\nforeach position {left center right} {\n    foreach thisline $words {\n        set col 0\n        set line \"\"\n        foreach word $thisline {\n            append line [justify $word $position $max([incr col])] \" \"\n        }\n        puts [string trimright $line]\n    }\n    puts \"\"\n}<\/lang>\nOutput:\n<pre>Given      a          text       file   of     many      lines,     where    fields  within  a      line\nare        delineated by         a      single 'dollar'  character, write    a       program\nthat       aligns     each       column of     fields    by         ensuring that    words   in     each\ncolumn     are        separated  by     at     least     one        space.\nFurther,   allow      for        each   word   in        a          column   to      be      either left\njustified, right      justified, or     center justified within     its      column.\n\n  Given        a         text     file    of     many      lines,    where   fields  within    a    line\n   are     delineated     by       a    single 'dollar'  character,  write      a    program\n   that      aligns      each    column   of    fields       by     ensuring  that    words    in   each\n  column      are     separated    by     at     least      one      space.\n Further,    allow       for      each   word     in         a       column    to      be    either left\njustified,   right    justified,   or   center justified   within     its    column.\n\n     Given          a       text   file     of      many     lines,    where  fields  within      a line\n       are delineated         by      a single  'dollar' character,    write       a program\n      that     aligns       each column     of    fields         by ensuring    that   words     in each\n    column        are  separated     by     at     least        one   space.\n  Further,      allow        for   each   word        in          a   column      to      be either left\njustified,      right justified,     or center justified     within      its column.<\/pre>\n==[[:Category:TUSCRIPT|TUSCRIPT]][[Category:TUSCRIPT]]==\n<lang tuscript>\n$$ MODE TUSCRIPT\nMODE DATA\n$$ SET exampletext=*\nGiven$a$text$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$'dollar'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.\n$$ MODE TUSCRIPT\nSET nix=SPLIT (exampletext,\":$:\",c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12)\nLOOP l1=1,12\nSET colum=CONCAT (\"c\",l1)\nSET newcolum=CONCAT (\"new\",l1)\nSET @newcolum=\"\", length=MAX\u00a0LENGTH (@colum), space=length+2\n LOOP n,l2=@colum\n SET newcell=CENTER (l2,space)\n SET @newcolum=APPEND (@newcolum,\"~\",newcell)\n ENDLOOP\n SET @newcolum=SPLIT  (@newcolum,\":~:\")\nENDLOOP\nSET exampletext=JOIN(new1,\"$\",new2,new3,new4,new5,new6,new7,new8,new9,new10,new11,new12)\n<\/lang>\nOutput:\n<pre>\n   Given    $     a      $    text    $  file  $   of   $   many    $   lines,   $  where   $ fields  $ within  $   a    $ line$ \n    are     $ delineated $     by     $   a    $ single $ 'dollar'  $ character, $  write   $    a    $ program $        $       \n    that    $   aligns   $    each    $ column $   of   $  fields   $     by     $ ensuring $  that   $  words  $   in   $ each$ \n   column   $    are     $ separated  $   by   $   at   $   least   $    one     $  space.  $         $         $        $       \n  Further,  $   allow    $    for     $  each  $  word  $    in     $     a      $  column  $   to    $   be    $ either $ left$ \n justified, $   right    $ justified, $   or   $ center $ justified $   within   $   its    $ column. $         $        $       \n\n<\/pre>\n\n==[[:Category:TXR|TXR]][[Category:TXR]]==\n\n<lang txr>@(collect)\n@  (coll)@{item \/[^$]+\/}@(end)\n@(end)\n@; nc = number of columns\n@; pi = padded items (data with row lengths equalized with empty strings)\n@; cw = vector of max column widths\n@; ce = center padding\n@(bind nc @(apply (fun max) (mapcar (fun length) item)))\n@(bind pi @(mapcar (lambda (row) \n                     (append row (repeat '(\"\") (- nc (length row)))))\n                   item))\n@(bind cw @(vector-list \n             (mapcar (lambda (column)\n                       (apply (fun max) (mapcar (fun length) column)))\n                     ;; matrix transpose trick cols become rows:\n                     (apply (fun mapcar) (cons (fun list) pi)))))\n@(bind ns \"\")\n@(output)\n@  (repeat)\n@    (rep :counter i)@{pi @[cw i]} @(end)\n@  (end)\n@  (repeat)\n@    (rep :counter i)@{pi @(- [cw i])} @(end)\n@  (end)\n@  (repeat)\n@    (rep :counter i)@\\\n     @{ns @(trunc (- [cw i] (length pi)) 2)}@\\\n     @{pi @(- [cw i] (trunc (- [cw i] (length pi)) 2))} @(end)\n@  (end)\n@(end)<\/lang>\n\n<pre>$ txr align-columns.txr align-columns.dat \nGiven      a          text       file   of     many      lines,     where    fields  within  a      line \nare        delineated by         a      single 'dollar'  character, write    a       program             \nthat       aligns     each       column of     fields    by         ensuring that    words   in     each \ncolumn     are        separated  by     at     least     one        space.                               \nFurther,   allow      for        each   word   in        a          column   to      be      either left \njustified, right      justified, or     center justified within     its      column.                     \n     Given          a       text   file     of      many     lines,    where  fields  within      a line \n       are delineated         by      a single  'dollar' character,    write       a program             \n      that     aligns       each column     of    fields         by ensuring    that   words     in each \n    column        are  separated     by     at     least        one   space.                             \n  Further,      allow        for   each   word        in          a   column      to      be either left \njustified,      right justified,     or center justified     within      its column.                     \n  Given        a         text     file    of     many      lines,    where   fields  within    a    line\n   are     delineated     by       a    single 'dollar'  character,  write      a    program\n   that      aligns      each    column   of    fields       by     ensuring  that    words    in   each\n  column      are     separated    by     at     least      one      space.     \n Further,    allow       for      each   word     in         a       column    to      be    either left\njustified,   right    justified,   or   center justified   within     its    column.<\/pre>\n\n==[[:Category:UNIX Shell|UNIX Shell]][[Category:UNIX Shell]]==\nThis is a draft implementation of the \"align columns\" problem using Unix shell commands.  The key tool for left and right justified text is the \"rs\" command.  Centered text is a little more complex, since this is not a feature currently in \"rs\" (''The centered solution will be added later.'')\n<lang bash>\ncat <<EOF_OUTER > just-nocenter.sh\n#!\/bin\/sh\n\ntd() {\ncat <<'EOF'\nGiven$a$text$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$'dollar'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.\nEOF\n}\n\nrows=$( td | wc -l )\n\n# get the number of fields\nfields=$(td | rs -c'$' -g1 -h | awk '{print $2}')\n\n# get the max of the value widths\ncwidth=$(td | rs -c'$' -g1 -w1 2>\/dev\/null | awk 'BEGIN{w=0}{if(length>w){w=length}}END{print w}')\n\n# compute the minimum line width for the columns\nlwidth=$(( (1 + cwidth) * fields ))\n\n# left adjusted columns\ntd | rs -c'$' -g1 -zn -w$lwidth\n\necho \"\"\n\n# right adjusted columns\ntd | rs -c'$' -g1 -znj -w$lwidth\n\necho \"\"\n\nexit\nEOF_OUTER\n<\/lang>\nOutput:\n<lang sh>\n$ .\/just-nocenter.sh \nGiven      a          text       file   of     many      lines,     where    fields  within  a      line\nare        delineated by         a      single 'dollar'  character, write    a       program        \nthat       aligns     each       column of     fields    by         ensuring that    words   in     each\ncolumn     are        separated  by     at     least     one        space.                          \nFurther,   allow      for        each   word   in        a          column   to      be      either left\njustified, right      justified, or     center justified within     its      column.                \n\n     Given          a       text   file     of      many     lines,    where  fields  within      a line\n       are delineated         by      a single  'dollar' character,    write       a program            \n      that     aligns       each column     of    fields         by ensuring    that   words     in each\n    column        are  separated     by     at     least        one   space.                            \n  Further,      allow        for   each   word        in          a   column      to      be either left\njustified,      right justified,     or center justified     within      its column.                    \n<\/lang>\n\nThe centered output will be added later, when I've more time.  '' I did this in about 10 minutes.''\n\n==[[:Category:Ursala|Ursala]][[Category:Ursala]]==\nThe algorithm is to lex the text to a list of lists of strings assuming $ as a separator,\nthen pad the lists out to the length of the maximum length list, transpose,\ndo the same with each column, and transpose again. For left justification,\nnothing further but concatenation is needed. For right justification, each word's string\nof trailing blanks is moved to the beginning, and for center justification, the\ntrailing blanks are divided equally between the beginning and end of each word.\n<lang Ursala>#import std\n\ntext = \n\n-[Given$a$text$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$'dollar'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.]-\n\npad = sep`$*; @FS ~&rSSSK7+ (zipp` ^*D\\~& leql$^)*rSSK7+ zipp0^*D\/leql$^ ~&\n\njust_left   = mat` *+ pad\njust_right  = mat` *+ pad; ==` ~-rlT**\njust_center = mat` *+ pad; ==` ~-rK30PlrK31PTT**\n\n#show+\n\nmain = mat0 <.just_left,just_center,just_right> text<\/lang>\noutput:\n<pre style=\"height:17ex;overflow:scroll\">\nGiven      a          text       file   of     many      lines,     where    fields  within  a      line\nare        delineated by         a      single 'dollar'  character, write    a       program            \nthat       aligns     each       column of     fields    by         ensuring that    words   in     each\ncolumn     are        separated  by     at     least     one        space.                              \nFurther,   allow      for        each   word   in        a          column   to      be      either left\njustified, right      justified, or     center justified within     its      column.                    \n\n  Given        a         text     file    of     many      lines,    where   fields  within    a    line\n   are     delineated     by       a    single 'dollar'  character,  write      a    program            \n   that      aligns      each    column   of    fields       by     ensuring  that    words    in   each\n  column      are     separated    by     at     least      one      space.                             \n Further,    allow       for      each   word     in         a       column    to      be    either left\njustified,   right    justified,   or   center justified   within     its    column.                    \n\n     Given          a       text   file     of      many     lines,    where  fields  within      a line\n       are delineated         by      a single  'dollar' character,    write       a program            \n      that     aligns       each column     of    fields         by ensuring    that   words     in each\n    column        are  separated     by     at     least        one   space.                            \n  Further,      allow        for   each   word        in          a   column      to      be either left\njustified,      right justified,     or center justified     within      its column.                    \n<\/pre>\n\n==[[:Category:VBA|VBA]][[Category:VBA]]==\nCall subroutine \"TestSplit\" with arguments ''align'' (one of: \"left\", \"right\", \"center\") and ''spacing'' (an integer) between columns.\nBoth arguments are optional and default to \"left\" and 1 respectively.\n\n<lang vb>\nPublic Sub TestSplit(Optional align As String = \"left\", Optional spacing As Integer = 1)\n  Dim word() As String\n  Dim colwidth() As Integer\n  Dim ncols As Integer\n  Dim lines(6) As String\n  Dim nlines As Integer\n  \n  'check arguments\n  If Not (align = \"left\" Or align = \"right\" Or align = \"center\") Then\n    MsgBox \"TestSplit: wrong argument 'align': \" & align\n    Exit Sub\n  End If\n  If spacing < 0 Then\n    MsgBox \"TestSplit: wrong argument: 'spacing' cannot be negative.\"\n    Exit Sub\n  End If\n  \n  ' Sample Input (should be from a file)\n  nlines = 6\n  lines(1) = \"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\"\n  lines(2) = \"are$delineated$by$a$single$'dollar'$character,$write$a$program\"\n  lines(3) = \"that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\"\n  lines(4) = \"column$are$separated$by$at$least$one$space.\"\n  lines(5) = \"Further,$allow$for$each$word$in$a$column$to$be$either$left$\"\n  lines(6) = \"justified,$right$justified,$or$center$justified$within$its$column.\"\n  \n  'first pass: count columns and column widths\n  'the words are not kept in memory\n  ncols = -1\n  For l = 1 To nlines\n    word = Split(RTrim(lines(l)), \"$\")\n    If UBound(word) > ncols Then\n      ncols = UBound(word)\n      ReDim Preserve colwidth(ncols)\n    End If\n    For i = 0 To UBound(word)\n      If Len(word(i)) > colwidth(i) Then colwidth(i) = Len(word(i))\n    Next i\n  Next l\n  \n  'discard possibly empty columns at the right\n  '(this assumes there is at least one non-empty column)\n  While colwidth(ncols) = 0\n    ncols = ncols - 1\n  Wend\n  \n  'second pass: print in columns\n  For l = 1 To nlines\n    word = Split(RTrim(lines(l)), \"$\")\n    For i = 0 To UBound(word)\n      a = word(i)\n      w = colwidth(i)\n      If align = \"left\" Then\n        Debug.Print a + String$(w - Len(a), \" \");\n      ElseIf align = \"right\" Then\n        Debug.Print String$(w - Len(a), \" \") + a;\n      ElseIf align = \"center\" Then\n        d = Int((w - Len(a)) \/ 2)\n        Debug.Print String$(d, \" \") + a + String$(w - (d + Len(a)), \" \");\n      End If\n      If i < ncols Then Debug.Print Spc(spacing);\n    Next i\n    Debug.Print\n  Next l\nEnd Sub\n<\/lang>\n\nSample Output:\n\n<pre>\ntestsplit , 4 'default alignment, non-default spacing\nGiven         a             text          file      of        many         lines,        where       fields     within     a         line\nare           delineated    by            a         single    'dollar'     character,    write       a          program    \nthat          aligns        each          column    of        fields       by            ensuring    that       words      in        each\ncolumn        are           separated     by        at        least        one           space.      \nFurther,      allow         for           each      word      in           a             column      to         be         either    left\njustified,    right         justified,    or        center    justified    within        its         column.    \n\n\ntestsplit \"center\" 'non-default alignment, default spacing\n  Given        a         text     file    of     many      lines,    where   fields  within    a    line\n   are     delineated     by       a    single 'dollar'  character,  write      a    program \n   that      aligns      each    column   of    fields       by     ensuring  that    words    in   each\n  column      are     separated    by     at     least      one      space.  \n Further,    allow       for      each   word     in         a       column    to      be    either left\njustified,   right    justified,   or   center justified   within     its    column. \n<\/pre>\n\n==[[:Category:Vedit macro language|Vedit macro language]][[Category:Vedit macro language]]==\nThis implementation converts the file currently being edited. The file can then be saved with different filename if required.\n<lang vedit>RS(10, \"$\")\t\t\/\/ Field separator\n#11 = 1\t\t\t\/\/ Align: 1 = left, 2 = center, 3 = right\n\n\/\/ Reset column widths. Max 50 columns\nfor (#1=40; #1<90; #1++) { #@1 = 0 }\n\n\/\/ Find max width of each column\nBOF\nRepeat(ALL) {\n    for (#1=40; #1<90; #1++) {\n        Match(@10, ADVANCE)\t\t\t\/\/ skip field separator if any\n\t#2 = Cur_Pos\n\tSearch(\"|{|@(10),|N}\", NOERR)\t\t\/\/ field separator or end of line\n\t#3 = Cur_Pos - #2\t\t\t\/\/ width of text\n\tif (#3 > #@1) { #@1 = #3 }\n\tif (At_EOL) { Break }\n    }\n    Line(1, ERRBREAK)\n}\n\n\/\/ Convert lines\nBOF\nRepeat(ALL) {\n    for (#1=40; #1<90; #1++) {\n\t#2 = Cur_Pos\n\tSearch(\"|{|@(10),|N}\", NOERR)\n\tif (At_EOL==0) { Del_Char(Chars_Matched) }\n\t#3 = #@1 - Cur_Pos + #2\t\t\t\/\/ number of spaces to insert\n\t#4 = 0\n\tif (#11 == 2) { #4 = #3\/2; #3 -= #4 }\t\/\/ Center\n\tif (#11 == 3) { #4 = #3;   #3 = 0 }\t\/\/ Right justify\n\tSet_Marker(1, Cur_Pos)\n\tGoto_Pos(#2)\n\tIns_Char(' ', COUNT, #4)\t\t\/\/ add spaces before the word\n\tGoto_Pos(Marker(1))\n\tIns_Char(' ', COUNT, #3+1)\t\t\/\/ add spaces after the word\n\tif (At_EOL) { Break }\n    }\n    Line(1, ERRBREAK)\n}<\/lang>\n\nExample output:\n<lang vedit>-- Left:\nGiven      a          text       file   of     many      lines,     where    fields  within  a      line \nare        delineated by         a      single 'dollar'  character, write    a       program \nthat       aligns     each       column of     fields    by         ensuring that    words   in     each \ncolumn     are        separated  by     at     least     one        space.   \nFurther,   allow      for        each   word   in        a          column   to      be      either left \njustified, right      justified, or     center justified within     its      column. \n\n-- Center:\n  Given        a         text     file    of     many      lines,    where   fields  within    a    line \n   are     delineated     by       a    single 'dollar'  character,  write      a    program \n   that      aligns      each    column   of    fields       by     ensuring  that    words    in   each \n  column      are     separated    by     at     least      one      space.  \n Further,    allow       for      each   word     in         a       column    to      be    either left \njustified,   right    justified,   or   center justified   within     its    column. \n\n-- Right:\n     Given          a       text   file     of      many     lines,    where  fields  within      a line \n       are delineated         by      a single  'dollar' character,    write       a program \n      that     aligns       each column     of    fields         by ensuring    that   words     in each \n    column        are  separated     by     at     least        one   space. \n  Further,      allow        for   each   word        in          a   column      to      be either left \njustified,      right justified,     or center justified     within      its column.<\/lang>\n\n[[Category:PARI\/GP\/Omit]]"}]}}}}