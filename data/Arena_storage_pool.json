{"query":{"pages":{"4028":{"pageid":4028,"ns":0,"title":"Arena storage pool","revisions":[{"*":"<div class=\"infobox\" style=\"width: 2in\">[[File:Rcode-button-task-crushed.png|64px|left|alt=Task|link=Category:Solutions by Programming Task]]'''Arena storage pool'''<br\/>\nYou are encouraged to [[Rosetta Code:Solve a Task|solve this task]] according to the task description, using any language you may know.[[Category:Programming Tasks]][[Category:Solutions by Programming Task]]<\/div>[[Category:Encyclopedia]]\nDynamically allocated objects take their memory from a [[heap]]. The memory for an object is provided by an '''allocator''' which maintains the storage pool used for the [[heap]]. Often a call to allocator is denoted as\n<lang ada>\nP := new T\n<\/lang>\nwhere T is the type of an allocated object and P is a [[reference]] to the object.\n\nThe storage pool chosen by the allocator can be determined by either:\n* the object type T;\n* the type of pointer P.\nIn the former case objects can be allocated only in one storage pool. In the latter case objects of the type can be allocated in any storage pool or on the [[stack]].\n\n'''Task description'''<br>\nThe task is to show how allocators and user-defined storage pools are supported by the language. In particular:\n# define an arena storage pool. An arena is a pool in which objects are allocated individually, but freed by groups.\n# allocate some objects (e.g., integers) in the pool.\nExplain what controls the storage pool choice in the language.\n\n==[[:Category:Ada|Ada]][[Category:Ada]]==\nIn [[Ada]] the choice of storage pool is controlled by the type of the pointer. Objects pointed by anonymous access types are allocated in the default storage pool. Pool-specific pointer types may get a pool assigned to them:\n<lang ada>type My_Pointer is access My_Object;\nfor My_Pointer'Storage_Pool use My_Pool;<\/lang>\nThe following example illustrates implementation of an arena pool. Specification:\n<lang ada>with System.Storage_Elements;  use System.Storage_Elements;\nwith System.Storage_Pools;     use System.Storage_Pools;\n\npackage Arena_Pools is\n   type Arena (Size : Storage_Count) is new Root_Storage_Pool with private;\n   overriding\n      procedure Allocate\n                (  Pool      : in out Arena;\n                   Address   : out System.Address;\n                   Size      : Storage_Count;\n                   Alignment : Storage_Count\n                );\n   overriding\n      procedure Deallocate\n                (  Pool      : in out Arena;\n                   Address   : System.Address;\n                   Size      : Storage_Count;\n                   Alignment : Storage_Count\n                )  is null;\n   overriding\n      function Storage_Size (Pool : Arena) return Storage_Count;\nprivate\n   type Arena (Size : Storage_Count) is new Root_Storage_Pool with record\n      Free : Storage_Offset := 1;\n      Core : Storage_Array (1..Size);\n   end record;\nend Arena_Pools;<\/lang>\nHere is an implementation of the package:\n<lang ada>package body Arena_Pools is\n   procedure Allocate\n             (  Pool      : in out Arena;\n                Address   : out System.Address;\n                Size      : Storage_Count;\n                Alignment : Storage_Count\n             )  is\n      Free : constant Storage_Offset :=\n         Pool.Free + Alignment - Pool.Core (Pool.Free)'Address mod Alignment + Size;\n   begin\n      if Free - 1 > Pool.Size then\n         raise Storage_Error;\n      end if;\n      Pool.Free := Free;\n      Address := Pool.Core (Pool.Free - Size)'Address;\n   end Allocate;\n\n   function Storage_Size (Pool : Arena) return Storage_Count is\n   begin\n      return Pool.Size;\n   end Storage_Size;\nend Arena_Pools;<\/lang>\nThe following is a test program that uses the pool:\n<lang ada>with Arena_Pools;\nuse  Arena_Pools;\n\nprocedure Test_Allocator is\n   Pool : Arena_Pools.Arena (1024);\n   type Integer_Ptr is access Integer;\n   for Integer_Ptr'Storage_Pool use Pool;\n   \n   X : Integer_Ptr := new Integer'(1);\n   Y : Integer_Ptr := new Integer'(2);\n   Z : Integer_Ptr;\nbegin\n   Z := new Integer;\n   Z.all := X.all + Y.all;\nend Test_Allocator;<\/lang>\n\n==[[:Category:C|C]][[Category:C]]==\nFor C, dynamic memory is often used for structures and for arrays when the size of the\narray is unknown in advance.  'Objects' in C are pretty much structures, with the structure sometimes including a pointer to a virtual dispatch table.\n\nTo use dynamic memory, the header for the standard library must be included in the module.\n<lang c>#include <stdlib.h><\/lang>\nUninitialized memory is allocated using the malloc function. To obtain the amount of memory that needs to be allocated, sizeof is used. Sizeof is not a normal C function, it is evaluated by the compiler to obtain the amount of memory needed.\n<lang c>int *var = malloc(n*sizeof(int));\nTypename *var = malloc(sizeof(Typename));\nTypename *var = malloc(sizeof var[0]);<\/lang>\nSince pointers to structures are needed so frequently, often a\ntypedef will define a type as being a pointer to the associated structure. \nOnce one gets used to the notation, programs are actually easier to read, as the\nvariable declarations don't include all the '*'s.\n<lang c>typedef struct mytypeStruct { .... } sMyType, *MyType;\n\nMyType var = malloc(sizeof(sMyType));<\/lang>\nThe calloc() function initializes all allocated memory to zero.  It is also often\nused for allocating memory for arrays of some type.\n<lang c>\/* allocate an array of n MyTypes *\/\nMyType var = calloc(n, sizeof(sMyType));\n\nMyType third = var+3;       \/* a reference to the 3rd item allocated *\/\n\nMyType fourth = &var[4];    \/* another way, getting the fourth item *\/<\/lang>\nFreeing memory dynamically allocated from the heap is done by calling free().\n<lang c>free(var);<\/lang>\nOne can allocate space on the stack using the alloca() function.  You do not\nfree memory that's been allocated with alloca\n<lang c>Typename *var = alloca(sizeof(Typename));<\/lang>\nAn object oriented approach will define a function for creating a new object of a class.\nIn these systems, the size of the memory that needs to be allocated for an instance of the\nclass will often be included in the 'class' record. \nSee http:\/\/rosettacode.org\/wiki\/Polymorphic%20copy#C\n\n==[[:Category:C++|C++]][[Category:C++]]==\nIn C++, the situation with allocators is quite complex:\n* You can define class-specific allocation\/deallocation by adding class members <code>operator new<\/code> and <code>operator delete<\/code>. Those are then used whenever you use new for that type (or a type derived from it, if it doesn't itself replace operator new), and when you delete an object of that type. Note that arrays and single objects have both separate allocation functions and deallocation functions.\n* You can replace the global allocation\/deallocation routines, which are used by new\/delete whenever there are no class specific functions available.\n* You can write operator new\/operator delete with additional arguments, both in a class and globally. To use those, you add those parameters after the keyword <code>new<\/code>, like\n<lang cpp>T* foo = new(arena) T;<\/lang>\n* In addition, for objects in containers, there's a completely separate allocator interface, where the containers use an allocator object for allocating\/deallocating memory.\n\nThe following code uses class-specific allocation and deallocation functions:\n\n<lang cpp>#include <csttdlib>\n#include <cassert>\n#include <new>\n\n\/\/ This class basically provides a global stack of pools; it is not thread-safe, and pools must be destructed in reverse order of construction\n\/\/ (you definitely want something better in production use :-))\nclass Pool\n{\npublic:\n  Pool(std::size_type sz);\n  ~Pool();\n  static Pool& current() { return *cur; }\n  void* allocate(std::size_type sz, std::size_t alignment);\nprivate:\n  char* memory; \/\/ char* instead of void* enables pointer arithmetic\n  char* free;\n  char* end;\n  Pool* prev;\n  static Pool* cur;\n\n  \/\/ prohibit copying\n  Pool(Pool const&); \/\/ not implemented\n  Pool& operator=(Pool const&); \/\/ not implemented\n};\n\nPool* pool::cur = 0;\n\nPool::Pool(std::size_type size):\n  memory(static_cast<char*>(::operator new(size))),\n  free(memory),\n  end(memory))\n{\n  prev = cur;\n  cur = this;\n}\n\nPool::~Pool()\n{\n  ::operator delete(memory);\n  cur = prev;\n}\n\nvoid* Pool::allocate(std::size_t size, std::size_t alignment)\n{\n  char* start = free;\n\n  \/\/ align the pointer\n  std::size_t extra = (start - memory) % aligment;\n  if (extra != 0)\n  {\n    extra = alignment - extra;\n  }\n\n  \/\/ test if we can still allocate that much memory\n  if (end - free < size + extra)\n    throw std::bad_alloc();\n\n  \/\/ the free memory now starts after the newly allocated object\n  free = start + size + extra;\n  return start;\n}\n\n\/\/ this is just a simple C-like struct, except that it uses a specific allocation\/deallocation function.\nstruct X\n{\n  int member;\n  void* operator new(std::size_t);\n  void operator delete(void*) {} \/\/ don't deallocate memory for single objects\n};\n\nvoid* X::operator new(std::size_t size)\n{\n  \/\/ unfortunately C++ doesn't offer a portable way to find out alignment\n  \/\/ however, using the size as alignment is always safe (although usually wasteful)\n  return Pool::current().allocate(size, size);\n}\n\n\/\/ Example program\nint main()\n{\n  Pool my_pool(3*sizeof(X));\n  X* p1 = new X; \/\/ uses the allocator function defined above\n  X* p2 = new X;\n  X* p3 = new X;\n  delete p3; \/\/ doesn't really deallocate the memory because operator delete has an empty body\n\n  try\n  {\n    X* p4 = new X; \/\/ should fail\n    assert(false);\n  }\n  catch(...)\n  {\n  }\n\n  X* p5 = new X[10]; \/\/ uses global array allocation routine because we didn't provide operator new[] and operator delete[]\n  delete[] p5; \/\/ global array deallocation\n\n  Pool* my_second_pool(1000); \/\/ a large pool\n  X* p6 = new X; \/\/ allocate a new object from that pool\n  X* p7 = new X;\n  delete my_second_pool \/\/ also deallocates the memory for p6 and p7\n\n} \/\/ Here my_pool goes out of scope, deallocating the memory for p1, p2 and p3<\/lang>\n\n[[Category:Clojure\/Omit]]\n\n==[[:Category:J|J]][[Category:J]]==\nThe concepts of pools and allocation is foreign to J, and excessively verbose for most purposes.  However, this task can be accomplished by relying on J's facilities for dealing with code written in foreign languages.\n\nFor example, you can define a class which allocates a pool of integers:\n\n<lang j>coclass 'integerPool'\nrequire 'jmf'\ncreate=: monad define\n  Lim=: y*SZI_jmf_\n  Next=: -SZI_jmf_\n  Pool=: mema Lim\n)\n \ndestroy=: monad define\n  memf Pool\n  codestroy''\n)\n \nalloc=: monad define\n  assert.Lim >: Next=: Next+SZI_jmf_\n  r=.Pool,Next,1,JINT\n  r set y\n  r\n)\n \nget=: adverb define\n  memr m\n)\n \nset=: adverb define\n  y memw m\n)<\/lang>\n\nWith this script you can then create instances of this class, and use them.  In this case, we will create a pool of three integers:\n\n<lang j>   pool0=: 3 conew 'integerPool'\n   x0=: alloc__pool0 0\n   x1=: alloc__pool0 0\n   x2=: alloc__pool0 0\n   x0 set__pool0 7\n   x1 set__pool0 8\n   x2 set__pool0 9\n   x0 get__pool0 + x1 get__pool0 + x2 get__pool0\n24<\/lang>\n\nFinally, the pool can be destroyed:\n\n<lang j>   destroy__pool0 _<\/lang>\n\nThat said, using J's built-in support for integers (and for using them) usually results in better code.\n\n==[[:Category:Mathematica|Mathematica]][[Category:Mathematica]]==\nMathematica does not allow stack\/heap control, so all variables are defined on the heap. However, tags must be given a ''value'' for a meaningful assignment to take place.\n<lang Mathematica>f[x_] := x^2<\/lang>\n\n==[[:Category:PARI\/GP|PARI\/GP]][[Category:PARI\/GP]]==\nGP has no particular control over the layout of objects in memory.\n\nPARI allocates objects on the PARI stack by default, but objects can be allocated on the heap if desired.\n<lang C>pari_init(1<<20, 0); \/\/ Initialize PARI with a stack size of 1 MB.\nGEN four = addii(gen_2, gen_2); \/\/ On the stack\nGEN persist = gclone(four); \/\/ On the heap<\/lang>\n\n==[[:Category:Pascal|Pascal]][[Category:Pascal]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Free_Pascal]][[SMW::on]]<\/div>\nThe procedure New allocates memory on the heap:\n<lang pascal>procedure New (var P: Pointer);<\/lang>\n\nThe Pointer P is typed and the amount of memory allocated on the heap matches the type. Deallocation is done with the procedure Dispose. In ObjectPascal constructors and destructors can be passed to New and Dispose correspondingly. The following example is from the rtl docs of [[Free_Pascal]]\n\n<lang pascal>Program Example16;\n{ Program to demonstrate the Dispose and New functions. }\nType\n  SS = String[20];\n  AnObj = Object\n    I : integer;\n    Constructor Init;\n    Destructor Done;\n  end;\n\nVar\n  P : ^SS;\n  T : ^AnObj;\n\nConstructor Anobj.Init;\nbegin\n  Writeln ( ' Initializing an instance of AnObj! ' );\nend;\n\nDestructor AnObj.Done;\nbegin\n  Writeln ( ' Destroying an instance of AnObj! ' ) ;\nend;\n\nbegin\n  New ( P );\n  P^ := 'Hello, World!';\n  Dispose ( P );\n{ P is undefined from here on! }\n  New ( T, Init );\n  T^.i := 0;\n  Dispose ( T, Done );\nend .<\/lang>\n\nInstead of implicit specification of the amount of memory using a type, the explicit amount can directly specified with the procedure getmem (out p: pointer; Size: PtrUInt);\n\n==[[:Category:PicoLisp|PicoLisp]][[Category:PicoLisp]]==\nPicoLisp allocates any kind of data from a single pool, because everything\nis built out of a \"cell\" primitive. Most of this allocation happens\nautomatically, but can also be done explicitly with\n'[http:\/\/software-lab.de\/doc\/refN.html#new new]' or\n'[http:\/\/software-lab.de\/doc\/refB.html#box box]'. For memory-allocated\nobjects, there is no explicit way of freeing them. Database objects can be\nfreed with '[http:\/\/software-lab.de\/doc\/refZ.html#zap zap]'.\n\n==[[:Category:Python|Python]][[Category:Python]]==\nIn Python:\n* Everything is an object.\n* Objects are dynamically allocated.\n* Unused objects are garbage collected.\n\nWhere objects appear from, or disappear to, is treated as an implementation detail.\n\nStatements, such as assignments, class and function definitions, and import statements can create objects and assign names to them which can be seen as assigning a reference to objects. Objects can also be referred to from other objects e.g. in collections such as lists.<br>\nWhen names go out of scope, or objects are explicitly destroyed, references to objects are diminished. Python's implementation keeps track of references to objects and marks objects that have no remaining references so that they become candidates for '[[wp:Garbage collection (computer science)|garbage collection]]' at a later time.\n \n==[[:Category:REXX|REXX]][[Category:REXX]]==\nIn the REXX language, each (internal and external) procedure has it's\nown storage (memory) to hold local variables and other information\npertaining to a procedure.\n<br>Each call to a precedure (to facilitate recursion) has it's own\nstorage.\n<br>Garbage collection can be performed after a procedure finishes\nexecuting (either via an <tt> EXIT, <\/tt> <tt> RETURN, <\/tt>\nor some other external action),\nbut this isn't specified in the language.\n<br>A <tt> DROP <\/tt> will mark a variable\nas not defined, but doesn't deallocate it's storage, but the freed\nstorage can be used by another variable within the program (or precedure).\n<br>Essentially, the method used by a particular REXX interpreter isn't\nof concern by a programmer as there is but one type of variable\n(character), and even (stemmed) arrays aren't preallocated or even\nallocated sequentially in virtual (local) storage (as it's elements are\ndefined).\n<br>Some REXX interpreters have built-in functions to query how much free\nmemory is available (these were written when real storage was a premium\nduring the early DOS days).<br>\n<lang rexx>\/*REXX doesn't have declarations\/allocations of variables, *\/\n\/*     but this is the closest to an allocation:           *\/\n\n\nstemmed_array.= 0    \/*any undefined element will have this value. *\/\n\nstemmed_array.1    = '1st entry'\nstemmed_array.2    = '2nd entry'\nstemmed_array.6000 = 12 ** 2\nstemmed_array.dog  = stemmed_array.6000 \/ 2\n\ndrop stemmed_array.\n<\/lang>\n\n==[[:Category:Tcl|Tcl]][[Category:Tcl]]==\nTcl does not really expose the heap itself, and while it is possible to use [http:\/\/www.swig.org\/ SWIG] or [[Critcl]] to map the implementation-level allocator into the language, this is highly unusual.\n\nHowever, it is entirely possible to use a pooled memory manager for Tcl's objects.<br>\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Tcl]] version 8.6[[SMW::on]]<\/div>\n\nThe pool engine class itself (a metaclass):\n<lang tcl>package require Tcl 8.6\noo::class create Pool {\n    superclass oo::class\n    variable capacity pool busy\n    unexport create\n    constructor args {\n\tnext {*}$args\n\tset capacity 100\n\tset pool [set busy {}]\n    }\n    method new {args} {\n\tif {[llength $pool]} {\n\t    set pool [lassign $pool obj]\n\t} else {\n\t    if {[llength $busy] >= $capacity} {\n\t\tthrow {POOL CAPACITY} \"exceeded capacity: $capacity\"\n\t    }\n\t    set obj [next]\n\t    set newobj [namespace current]::[namespace tail $obj]\n\t    rename $obj $newobj\n\t    set obj $newobj\n\t}\n\ttry {\n\t    [info object namespace $obj]::my Init {*}$args\n\t} on error {msg opt} {\n\t    lappend pool $obj\n\t    return -options $opt $msg\n\t}\n\tlappend busy $obj\n\treturn $obj\n    }\n    method ReturnToPool obj {\n\ttry {\n\t    if {\"Finalize\" in [info object methods $obj -all -private]} {\n\t\t[info object namespace $obj]::my Finalize\n\t    }\n\t} on error {msg opt} {\n\t    after 0 [list return -options $opt $msg]\n\t    return false\n\t}\n\tset idx [lsearch -exact $busy $obj]\n\tset busy [lreplace $busy $idx $idx]\n\tif {[llength $pool] + [llength $busy] + 1 <= $capacity} {\n\t    lappend pool $obj\n\t    return true\n\t} else {\n\t    return false\n\t}\n    }\n    method capacity {{value {}}} {\n\tif {[llength [info level 0]] == 3} {\n\t    if {$value < $capacity} {\n\t\twhile {[llength $pool] > 0 && [llength $pool] + [llength $busy] > $value} {\n\t\t    set pool [lassign $pool obj]\n\t\t    rename $obj {}\n\t\t}\n\t    }\n\t    set capacity [expr {$value >> 0}]\n\t} else {\n\t    return $capacity\n\t}\n    }\n    method clearPool {} {\n\tforeach obj $busy {\n\t    $obj destroy\n\t}\n    }\n    method destroy {} {\n\tmy clearPool\n\tnext\n    }\n    self method create {class {definition {}}} {\n\tset cls [next $class $definition]\n\too::define $cls method destroy {} {\n\t    if {![[info object namespace [self class]]::my ReturnToPool [self]]} {\n\t\tnext\n\t    }\n\t}\n\treturn $cls\n    }\n}<\/lang>\nExample of how to use:\n<lang tcl>Pool create PoolExample {\n    variable int\n\n    method Init value {\n\tputs stderr \"Initializing [self] with $value\"\n\tset int $value\n\tincr int 0\n    }\n    method Finalize {} {\n\tputs stderr \"Finalizing [self] which held $int\"\n    }\n\n    method value {{newValue {}}} {\n\tif {[llength [info level 0]] == 3} {\n\t    set int [incr newValue 0]\n\t} else {\n\t    return $int\n\t}\n    }\n}\n\nPoolExample capacity 10\nset objs {}\ntry {\n    for {set i 0} {$i < 20} {incr i} {\n\tlappend objs [PoolExample new $i]\n    }\n} trap {POOL CAPACITY} msg {\n    puts \"trapped: $msg\"\n}\nputs -nonewline \"number of objects: [llength $objs]\\n\\t\"\nforeach o $objs {\n    puts -nonewline \"[$o value] \"\n}\nputs \"\"\nset objs [lassign $objs a b c]\n$a destroy\n$b destroy\n$c destroy\nPoolExample capacity 9\ntry {\n    for {} {$i < 20} {incr i} {\n\tlappend objs [PoolExample new $i]\n    }\n} trap {POOL CAPACITY} msg {\n    puts \"trapped: $msg\"\n}\nputs -nonewline \"number of objects: [llength $objs]\\n\\t\"\nforeach o $objs {\n    puts -nonewline \"[$o value] \"\n}\nputs \"\"\nPoolExample clearPool<\/lang>\nProduces this output (red text to <tt>stderr<\/tt>, black text to <tt>stdout<\/tt>):\n <span style=\"color:red\">Initializing ::oo::Obj4::Obj5 with 0\n Initializing ::oo::Obj4::Obj6 with 1\n Initializing ::oo::Obj4::Obj7 with 2\n Initializing ::oo::Obj4::Obj8 with 3\n Initializing ::oo::Obj4::Obj9 with 4\n Initializing ::oo::Obj4::Obj10 with 5\n Initializing ::oo::Obj4::Obj11 with 6\n Initializing ::oo::Obj4::Obj12 with 7\n Initializing ::oo::Obj4::Obj13 with 8\n Initializing ::oo::Obj4::Obj14 with 9<\/span>\n trapped: exceeded capacity: 10\n number of objects: 10\n         0 1 2 3 4 5 6 7 8 9 \n <span style=\"color:red\">Finalizing ::oo::Obj4::Obj5 which held 0\n Finalizing ::oo::Obj4::Obj6 which held 1\n Finalizing ::oo::Obj4::Obj7 which held 2\n Initializing ::oo::Obj4::Obj6 with 10\n Initializing ::oo::Obj4::Obj7 with 11<\/span>\n trapped: exceeded capacity: 9\n number of objects: 9\n         3 4 5 6 7 8 9 10 11 \n <span style=\"color:red\">Finalizing ::oo::Obj4::Obj8 which held 3\n Finalizing ::oo::Obj4::Obj9 which held 4\n Finalizing ::oo::Obj4::Obj10 which held 5\n Finalizing ::oo::Obj4::Obj11 which held 6\n Finalizing ::oo::Obj4::Obj12 which held 7\n Finalizing ::oo::Obj4::Obj13 which held 8\n Finalizing ::oo::Obj4::Obj14 which held 9\n Finalizing ::oo::Obj4::Obj6 which held 10\n Finalizing ::oo::Obj4::Obj7 which held 11<\/span>\n\n[[Category:Go\/Omit]]\n[[Category:Haskell\/Omit]]\n[[Category:M4\/Omit]]\n[[Category:ML\/I\/Omit]]\n[[Category:Oz\/Omit]]\n[[Category:TI-89 BASIC\/Omit]]"}]}}},"query-continue":{"revisions":{"rvstartid":136039}}}