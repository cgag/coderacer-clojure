{"query-continue":{"search":{"gsroffset":1},"revisions":{"rvstartid":137823}},"query":{"pages":{"2151":{"pageid":2151,"ns":0,"title":"100 doors","revisions":[{"*":"<div class=\"infobox\" style=\"width: 2in\">[[File:Rcode-button-task-crushed.png|64px|left|alt=Task|link=Category:Solutions by Programming Task]]'''100 doors'''<br\/>\nYou are encouraged to [[Rosetta Code:Solve a Task|solve this task]] according to the task description, using any language you may know.[[Category:Programming Tasks]][[Category:Solutions by Programming Task]]<\/div>\nProblem: You have 100 doors in a row that are all initially closed. You make 100 [[task feature::Rosetta Code:multiple passes|passes]] by the doors. The first time through, you visit every door and toggle the door (if the door is closed, you open it; if it is open, you close it). The second time you only visit every 2nd door (door #2, #4, #6, ...). The third time, every 3rd door (door #3, #6, #9, ...), etc, until you only visit the 100th door.\n\nQuestion: What state are the doors in after the last pass? Which are open, which are closed? [http:\/\/www.techinterview.org\/Puzzles\/fog0000000079.html]\n\n'''[[task feature::Rosetta Code:extra credit|Alternate]]:'''  As noted in this page's [[Talk:100 doors|discussion page]], the only doors that remain open are whose numbers are perfect squares of integers.  Opening only those doors is an [[task feature::Rosetta Code:optimization|optimization]] that may also be expressed.\n\n==[[:Category:4DOS Batch|4DOS Batch]][[Category:4DOS Batch]]==\n\n<lang 4DOS Batch>\n@echo off\nset doors=%@repeat[C,100]\ndo step = 1 to 100\n  do door = %step to 100 by %step\n    set doors=%@left[%@eval[%door-1],%doors]%@if[%@instr[%@eval[%door-1],1,%doors]==C,O,C]%@right[%@eval[100-%door],%doors]\n  enddo\nenddo\n<\/lang>\n\nThe SET line consists of three functions: \n<lang>\n%@left[n,string]                      ^: Return n leftmost chars in string\n%@right[n,string]                     ^: Return n rightmost chars in string\n%@if[condition,true-val,false-val]    ^: Evaluate condition; return true-val if true, false-val if false\n<\/lang>\n\nHere @IF is used to toggle between C and O.\n\n==[[:Category:6502 Assembly|6502 Assembly]][[Category:6502 Assembly]]== \n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[http:\/\/www.6502asm.com\/ 6502asm.com]] version 1.2[[SMW::on]]<\/div>\n\n'''optimized'''\n(Largely inspired by the optimized C implementation)\n<lang 6502asm>\n                        ;assume all memory is initially set to 0\n          inc $1        ;start out with a delta of 1\nopenloop: inc $200,X    ;open a door at X\n          inc $1        ;add 2 to delta\n          inc $1\n          txa           ;add delta to X\n          adc $1\n          tax\n          cpx #$65      ;check to see if we're at the 100th door\n          bmi openloop  ;jump back to openloop if less than 100<\/lang>\n\n==[[:Category:8086 Assembly|8086 Assembly]][[Category:8086 Assembly]]==\nSee [[100 doors\/8086 Assembly]]\n\n==[[:Category:ABAP|ABAP]][[Category:ABAP]]==\n'''unoptimized'''\n<lang ABAP>form open_doors_unopt.\n  data: lv_door  type i,\n        lv_count type i value 1.\n  data: lt_doors type standard table of c initial size 100.\n  field-symbols: <wa_door> type c.\n  do 100 times.\n    append initial line to lt_doors assigning <wa_door>.\n    <wa_door> = 'X'.\n  enddo.\n\n  while lv_count < 100.\n    lv_count = lv_count + 1.\n    lv_door = lv_count.\n    while lv_door < 100.\n      read table lt_doors index lv_door assigning <wa_door>.\n      if <wa_door> = ' '.\n        <wa_door> = 'X'.\n      else.\n        <wa_door> = ' '.\n      endif.\n      add lv_count to lv_door.\n    endwhile.\n  endwhile.\n\n  loop at lt_doors assigning <wa_door>.\n    if <wa_door> = 'X'.\n      write : \/ 'Door', (4) sy-tabix right-justified, 'is open' no-gap.\n    endif.\n  endloop.\nendform.<\/lang>\n\n'''optimized'''\n\nUsing <math>\\sum_{i=1}^n (2i-1) = n^2<\/math>\n<lang ABAP>form open_doors_opt.\n  data: lv_square type i value 1,\n        lv_inc    type i value 3.\n  data: lt_doors  type standard table of c initial size 100.\n  field-symbols: <wa_door> type c.\n  do 100 times.\n    append initial line to lt_doors assigning <wa_door>.\n    if sy-index = lv_square.\n      <wa_door> = 'X'.\n      add: lv_inc to lv_square, 2 to lv_inc.\n      write : \/ 'Door', (4) sy-index right-justified, 'is open' no-gap.\n    endif.\n  enddo.\nendform.<\/lang>\n\n==[[:Category:ACL2|ACL2]][[Category:ACL2]]==\n\n<lang lisp>(defun rep (n x)\n   (if (zp n)\n       nil\n       (cons x\n             (rep (- n 1) x))))\n\n(defun toggle-every-r (n i bs)\n   (if (endp bs)\n       nil\n       (cons (if (zp i)\n                 (not (first bs))\n                 (first bs))\n             (toggle-every-r n (mod (1- i) n) (rest bs)))))\n\n(defun toggle-every (n bs)\n   (toggle-every-r n (1- n) bs))\n\n(defun 100-doors (i doors)\n   (if (zp i)\n       doors\n       (100-doors (1- i) (toggle-every i doors))))<\/lang>\n\n==[[:Category:ActionScript|ActionScript]][[Category:ActionScript]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[ActionScript]] version 3.0[[SMW::on]]<\/div>\n'''unoptimized'''\n<lang actionscript>package {                                                                                \n    import flash.display.Sprite;                                              \n\n    public class Doors extends Sprite {\n        public function Doors() {\n\n            \/\/ Initialize the array\n            var doors:Array = new Array(100);\n            for (var i:Number = 0; i < 100; i++) {\n                doors[i] = false;\n\n            \/\/ Do the work\n            for (var pass:Number = 0; pass < 100; pass++) {\n                for (var j:Number = pass; j < 100; j += (pass+1)) {\n                    doors[j] = !doors[j];\n                }\n            }\n            trace(doors);\n        }\n    }\n}<\/lang>\n\n==[[:Category:Ada|Ada]][[Category:Ada]]==\n'''unoptimized'''\n<lang ada>with Ada.Text_Io; use Ada.Text_Io;\n \n procedure Doors is\n    type Door_State is (Closed, Open);\n    type Door_List is array(Positive range 1..100) of Door_State;\n    The_Doors : Door_List := (others => Closed);\n begin\n    for I in 1..100 loop\n       for J in The_Doors'range loop\n          if J mod I = 0 then\n             if The_Doors(J) = Closed then\n                 The_Doors(J) := Open;\n             else\n                The_Doors(J) := Closed;\n             end if;\n          end if;\n       end loop;\n    end loop;\n    for I in The_Doors'range loop\n       Put_Line(Integer'Image(I) & \" is \" & Door_State'Image(The_Doors(I)));\n    end loop;\n end Doors;<\/lang>\n\n'''optimized'''\n<lang ada>with Ada.Text_Io; use Ada.Text_Io;\n with Ada.Numerics.Elementary_Functions; use Ada.Numerics.Elementary_Functions;\n \n procedure Doors_Optimized is\n    Num : Float;\n begin\n    for I in 1..100 loop\n       Num := Sqrt(Float(I));\n       Put(Integer'Image(I) & \" is \");\n       if Float'Floor(Num) = Num then\n          Put_Line(\"Opened\");\n       else\n          Put_Line(\"Closed\");\n       end if;\n    end loop;\n end Doors_Optimized;<\/lang>\n\n==[[:Category:Aikido|Aikido]][[Category:Aikido]]== \n<lang aikido>\nvar doors = new int [100]\n\nforeach pass 100 {\n    for (var door = pass ; door < 100 ; door += pass+1) {\n        doors[door] = !doors[door]\n    }\n}\n\nvar d = 1\nforeach door doors {\n    println (\"door \" + d++ + \" is \" + (door ? \"open\" : \"closed\"))\n\n}\n\n<\/lang>\n\n==[[:Category:ALGOL 68|ALGOL 68]][[Category:ALGOL 68]]== \n'''unoptimized'''\n<lang algol68># declare some constants #\nINT limit = 100;\n\nPROC doors = VOID:\n(\n  MODE DOORSTATE = BOOL;\n  BOOL closed = FALSE;\n  BOOL open = NOT closed;\n  MODE DOORLIST = [limit]DOORSTATE;\n\n  DOORLIST the doors;\n  FOR i FROM LWB the doors TO UPB the doors DO the doors[i]:=closed OD;\n\n  FOR i FROM LWB the doors TO UPB the doors DO\n    FOR j FROM LWB the doors TO UPB the doors DO\n      IF j MOD i = 0 THEN\n        the doors[j] :=  NOT the doors[j]\n      FI\n    OD\n  OD;\n  FOR i FROM LWB the doors TO UPB the doors DO\n    printf(($g\" is \"gl$,i,(the doors[i]|\"opened\"|\"closed\")))\n  OD\n);\ndoors;<\/lang>\n'''optimized'''\n<lang algol68>PROC doors optimised = ( INT limit )VOID:\n  FOR i TO limit DO\n    REAL num := sqrt(i);\n    printf(($g\" is \"gl$,i,(ENTIER num = num |\"opened\"|\"closed\") ))\n  OD\n;\ndoors optimised(limit)<\/lang>\n==[[:Category:AmigaE|AmigaE]][[Category:AmigaE]]==\n<lang amigae>PROC main()\n  DEF t[100]: ARRAY,\n      pass, door\n  FOR door := 0 TO 99 DO t[door] := FALSE\n  FOR pass := 0 TO 99\n    door := pass\n    WHILE door <= 99\n      t[door] := Not(t[door])\n      door := door + pass + 1\n    ENDWHILE\n  ENDFOR\n  FOR door := 0 TO 99 DO WriteF('\\d is \\s\\n', door+1,\n                                IF t[door] THEN 'open' ELSE 'closed')\nENDPROC<\/lang>\n\n==[[:Category:APL|APL]][[Category:APL]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Dyalog APL]][[SMW::on]]<\/div>\n\n'''unoptimized'''\n<lang APL>out\u2190doors num\n\u235d Simulates the 100 doors problem for any number of doors\n\u235d Returns a boolean vector with 1 being open\n\nout\u2190\u2373num            \u235d num steps\nout\u2190\u2373\u00a8out           \u235d Count out the spacing for each step\nout\u21901=out           \u235d Make that into a boolean vector\nout\u2190\u233d\u00a8out           \u235d Flip each vector around\nout\u2190(num\u2218\u2374)\u00a8out     \u235d Copy each out to the right size\nout\u2190\u2260\/out           \u235d XOR each vector, toggling each marked door\nout\u2190\u2283out            \u235d Disclose the results to get a vector<\/lang>\nSample Output:\n<pre>\n 10 10\u2374doors 100\n1 0 0 1 0 0 0 0 1 0\n0 0 0 0 0 1 0 0 0 0\n0 0 0 0 1 0 0 0 0 0\n0 0 0 0 0 1 0 0 0 0\n0 0 0 0 0 0 0 0 1 0\n0 0 0 0 0 0 0 0 0 0\n0 0 0 1 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n1 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 1  \n<\/pre>\n\n'''optimized'''\n<lang APL>out\u2190doorsOptimized num;marks\n\u235d Returns a boolean vector of the doors that would be left open\n\nmarks\u2190\u230anum*0.5        \u235d Take the square root of the size, floored\nmarks\u2190(\u2373marks)*2      \u235d Get each door to be opened\nout\u2190num\u23740             \u235d Make a vector of 0s\nout[marks]\u21901          \u235d Set the marked doors to 1<\/lang>\nSample Output:\n<pre>\n 10 10\u2374doorsOptimized 100\n1 0 0 1 0 0 0 0 1 0\n0 0 0 0 0 1 0 0 0 0\n0 0 0 0 1 0 0 0 0 0\n0 0 0 0 0 1 0 0 0 0\n0 0 0 0 0 0 0 0 1 0\n0 0 0 0 0 0 0 0 0 0\n0 0 0 1 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n1 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 1  \n<\/pre>\n\n'''Alternate 1-line version'''\nNote that &#9109;IO = 1\n<pre>\n2|+\/[1]0=D&#8728;.|D&#8592;&#9075;100\n<\/pre>\nThe idea is that the <i>n<\/i>:th door will be flipped the same number of times as there are divisors for <i>n<\/i>. So first we make D all ints 1..100 (D&#8592;&#9075;100).<br>The next step is to find the remainders of every such int when divided by every other (D&#8728;.|D).<br> This results in a 100&#215;100 matrix which we turn into a binary one by testing if the values are equal to zero i.e. divisors.<br>Next: sum along axis 1, i.e. the columns. This tells us the number of divisors. Finally calculate the remainder of these when divided by 2, i.e. find which <i>n<\/i> have an odd number of divisors, i.e. will be flipped an odd number of times and thus end up open.\n\n==[[:Category:AppleScript|AppleScript]][[Category:AppleScript]]==\n<lang AppleScript>set is_open to {}\nrepeat 100 times\n   set end of is_open to false\nend\nrepeat with pass from 1 to 100\n  repeat with door from pass to 100 by pass\n    set item door of is_open to not item door of is_open\n  end\nend\nset open_doors to {}\nrepeat with door from 1 to 100\n   if item door of is_open then\n     set end of open_doors to door\n   end\nend\nset text item delimiters to \", \"\ndisplay dialog \"Open doors: \" & open_doors<\/lang>\n\n==[[:Category:Arbre|Arbre]][[Category:Arbre]]==\n<lang Arbre>\nopenshut(n):\n  for x in [1..n]\n    x%n==0\n\npass(n):\n  if n==100\n    openshut(n)\n  else\n    openshut(n) xor pass(n+1)\n\n100doors():\n  pass(1) -> io\n<\/lang>\n\n==[[:Category:Argile|Argile]][[Category:Argile]]==\n<lang Argile>use std, array\n\nclose all doors\nfor each pass from 1 to 100\n  for (door = pass) (door <= 100) (door += pass)\n    toggle door\n\nlet int pass, door.\n\n.: close all doors :. {memset doors 0 size of doors}\n.:toggle <int door>:. {    !!(doors[door - 1])     }\n\nlet doors be an array of 100 bool\n\nfor each door from 1 to 100\n  printf \"#%.3d %s\\n\" door (doors[door - 1]) ? \"[ ]\", \"[X]\"<\/lang>\n\n==[[:Category:AutoHotkey|AutoHotkey]][[Category:AutoHotkey]]==\n=== Standard Approach ===\n<lang autohotkey>Loop, 100\n  Door%A_Index% := \"closed\"\n\nLoop, 100 {\n  x := A_Index, y := A_Index\n  While (x <= 100)\n  {\n    CurrentDoor := Door%x%\n    If CurrentDoor contains closed\n    {\n      Door%x% := \"open\"\n      x += y\n    }\n    else if CurrentDoor contains open\n    {\n      Door%x% := \"closed\"\n      x += y\n    }\n  }\n}\n\nLoop, 100 {\n   CurrentDoor := Door%A_Index%\n   If CurrentDoor contains open\n      Res .= \"Door \" A_Index \" is open`n\"\n}\nMsgBox % Res<\/lang>\n\n=== Alternative Approach ===\nMaking use of the identity:\n\n<math>\\sum_{i=1}^n (2i-1) = n^2<\/math>\n<lang autohotkey>increment := 3, square := 1 \nLoop, 100 \n    If (A_Index = square) \n        outstring .= \"`nDoor \" A_Index \" is open\" \n        ,square += increment, increment += 2 \nMsgBox,, Succesfull, % SubStr(outstring, 2)<\/lang>\n=== Optimized ===\n<lang autohotkey>While (Door := A_Index ** 2) <= 100\n   Result .= \"Door \" Door \" is open`n\"\nMsgBox, %Result%<\/lang>\n\n==[[:Category:Axiom|Axiom]][[Category:Axiom]]==\nUnoptimized:<lang Axiom>(open,closed,change,open?) := (true,false,not,test);\ndoors := bits(100,closed);\nfor i in 1..#doors repeat\n  for j in i..#doors by i repeat\n    doors.j := change doors.j\n[i for i in 1..#doors | open? doors.i]\n<\/lang>Optimized:<lang Axiom>[i for i in 1..100 | perfectSquare? i] -- or\n[i^2 for i in 1..sqrt(100)::Integer]<\/lang>\n==[[:Category:AWK|AWK]][[Category:AWK]]==\n'''unoptimized'''\n<lang awk>BEGIN {\n  for(i=1; i <= 100; i++)\n  {\n    doors[i] = 0 # close the doors\n  }\n  for(i=1; i <= 100; i++)\n  {\n    for(j=i; j <= 100; j += i)\n    {\n      doors[j] = (doors[j]+1) % 2\n    }\n  }\n  for(i=1; i <= 100; i++)\n  {\n    print i, doors[i] ? \"open\" : \"close\"\n  }\n}<\/lang>\n'''optimized'''\n<lang awk>BEGIN {\n  for(i=1; i <= 100; i++) {\n    doors[i] = 0 # close the doors\n  }\n  for(i=1; i <= 100; i++) {\n    if ( int(sqrt(i)) == sqrt(i) ) {\n      doors[i] = 1\n    }\n  }\n  for(i=1; i <= 100; i++)\n  {\n    print i, doors[i] ? \"open\" : \"close\"\n  }\n}<\/lang>\n\n==[[:Category:BASIC|BASIC]][[Category:BASIC]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[QuickBasic]] version 4.5[[SMW::on]]<\/div>\n\n'''unoptimized'''\n<lang qbasic>DIM doors(0 TO 99)\nFOR pass = 0 TO 99\n\tFOR door = pass TO 99 STEP pass + 1\n\t\tPRINT doors(door)\n\t\tPRINT NOT doors(door)\n\t\tdoors(door) = NOT doors(door)\n\tNEXT door\nNEXT pass\nFOR i = 0 TO 99\n\tPRINT \"Door #\"; i + 1; \" is \";\n\tIF NOT doors(i) THEN\n\t\tPRINT \"closed\"\n\tELSE\n\t\tPRINT \"open\"\n\tEND IF\nNEXT i<\/lang>\n'''optimized'''\n<lang qbasic>DIM doors(0 TO 99)\nFOR door = 0 TO 99\n\tIF INT(SQR(door)) = SQR(door) THEN doors(door) = -1\nNEXT door\nFOR i = 0 TO 99\n\tPRINT \"Door #\"; i + 1; \" is \";\n\tIF NOT doors(i) THEN\n\t\tPRINT \"closed\"\n\tELSE\n\t\tPRINT \"open\"\n\tEND IF\nNEXT i<\/lang>\n\n==[[:Category:Batch File|Batch File]][[Category:Batch File]]==\n\n'''unoptimized'''\n<lang dos>\n@echo off\nsetlocal enableDelayedExpansion\n:: 0 = closed\n:: 1 = open\n:: SET \/A treats undefined variable as 0\n:: Negation operator ! must be escaped because delayed expansion is enabled\nfor \/l %%p in (1 1 100) do for \/l %%d in (%%p %%p 100) do set \/a \"door%%d=^!door%%d\"\nfor \/l %%d in (1 1 100) do if !door%%d!==1 (\n  echo door %%d is open\n) else echo door %%d is closed\n<\/lang>\n\n'''optimized'''\n<lang dos>\n@echo off\nsetlocal enableDelayedExpansion\nset \/a square=1, incr=3\nfor \/l %%d in (1 1 100) do (\n  if %%d neq !square! (echo door %%d is closed) else (\n    echo door %%d is open\n    set \/a square+=incr, incr+=2\n  )\n)\n<\/lang>\n\n==[[:Category:BBC BASIC|BBC BASIC]][[Category:BBC BASIC]]==\n<lang bbcbasic>      DIM doors%(100)\n      \n      FOR pass% = 1 TO 100\n        FOR door% = pass% TO 100 STEP pass%\n          doors%(door%) EOR= TRUE\n        NEXT door%\n      NEXT pass%\n      \n      FOR door% = 1 TO 100\n        IF doors%(door%) PRINT \"Door \" ; door% \" is open\"\n      NEXT door%<\/lang>\n\n==[[:Category:Befunge|Befunge]][[Category:Befunge]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[CCBI]] version 2.1[[SMW::on]]<\/div>\n<lang befunge>108p0>:18p;;>:9g!18g9p08g]\n*`!0\\|+relet|-1`*aap81::+]\n;::+1<r]!g9;>$08g1+:08paa[\n*`#@_^._aa<\/lang>\n\n==[[:Category:BlitzMax|BlitzMax]][[Category:BlitzMax]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[BlitzMax]] version 1.37[[SMW::on]]<\/div>\n\n'''optimized'''\n<lang BlitzMax>Graphics 640,480\ni=1\nWhile ((i*i)<=100)\n\ta$=i*i\n\tDrawText a$,10,20*i\n\tPrint i*i\n\ti=i+1 \nWend\nFlip \nWaitKey <\/lang>\n\n==[[:Category:Bracmat|Bracmat]][[Category:Bracmat]]==\nBracmat is not really at home in tasks that involve addressing things by index number. Here are four solutions that each do the task, but none should win a price for cleanliness.\n\nSolution 1. Use an indexable array. Local variables are stored in stacks. Each stack corresponds to one variable name and vice versa. Stacks can also be used as arrays, but because of how local variables are implemented, arrays cannot be declared as local variables.\n<lang bracmat>( 100doors-tbl\n=   door step\n  .   tbl$(doors.101) { Create an array. Indexing is 0-based. Add one extra for addressing element nr. 100 }\n    & 0:?step\n    &   whl\n      ' ( 1+!step:~>100:?step   { ~> means 'not greater than', i.e. 'less than or equal' }\n        & 0:?door\n        &   whl\n          ' ( !step+!door:~>100:?door\n            & 1+-1*!(!door$doors):?doors  { <number>$<variable> sets the current index, which stays the same until explicitly changed. }\n            )\n        )\n    & 0:?door\n    &   whl\n      ' ( 1+!door:~>100:?door\n        &   out\n          $ ( door\n              !door\n              is\n              ( !(!door$doors):1&open\n              | closed\n              )\n            )\n        )\n    & tbl$(doors.0)  { clean up the array }\n)<\/lang>\n\nSolution 2. Use one variable for each door. In Bracmat, a variable name can be any non-empty string, even a number, so we use the numbers 1 .. 100 as variable names, but also as door numbers. When used as variable an extra level of indirection is needed. See the occurrences of <code>?!<\/code> and <code>!!<\/code> in the following code.\n<lang bracmat>( 100doors-var\n=   step door\n  .   0:?door\n    &   whl\n      ' ( 1+!door:~>100:?door\n        & closed:?!door { this creates a variable and assigns a value 'closed' to it }\n        )\n    & 0:?step\n    &   whl\n      ' ( 1+!step:~>100:?step\n        & 0:?door\n        &   whl\n          ' ( !step+!door:~>100:?door\n            &   ( !!door:closed&open\n                | closed\n                )\n              : ?!door   \n            )\n        )\n    & 0:?door\n    &   whl\n      ' ( 1+!door:~>100:?door\n        & out$(door !door is !!door)\n        )\n    & 0:?door\n    &   whl\n      ' ( 1+!door:~>100:?door\n        & tbl$(!door.0)         { cleanup the variable }\n        )\n)<\/lang>\n\nSolution 3. Use a list and a dedicated positioning pattern to address the right door in the list. Create a new list by concatenating the skipped elements with the toggled elements. This solution is computationally unfavourable because of the many concatenations.\n<lang bracmat>( 100doors-list\n=   doors door doorIndex step\n  .   :?doors\n    & 0:?door\n    &   whl\n      ' ( 1+!door:~>100:?door\n        & closed !doors:?doors\n        )\n    & 0:?skip\n    &   whl\n      ' ( :?ndoors\n        &   whl\n          ' ( !doors:?skipped [!skip %?door ?doors  { the [<number> pattern only succeeds when the scanning cursor is at position <number> }\n            &     !ndoors\n                  !skipped\n                  ( !door:open&closed\n                  | open\n                  )\n              : ?ndoors\n            )\n        & !ndoors !doors:?doors\n        & 1+!skip:<100:?skip\n        )\n    & out$!doors\n)<\/lang>\n\nSolution 4. Use a list of objects. Each object can be changed without the need to re-create the whole list.\n<lang bracmat>( 100doors-obj\n=   doors door doorIndex step\n  .   :?doors\n    & 0:?door\n    &   whl\n      ' ( 1+!door:~>100:?door\n        & new$(=closed) !doors:?doors\n        )\n    & 0:?skip\n    &   whl\n      ' ( !doors:?tododoors\n        &   whl\n          ' ( !tododoors:? [!skip %?door ?tododoors\n            &   ( !(door.):open&closed\n                | open\n                )\n              : ?(door.)\n            )\n        & 1+!skip:<100:?skip\n        )\n    & out$!doors\n)<\/lang>\n\nThese four functions are called in the following way:\n<lang bracmat>100doors-tbl$\n& 100doors-var$\n& 100doors-list$\n& 100doors-obj$;<\/lang>\n\n==[[:Category:C|C]][[Category:C]]==\n===unoptimized===\n<div class=\"examplemeta libheader\">'''Uses:''' [[SMW::off]][[uses::Library\/C Runtime|C Runtime]][[Category:C Runtime]]<small> ('''Components:'''[[SMW::on]][[Uses Library::Library\/C Runtime\/printf|printf]],)<\/small><\/div>\n<lang c>#include <stdio.h>\n\nint main()\n{\n  char is_open[100] = { 0 };\n  int pass, door;\n\n  \/\/ do the 100 passes\n  for (pass = 0; pass < 100; ++pass)\n    for (door = pass; door < 100; door += pass+1)\n      is_open[door] = !is_open[door];\n\n  \/\/ output the result\n  for (door = 0; door < 100; ++door)\n    printf(\"door #%d is %s.\\n\", door+1, (is_open[door]? \"open\" : \"closed\"));\n\n  return 0;\n}<\/lang>\n\n===optimized===\nThis optimized version makes use of the fact that finally only the doors with square index are open, as well as the fact that <math>n^2 = 1 + 3 + 5 + \\ldots + (2n+1)<\/math>.\n\n<div class=\"examplemeta libheader\">'''Uses:''' [[SMW::off]][[uses::Library\/C Runtime|C Runtime]][[Category:C Runtime]]<small> ('''Components:'''[[SMW::on]][[Uses Library::Library\/C Runtime\/printf|printf]],)<\/small><\/div>\n<lang c>#include <stdio.h>\n\nint main()\n{\n  int square = 1, increment = 3, door;\n  for (door = 1; door <= 100; ++door)\n  {\n    printf(\"door #%d\", door);\n    if (door == square)\n    {\n      printf(\" is open.\\n\");\n      square += increment;\n      increment += 2;\n    }\n    else\n      printf(\" is closed.\\n\");\n  }\n  return 0;\n}<\/lang>\n\nThe following ultra-short optimized version demonstrates the flexibility of C loops, but isn't really considered good C style:\n\n<lang c>#include <stdio.h>\n\nint main()\n{\n  int door, square, increment;\n  for (door = 1, square = 1, increment = 1; door <= 100; door++ == square && (square += increment += 2))\n    printf(\"door #%d is %s.\\n\", door, (door == square? \"open\" : \"closed\"));\n  return 0;\n}<\/lang>\n\nOr really optimize it -- square of an integer is, well, computable:<lang C>#include <stdio.h>\n\nint main()\n{\n\tint i;\n\tfor (i = 1; i * i <= 100; i++)\n\t\tprintf(\"door %d open\\n\", i * i);\n\n\treturn 0;\n}<\/lang>\n\n==[[:Category:C++|C++]][[Category:C++]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[GCC]] version 4.1.2 20061115 (prerelease) (SUSE Linux)[[SMW::on]]<\/div>\n\n'''unoptimized '''\n<lang cpp>#include <iostream>\n\nint main()\n{\n  bool is_open[100] = { false };\n\n  \/\/ do the 100 passes\n  for (int pass = 0; pass < 100; ++pass)\n    for (int door = pass; door < 100; door += pass+1)\n      is_open[door] = !is_open[door];\n\n  \/\/ output the result\n  for (int door = 0; door < 100; ++door)\n    std::cout << \"door #\" << door+1 << (is_open[door]? \" is open.\" : \" is closed.\") << std::endl;\n  return 0;\n}<\/lang>\n\n'''optimized '''\nThis optimized version makes use of the fact that finally only the doors with square index are open, as well as the fact that <math>(n+1)^2 = 1 + 3 + 5 + \\ldots + (2n+1)<\/math>.\n\n<lang cpp>#include <iostream>\n\nint main()\n{\n  int square = 1, increment = 3;\n  for (int door = 1; door <= 100; ++door)\n  {\n    std::cout << \"door #\" << door;\n    if (door == square)\n    {\n      std::cout << \" is open.\" << std::endl;\n      square += increment;\n      increment += 2;\n    }\n    else\n      std::cout << \" is closed.\" << std::endl;\n  }\n  return 0;\n}<\/lang>\n\nThe only calculation that's really needed:\n<lang cpp>#include <iostream> \/\/compiled with \"Dev-C++\" , from RaptorOne\n\nint main()\n{\n    for(int i=1; i*i<=100; i++)\n            std::cout<<\"Door \"<<i*i<<\" is open!\"<<std::endl;\n}<\/lang>\n\n==<span id=\"C sharp\">[[:Category:C sharp|C#]]<\/span>[[Category:C sharp]]==\n'''Unoptimized'''\n<lang csharp>using System;\nclass Program\n{\n    static void Main()\n    {\n        \/\/To simplify door numbers, uses indexes 1 to 100 (rather than 0 to 99)\n        bool[] doors = new bool[101];\n        for (int pass = 1; pass <= 100; pass++)\n            for (int current = pass; current <= 100; current += pass)\n                doors[current] = !doors[current];\n        for (int i = 1; i <= 100; i++)\n            Console.WriteLine(\"Door #{0} \" + (doors[i] ? \"Open\" : \"Closed\"), i);\n    }\n}<\/lang>\n'''Optimized'''\n<lang csharp>using System;\nclass Program\n{\n    static void Main()\n    {\n        int door = 1, inrementer = 0;\n        for (int current = 1; current <= 100; current++)\n        {\n            Console.Write(\"Door #{0} \", current);\n            if (current == door)\n            {\n                Console.WriteLine(\"Open\");\n                inrementer++;\n                door += 2 * inrementer + 1;\n            }\n            else\n                Console.WriteLine(\"Closed\");\n        }\n    }\n}<\/lang>\n'''Optimized for brevity'''\n<lang csharp>using System;\nclass Program\n{\n    static void Main()\n    {\n        double n;\n        for (int t = 1; t <= 100; ++t)\n                Console.WriteLine(t + \": \" + (((n = Math.Sqrt(t)) == (int)n) ? \"Open\" : \"Closed\"));\n    }\n}<\/lang>\n\n==[[:Category:C1R|C1R]][[Category:C1R]]==\n<lang c>100_doors<\/lang>\n==[[:Category:CLIPS|CLIPS]][[Category:CLIPS]]==\n\n'''Unoptimized'''\n\n<lang clips>(deffacts initial-state\n  (door-count 100)\n)\n\n(deffunction toggle\n  (?state)\n  (switch ?state\n    (case \"open\" then \"closed\")\n    (case \"closed\" then \"open\")\n  )\n)\n\n(defrule create-doors-and-visits\n  (door-count ?count)\n  =>\n  (loop-for-count (?num 1 ?count) do\n    (assert (door ?num \"closed\"))\n    (assert (visit-from ?num ?num))\n  )\n  (assert (doors initialized))\n)\n\n(defrule visit\n  (door-count ?max)\n  ?visit <- (visit-from ?num ?step)\n  ?door <- (door ?num ?state)\n  =>\n  (retract ?visit)\n  (retract ?door)\n  (assert (door ?num (toggle ?state)))\n  (if\n    (<= (+ ?num ?step) ?max)\n    then\n    (assert (visit-from (+ ?num ?step) ?step))\n  )\n)\n\n(defrule start-printing\n  (doors initialized)\n  (not (visit-from ? ?))\n  =>\n  (printout t \"These doors are open:\" crlf)\n  (assert (print-from 1))\n)\n\n(defrule print-door\n  (door-count ?max)\n  ?pf <- (print-from ?num)\n  (door ?num ?state)\n  =>\n  (retract ?pf)\n  (if\n    (= 0 (str-compare \"open\" ?state))\n    then\n    (printout t ?num \" \")\n  )\n  (if\n    (< ?num ?max)\n    then\n    (assert (print-from (+ ?num 1)))\n    else\n    (printout t crlf \"All other doors are closed.\" crlf)\n  )\n)<\/lang>\n\n'''Optimized'''\n\n<lang clips>(deffacts initial-state\n  (door-count 100)\n)\n\n(deffunction is-square\n  (?num)\n  (= (sqrt ?num) (integer (sqrt ?num)))\n)\n\n(defrule check-doors\n  (door-count ?count)\n  =>\n  (printout t \"These doors are open:\" crlf)\n  (loop-for-count (?num 1 ?count) do\n    (if (is-square ?num) then\n      (printout t ?num \" \")\n    )\n  )\n  (printout t crlf \"All other doors are closed.\" crlf)\n)<\/lang>\n\n==[[:Category:Clojure|Clojure]][[Category:Clojure]]==\n'''Unoptimized \/ mutable array'''\n<lang clojure>(defn doors []\n  (let [doors (into-array (repeat 100 false))]\n    (doseq [pass   (range 1 101) \n            i      (range (dec pass) 100 pass) \n            :while (< i 100)]\n      (aset doors i (not (aget doors i))))\n    doors))   \n\n(defn open-doors [] (for [[d n] (map vector (doors) (iterate inc 1)) :when d] n))\n\n(defn print-open-doors []\n  (println \n    \"Open doors after 100 passes:\"\n    (apply str (interpose \", \" (open-doors)))))<\/lang>\n\n'''Unoptimized \/ functional '''\n<lang clojure>(defn doors []\n  (reduce (fn [doors toggle-idx] (update-in doors [toggle-idx] not))\n          (into [] (repeat 100 false))\n          (for [pass   (range 1 101)\n                i      (range (dec pass) 100 pass)\n                :while (< i 100)]\n            i)))\n\n(defn open-doors [] (for [[d n] (map vector (doors) (iterate inc 1)) :when d] n))\n\n(defn print-open-doors []\n  (println \n    \"Open doors after 100 passes:\"\n    (apply str (interpose \", \" (open-doors)))))<\/lang>\n\n'''Optimized \/ functional'''\n<lang clojure>(defn doors []\n\t(reduce (fn [doors idx] (assoc doors idx true)) \n\t        (into [] (repeat 100 false))\n\t        (map #(dec (* % %)) (range 1 11))))\n\n(defn open-doors [] (for [[d n] (map vector (doors) (iterate inc 1)) :when d] n))\n\n(defn print-open-doors []\n  (println \n    \"Open doors after 100 passes:\"\n    (apply str (interpose \", \" (open-doors)))))<\/lang>\n\n==[[:Category:COBOL|COBOL]][[Category:COBOL]]==\n<lang cobol>       IDENTIFICATION DIVISION.\n       PROGRAM-ID. 100Doors.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 Current        PIC 9(3)   VALUE ZEROES.\n       01 StepSize       PIC 9(3)   VALUE ZEROES.\n       01 DoorTable.\n          02 Doors       PIC 9(1)   OCCURS 100 TIMES.\n       01 Idx            PIC 9(3).\n\n       PROCEDURE DIVISION.\n       Begin.\n           MOVE 1 TO StepSize\n           PERFORM 100 TIMES\n             MOVE StepSize TO Current\n             PERFORM UNTIL Current > 100\n               SUBTRACT Doors(Current) FROM 1 GIVING Doors(Current)\n               ADD StepSize TO Current GIVING Current\n             END-PERFORM\n             ADD 1 TO StepSize GIVING StepSize\n           END-PERFORM\n           PERFORM VARYING Idx FROM 1 BY 1\n                   UNTIL Idx > 100\n             IF Doors(Idx) = 0\n               DISPLAY Idx \" is closed.\"\n             ELSE\n               DISPLAY Idx \" is open.\"\n             END-IF\n           END-PERFORM\n           STOP RUN.<\/lang>\n\n==[[:Category:CoffeeScript|CoffeeScript]][[Category:CoffeeScript]]==\n'''unoptimized''':\n<lang coffeescript>doors = []\n \nfor pass in [1..100]\n  for i in [pass..100] by pass\n    doors[i] = !doors[i]\n \nconsole.log \"Doors #{index for index, open of doors when open} are open\"\n \n# matrix output\nconsole.log doors.map (open) -> +open\n<\/lang>\n\n'''optimized''':\n\n<lang coffeescript>isInteger = (i) -> Math.floor(i) == i\n\nconsole.log door for door in [1..100] when isInteger Math.sqrt door<\/lang>\n\n'''ultra-optimized''':\n<lang coffeescript>console.log Math.pow(i,2) for i in [1..10]<\/lang>\n\n==[[:Category:ColdFusion|ColdFusion]][[Category:ColdFusion]]==\n'''Basic Solution: Returns List of 100 values: 1=open 0=closed'''\n<lang coldfusion>\n\tdoorCount = 1;\n\tdoorList = \"\";\n\t\/\/ create all doors and set all doors to open\n\twhile (doorCount LTE 100) {\n\t\tdoorList = ListAppend(doorList,\"1\");\n\t\tdoorCount = doorCount + 1;\n\t}\n\tloopCount = 2;\n\tdoorListLen = ListLen(doorList);\n\twhile (loopCount LTE 100) {\n\t\tloopDoorListCount = 1;\n\t\twhile (loopDoorListCount LTE 100) {\n\t\t\ttestDoor = loopDoorListCount \/ loopCount;\n\t\t\tif (testDoor EQ Int(testDoor)) {\n\t\t\t\tcheckOpen = ListGetAt(doorList,loopDoorListCount);\n\t\t\t\tif (checkOpen EQ 1) {\n\t\t\t\t\tdoorList = ListSetAt(doorList,loopDoorListCount,\"0\");\n\t\t\t\t} else {\n\t\t\t\t\tdoorList = ListSetAt(doorList,loopDoorListCount,\"1\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tloopDoorListCount = loopDoorListCount + 1;\n\t\t}\n\t\tloopCount = loopCount + 1;\n\t}\n<\/lang>\n\n'''Squares of Integers Solution: Returns List of 100 values: 1=open 0=closed'''\n<lang coldfusion>\n\tdoorCount = 1;\n\tdoorList = \"\";\n\tloopCount = 1;\n\twhile (loopCount LTE 100) {\n\t\tif (Sqr(loopCount) NEQ Int(Sqr(loopCount))) {\n\t\t\tdoorList = ListAppend(doorList,0);\n\t\t} else {\n\t\t\tdoorList = ListAppend(doorList,1);\n\t\t}\n\t\tloopCount = loopCount + 1;\n\t}\n<\/lang>\n\n'''Display only'''\n<lang coldfusion>\n    \/\/ Display all doors\n    <cfloop from=\"1\" to=\"100\" index=\"x\">\n    \tDoor #x# Open: #YesNoFormat(ListGetAt(doorList,x))#<br \/>\n    <\/cfloop>\n\n    \/\/ Output only open doors\n    <cfloop from=\"1\" to=\"100\" index=\"x\">\n    \t<cfif ListGetAt(doorList,x) EQ 1>\n        \t#x#<br \/>\n        <\/cfif>\n    <\/cfloop>\n<\/lang>\n\n==[[:Category:Common Lisp|Common Lisp]][[Category:Common Lisp]]==\n\n'''Unoptimized \/ functional '''\nThis is a very unoptimized version of the problem, using recursion and quite considerable list-copying. It emphasizes the functional way of solving this problem\n\n<lang lisp>(defun visit-door (doors doornum value1 value2)\n    \"visits a door, swapping the value1 to value2 or vice-versa\"\n    (let ((d (copy-list doors))\n          (n (- doornum 1)))\n             (if (eq   (nth n d) value1)\n                 (setf (nth n d) value2)\n                 (setf (nth n d) value1))\n             d))\n\n(defun visit-every (doors num iter value1 value2)\n    \"visits every 'num' door in the list\"\n    (if (> (* iter num) (length doors))\n        doors\n        (visit-every (visit-door doors (* num iter) value1 value2)\n                     num\n                     (+ 1 iter)\n                     value1\n                     value2)))\n\n(defun do-all-visits (doors cnt value1 value2)\n    \"Visits all doors changing the values accordingly\"\n    (if (< cnt 1)\n        doors\n        (do-all-visits (visit-every doors cnt 1 value1 value2)\n                       (- cnt 1)\n                       value1\n                       value2)))\n\n(defun print-doors (doors)\n    \"Pretty prints the doors list\"\n    (format T \"~{~A ~A ~A ~A ~A ~A ~A ~A ~A ~A~%~}~%\" doors))\n\n(defun start (&optional (size 100))\n    \"Start the program\"\n    (let* ((open \"_\")\n           (shut \"#\")\n           (doors (make-list size :initial-element shut)))\n               (print-doors (do-all-visits doors size open shut))))<\/lang>\n\n'''Unoptimized \/ imperative '''\nThis is a version that closely follows the problem description and is still quite short.\n\n<lang lisp>(define-modify-macro toggle () not)\n\n(defun 100-doors ()\n  (let ((doors (make-array 100 :initial-element nil)))\n    (dotimes (i 100)\n      (loop for j from i below 100 by (1+ i)\n\t do (toggle (svref doors j))))\n    (dotimes (i 100)\n      (format t \"door ~a: ~:[closed~;open~]~%\" (1+ i) (svref doors i)))))<\/lang>\n\n'''Optimized '''\nThis is an optimized version of the above, using the perfect square algorithm (Note: This is non-functional as the state of the doors variable gets modified by a function call)\n\n<lang lisp>(defun perfect-square-list (n)                       \n    \"Generates a list of perfect squares from 0 up to n\"\n    (loop for i from 1 to (sqrt n) collect (expt i 2))) \n                 \n(defun open-door (doors num open)\n    \"Sets door at num to open\"\n    (setf (nth (- num 1) doors) open)\n    doors) \n                                  \n(defun visit-all (doors vlist open)\n    \"Visits and opens all the doors indicated in vlist\"\n    (if (null vlist) \n        doors                     \n        (visit-all (open-door doors (car vlist) open) \n                   (cdr vlist) \n                   open))) \n                   \n(defun start2 (&optional (size 100))                        \n    \"Start the program\"\n    (print-doors (visit-all (make-list size :initial-element \"#\")\n                            (perfect-square-list size) \"_\")))<\/lang>\n\n'''Optimized (2) '''\nThis version displays a much more functional solution through the use of MAPCAR (note however that this is imperative as it does variable mutation)\n\n<lang lisp>(let  ((i 0))\n    (mapcar (lambda (x)\n                (if (zerop (mod (sqrt (incf i)) 1))\n                    \"_\" \"#\"))\n            (make-list 100)))<\/lang>\n\n==[[:Category:D|D]][[Category:D]]==\n<lang d>import std.stdio;\n\nenum DoorState { Closed, Open }\nalias DoorState[] Doors;\n\nDoors flipUnoptimized(Doors doors) {\n    doors[] = DoorState.Closed;\n    foreach (i; 0 .. doors.length)\n        for (int j = i; j < doors.length; j += i+1)\n            if (doors[j] == DoorState.Open)\n                doors[j] = DoorState.Closed;\n            else\n                doors[j] = DoorState.Open;\n    return doors;\n}\n\nDoors flipOptimized(Doors doors) {\n    doors[] = DoorState.Closed;\n    for (int i = 1; i*i <= doors.length; i++)\n        doors[i*i - 1] = DoorState.Open;\n    return doors;\n}\n\n\/\/ test program\nvoid main() {\n    auto doors = new Doors(100);\n    foreach (i, door; flipUnoptimized(doors))\n        if (door == DoorState.Open)\n            write(i+1, \" \");\n    writeln();\n\n    foreach (i, door; flipOptimized(doors))\n        if (door == DoorState.Open)\n            write(i+1, \" \");\n    writeln();\n}<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>1 4 9 16 25 36 49 64 81 100 \n1 4 9 16 25 36 49 64 81 100 <\/pre>\n\n==[[:Category:Dart|Dart]][[Category:Dart]]==\n'''unoptimized'''\n<lang dart>main() {\n    for (var k = 1, x = new List(101); k <= 100; k++) {\n        for (int i = k; i <= 100; i += k)\n            x[i] = !x[i];\n        if (x[k]) print(\"$k open\");\n    }\n}<\/lang>\n\n'''optimized version''' (including generating squares without multiplication)\n<lang dart>main() {\n  for(int i=1,s=3;i<=100;i+=s,s+=2)\n    print(\"door $i is open\");\n}<\/lang>\n\n==[[:Category:Delphi|Delphi]][[Category:Delphi]]==\n:''See [[#Pascal|Pascal]]''\n\n==[[:Category:DWScript|DWScript]][[Category:DWScript]]==\n'''Unoptimized'''\n<lang delphi>var doors : array [1..100] of Boolean;\nvar i, j : Integer;\n\nfor i := 1 to 100 do\n   for j := i to 100 do\n      if (j mod i) = 0 then\n         doors[j] := not doors[j];\n\nfor i := 1 to 100 do\n   if doors[i] then\n      PrintLn('Door '+IntToStr(i)+' is open');<\/lang>\n\n==[[:Category:Dylan|Dylan]][[Category:Dylan]]==\n'''Unoptimized'''\n<lang dylan>define method doors()\n  let doors = make(<array>, fill: #f, size: 100);\n  for (x from 0 below 100)\n    for (y from x below 100 by x + 1)\n      doors[y] := ~doors[y]\n    end\n  end;\n  for (x from 1 to 100) \n    if (doors[x - 1]) \n      format-out(\"door %d open\\n\", x)\n    end\n  end\nend<\/lang>\n\n==[[:Category:E|E]][[Category:E]]==\n'''Graphical'''\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[E-on-Java]][[SMW::on]]<\/div>\n\nThis version animates the changes of the doors (as checkboxes).\n\n<lang e>#!\/usr\/bin\/env rune\n\nvar toggles := []\nvar gets := []\n\n# Set up GUI (and data model)\ndef frame := <swing:makeJFrame>(\"100 doors\")\nframe.getContentPane().setLayout(<awt:makeGridLayout>(10, 10))\nfor i in 1..100 {\n  def component := <import:javax.swing.makeJCheckBox>(E.toString(i))\n  toggles with= fn { component.setSelected(!component.isSelected()) }\n  gets with= fn { component.isSelected() }\n  frame.getContentPane().add(component)\n}\n\n# Set up termination condition\ndef done\nframe.addWindowListener(def _ {\n  to windowClosing(event) {\n    bind done := true\n  }\n  match _ {}\n})\n\n# Open and close doors\ndef loop(step, i) {\n  toggles[i] <- ()\n  def next := i + step\n  timer.whenPast(timer.now() + 10, fn {\n    if (next >= 100) {\n      if (step >= 100) {\n        # Done.\n      } else {\n        loop <- (step + 1, step)\n      }\n    } else {\n      loop <- (step, i + step)\n    }    \n  })\n}\nloop(1, 0)\n\nframe.pack()\nframe.show()\ninterp.waitAtTop(done)<\/lang>\n\n\n==[[:Category:Eiffel|Eiffel]][[Category:Eiffel]]==\nThis is my first RosettaCode submission, as well as a foray into Eiffel for myself. I've tried to adhere to the description of the problem statement, as well as showcase a few Eiffelisms shown in the documentation.\n\n'''file: application.e'''\n<lang eiffel>note\n\tdescription: \"100 Doors problem\"\n\tdate: \"07-AUG-2011\"\n\trevision: \"1.0\"\n\nclass\n\tAPPLICATION\n\ncreate\n\tmake\n\nfeature {NONE} -- Initialization\n\n\tdoors: LINKED_LIST [DOOR]\n\t\t\t-- A set of doors\n\t\tonce\n\t\t\tResult := create {LINKED_LIST [DOOR]}.make\n\t\tend\n\n\tmake\n\t\t\t-- Run application.\n\t\tlocal\n\t\t\tcount, i: INTEGER\n\t\tdo\n\t\t\t\t--initialize doors\n\t\t\tcount := 100\n\t\t\tfrom\n\t\t\t\ti := 1\n\t\t\tuntil\n\t\t\t\ti > count\n\t\t\tloop\n\t\t\t\tdoors.extend (create {DOOR}.make (i, false))\n\t\t\t\ti := i + 1\n\t\t\tend\n\n\t\t\t\t-- toggle doors\n\t\t\tfrom\n\t\t\t\ti := 1\n\t\t\tuntil\n\t\t\t\ti > count\n\t\t\tloop\n\t\t\t\tacross\n\t\t\t\t\tdoors as this\n\t\t\t\tloop\n\t\t\t\t\tif this.item.address \\\\ i = 0 then\n\t\t\t\t\t\tthis.item.open := not this.item.open\n\t\t\t\t\tend\n\t\t\t\tend -- across doors\n\t\t\t\ti := i + 1\n\t\t\tend -- for i\n\n\t\t\t\t-- print results\n\t\t\tdoors.do_all (agent  (door: DOOR)\n\t\t\t\tdo\n\t\t\t\t\tif door.open then\n\t\t\t\t\t\tio.put_string (\"Door \" + door.address.out + \" is open.\")\n\t\t\t\t\telseif not door.open then\n\t\t\t\t\t\tio.put_string (\"Door \" + door.address.out + \" is closed.\")\n\t\t\t\t\tend\n\t\t\t\t\tio.put_new_line\n\t\t\t\tend)\n\t\tend -- make\n\nend -- APPLICATION<\/lang>\n\n'''file: door.e'''\n<lang eiffel>note\n\tdescription: \"A door with an address and an open or closed state.\"\n\tdate: \"07-AUG-2011\"\n\trevision: \"1.0\"\n\nclass\n\tDOOR\n\t-- Represents a door\n\ncreate\n\tmake\n\nfeature -- initialization\n\n\tmake (addr: INTEGER; status: BOOLEAN)\n\t\t-- create door with address and status\n\t\trequire\n\t\t\tvalid_address: addr \/= '%U'\n\t\t\tvalid_status: status \/= '%U'\n\t\tdo\n\t\t\taddress := addr\n\t\t\topen := status\n\t\tensure\n\t\t\taddress_set: address = addr\n\t\t\tstatus_set: open = status\n\t\tend\n\nfeature -- access\n\n\taddress: INTEGER\n\n\topen: BOOLEAN assign set_open\n\nfeature -- mutators\n\n\tset_open (status: BOOLEAN)\n\t\trequire\n\t\t\tvalid_status: status \/= '%U'\n\t\tdo\n\t\t\topen := status\n\t\tensure\n\t\t\topen_updated: open = status\n\t\tend\n\nend<\/lang>\n\n\n==[[:Category:Ela|Ela]][[Category:Ela]]==\n'''Standard Approach'''\n\n<lang ela>let gate (x::xs) (y::ys) | x == y = Open :: gate xs ys\n    gate (x::xs) ys               = Closed :: gate xs ys\n    gate []      _                = []\n\nlet run n = gate [1..n] [& k*k \\\\ k <- [1..]]<\/lang>\n\n'''Alternate Approach'''\n<lang ela>open Core\nlet run n = takeWhile (<n) [& k*k \\\\ k <- [1..]]<\/lang>\n\n\n==[[:Category:Emacs Lisp|Emacs Lisp]][[Category:Emacs Lisp]]==\n'''Unoptimized'''\n\n<lang lisp>(defun create-doors ()\n  \"Returns a list of closed doors\n\nEach door only has two status: open or closed.\nIf a door is closed it has the value 0, if it's open it has the value 1.\"\n  (let ((return_value '(0))\n         ;; There is already a door in the return_value, so k starts at 1\n         ;; otherwise we would need to compare k against 99 and not 100 in\n         ;; the while loop\n         (k 1))\n    (while (< k 100)\n      (setq return_value (cons 0 return_value))\n      (setq k (+ 1 k)))\n    return_value))\n\n(defun toggle-single-door (doors)\n  \"Toggle the stat of the door at the `car' position of the DOORS list\n\nDOORS is a list of integers with either the value 0 or 1 and it represents\na row of doors.\n\nReturns a list where the `car' of the list has it's value toggled (if open\nit becomes closed, if closed it becomes open).\"\n  (if (= (car doors) 1)\n    (cons 0 (cdr doors))\n    (cons 1 (cdr doors))))\n\n(defun toggle-doors (doors step original-step)\n  \"Step through all elements of the doors' list and toggle a door when step is 1\n\nDOORS is a list of integers with either the value 0 or 1 and it represents\na row of doors.\nSTEP is the number of doors we still need to transverse before we arrive\nat a door that has to be toggled.\nORIGINAL-STEP is the value of the argument step when this function is\ncalled for the first time.\n\nReturns a list of doors\"\n  (cond ((null doors)\n          '())\n    ((= step 1)\n      (cons (car (toggle-single-door doors))\n        (toggle-doors (cdr doors) original-step original-step)))\n    (t\n      (cons (car doors)\n        (toggle-doors (cdr doors) (- step 1) original-step)))))\n\n(defun main-program ()\n  \"The main loop for the program\"\n  (let ((doors_list (create-doors))\n         (k 1)\n         ;; We need to define max-specpdl-size and max-specpdl-size to big\n         ;; numbers otherwise the loop reaches the max recursion depth and\n         ;; throws an error.\n         ;; If you want more information about these variables, press Ctrl\n         ;; and h at the same time and then press v and then type the name\n         ;; of the variable that you want to read the documentation.\n         (max-specpdl-size 5000)\n         (max-lisp-eval-depth 2000))\n    (while (< k 101)\n      (setq doors_list (toggle-doors doors_list k k))\n      (setq k (+ 1 k)))\n    doors_list))\n\n(defun print-doors (doors)\n  \"This function prints the values of the doors into the current buffer.\n\nDOORS is a list of integers with either the value 0 or 1 and it represents\na row of doors.\n\"\n  ;; As in the main-program function, we need to set the variable\n  ;; max-lisp-eval-depth to a big number so it doesn't reach max recursion\n  ;; depth.\n  (let ((max-lisp-eval-depth 5000))\n    (unless (null doors)\n      (insert (int-to-string (car doors)))\n      (print-doors (cdr doors)))))\n\n;; Returns a list with the final solution\n(main-program)\n\n;; Print the final solution on the buffer\n(print-doors (main-program))<\/lang>\n\n==[[:Category:Erlang|Erlang]][[Category:Erlang]]==\n'''optimized'''\n<lang erlang>doors() ->\n     F = fun(X) -> Root = math:pow(X,0.5), Root == trunc(Root) end,\n     Out = fun(X, true) -> io:format(\"Door ~p: open~n\",[X]);\n              (X, false)-> io:format(\"Door ~p: close~n\",[X]) end,\n     [Out(X,F(X)) || X <- lists:seq(1,100)].<\/lang>\n\n==[[:Category:Euler Math Toolbox|Euler Math Toolbox]][[Category:Euler Math Toolbox]]==\n<lang Euler Math Toolbox>\nfunction Doors\n$  doors:=zeros(1,100);\n$  for i=1 to 100 step 1\n$    for j=i to 100 step i\n$      if doors[j]==0 then doors[j]:=1;\n$      else doors[j]:=0;\n$      endif;\n$    end;\n$  end;\n$  return doors\n$endfunction\n\nA:=Doors;\nfor i=1 to 100 step 1; if A[i]==1 then \"door \"|i|\" is open\" endif; end;\n<\/lang>\nOutput\n<lang>\n door 1 is open\n door 4 is open\n door 9 is open\n door 16 is open\n door 25 is open\n door 36 is open\n door 49 is open\n door 64 is open\n door 81 is open\n door 100 is open\n<\/lang>\n\n==[[:Category:Euphoria|Euphoria]][[Category:Euphoria]]==\nunoptimised\n<lang Euphoria>-- doors.ex\ninclude std\/console.e\nsequence doors\ndoors = repeat( 0, 100 ) -- 1 to 100, initialised to false \n\nfor pass = 1 to 100 do\n\tfor door = pass to 100 by pass do\n\t\t--printf( 1, \"%d\", doors[door] )\n\t\t--printf( 1, \"%d\", not doors[door] )\n\t\tdoors[door] = not doors[door]\n\tend for\nend for\n\nsequence oc\n\nfor i = 1 to 100 do\n\tif doors[i] then\n\t\toc = \"open\"\n\telse\n\t\toc = \"closed\"\n\tend if\n \tprintf( 1, \"door %d is %s\\n\", { i, oc } )\nend for\n<\/lang>\n\n==<span id=\"F_Sharp\">[[:Category:F_Sharp|F#]]<\/span>[[Category:F_Sharp]]==\nRequires #light in versions of F# prior to 2010 beta.\n<lang fsharp>let answerDoors =\n    let ToggleNth n (lst:bool array) =                  \/\/ Toggle every n'th door\n        [(n-1) .. n .. 99]                              \/\/ For each appropriate door\n        |> Seq.iter (fun i -> lst.[i] <- not lst.[i])   \/\/ toggle it\n    let doors = Array.create 100 false                  \/\/ Initialize all doors to closed\n    Seq.iter (fun n -> ToggleNth n doors) [1..100]      \/\/ toggle the appropriate doors for each pass\n    doors                                               \/\/ Initialize all doors to closed\n<\/lang>\nFollowing is the solution using perfect squares.  The coercions in PerfectSquare are, I believe, slightly different in versions prior to 2010 beta and, again, #light is required in those versions.\n<lang fsharp>open System\nlet answer2 =\n    let PerfectSquare n =\n        let sqrt = int(Math.Sqrt(float n))\n        n = sqrt * sqrt\n    [| for i in 1..100 do yield PerfectSquare i |]<\/lang>\n\n==[[:Category:Factor|Factor]][[Category:Factor]]==\n<lang Factor>USING: bit-arrays formatting fry kernel math math.ranges\nsequences ;\nIN: rosetta.doors\n\nCONSTANT: number-of-doors 100\n\n: multiples ( n -- range )\n    0 number-of-doors rot <range> ;\n\n: toggle-multiples ( n doors -- )\n    [ multiples ] dip '[ _ [ not ] change-nth ] each ;\n\n: toggle-all-multiples ( doors -- )\n    [ number-of-doors [1,b] ] dip '[ _ toggle-multiples ] each ;\n\n: print-doors ( doors -- )\n    [\n        swap \"open\" \"closed\" ? \"Door %d is %s\\n\" printf\n    ] each-index ;\n\n: main ( -- )\n    number-of-doors 1 + <bit-array>\n    [ toggle-all-multiples ] [ print-doors ] bi ;<\/lang>\n\n==[[:Category:Falcon|Falcon]][[Category:Falcon]]==\n'''Unoptimized code'''\n<lang falcon>doors = arrayBuffer( 101, false )\n\nfor pass in [ 0 : doors.len() ]\n  for door in [ 0 : doors.len() : pass+1 ]\n    doors[ door ] = not doors[ door ]\n  end\nend\n\nfor door in [ 1 : doors.len() ]  \/\/ Show Output\n  >  \"Door \", $door, \" is: \", ( doors[ door ] ) ? \"open\" : \"closed\"\nend\n<\/lang>\n'''Optimized code'''\n<lang falcon>\nfor door in [ 1 : 101 ]: > \"Door \", $door, \" is: \", fract( door ** 0.5 ) ? \"closed\" : \"open\"<\/lang>\n\n==[[:Category:Fantom|Fantom]][[Category:Fantom]]==\n'''Unoptimized'''\n<lang fantom>\n    states := (1..100).toList\n    100.times |i| {\n      states = states.map |state| { state % (i+1) == 0 ? -state : +state }\n    }\n    echo(\"Open doors are \" + states.findAll { it < 0 }.map { -it })\n<\/lang>\n'''Optimized'''\n<lang fantom>\n    echo(\"Open doors are \" + (1..100).toList.findAll { it.toFloat.pow(0.5f).toInt.pow(2) == it})\n<\/lang>\n\n==[[:Category:Forth|Forth]][[Category:Forth]]==\n\n'''Unoptimized'''\n<lang forth>: toggle ( c-addr -- )  \\ toggle the byte at c-addr\n    dup c@ 1 xor swap c! ;\n\n100  1+ ( 1-based indexing ) constant ndoors\ncreate doors  ndoors allot\n\n: init ( -- )  doors ndoors erase ;  \\ close all doors\n\n: pass ( n -- )  \\ toggle every nth door\n    ndoors over do\n        doors i + toggle\n    dup ( n ) +loop drop ;\n\n: run ( -- )  ndoors 1 do  i pass  loop ;\n: display ( -- )  \\ display open doors\n    ndoors 1 do  doors i + c@ if  i .  then loop cr ;\n\ninit run display<\/lang>\n\n'''Optimized'''\n<lang forth>: squared ( n -- n' )  dup * ;\n: doors ( n -- )\n    1 begin 2dup squared >= while\n        dup squared .\n    1+ repeat 2drop ;\n100 doors<\/lang>\n\n==[[:Category:Fortran|Fortran]][[Category:Fortran]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Fortran]] version  ISO 90 and later[[SMW::on]]<\/div>\n'''unoptimized'''\n<lang fortran>PROGRAM DOORS\n\n  INTEGER, PARAMETER :: n = 100    ! Number of doors\n  INTEGER :: i, j\n  LOGICAL :: door(n) = .TRUE.      ! Initially closed\n \n  DO i = 1, n\n    DO j = i, n, i\n      door(j) = .NOT. door(j)\n    END DO\n  END DO \n\n  DO i = 1, n\n    WRITE(*,\"(A,I3,A)\", ADVANCE=\"NO\") \"Door \", i, \" is \"\n    IF (door(i)) THEN\n      WRITE(*,\"(A)\") \"closed\"\n    ELSE\n      WRITE(*,\"(A)\") \"open\"\n    END IF\n  END DO\n\nEND PROGRAM DOORS<\/lang>\n\n'''optimized'''\n<lang fortran>PROGRAM DOORS\n\n  INTEGER, PARAMETER :: n = 100    ! Number of doors\n  INTEGER :: i\n  LOGICAL :: door(n) = .TRUE.      ! Initially closed\n \n  DO i = 1, SQRT(REAL(n))\n    door(i*i) = .FALSE.\n  END DO  \n \n  DO i = 1, n\n    WRITE(*,\"(A,I3,A)\", ADVANCE=\"NO\") \"Door \", i, \" is \"\n    IF (door(i)) THEN\n      WRITE(*,\"(A)\") \"closed\"\n    ELSE\n      WRITE(*,\"(A)\") \"open\"\n    END IF\n  END DO\n \nEND PROGRAM DOORS<\/lang>\n\n==[[:Category:GAP|GAP]][[Category:GAP]]==\n<lang gap>doors := function(n)\n  local a,j,s;\n  a := [ ];\n  for j in [1 .. n] do\n    a[j] := 0;\n  od;\n  for s in [1 .. n] do\n    j := s;\n    while j <= n do\n      a[j] := 1 - a[j];\n      j := j + s;\n    od;\n  od;\n  return Filtered([1 .. n], j -> a[j] = 1);\nend;\n\ndoors(100);\n# [ 1, 4, 9, 16, 25, 36, 49, 64, 81, 100 ]<\/lang>\n\n==[[:Category:GML|GML]][[Category:GML]]==\n<lang gml>var doors,a,i;\n\/\/Sets up the array for all of the doors.\nfor (i=1;i<=100;i+=1)\n    {\n        doors[i]=0;\n    }\n\/\/This first for loop goes through and passes the interval down to the next for loop.\nfor (i=1;i<=100;i+=1)\n    {\n        \/\/This for loop opens or closes the doors and uses the interval(if interval is 2 it only uses every other etc..)\n        for (a=0;a<=100;a+=i;)\n            {\n                \/\/Opens or closes a door.\n                doors[a]=!doors[a];\n            }\n    }\nopen_doors='';\n\/\/This for loop goes through the array and checks for open doors.\n\/\/If the door is open it adds it to the string then displays the string.\nfor (i=1;i<=100;i+=1)\n    {\n        if doors[i]=1\n            {\n                open_doors+=\"Door Number \"+string(i)+\" is open#\";\n            }\n    }\nshow_message(open_doors);\ngame_end();<\/lang>\n\n==[[:Category:Go|Go]][[Category:Go]]==\n'''unoptimized'''\n<lang go>package main\n\nimport \"fmt\"\n\nfunc main() {\n    doors := make([]bool, 100)\n\n    \/\/ the 100 passes called for in the task description\n    for pass := 1; pass <= 100; pass++ {\n        for door := pass-1; door < 100; door += pass {\n            doors[door] = !doors[door]\n        }\n    }\n\n    \/\/ one more pass to answer the question\n    for i, v := range doors {\n        if v {\n            fmt.Print(\"1\")\n        } else {\n            fmt.Print(\"0\")\n        }\n\n        if i%10 == 9 {\n            fmt.Print(\"\\n\")\n        } else {\n            fmt.Print(\" \")\n        }\n\n    }\n}<\/lang>\nOutput:\n<pre>\n1 0 0 1 0 0 0 0 1 0\n0 0 0 0 0 1 0 0 0 0\n0 0 0 0 1 0 0 0 0 0\n0 0 0 0 0 1 0 0 0 0\n0 0 0 0 0 0 0 0 1 0\n0 0 0 0 0 0 0 0 0 0\n0 0 0 1 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n1 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 1\n<\/pre>\n'''optimized'''\n<lang go>package main\n\nimport \"fmt\"\n\nfunc main() {\n    var door int = 1\n    var incrementer = 0\n\n    for current := 1; current <= 100; current++ {\n        fmt.Printf(\"Door %d \", current)\n\n        if current == door {\n            fmt.Printf(\"Open\\n\")\n            incrementer++\n            door += 2*incrementer + 1\n        } else {\n            fmt.Printf(\"Closed\\n\")\n        }\n    }\n}<\/lang>\n\n==[[:Category:Golfscript|Golfscript]][[Category:Golfscript]]==\n<lang golfscript>100:c;[{0}c*]:d;\nc,{.c,>\\)%{.d<\\.d=1^\\)d>++:d;}\/}\/\n[c,{)\"door \"\\+\" is\"+}%d{{\"open\"}{\"closed\"}if}%]zip\n{\" \"*puts}\/<\/lang>\n\n'''optimized with sqrt'''\n(Original version of GolfScript has no sqrt operator, but it can be\nadded easily; the code was tested using a work-in-progress C interpreter\nfor a language compatible enough with Golfscript)\n<lang golfscript>100,{)}%\n{:d.sqrt 2?=\n{\"open\"}{\"close\"}if\"door \"d+\" is \"+\\+puts}\/<\/lang>\n\n'''optimized without sqrt'''\n<lang golfscript>[{\"close\"}100*]:d;\n10,{)2?(.d<\\[\"open\"]\\)d>++:d;}\/\n[100,{)\"door \"\\+\" is\"+}%d]zip\n{\" \"*puts}\/<\/lang>\n\n==[[:Category:Groovy|Groovy]][[Category:Groovy]]==\n'''unoptimized'''\n<lang groovy>doors = [false] * 100\n(0..99).each {\n   it.step(100, it + 1) {\n      doors[it] ^= true\n   }\n}\n(0..99).each {\n   println(\"Door #${it + 1} is ${doors[it] ? 'open' : 'closed'}.\")\n}<\/lang>\n\n'''optimized a'''\nUsing square roots\n\n<lang groovy>(1..100).each {\n   println(\"Door #${it} is ${Math.sqrt(it).with{it==(int)it} ? 'open' : 'closed'}.\")\n}<\/lang>\n\n'''optimized b'''\nWithout using square roots\n<lang groovy>doors = ['closed'] * 100\n(1..10).each { doors[it**2 - 1] = 'open' }\n(0..99).each {\n   println(\"Door #${it + 1} is ${doors[it]}.\")\n}<\/lang>\n\n==[[:Category:Haskell|Haskell]][[Category:Haskell]]==\n'''unoptimized'''\n<lang haskell>data Door = Open | Closed deriving Show\n \ntoggle Open   = Closed\ntoggle Closed = Open\n\ntoggleEvery :: [Door] -> Int -> [Door] \ntoggleEvery xs k = zipWith ($) fs xs\n    where fs = cycle $ (replicate (k-1) id) ++ [toggle]\n\nrun n = foldl toggleEvery (replicate n Closed) [0..n]<\/lang>\n\n'''optimized'''\n(without using square roots)\n<lang haskell>gate :: Eq a => [a] -> [a] -> [Door]\ngate (x:xs) (y:ys) | x == y  =  Open   : gate xs ys\ngate (x:xs) ys               =  Closed : gate xs ys\ngate []     _                =  []\n\nrun n = gate [1..n] [k*k | k <- [1..]]<\/lang>\n\nalternatively, returning a list of all open gates, it's a one-liner:\n\n<lang haskell>run n = takeWhile (< n) [k*k | k <- [1..]]<\/lang>\n\n==[[:Category:haXe|haXe]][[Category:haXe]]==\n<lang haxe>class RosettaDemo\n{\n    static public function main()\n    {\n        findOpenLockers(100);\n    }\n\n    static function findOpenLockers(n : Int)\n    {\n        var i = 1;\n\n        while((i*i) <= n)\n        {\n            neko.Lib.print(i*i + \"\\n\");\n            i++;\n        }\n    }\n}<\/lang>\n\n==[[:Category:HicEst|HicEst]][[Category:HicEst]]==\nUnoptimized\n<lang hicest>REAL :: n=100, open=1, door(n)\n\ndoor = 1 - open ! = closed\nDO i = 1, n\n  DO j = i, n, i\n    door(j) = open - door(j)\n  ENDDO\nENDDO\nDLG(Text=door, TItle=SUM(door)\/\/\" doors open\") <\/lang>\nOptimized\n<lang hicest>door = 1 - open ! = closed\nDO i = 1, n^0.5\n  door(i*i) = open\nENDDO\nDLG(Text=door, TItle=SUM(door)\/\/\" doors open\") <\/lang>\n\n==[[:Category:Icon|Icon]][[Category:Icon]] and [[:Category:Unicon|Unicon]][[Category:Unicon]]==\nIcon and Unicon don't have a boolean type because most often, logic is expressed in terms of success or failure, which affects flow at run time.\n\n'''Unoptimized solution.'''\n<lang icon>\nprocedure main()\n    door := table(0)    # default value of entries is 0\n    every pass := 1 to 100 do\n        every door[i := pass to 100 by pass] := 1 - door[i]\n\n    every write(\"Door \", i := 1 to 100, \" is \", if door[i] = 1 then \"open\" else \"closed\")\nend\n<\/lang>\n\n'''Optimized solution.'''\n<lang icon>\nprocedure main()\n    every write(\"Door \", i := 1 to 100, \" is \", if integer(sqrt(i)) = sqrt(i) then \"open\" else \"closed\")\nend\n<\/lang>\n\nor\n\n<lang icon>procedure main(args)\n    dMap := table(\"closed\")\n    every dMap[(1 to sqrt(100))^2] := \"open\"\n    every write(\"Door \",i := 1 to 100,\" is \",dMap[i])\nend<\/lang>\n\n==[[:Category:Inform 7|Inform 7]][[Category:Inform 7]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Z-machine]] version 8[[SMW::on]]<\/div>\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Glulx virtual machine]][[SMW::on]]<\/div>\n<lang inform7>Hallway is a room.\n\nA toggle door is a kind of thing.\nA toggle door can be open or closed. It is usually closed.\nA toggle door has a number called the door number.\nUnderstand the door number property as referring to a toggle door.\nRule for printing the name of a toggle door: say \"door #[door number]\".\n\nThere are 100 toggle doors.\n\nWhen play begins (this is the initialize doors rule):\n\tlet the next door number be 1;\n\trepeat with D running through toggle doors:\n\t\tnow the door number of D is the next door number;\n\t\tincrement the next door number.\n\nTo toggle (D - open toggle door): now D is closed.\nTo toggle (D - closed toggle door): now D is open.\n\nWhen play begins (this is the solve puzzle rule):\n\tlet the door list be the list of toggle doors;\n\tlet the door count be the number of entries in the door list;\n\trepeat with iteration running from 1 to 100:\n\t\tlet N be the iteration;\n\t\twhile N is less than the door count:\n\t\t\ttoggle entry N in the door list;\n\t\t\tincrease N by the iteration;\n\tsay \"Doors left open: [list of open toggle doors].\";\n\tend the story.<\/lang>\n\n==[[:Category:Informix 4GL|Informix 4GL]][[Category:Informix 4GL]]==\n<lang Informix 4GL>\nMAIN\n    DEFINE\n        i, pass SMALLINT,\n        doors ARRAY[100] OF SMALLINT\n \n    FOR i = 1 TO 100\n        LET doors[i] = FALSE\n    END FOR\n \n    FOR pass = 1 TO 100\n        FOR i = pass TO 100 STEP pass\n            LET doors[i] = NOT doors[i]\n        END FOR\n    END FOR\n \n    FOR i = 1 TO 100\n        IF doors[i]\n          THEN DISPLAY i USING \"Door <<& is open\"\n          ELSE DISPLAY i USING \"Door <<& is closed\"\n        END IF\n    END FOR\nEND MAIN\n<\/lang>\n\n==[[:Category:Io|Io]][[Category:Io]]==\nsimple boolean list solution:\n<lang io>\ndoors := List clone\nfor(i,1,100, doors append(false))\nfor(i,1,100,\n    for(x,i,100, i, doors atPut(x - 1, doors at(x - 1) not))\n)\ndoors foreach(i, x, if(x, \"Door #{i + 1} is open\" interpolate println))\n<\/lang>\n\n==[[:Category:Ioke|Ioke]][[Category:Ioke]]==\n'''Unoptimized Object Oriented solution.'''\n<lang ioke>NDoors = Origin mimic\n\nNDoors Toggle = Origin mimic do(\n  initialize = method(toggled?, @toggled? = toggled?)\n  toggle! = method(@toggled? = !toggled?. self)\n)\n\nNDoors Doors = Origin mimic do(\n  initialize = method(n,\n    @n = n\n    @doors = {} addKeysAndValues(1..n, (1..n) map(_, NDoors Toggle mimic(false)))\n  )\n  numsToToggle = method(n, for(x <- (1..@n), (x % n) zero?, x))\n  toggleThese = method(nums, nums each(x, @doors[x] = @doors at(x) toggle))\n  show = method(@doors filter:dict(value toggled?) keys sort println)\n)\n\n; Test code\nx = NDoors Doors mimic(100)\n(1..100) each(n, x toggleThese(x numsToToggle(n)))\nx show<\/lang>\n\n==[[:Category:J|J]][[Category:J]]==\n'''unoptimized'''\n<lang j>   ~:\/ (100 $ - {. 1:)\"0 >:i.100\n1 0 0 1 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 ...\n   ~:\/ 0=|\/~ >:i.100  NB. alternative\n1 0 0 1 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 ...<\/lang>\n'''optimized'''\n<lang j>   (e. *:) 1+i.100\n1 0 0 1 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 ...\n   1 (<:*:i.10)} 100$0  NB. alternative\n1 0 0 1 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 ...<\/lang>\n\n'''with formatting'''\n<lang j>   'these doors are open' ; >: I. (>:i.100) e. *: i.11\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502these doors are open\u25021 4 9 16 25 36 49 64 81 100\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n<\/lang>\n\n==[[:Category:Java|Java]][[Category:Java]]==\n'''unoptimized'''\n<lang java>\npublic class HundredDoors {\n    public static void main(String[] args) {\n        boolean[] doors = new boolean[101];\n        for (int i = 1; i <= 100; i++) {\n            for (int j = i; j <= 100; j++) {\n                if(j % i == 0) doors[j] = !doors[j];\n            }\n        }\n        for (int i = 1; i <= 100; i++) {\n            System.out.printf(\"Door %d: %s%n\", i, doors[i] ? \"open\" : \"closed\");\n        }\n    }\n}<\/lang>\n\n'''optimized'''\n<lang java>public class Doors\n{\n public static void main(final String[] args)\n {\n  boolean[] doors = new boolean[100];\n\n  for (int pass = 0; pass < 10; pass++)\n   doors[(pass + 1) * (pass + 1) - 1] = true;\n\n  for(int i = 0; i < 100; i++)\n   System.out.println(\"Door #\" + (i + 1) + \" is \" + (doors[i] ? \"open.\" : \"closed.\"));\n }\n}<\/lang>\n'''optimized 2'''\n<lang java>public class Doors\n{\n public static void main(final String[] args)\n {\n  StringBuilder sb = new StringBuilder();\n\n  for (int i = 1; i <= 10; i++)\n   sb.append(\"Door #\").append(i*i).append(\" is open\\n\");\n\n  System.out.println(sb.toString());\n }\n}<\/lang>\n\n'''optimized 3'''\n<lang java>public class Doors{\n   public static void main(String[] args){\n      int i;\t\t\n      for(i = 1; i < 101; i++){\n         double sqrt = Math.sqrt(i);\n         if(sqrt != (int)sqrt){\n            System.out.println(\"Door \" + i + \" is closed\");\n         }else{\n            System.out.println(\"Door \" + i + \" is open\");\n         }\n      }\n   } \t\n}<\/lang>\n\n==[[:Category:JavaScript|JavaScript]][[Category:JavaScript]]==\n<lang javascript>var doors = [], n = 100, i, j;\n\nfor (i = 1; i <= n; i++) {\n\tfor (j = i; j <= n; j += i) {\n\t\tdoors[j] = !doors[j];\n\t}\n}\n\nfor (i = 1 ; i <= n ; i++) {\n\tif (doors[i]) console.log(\"Door \" + i + \" is open\");\n}<\/lang>\noutputs\n<pre>door 1 is open.\ndoor 4 is open.\ndoor 9 is open.\ndoor 16 is open.\ndoor 25 is open.\ndoor 36 is open.\ndoor 49 is open.\ndoor 64 is open.\ndoor 81 is open.\ndoor 100 is open.<\/pre>\n\nUsing features of JavaScript 1.6, this <div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Firefox]] version 1.5[[SMW::on]]<\/div>\n<lang javascript>var\n n = 100,\n doors = [n],\n step,\n idx;\n\/\/ now, start opening and closing\nfor (step = 1; step <= n; step += 1)\n for (idx = step; idx <= n; idx += step)\n \/\/ toggle state of door\n doors[idx] = !doors[idx];\n\n\/\/ find out which doors are open\nvar open = doors.reduce(function(open, val, idx) {\n    if (val) {\n        open.push(idx);\n    }\n    return open;\n}, []);\ndocument.write(\"These doors are open: \" + open.join(', '));<\/lang>\noutputs\n<pre>these doors are open: 1, 4, 9, 16, 25, 36, 49, 64, 81, 100<\/pre>\n\n==[[:Category:K|K]][[Category:K]]==\n'''unoptimized''' \/ converted from Q . \n<lang k> `closed `open ![ ; 2 ] @ #:' 1 _ = ,\/ &:' 0 = t !\\:\/: t : ! 101<\/lang>\n\n'''optimized'''  \/ 1 origin indices \n<lang k> ( 1 + ! 10 ) ^ 2<\/lang>\n\n\/ As parameterized function :\n<lang k> { ( 1 + ! _ x ^ % 2 ) ^ 2 } 100 <\/lang>\n\n==[[:Category:LabVIEW|LabVIEW]][[Category:LabVIEW]]==\nThis image is a [http:\/\/zone.ni.com\/devzone\/cda\/tut\/p\/id\/9330 VI Snippet], an executable image of [[LabVIEW]] code. The LabVIEW version is shown on the top-right hand corner. You can download it, then drag-and-drop it onto the LabVIEW block diagram from a file browser, and it will appear as runnable, editable code.<br\/>[[File:100doors.png]]\n;Optimized\nThis image is a [http:\/\/zone.ni.com\/devzone\/cda\/tut\/p\/id\/9330 VI Snippet], an executable image of [[LabVIEW]] code. The LabVIEW version is shown on the top-right hand corner. You can download it, then drag-and-drop it onto the LabVIEW block diagram from a file browser, and it will appear as runnable, editable code.<br\/>[[File:LabVIEW_100_doors.png]]\n\n==[[:Category:Lhogho|Lhogho]][[Category:Lhogho]]==\nThis implementation defines 100 variables, named \"1 through \"100, rather than using a list. Thanks to Pavel Boytchev, the author of Lhogho, for help with the code.\n\n<lang Logo>to doors\n\t;Problem 100 Doors \n\t;Lhogho\n\n\tfor \"p [1 100] \n\t[\n\t\tmake :p \"false\n\t]\n\n\tfor \"a [1 100 1]\n\t[\n\t\tfor \"b [:a 100 :a]\n\t\t[\n\t\t\tif :b < 101 \n\t\t\t[\n\t\t\t\tmake :b not thing :b\n\t\t\t]\n\t\t]\n\t]\n\n\tfor \"c [1 100]\n\t[\n\t\tif thing :c \n\t\t[ \n\t\t\t(print \"door :c \"is \"open) \n\t\t]\n\t] \nend\n\ndoors<\/lang>\n\n==[[:Category:Liberty BASIC|Liberty BASIC]][[Category:Liberty BASIC]]==\n<lang lb>dim doors(100)\nfor pass = 1 to 100\n    for door = pass to 100 step pass\n        doors(door) = not(doors(door))\n    next door\nnext pass\nprint \"open doors \";\nfor door = 1 to 100\n    if doors(door) then print door;\"  \";\nnext door<\/lang>\n\n==[[:Category:Logo|Logo]][[Category:Logo]]==\n\n \n<lang Logo>to doors\n;Problem 100 Doors \n;FMSLogo\n;lrcvs 2010\n\nmake \"door (vector 100 1) \nfor [p 1 100][setitem :p :door 0] \n  \nfor [a 1 100 1][for [b :a 100 :a][make \"x item :b :door \n\t                          ifelse :x  = 0 [setitem :b :door 1][setitem :b :door 0] ] ] \n  \nfor [c 1 100][make \"y item :c :door \n\t      ifelse :y = 0 [pr (list :c \"Close)] [pr (list :c \"Open)] ] \nend<\/lang>\n\n==[[:Category:Lua|Lua]][[Category:Lua]]==\n<lang lua>is_open = {}\n\nfor door = 1,100 do is_open[door] = false end\n\nfor pass = 1,100 do\n    for door = pass,100,pass do\n        is_open[door] = not is_open[door]\n    end\nend\n\nfor i,v in next,is_open do\n    if v then\n        print ('Door '..i..':','open')\n    else\n        print ('Door '..i..':', 'close')\n    end\nend<\/lang>\n\n==[[:Category:M4|M4]][[Category:M4]]==\n<lang m4>define(`_set', `define(`$1[$2]', `$3')')dnl\ndefine(`_get', `defn(`$1[$2]')')dnl\ndefine(`for',`ifelse($#,0,``$0'',`ifelse(eval($2<=$3),1,\n`pushdef(`$1',$2)$5`'popdef(`$1')$0(`$1',eval($2+$4),$3,$4,`$5')')')')dnl\ndefine(`opposite',`_set(`door',$1,ifelse(_get(`door',$1),`closed',`open',`closed'))')dnl\ndefine(`upper',`100')dnl\nfor(`x',`1',upper,`1',`_set(`door',x,`closed')')dnl\nfor(`x',`1',upper,`1',`for(`y',x,upper,x,`opposite(y)')')dnl\nfor(`x',`1',upper,`1',`door x is _get(`door',x)\n')dnl<\/lang>\n\n==[[:Category:Mathematica|Mathematica]][[Category:Mathematica]]==\n'''unoptimized 1'''\n<lang mathematica>n=100;\ntmp=ConstantArray[-1,n];\nDo[tmp[[i;;;;i]]*=-1;,{i,n}];\nDo[Print[\"door \",i,\" is \",If[tmp[[i]]==-1,\"closed\",\"open\"]],{i,1,Length[tmp]}]<\/lang>\n\n'''unoptimized 2'''\n<lang mathematica>f[n_] = \"Closed\"; \nDo[Do[If[f[n] == \"Closed\", f[n] = \"Open\", f[n] = \"Closed\"], {n, k, 100, k}], {k, 1, 100}]; \nTable[f[n], {n, 1, 100}]<\/lang>\n\n'''optimized 1'''\n<lang mathematica>Do[Print[\"door \",i,\" is \",If[IntegerQ[Sqrt[i]],\"open\",\"closed\"]],{i,100}]<\/lang>\n\n'''optimized 2'''\n<lang mathematica>n=100;\na=Range[1,Sqrt[n]]^2\nDo[Print[\"door \",i,\" is \",If[MemberQ[a,i],\"open\",\"closed\"]],{i,100}]<\/lang>\n\n'''optimized 3'''\n<lang mathematica>n=100\nnn=1\na=0\nFor[i=1,i<=n,i++,\n If[i==nn,\n  Print[\"door \",i,\" is open\"];\n  a++;\n  nn+=2a+1;\n ,\n  Print[\"door \",i,\" is closed\"];\n ];\n]<\/lang>\n\nThese will only give the indices for the open doors:\n'''unoptimized 2'''\n<lang mathematica>Pick[Range[100], Xor@@@Array[Divisible[#1,#2]&, {100,100}]]<\/lang>\n\n'''optimized 4'''\n<lang mathematica>Range[Sqrt[100]]^2<\/lang>\n\n==[[:Category:MATLAB|MATLAB]][[Category:MATLAB]]==\n\n===Iterative Method===\n'''Unoptimized'''\n<lang MATLAB>\na=zeros(1,100);\nfor b=1:100;\nfor i=b:b:100;\n    if a(i)==1\n        a(i)=0;\n    else \n        a(i)=1;\n    end\nend\nend\na\n<\/lang>\n'''Optimized'''\n<lang MATLAB>\nfor x=1:100;\n  if sqrt(x) == floor(sqrt(x))\n    a(i)=1;\n  end\nend\na\n<\/lang>\n'''More Optimized'''\n<lang MATLAB>\na = zeros(100,1);\nfor counter = 1:sqrt(100);\n  a(counter^2) = 1;\nend\na\n<\/lang>\n\n===Vectorized Method===\n<lang MATLAB>function [doors,opened,closed] = hundredDoors()\n\n    %Initialize the doors, make them booleans for easy vectorization\n    doors = logical( (1:1:100) );\n    \n    %Go through the flipping process, ignore the 1 case because the doors\n    %array is already initialized to all open\n    for initialPosition = (2:100)\n        doors(initialPosition:initialPosition:100) = not( doors(initialPosition:initialPosition:100) );\n    end\n    \n    opened = find(doors); %Stores the numbers of the open doors\n    closed = find( not(doors) ); %Stores the numbers of the closed doors\n    \nend<\/lang>\n\n===Known-Result Method===\n<lang MATLAB>\ndoors((1:10).^2) = 1;\n\ndoors\n<\/lang>\n\n==[[:Category:MAXScript|MAXScript]][[Category:MAXScript]]==\n'''unoptimized'''\n<lang maxscript>doorsOpen = for i in 1 to 100 collect false\n\nfor pass in 1 to 100 do\n(\n    for door in pass to 100 by pass do\n    (\n        doorsOpen[door] = not doorsOpen[door]\n    )\n)\n\nfor i in 1 to doorsOpen.count do\n(\n    format (\"Door % is open?: %\\n\") i doorsOpen[i]\n)<\/lang>\n'''optimized'''\n<lang maxscript>for i in 1 to 100 do\n(\n    root = pow i 0.5\n    format (\"Door % is open?: %\\n\") i (root == (root as integer))\n)<\/lang>\n\n==[[:Category:Mercury|Mercury]][[Category:Mercury]]==\n<lang Mercury>:- module doors.\n:- interface.\n:- import_module array, io, int.\n\n:- type door ---> open ; closed.\n:- type doors == array(door).\n\n:- func toggle(door) = door.\n:- pred walk(int::in, doors::in, doors::out) is semidet.\n:- pred walks(int::in, int::in, doors::in, doors::out) is det.\n\n:- pred main(io::di, io::uo) is det.\n\n:- implementation.\n\ntoggle(open) = closed.\ntoggle(closed) = open.\n\nwalk(N, !D) :- walk(N, N, !D).\n\n:- pred walk(int::in, int::in, doors::in, doors::out) is semidet.\nwalk(At, By, !D) :-\n        semidet_lookup(!.D, At - 1, Door),\n        slow_set(!.D, At - 1, toggle(Door), !:D),\n        ( walk(At + By, By, !D) -> true ; true ).\n\nwalks(N, End, !D) :-\n        ( N =< End, walk(N, !D) -> walks(N + 1, End, !D) ; true ).\n\nmain(!IO) :-\n        io.write(Doors1, !IO), io.nl(!IO),\n        array.init(100, closed, Doors0),\n        walks(1, 100, Doors0, Doors1).<\/lang>\n\n==[[:Category:Metafont|Metafont]][[Category:Metafont]]==\n<lang metafont>boolean doors[];\nfor i = 1 upto 100: doors[i] := false; endfor\nfor i = 1 upto 100:\n  for j = 1 step i until 100:\n    doors[j] := not doors[j];\n  endfor\nendfor\nfor i = 1 upto 100:\n  message decimal(i) & \" \" & if doors[i]: \"open\" else: \"close\" fi;\nendfor\nend<\/lang>\n\n==[[:Category:MIPS Assembly|MIPS Assembly]][[Category:MIPS Assembly]]==\n<lang mips>.data\n  doors:     .space 100\n  num_str:   .asciiz \"Number \"\n  comma_gap: .asciiz \" is \"\n  newline:   .asciiz \"\\n\"\n\n.text\nmain:\n# Clear all the cells to zero\n  li $t1, 100\n  la $t2, doors\nclear_loop:\n  sb $0, ($t2)\n  add $t2, $t2, 1\n  sub $t1, $t1, 1\n  bnez $t1, clear_loop\n\n# Now start the loops\n  li $t0, 1         # This will the the step size\n  li $t4, 1         # just an arbitrary 1\nloop1:\n  move $t1, $t0      # Counter\n  la $t2, doors      # Current pointer\n  add $t2, $t2, $t0\n  addi $t2, $t2, -1\nloop2:\n  lb $t3, ($t2)\n  sub $t3, $t4, $t3\n  sb $t3, ($t2)\n  add $t1, $t1, $t0\n  add $t2, $t2, $t0\n  ble $t1, 100, loop2\n\n  addi $t0, $t0, 1\n  ble $t0, 100, loop1\n\n  # Now display everything\n  la $t0, doors\n  li $t1, 1\nloop3:\n  li $v0, 4\n  la $a0, num_str\n  syscall\n  \n  li $v0, 1\n  move $a0, $t1\n  syscall\n\n  li $v0, 4\n  la $a0, comma_gap\n  syscall\n\n  li $v0, 1\n  lb $a0, ($t0)\n  syscall\n\n  li $v0, 4,\n  la $a0, newline\n  syscall\n\n  addi $t0, $t0, 1\n  addi $t1, $t1, 1\n  bne $t1, 101 loop3\n<\/lang>\n\n==[[:Category:Mirah|Mirah]][[Category:Mirah]]==\n\n<lang Mirah>import java.util.ArrayList\n\nclass Door\n\t:state\n\n\tdef initialize\n\t\t@state=false\n\tend\n \n\tdef closed?; !@state; end\n\tdef open?; @state; end\n\n\tdef close; @state=false; end\n\tdef open; @state=true; end\n \n\tdef toggle\n\t\tif closed?\n\t\t\topen\n\t\telse\n\t\t\tclose\n\t\tend\n\tend\n \n\tdef toString; Boolean.toString(@state); end\nend\n \ndoors=ArrayList.new\n1.upto(100) do\n    doors.add(Door.new)\nend \n\n1.upto(100) do |multiplier|\n    index = 0\n    doors.each do |door|\n        Door(door).toggle if (index+1)%multiplier == 0\n        index += 1\n    end\nend\n\ni = 0\ndoors.each do |door| \n    puts \"Door #{i+1} is #{door}.\"\n    i+=1\nend\n<\/lang>\n\n==[[:Category:ML\/I|ML\/I]][[Category:ML\/I]]==\n<lang ML\/I>MCSKIP \"WITH\" NL\n\"\" 100 doors\nMCINS %.\nMCSKIP MT,<>\n\"\" Doors represented by P1-P100, 0 is closed\nMCPVAR 100\n\"\" Set P variables to 0\nMCDEF ZEROPS WITHS NL AS <MCSET T1=1\n%L1.MCSET PT1=0\nMCSET T1=T1+1\nMCGO L1 UNLESS T1 EN 101\n>\nZEROPS\n\"\" Generate door state\nMCDEF STATE WITHS () AS <MCSET T1=%A1.\nMCGO L1 UNLESS T1 EN 0\nclosed<>MCGO L0\n%L1.open>\n\"\" Main macro - no arguments\n\"\" T1 is pass number\n\"\" T2 is door number\nMCDEF DOORS WITHS NL\nAS <MCSET T1=1\n\"\" pass loop\n%L1.MCGO L4 IF T1 GR 100\n\"\" door loop\nMCSET T2=T1\n%L2.MCGO L3 IF T2 GR 100\nMCSET PT2=1-PT2\nMCSET T2=T2+T1\nMCGO L2\n%L3.MCSET T1=T1+1\nMCGO L1\n%L4.\"\" now output the result\nMCSET T1=1\n%L5.door %T1. is STATE(%PT1.)\nMCSET T1=T1+1\nMCGO L5 UNLESS T1 GR 100\n>\n\"\" Do it\nDOORS<\/lang>\n\n==[[:Category:MMIX|MMIX]][[Category:MMIX]]==\nSee [[100 doors\/MMIX]]\n\n==[[:Category:Modula-2|Modula-2]][[Category:Modula-2]]==\n'''unoptimized'''\n<lang modula2>MODULE Doors;\nIMPORT InOut;\n\nTYPE State = (Closed, Open);\nTYPE List = ARRAY [1 .. 100] OF State;\n\nVAR\n  Doors: List;\n  I, J:  CARDINAL;\n\nBEGIN\n  FOR I := 1 TO 100 DO\n    FOR J := 1 TO 100 DO\n      IF J MOD I = 0 THEN\n        IF Doors[J] = Closed THEN\n          Doors[J] := Open\n        ELSE\n          Doors[J] := Closed\n        END\n      END\n    END\n  END;\n\n  FOR I := 1 TO 100 DO\n    InOut.WriteCard(I, 3);\n    InOut.WriteString(' is ');\n\n    IF Doors[I] = Closed THEN\n      InOut.WriteString('Closed.')\n    ELSE\n      InOut.WriteString('Open.')\n    END;\n\n    InOut.WriteLn\n  END\nEND Doors.<\/lang>\n\n'''optimized'''\n<lang modula2>MODULE DoorsOpt;\nIMPORT InOut;\n\nTYPE State = (Closed, Open);\nTYPE List = ARRAY [1 .. 100] OF State;\n\nVAR\n  Doors: List;\n  I:  CARDINAL;\n\nBEGIN\n  FOR I := 1 TO 10 DO\n    Doors[I*I] := Open\n  END;\n\n  FOR I := 1 TO 100 DO\n    InOut.WriteCard(I, 3);\n    InOut.WriteString(' is ');\n    IF Doors[I] = Closed THEN\n      InOut.WriteString('Closed.')\n    ELSE\n      InOut.WriteString('Open.')\n    END;\n    InOut.WriteLn\n  END\nEND DoorsOpt.<\/lang>\n\n==[[:Category:Modula-3|Modula-3]][[Category:Modula-3]]==\n'''unoptimized'''\n<lang modula3>MODULE Doors EXPORTS Main;\n\nIMPORT IO, Fmt;\n\nTYPE State = {Closed, Open};\nTYPE List = ARRAY [1..100] OF State;\n\nVAR doors := List{State.Closed, ..};\n\nBEGIN\n  FOR i := 1 TO 100 DO\n    FOR j := FIRST(doors) TO LAST(doors) DO\n      IF j MOD i = 0 THEN\n        IF doors[j] = State.Closed THEN\n          doors[j] := State.Open;\n        ELSE\n          doors[j] := State.Closed;\n        END;\n      END;\n    END;\n  END;\n\n  FOR i := FIRST(doors) TO LAST(doors) DO\n    IO.Put(Fmt.Int(i) & \" is \");\n    IF doors[i] = State.Closed THEN\n      IO.Put(\"Closed.\\n\");\n    ELSE\n      IO.Put(\"Open.\\n\");\n    END;\n  END;\nEND Doors.<\/lang>\n\n'''optimized'''\n\n<lang modula3>MODULE DoorsOpt EXPORTS Main;\n\nIMPORT IO, Fmt;\n\nTYPE State = {Closed, Open};\nTYPE List = ARRAY [1..100] OF State;\n\nVAR doors := List{State.Closed, ..};\n\nBEGIN\n  FOR i := 1 TO 10 DO\n    doors[i * i] := State.Open;\n  END;\n\n  FOR i := FIRST(doors) TO LAST(doors) DO\n    IO.Put(Fmt.Int(i) & \" is \");\n    IF doors[i] = State.Closed THEN\n      IO.Put(\"Closed.\\n\");\n    ELSE\n      IO.Put(\"Open.\\n\");\n    END;\n  END;\nEND DoorsOpt.<\/lang>\n\n==[[:Category:MOO|MOO]][[Category:MOO]]==\n<lang moo>is_open = make(100);\nfor pass in [1..100]\n  for door in [pass..100]\n    if (door % pass)\n      continue;\n    endif\n    is_open[door] = !is_open[door];\n  endfor\nendfor\n\n\"output the result\";\nfor door in [1..100]\n  player:tell(\"door #\", door, \" is \", (is_open[door] ? \"open\" : \"closed\"), \".\");\nendfor<\/lang>\n\n\n==[[:Category:MUMPS|MUMPS]][[Category:MUMPS]]==\n<lang MUMPS>doors\tnew door,pass\n\tFor door=1:1:100 Set door(door)=0\n\tFor pass=1:1:100 For door=pass:pass:100 Set door(door)='door(door)\n\tFor door=1:1:100 If door(door) Write !,\"Door\",$j(door,4),\" is open\"\n\tWrite !,\"All other doors are closed.\"\n\tQuit\nDo doors\nDoor   1 is open\nDoor   4 is open\nDoor   9 is open\nDoor  16 is open\nDoor  25 is open\nDoor  36 is open\nDoor  49 is open\nDoor  64 is open\nDoor  81 is open\nDoor 100 is open\nAll other doors are closed.<\/lang>\n\n==[[:Category:NetRexx|NetRexx]][[Category:NetRexx]]==\n'''unoptimized'''\n<lang netrexx>\/* NetRexx *\/\noptions replace format comments java crossref savelog symbols binary\n\nTrue  = Rexx(1 == 1)\nFalse = Rexx(\\True)\n\ndoors = False\n\nloop i_ = 1 to 100\n  loop j_ = 1 to 100\n    if 0 = (j_ \/\/ i_) then doors[j_] = \\doors[j_]\n    end j_\n  end i_\n\nloop d_ = 1 to 100\n  if doors[d_] then  state = 'open'\n  else  state = 'closed'\n\n  say 'Door Nr.' Rexx(d_).right(4) 'is' state\n  end d_\n<\/lang>\n\n'''optimized''' (Based on the Java 'optimized' version)\n<div class=\"examplemeta translation\">'''Translation of''': [[100 doors#Java|Java]]<\/div>\n<lang netrexx>\/* NetRexx *\/\noptions replace format comments java crossref savelog symbols binary\n\nTrue  = (1 == 1)\nFalse = \\True\n\ndoors = boolean[100]\n\nloop i_ = 0 to 9\n  doors[(i_ + 1) * (i_ + 1) - 1] = True;\n  end i_\n\nloop i_ = 0 to 99\n  if doors[i_] then  state = 'open'\n  else  state = 'closed'\n\n  say 'Door Nr.' Rexx(i_ + 1).right(4) 'is' state\n  end i_\n<\/lang>\n\n'''optimized 2''' (Based on the Java 'optimized 2' version)\n<div class=\"examplemeta translation\">'''Translation of''': [[100 doors#Java|Java]]<\/div>\n<lang netrexx>\/* NetRexx *\/\noptions replace format comments java crossref savelog symbols binary\n\nresultstring = ''\n\nloop i_ = 1 to 10\n  resultstring = resultstring || 'Door Nr.' Rexx(i_ * i_).right(4) 'is open\\n'\n  end i_\n\nsay resultstring\n<\/lang>\n\n'''optimized 3''' \n<lang netrexx>\/* NetRexx *\/\n\nloop i = 1 to 10\n   say 'Door Nr.' i * i 'is open.'\n  end i\n\n<\/lang>\n\n==[[:Category:Objeck|Objeck]][[Category:Objeck]]==\n'''optimized'''\n<lang objeck>\nbundle Default {\n  class Doors {\n    function : Main(args : String[]) ~ Nil {\n      doors := Bool->New[100];\n      \n      for(pass := 0; pass < 10; pass += 1;) {\n        doors[(pass + 1) * (pass + 1) - 1] := true;\n      };\n      \n      for(i := 0; i < 100; i += 1;) {    \n        IO.Console->GetInstance()->Print(\"Door #\")->Print(i + 1)->Print(\" is \");\n        if(doors[i]) {\n          \"open.\"->PrintLine();\n        }\n        else {\n          \"closed.\"->PrintLine();\n        };\n      };\n    }\n  }\n}\n<\/lang>\n\n==[[:Category:OCaml|OCaml]][[Category:OCaml]]==\n'''unoptimized'''\n<lang ocaml>let max_doors = 100\n\nlet show_doors =\n  Array.iteri (fun i x -> Printf.printf \"Door %d is %s\\n\" (i+1)\n                                        (if x then \"open\" else \"closed\"))\n\nlet flip_doors doors =\n  for i = 1 to max_doors do\n    let rec flip idx =\n      if idx < max_doors then begin\n        doors.(idx) <- not doors.(idx);\n        flip (idx + i)\n      end\n    in flip (i - 1)\n  done;\n  doors\n\nlet () =\n  show_doors (flip_doors (Array.make max_doors false))<\/lang>\n\n'''optimized'''\n<lang ocaml>let optimised_flip_doors doors =\n  for i = 1 to int_of_float (sqrt (float_of_int max_doors)) do\n    doors.(i*i - 1) <- true\n  done;\n  doors\n\nlet () =\n  show_doors (optimised_flip_doors (Array.make max_doors false))<\/lang>\n\n==[[:Category:Octave|Octave]][[Category:Octave]]==\n<lang octave>doors = false(100,1);\nfor i = 1:100\n  for j = i:i:100\n    doors(j) = !doors(j);\n  endfor\nendfor\nfor i = 1:100\n  if ( doors(i) )\n    s = \"open\";\n  else\n    s = \"closed\";\n  endif\n  printf(\"%d %s\\n\", i, s);\nendfor<\/lang>\n\n==[[:Category:OpenEdge\/Progress|OpenEdge\/Progress]][[Category:OpenEdge\/Progress]]==\n<lang Progress (OpenEdge ABL)>DEFINE VARIABLE lopen   AS LOGICAL     NO-UNDO EXTENT 100.\nDEFINE VARIABLE idoor   AS INTEGER     NO-UNDO.\nDEFINE VARIABLE ipass   AS INTEGER     NO-UNDO.\nDEFINE VARIABLE cresult AS CHARACTER   NO-UNDO.\n\nDO ipass = 1 TO 100:\n   idoor = 0.\n   DO WHILE idoor <= 100:\n      idoor = idoor + ipass.\n      IF idoor <= 100 THEN\n         lopen[ idoor ] = NOT lopen[ idoor ].\n   END.\nEND.\n\nDO idoor = 1 TO 100:\n   cresult = cresult + STRING( lopen[ idoor ], \"1  \/0  \" ).\n   IF idoor MODULO 10 = 0 THEN\n      cresult = cresult + \"~r\":U.\nEND.\n\nMESSAGE cresult VIEW-AS ALERT-BOX.\n<\/lang>\n\n==[[:Category:Oz|Oz]][[Category:Oz]]==\n<lang oz>declare\n  NumDoors = 100\n  NumPasses = 100\n\n  fun {NewDoor} closed end\n\n  fun {Toggle Door}\n     case Door of closed then open\n     [] open then closed\n     end\n  end\n\n  fun {Pass Doors I}\n     {List.mapInd Doors\n      fun {$ Index Door}\n         if Index mod I == 0 then {Toggle Door}\n         else Door\n         end\n      end}\n  end\n  \n  Doors0 = {MakeList NumDoors}\n  {ForAll Doors0 NewDoor}\n\n  DoorsN = {FoldL {List.number 1 NumPasses 1} Pass Doors0}\nin\n  %% print open doors\n  {List.forAllInd DoorsN\n   proc {$ Index Door}\n      if Door == open then\n\t {System.showInfo \"Door \"#Index#\" is open.\"}\n      end\n   end\n  }<\/lang>\n\nOutput:\n<pre>\nDoor 1 is open.\nDoor 4 is open.\nDoor 9 is open.\nDoor 16 is open.\nDoor 25 is open.\nDoor 36 is open.\nDoor 49 is open.\nDoor 64 is open.\nDoor 81 is open.\nDoor 100 is open.\n<\/pre>\n\n==[[:Category:PARI\/GP|PARI\/GP]][[Category:PARI\/GP]]==\n'''Unoptimized version.'''\n<lang parigp>\nv=vector(d=100);\/*set 100 closed doors*\/\nfor(i=1,d,forstep(j=i,d,i,v[j]=1-v[j]));\nfor(i=1,d,if(v[i],print(\"Door \",i,\" is open.\")))\n<\/lang>\n'''Optimized version.'''\n<lang parigp>for(n=1,10,print(\"Door \",n^2,\" is open.\"))<\/lang>\n\n==[[:Category:Pascal|Pascal]][[Category:Pascal]]==\n<lang pascal>Program OneHundredDoors;\n\nvar\n   doors : Array[1..100] of Boolean;\n   i, j\t : Integer;\n   \nbegin\n   for i := 1 to 100 do\n      doors[i] := False;\n   for i := 1 to 100 do begin\n      j := i;\n      while j <= 100 do begin\n\t doors[j] := not doors[j];\n\t j := j + i\n      end\n   end;\n   for i := 1 to 100 do begin\n      Write(i, ' ');\n      if doors[i] then\n\t WriteLn('open')\n      else\n\t WriteLn('closed');\n   end\nend.<\/lang>\n\n'''Optimized version.'''\n\n<lang pascal>program OneHundredDoors;\n\n{$APPTYPE CONSOLE}\n\nuses\n  math, sysutils;\n\nvar\n   AOpendoors  : String;\n   ACloseDoors : String;\n   i\t       : Integer;\n\nbegin\n   for i := 1 to 100 do\n   begin\n      if (sqrt(i) = floor(sqrt(i))) then\n        AOpenDoors := AOpenDoors + IntToStr(i) + ';'\n      else\n        ACloseDoors := ACloseDoors + IntToStr(i) +';';\n   end;\n\n   WriteLn('Open doors: ' + AOpenDoors);\n   WriteLn('Close doors: ' + ACloseDoors);\nend.     <\/lang>\n\n==[[:Category:Perl|Perl]][[Category:Perl]]==\n'''unoptimized'''\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Perl]] version 5.x[[SMW::on]]<\/div>\n<lang perl>my @doors;\nfor my $pass (1 .. 100) {\n    for (1 .. 100) {\n        if (0 == $_ % $pass) {\n            $doors[$_] = not $doors[$_];\n        };\n    };\n};\n\nprint \"Door $_ is \", $doors[$_] ? \"open\" : \"closed\", \"\\n\" for 1 .. 100;<\/lang>\n\n'''optimized'''\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Perl]] version 5.x[[SMW::on]]<\/div>\n<lang perl>print \"Door $_ is open\\n\" for map $_**2, 1 .. 10;<\/lang>\n<lang perl>print \"Door $_ is \", qw\"closed open\"[int sqrt == sqrt], \"\\n\" for 1..100;<\/lang>\n<lang perl>while( ++$i <= 100 )\n{\n    $root = sqrt($i);\n    if ( int( $root ) == $root )\n    {\n        print \"Door $i is open\\n\";\n    }\n    else\n    {\n        print \"Door $i is closed\\n\";\n    }\n}<\/lang>\n\n==[[:Category:Perl 6|Perl 6]][[Category:Perl 6]]==\n'''unoptimized''' <div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Rakudo]] version 2010.07\"[[SMW::on]]<\/div>\n<lang perl6>my @doors = False xx 101;\n\n($_ = !$_ for @doors[0, * + $_ ...^ * > 100]) for 1..100;\n\nsay \"Door $_ is \", <closed open>[ @doors[$_] ] for 1..100;<\/lang>\n\n'''optimized'''\n\n<lang perl6>say \"Door $_ is open\" for map {$^n ** 2}, 1..10;<\/lang>\n\nHere's a version using the cross meta-operator instead of a map:\n\n<lang perl6> say \"Door $_ is open\" for 1..10 X** 2;<\/lang>\n\nThis one prints both opened and closed doors:\n\n<lang perl6>say \"Door $_ is \", <closed open>[.sqrt == .sqrt.floor] for 1..100;<\/lang>\n\n==[[:Category:PHP|PHP]][[Category:PHP]]==\n'''optimized'''\n<lang php><?php\nfor ($i = 1; $i <= 100; $i++) {\n\t$root = sqrt($i);\n\t$state = ($root == ceil($root)) ? 'open' : 'closed';\n\techo \"Door {$i}: {$state}\\n\";\n}\n?><\/lang>\n\n'''unoptimized'''\n<lang php><?php\n$toggleState = array('open' => 'closed', 'closed' => 'open');\n$doors = array_fill(1, 100, 'closed');\nfor ($pass = 1; $pass <= 100; ++$pass) {\n\tfor ($nr = 1; $nr <= 100; ++$nr) {\n\t\tif ($nr % $pass == 0) {\n\t\t\t$doors[$nr] = $toggleState[$doors[$nr]];\n\t\t}\n\t}\n}\nfor ($nr = 1; $nr <= 100; ++$nr)\n\tprintf(\"Door %d is %s\\n\", $nr, $doors[$nr]);\n?><\/lang>\n\n==[[:Category:PicoLisp|PicoLisp]][[Category:PicoLisp]]==\nunoptimized\n<lang PicoLisp>(let Doors (need 100)\n   (for I 100\n      (for (D (nth Doors I)  D  (cdr (nth D I)))\n         (set D (not (car D))) ) )\n   (println Doors) )<\/lang>\noptimized\n<lang PicoLisp>(let Doors (need 100)\n   (for I (sqrt 100)\n      (set (nth Doors (* I I)) T) )\n   (println Doors) )<\/lang>\nOutput in both cases:\n<pre>(T NIL NIL T NIL NIL NIL NIL T NIL NIL NIL NIL NIL NIL T NIL NIL NIL NIL NIL NIL\n NIL NIL T NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL T NIL NIL NIL NIL NIL NIL NIL\n NIL NIL NIL NIL NIL T NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL T\n NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL T NIL NIL NIL N\nIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL T)<\/pre>\n\nWith formatting:\n<lang PicoLisp>(let Doors (need 100)\n   (for I (sqrt 100)\n      (set (nth Doors (* I I)) T) )\n   (make\n      (for (N . D) Doors\n         (when D (link N)) ) ) )<\/lang>\nOutput:\n<pre>(1 4 9 16 25 36 49 64 81 100)<\/pre>\n\n==[[:Category:Piet|Piet]][[Category:Piet]]==\n[http:\/\/www.toothycat.net\/~sham\/piet\/100doors.png image]\n\n==[[:Category:Pike|Pike]][[Category:Pike]]==\n<lang pike>array onehundreddoors()\n{\n    array doors = allocate(100);\n    foreach(doors; int i;)\n        for(int j=i; j<100; j+=i+1)\n            doors[j] = !doors[j];\n    return doors;\n}<\/lang>\noptimized version:\n<lang pike>array doors = map(enumerate(100,1,1), lambda(int x)\n                                      {  \n                                          return sqrt((float)x)%1 == 0.0; \n                                      });<\/lang>\n\n<lang pike>write(\"%{%d %d %d %d %d %d %d %d %d %d\\n%}\\n\", doors\/10)<\/lang>\noutput:\n 1 0 0 1 0 0 0 0 1 0\n 0 0 0 0 0 1 0 0 0 0\n 0 0 0 0 1 0 0 0 0 0\n 0 0 0 0 0 1 0 0 0 0\n 0 0 0 0 0 0 0 0 1 0\n 0 0 0 0 0 0 0 0 0 0\n 0 0 0 1 0 0 0 0 0 0\n 0 0 0 0 0 0 0 0 0 0\n 1 0 0 0 0 0 0 0 0 0\n 0 0 0 0 0 0 0 0 0 1\n\n==[[:Category:PL\/I|PL\/I]][[Category:PL\/I]]==\n<lang PL\/I>\ndeclare door(100) bit (1) aligned;\ndeclare closed bit (1) static initial ('0'b),\n        open   bit (1) static initial ('1'b);\ndeclare (i, inc) fixed binary;\n\ndoor = closed;\ninc = 1;\ndo until (inc >= 100);\n   do i = inc to 100 by inc;\n      door(i) = ^door(i); \/* close door if open; open it if closed. *\/\n   end;\n   inc = inc+1;\nend;\n\ndo i = 1 to 100;\n   put skip edit ('Door ', trim(i), ' is ') (a);\n   if door(i) then put edit (' open.') (a);\n   else put edit (' closed.') (a);\nend;\n<\/lang>\n\n==[[:Category:Pop11|Pop11]][[Category:Pop11]]==\n'''unoptimized'''\n<lang pop11>lvars i;\nlvars doors = {% for i from 1 to 100 do false endfor %};\nfor i from 1 to 100 do\n   for j from i by i to 100 do\n      not(doors(j)) -> doors(j);\n   endfor;\nendfor;\n;;; Print state\nfor i from 1 to 100 do\n   printf('Door ' >< i >< ' is ' ><\n            if doors(i) then 'open' else 'closed' endif, '%s\\n');\nendfor;<\/lang>\n\n'''optimized'''\n<lang pop11>for i to 100 do\n    lvars root = sqrt(i);\n    i; if root = round(root) then ' open' ><; else ' closed' ><; endif; =>\nendfor;<\/lang>\n\n==[[:Category:PostScript|PostScript]][[Category:PostScript]]==\nBruteforce:<lang PostScript>\/doors [ 100 { false } repeat ] def\n\n1 1 100 { dup 1 sub exch 99 {\n        dup doors exch get not doors 3 1 roll put\n} for } for\ndoors pstack<\/lang>Shows: <lang>[true false false true false false false false true false ...<90 doors later>... true]<\/lang>\n\n==[[:Category:PowerShell|PowerShell]][[Category:PowerShell]]==\n===unoptimized===\n<lang powershell>$doors = @(0..99)\nfor($i=0; $i -lt 100; $i++) {\n  $doors[$i] = 0  # start with all doors closed\n}\nfor($i=0; $i -lt 100; $i++) {\n  $step = $i + 1\n  for($j=$i; $j -lt 100; $j = $j + $step) {\n    $doors[$j] = $doors[$j] -bxor 1\n  }\n}\nforeach($doornum in 1..100) {\n  if($doors[($doornum-1)] -eq $true) {\"$doornum open\"}\n  else {\"$doornum closed\"}\n}<\/lang>\n===unoptimized Pipeline===\n<lang powershell>$doors = 1..100 | ForEach-Object {0}\n1..100 | ForEach-Object { $a=$_;1..100 | Where-Object { -not ( $_ % $a )  } | ForEach-Object { $doors[$_-1] = $doors[$_-1] -bxor 1 }; if ( $doors[$a-1] ) { \"door opened\" } else { \"door closed\" } }\n<\/lang>\n===unoptimized Pipeline 2===\n<lang powershell>$doors = 1..100 | ForEach-Object {0}\n$visited = 1..100\n1..100 | ForEach-Object { $a=$_;$visited[0..([math]::floor(100\/$a)-1)] | Where-Object { -not ( $_ % $a )  } | ForEach-Object { $doors[$_-1] = $doors[$_-1] -bxor 1;$visited[$_\/$a-1]+=($_\/$a) }; if ( $doors[$a-1] ) { \"door opened\" } else { \"door closed\" } }\n<\/lang>\n\n==[[:Category:ProDOS|ProDOS]][[Category:ProDOS]]==\nUses math module.\n<lang ProDOS>enableextensions \nenabledelayedexpansion\neditvar \/newvar \/value=0 \/title=closed\neditvar \/newvar \/value=1 \/title=open\neditvar \/newvar \/range=1-100 \/increment=1 \/from=2\neditvar \/newvar \/value=2 \/title=next\n:doors\nfor \/alloccurrences (!next!-!102!) do editvar \/modify \/value=-open-\neditvar \/modify \/value=-next-=+1\nif -next- \/hasvalue=100 goto :cont else goto :doors\n:cont\nprintline !1!-!102!\nstoptask<\/lang>\n\n==[[:Category:Prolog|Prolog]][[Category:Prolog]]==\n===unoptimized===\n<lang Prolog>doors_unoptimized(N) :-\n\tlength(L, N),\n\tmaplist(init, L),\n\tdoors(N, N, L, L1),\n\taffiche(N, L1).\n\ninit(close).\n\ndoors(Max, 1, L, L1) :-\n\t!,\n       inverse(1, 1, Max, L, L1).\n\ndoors(Max, N, L, L1) :-\n\tN1 is N - 1,\n\tdoors(Max, N1, L, L2),\n\tinverse(N, 1, Max, L2, L1).\n\n\ninverse(N, Max, Max, [V], [V1]) :-\n\t!,\n\t0 =:= Max mod N -> inverse(V, V1); V1 = V.\n\ninverse(N, M, Max, [V|T], [V1|T1]) :-\n\tM1 is M+1,\n\tinverse(N, M1, Max, T, T1),\n\t(   0 =:= M mod N -> inverse(V, V1); V1 = V).\n\n\ninverse(open, close).\ninverse(close, open).\n\naffiche(N, L) :-\n\tforall(between(1, N, I),\n\t       (   nth1(I, L, open) -> format('Door ~w is open.~n', [I]); true)).\n<\/lang>\n\n===optimized===\n<lang Prolog>doors_optimized(N) :-\n\tMax is floor(sqrt(N)),\n\tforall(between(1, Max, I),\n\t       (   J is I*I,format('Door ~w is open.~n',[J]))).\n\n<\/lang>\n\n==[[:Category:PureBasic|PureBasic]][[Category:PureBasic]]==\n'''unoptimized'''\n<lang purebasic>Dim doors.i(100)\n \nFor x = 1 To 100\n  y = x\n  While y <= 100\n    doors(y) = 1 - doors(y)\n    y + x\n  Wend\nNext\n \nOpenConsole()\nPrintN(\"Following Doors are open:\")\nFor x = 1 To 100\n  If doors(x)\n    Print(Str(x) + \", \")\n  EndIf\nNext\nInput()<\/lang>\n\n'''optimized'''\n<lang PureBasic>OpenConsole()\nPrintN(\"Following Doors are open:\")\nFor i = 1 To 100\n    root.f = Sqr(i)\n    If root = Int(root)\n    \tPrint (Str(i) + \", \")\n    EndIf\nNext     \nInput()<\/lang>\n\n\nOutput:\n<pre>Following Doors are open:\n1, 4, 9, 16, 25, 36, 49, 64, 81, 100,<\/pre>\n\n==[[:Category:Python|Python]][[Category:Python]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Python]] version 2.5+[[SMW::on]]<\/div>\n'''unoptimized'''\n<lang python>close = 0\nopen = 1\ndoors = [close] * 100\n  \nfor i in range(100):\n    for j in range(i, 100, i+1):\n        doors[j] = open if doors[j] is close else close\n    print \"Door %d:\" % (i+1), 'open' if doors[i] else 'close'\n<\/lang>\n\n'''optimized'''\n\nA version that only visits each door once:\n\n<lang python>for i in xrange(1, 101):\n    root = i ** 0.5\n    print \"Door %d:\" % i, 'open' if root == int(root) else 'close'<\/lang>\n\nOne liner using a list comprehension, item lookup, and is_integer\n\n<lang python>print '\\n'.join(['Door %s is %s' % (i, ('closed', 'open')[(i**0.5).is_integer()]) for i in xrange(1, 101)])<\/lang>\n\nOne liner using a generator expression, ternary operator, and modulo\n\n<lang python>print '\\n'.join('Door %s is %s' % (i, 'closed' if i**0.5 % 1 else 'open') for i in range(1, 101))<\/lang>\n\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Python]] version 3.x[[SMW::on]]<\/div>\n<lang python>\nfor i in list(range(1, 101)):\n    if i**0.5 % 1: state='open'\n    else: state='close'\n    print (\"Door {}:{}\".format(i, state))\n<\/lang>\n\n==[[:Category:Q|Q]][[Category:Q]]==\n'''unoptimized'''\n<lang q>`closed`open mod[;2]count each 1 _ group raze where each 0=t mod\\:\/:t:til 101<\/lang>\n\n'''optimized'''\n<lang q>`closed`open (1+til 100) in `int$xexp[;2] 1+til 10<\/lang>\n\n==[[:Category:R|R]][[Category:R]]==\n'''unoptimized'''\n<lang r>doors_puzzle <- function(ndoors=100,passes=100) {\n    doors <- rep(FALSE,ndoors)\n    for (ii in seq(1,passes)) {\n        mask <- seq(0,ndoors,ii)\n        doors[mask] <- !doors[mask]\t\n    }\n    return (which(doors == TRUE))\n}\n\ndoors_puzzle()<\/lang>\n\n'''optimized'''\n<lang r>## optimized version... we only have to to up to the square root of 100\nseq(1,sqrt(100))**2<\/lang>\n\n'''optimized'''\n<lang r>x <- rep(1, 100)\nfor (i in 1:100-1) {\n    x <- xor(x, rep(c(rep(0,i),1), length.out=100))\n}\nwhich(!x)<\/lang>\n\n==[[:Category:REALbasic|REALbasic]][[Category:REALbasic]]==\n<lang realbasic>\/\/True=Open; False=Closed\n  Dim doors(100) As Boolean   \/\/Booleans default to false\n  For j As Integer = 1 To 100\n    For i As Integer = 1 to 100\n      If i Mod j = 0 Then\n        doors(i) = Not doors(i)\n      End If\n    Next\n  Next<\/lang>\n\n==[[:Category:REBOL|REBOL]][[Category:REBOL]]==\n\n===Unoptimized===\n<lang rebol>doors: array\/initial 100 'closed\nrepeat i 100 [\n    door: at doors i\n    forskip door i [change door either 'open = first door ['closed] ['open]]\n]<\/lang>\n\n===Optimized===\n<lang rebol>doors: array\/initial 100 'closed\nrepeat i 10 [doors\/(i * i): 'open]\n<\/lang>\n\n==[[:Category:Retro|Retro]][[Category:Retro]]==\n<lang Retro>: squared ( n-n  ) dup * ;\n: doors   ( n-   ) [ 1 repeat 2over squared > 0; drop dup squared putn space 1+ again ] do 2drop ;\n100 doors<\/lang>\n\n==[[:Category:REXX|REXX]][[Category:REXX]]==\n===version 1===\n<lang rexx>\/*rexx*\/\ndoor. = 0\ndo inc = 1 to 100\n  do d = inc to 100 by inc\n    door.d = \\door.d\n  end\nend\nsay \"The open doors after 100 passes:\"\ndo i = 1 to 100\n  if door.i = 1 then say i\nend\n<\/lang>\n===version 2, the hard way===\nHere is another version, solving it the hard way.\n<lang rexx>\/*REXX program to solve the 100 door puzzle, the hard-way version.  *\/\nparse arg doors .            \/*get the first argument (# of doors.) *\/\nif doors=='' then doors=100  \/*not specified?  Then assume 100 doors*\/\n                                    \/*   0 = closed.  *\/\n                                    \/*   1 = open.    *\/\ndoor.=0                      \/*assume all that all doors are closed.*\/\n\n     do j=1 for doors        \/*process a pass-through for all doors.*\/\n       do k=j by j to doors  \/* ... every Jth door from this point. *\/\n       door.k=\\door.k        \/*toggle the  \"openness\"  of the door. *\/\n       end   \/*k*\/\n     end     \/*j*\/\nsay\nsay 'After' doors \"passes, the following doors are open:\"\nsay\n          do n=1 for doors\n          if door.n then say right(n,20)\n          end    \/*n*\/<\/lang>\n'''outut'''\n<pre style=\"height:30ex;overflow:scroll\">\nAfter 100 passes, the following doors are open:\n\n                   1\n                   4\n                   9\n                  16\n                  25\n                  36\n                  49\n                  64\n                  81\n                 100\n<\/pre>\n===version 3, the easy way=== \nHere is another version, solving it the easy way.\n<lang rexx>\/*REXX program to solve the 100 door puzzle, the easy-way version.  *\/\nparse arg doors .            \/*get the first argument (# of doors.) *\/\nif doors=='' then doors=100  \/*not specified?  Then assume 100 doors*\/\n                                    \/*   0 = closed.  *\/\n                                    \/*   1 = open.    *\/\ndoor.=0                      \/*assume all that all doors are closed.*\/\nsay\nsay 'For the' doors \"doors problem, the following doors are open:\"\nsay\n      do j=1 for doors       \/*process an easy pass-through.        *\/\n      p=j*j                  \/*square the door number.              *\/\n                             \/*An alternative:     P=J**2           *\/\n      if p>doors then leave  \/*if too large, we're done.            *\/\n      say right(p,20)\n      end   \/*j*\/<\/lang>\n'''output'''\n<pre style=\"height:30ex;overflow:scroll\">\nFor the 100 doors problem, the following doors are open:\n\n                   1\n                   4\n                   9\n                  16\n                  25\n                  36\n                  49\n                  64\n                  81\n                 100\n<\/pre>\n===version 4, easy way, 1,000 doors===\nHere's another easy-way solution (version 2), but for 1,000 doors.\n<lang rexx>\/*REXX program to solve the 100 door puzzle, the easy-way version 2.*\/\nparse arg doors .            \/*get the first argument (# of doors.) *\/\nif doors=='' then doors=100  \/*not specified?  Then assume 100 doors*\/\ndoors=1000\n                                    \/*   0 = closed.  *\/\n                                    \/*   1 = open.    *\/\ndoor.=0                      \/*assume all that all doors are closed.*\/\nsay\nsay 'For the' doors \"doors problem, the open doors are:\"\nsay\n      do j=1 for doors while j*j<=doors  \/*limit the pass-throughs.     *\/\n      say right(j**2,20)\n      end   \/*j*\/<\/lang>\n'''output'''\n<pre style=\"height:30ex;overflow:scroll\">\nFor the 1000 doors problem, the open doors are:\n\n                   1\n                   4\n                   9\n                  16\n                  25\n                  36\n                  49\n                  64\n                  81\n                 100\n                 121\n                 144\n                 169\n                 196\n                 225\n                 256\n                 289\n                 324\n                 361\n                 400\n                 441\n                 484\n                 529\n                 576\n                 625\n                 676\n                 729\n                 784\n                 841\n                 900\n                 961\n<\/pre>\n\n==[[:Category:Ruby|Ruby]][[Category:Ruby]]==\n'''unoptimized; Ruby-way'''<br \/>\n(I tried to show as much of Ruby syntax and conventions as possible. Of course, instead of a class you could just use generic true\/false, but that's not the point, is it?)\n<lang ruby>class Door\n\tattr_reader :state\n\tdef initialize\n\t\t@state=:closed\n\tend\n\t\n\tdef close; @state=:closed; end\n\tdef open; @state=:open; end\n\t\n\tdef closed?; @state==:closed; end\n\tdef open?; @state==:open; end\n\t\n\tdef toggle\n\t\tif closed?\n\t\t\topen\n\t\telse\n\t\t\tclose\n\t\tend\n\tend\n\t\n\tdef to_s; @state.to_s; end\nend\n\ndoors=Array.new(100){Door.new}\n1.upto(100) do |multiplier|\n\tdoors.each_with_index do |door, i|\n\t\tdoor.toggle if (i+1)%multiplier==0\n\tend\nend\n\ndoors.each_with_index{|door, i| puts \"Door #{i+1} is #{door}.\"}<\/lang>\n\n'''unoptimized'''\n<lang ruby>n = 100\nOpen = \"open\"\nClosed = \"closed\"\ndef Open.f\n    Closed\nend\ndef Closed.f\n    Open\nend\ndoors = [Closed] * (n+1)\nfor mul in 1..n\n    for x in 1..n\n        doors[mul*x] = (doors[mul*x] || break).f\n    end\nend\ndoors.each_with_index {\n    |b, i|\n    puts \"Door #{i} is #{b}\" if i>0\n}<\/lang>\n\n'''optimized'''\n<lang ruby>n = 100\n(1..n).each do |i| \n    puts \"Door #{i} is #{i**0.5 == (i**0.5).round ? \"open\" : \"closed\"}\"\nend\n<\/lang>\n\n'''generic true\/false, with another way of handling the inner loop demonstrating Range#step'''\n<lang ruby>\ndoors = [false] * 100\n100.times do |i|\n  (i .. doors.length).step(i+1) do |j|\n    doors[j] = !doors[j]\n  end\nend\nputs doors.inspect\n\n<\/lang>\n\n==[[:Category:Run BASIC|Run BASIC]][[Category:Run BASIC]]==\n<lang Runbasic>dim doors(100)\nprint \"Open doors \";\nfor i = 1 to 100 \n    for door = i to 100 step i\n        doors(door) = (doors(door) <> 1)\n        if i = door and doors(door) = 1 then   print i;\" \";\n    next door\nnext i<\/lang>Output:\n<pre>Open doors 1 4 9 16 25 36 49 64 81 100<\/pre>\n\n==[[:Category:S-lang|S-lang]][[Category:S-lang]]==\n<lang s-lang>variable door,\n    isOpen = Char_Type [101],\n    pass;\n \nfor (door = 1; door <= 100; door++) {\n    isOpen[door] = 0;\n}\n \nfor (pass = 1; pass <= 100; pass++) {\n    for (door = pass; door <= 100; door += pass) {\n        isOpen[door] = not isOpen[door];\n    }\n}\n \nfor (door = 1; door <= 100; door++) {\n    if (isOpen[door]) {\n        print(\"Door \" + string(door) + \":open\");\n    } else {\n        print(\"Door \" + string(door) + \":close\");\n    }\n}<\/lang>\n\n==[[:Category:Salmon|Salmon]][[Category:Salmon]]==\nHere's an unoptimized version:\n<lang Salmon>variable open := <<(* --> false)>>;\nfor (pass; 1; pass <= 100)\n    for (door_num; pass; door_num <= 100; pass)\n        open[door_num] := !(open[door_num]);;;\niterate (door_num; [1...100])\n    print(\"Door \", door_num, \" is \",\n          (open[door_num] ? \"open.\\n\" : \"closed.\\n\"));;<\/lang>\n\nAnd here's an optimized one-line version:\n\n<lang Salmon>iterate (x; [1...10]) { iterate (y; [(x-1)*(x-1)+1...x*x-1]) { print(\"Door \", y, \" is closed.\\n\"); }; print(\"Door \", x*x, \" is open.\\n\"); };<\/lang>\n\nAnd a shorter optimized one-line version:\n\n<lang Salmon>variable y:=1;for(x;1;x<101)\"Door \"~sprint(x)~\" is \"~(x==y*y?{++y;return\"open\";}:\"closed\")!;<\/lang>\n\n==[[:Category:SAS|SAS]][[Category:SAS]]==\n<lang sas>data _null_;\n   open=1;\n   close=0;\n   array Door{100};\n   do Pass = 1 to 100;\n      do Current = Pass to 100 by Pass;\n         if Door{Current} ne open \n            then Door{Current} = open;\n            else Door{Current} = close;\n      end;\n   end;\n   NumberOfOpenDoors = sum(of Door{*});\n   put \"Number of Open Doors:  \" NumberOfOpenDoors; \nrun;<\/lang>\n\n==[[:Category:Scala|Scala]][[Category:Scala]]==\n<lang scala>for { i <- 1 to 100\n      r = 1 to 100 map (i % _ == 0) reduceLeft (_^_)                 \n    } println (i +\" \"+ (if (r) \"open\" else \"closed\"))<\/lang>\nThe map operation maps each door (i) to a boolean sequence of toggles, one for each pass: true toggles, false leaves the same.\n\nThe reduceLeft method combines all the toggles sequentially, using the XOR operator.\n\nAnd then we just need to output the result.\n\n\"Optimized\" version:\n<lang scala>val o = 1 to 10 map (i => i * i)\nprintln(\"open: \" + o)\nprintln(\"closed: \" + (1 to 100 filterNot o.contains))<\/lang>\n\n==[[:Category:Sather|Sather]][[Category:Sather]]==\n<lang sather>class MAIN is\n  main is\n    pass, door :INT;\n    doors :ARRAY{BOOL} := #(100);\n    loop \n      doors[0.upto!(99)] := false;\n    end;\n    pass := 0;\n    loop while!(pass < 100);\n      door := pass;\n      loop while! (door < 100);\n        doors[door] := ~doors[door];\n\tdoor := door + pass + 1\n      end;\n      pass := pass + 1;\n    end;\n    loop\n      door := 0.upto!(99);\n      #OUT + (door+1) + \" \" + doors[door] + \"\\n\";\n    end;\n  end;\nend;<\/lang>\n\n==[[:Category:Scheme|Scheme]][[Category:Scheme]]==\n'''unoptimized'''\n<lang scheme>(define *max-doors* 100)\n\n(define (show-doors doors)\n  (let door ((i 0)\n             (l (vector-length doors)))\n    (cond ((= i l) \n           (newline))\n          (else \n           (printf \"~nDoor ~a is ~a\" \n                   (+ i 1) \n                   (if (vector-ref doors i) \"open\" \"closed\"))\n           (door (+ i 1) l)))))\n\n(define (flip-doors doors)\n  (define (flip-all i)\n    (cond ((> i *max-doors*) doors)\n          (else \n           (let flip ((idx (- i 1)))\n             (cond ((>= idx *max-doors*) \n                    (flip-all (+ i 1))) \n                   (else \n                    (vector-set! doors idx (not (vector-ref doors idx)))\n                    (flip (+ idx i))))))))\n  (flip-all 1))\n\n(show-doors (flip-doors (make-vector *max-doors* #f)))<\/lang>\n\n'''optimized'''\n<lang scheme>(define (optimised-flip-doors doors)\n  (define (flip-all i)\n    (cond ((> i (floor (sqrt *max-doors*))) doors)\n          (else \n           (vector-set! doors (- (* i i) 1) #t)\n           (flip-all (+ i 1)))))\n  (flip-all 1))\n\n(show-doors (optimised-flip-doors (make-vector *max-doors* #f)))<\/lang>\n\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Racket]][[SMW::on]]<\/div> (moved from the Racket language entry, may be redundant) \n<lang scheme>#lang racket\n\n;; Like \"map\", but the proc must take an index as well as the element.\n(define (map-index proc seq)\n  (for\/list ([(elt i) (in-indexed seq)])\n    (proc elt i)))\n\n;; Applies PROC to every STEPth element of SEQ, leaving the others\n;; unchanged.\n(define (map-step proc step seq)\n  (map-index\n   (lambda (elt i)\n     ((if (zero? (remainder i step) )\n          proc\n          values) elt))\n   seq))\n\n(define (toggle-nth n seq)\n  (map-step not n seq))\n\n(define (solve seq)\n  (for\/fold ([result seq])\n      ([(_ pass) (in-indexed  seq)])\n      (toggle-nth (add1 pass) result)))\n\n(for ([(door index) (in-indexed (solve (make-vector 100 #f)))])\n  (when door\n    (printf \"~a is open~%\" index)))<\/lang>\n\noptimized:\n\n<lang scheme>#lang racket\n\n(for-each (lambda (x) (printf \"~a is open\\n\" x))\n            (filter (lambda (x)\n                      (exact-integer? (sqrt x)))\n                    (sequence->list (in-range 1 101))))<\/lang>\n\n\n==[[:Category:Seed7|Seed7]][[Category:Seed7]]==\n'''unoptimized'''\n<lang seed7>$ include \"seed7_05.s7i\";\n \nconst proc: main is func\n  local\n    var array boolean: doorOpen is 100 times FALSE;\n    var integer: pass is 0;\n    var integer: index is 0;\n    var array[boolean] string: closedOrOpen is [boolean] (\"closed\", \"open\");\n  begin\n    for pass range 1 to 100 do\n      for key index range doorOpen do\n        if index rem pass = 0 then\n          doorOpen[index] := not doorOpen[index];\n        end if;\n      end for;\n    end for;\n    for key index range doorOpen do\n      write(index lpad 3 <& \" is \" <& closedOrOpen[doorOpen[index]] rpad 7);\n      if index rem 5 = 0 then\n        writeln;\n      end if;\n    end for;\n  end func;<\/lang>\n\n'''optimized'''\n<lang seed7>$ include \"seed7_05.s7i\";\n\nconst proc: main is func\n  local\n    var integer: index is 0;\n    var integer: number is 0;\n    var array[boolean] string: closedOrOpen is [boolean] (\"closed\", \"open\");\n  begin\n    for index range 1 to 100 do\n      number := sqrt(index);\n      write(index lpad 3 <& \" is \" <& closedOrOpen[number**2 = index] rpad 7);\n      if index rem 5 = 0 then\n        writeln;\n      end if;\n    end for;\n  end func;<\/lang>\n\nOutput of both programs:\n<pre>\n  1 is open     2 is closed   3 is closed   4 is open     5 is closed \n  6 is closed   7 is closed   8 is closed   9 is open    10 is closed \n 11 is closed  12 is closed  13 is closed  14 is closed  15 is closed \n 16 is open    17 is closed  18 is closed  19 is closed  20 is closed \n 21 is closed  22 is closed  23 is closed  24 is closed  25 is open   \n 26 is closed  27 is closed  28 is closed  29 is closed  30 is closed \n 31 is closed  32 is closed  33 is closed  34 is closed  35 is closed \n 36 is open    37 is closed  38 is closed  39 is closed  40 is closed \n 41 is closed  42 is closed  43 is closed  44 is closed  45 is closed \n 46 is closed  47 is closed  48 is closed  49 is open    50 is closed \n 51 is closed  52 is closed  53 is closed  54 is closed  55 is closed \n 56 is closed  57 is closed  58 is closed  59 is closed  60 is closed \n 61 is closed  62 is closed  63 is closed  64 is open    65 is closed \n 66 is closed  67 is closed  68 is closed  69 is closed  70 is closed \n 71 is closed  72 is closed  73 is closed  74 is closed  75 is closed \n 76 is closed  77 is closed  78 is closed  79 is closed  80 is closed \n 81 is open    82 is closed  83 is closed  84 is closed  85 is closed \n 86 is closed  87 is closed  88 is closed  89 is closed  90 is closed \n 91 is closed  92 is closed  93 is closed  94 is closed  95 is closed \n 96 is closed  97 is closed  98 is closed  99 is closed 100 is open   \n<\/pre>\n\n==[[:Category:SETL|SETL]][[Category:SETL]]==\n'''Unoptimized'''\n<lang setl>program hundred_doors;\n\nconst toggle := {['open', 'closed'], ['closed', 'open']};\n\ndoorStates := ['closed'] * 100;\n\n(for interval in [1..100])\n  doorStates := [if i mod interval = 0 then\n                    toggle(prevState) else\n                    prevState end:\n                 prevState = doorStates(i)];\nend;\n\n(for finalState = doorStates(i))\n  print('door', i, 'is', finalState);\nend;\n\nend program;<\/lang>\nIf 'open' weren't a reserved word, we could omit the single quotes around it.\n\n'''Optimized'''\nExploits the fact that squares are separated by successive odd numbers.  Use array replication to insert the correct number of closed doors in between the open ones.\n<lang setl>program hundred_doors;\n\ndoorStates := (+\/ [['closed'] * oddNum with 'open': oddNum in [1,3..17]]);\n\n(for finalState = doorStates(i))\n  print('door', i, 'is', finalState);\nend;\n\nend program;<\/lang>\n\n==[[:Category:Slate|Slate]][[Category:Slate]]==\n'''Unoptimized'''\n<lang slate>define: #a -> (Array newSize: 100).\na infect: [| :_ | False].\n\na keysDo: [| :pass |\n  pass to: a indexLast by: pass do: [| :door |\n    a at: door infect: #not `er]].\n\na keysAndValuesDo: [| :door :isOpen |\n  inform: 'door #' ; door ; ' is ' ; (isOpen ifTrue: ['open'] ifFalse: ['closed'])].<\/lang>\n\n'''Optimized'''\n<lang slate>define: #a -> (Array newSize: 100).\na infect: [| :_ | False].\n\n0 below: 10 do: [| :door | a at: door squared put: True].\na keysAndValuesDo: [| :door :isOpen |\n  inform: 'door #' ; door ; ' is ' ; (isOpen ifTrue: ['open'] ifFalse: ['closed'])].<\/lang>\n\n==[[:Category:Smalltalk|Smalltalk]][[Category:Smalltalk]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[GNU Smalltalk]][[SMW::on]]<\/div>\n'''Unoptimized'''\n<lang smalltalk>|a|\na := Array new: 100 .\n1 to: 100 do: [ :i | a at: i put: false ].\n\n1 to: 100 do: [ :pass |\n  pass to: 100 by: pass do: [ :door |\n    a at: door put: (a at: door) not .\n  ]\n].\n\n\"output\"\n1 to: 100 do: [ :door |\n   ( 'door #%1 is %2' %\n     { door . (a at: door) ifTrue: [ 'open' ] ifFalse: [ 'closed' ] } ) displayNl\n]<\/lang>\n'''Optimized'''\n\n<lang smalltalk>|a|\na := (1 to: 100) collect: [ :x | false ].\n1 to: 10 do: [ :i | a at: (i squared) put: true ].\n1 to: 100 do: [ :i |\n   ( 'door #%1 is %2' % { i . \n           (a at: i) ifTrue: [ 'open' ] \n                     ifFalse: [ 'closed' ] }\n   ) displayNl\n]<\/lang>\n\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Squeak Smalltalk]][[SMW::on]]<\/div>\n'''Unoptimized, using Morphs'''\n<lang smalltalk>\n| m w h smh smw delay closedDoor border subMorphList |\n\nclosedDoor := Color black.\nborder := Color veryLightGray.\ndelay := Delay forMilliseconds: 50.\nw := World bounds corner x.\nh := (World bounds corner y) \/ 2.\nsmw := w\/100.\nsmh := h\/2.\n\nm := BorderedMorph new position: 0@h.\nm height: smh; width: w; borderColor: border.\nm color: Color veryLightGray.\n\n1 to: 100 do: [ :pos || sm |\n\tsm := BorderedMorph new height: smh ; width: smw ; \n\t\tborderColor: border; color: closedDoor; \n\t\tposition: (smw*pos)@h.\n\tm addMorph: sm asElementNumber: pos].\n\nm openInWorld.\ndelay wait.\nsubMorphList := m submorphs.\n\"display every step\"\n[1 to: 100 do: [ :step |\n\tstep to: 100 by: step do: [ :pos | | subMorph |\n\t\tsubMorph := subMorphList at: pos.\n\t\tsubMorph color: subMorph color negated.\n\t\tdelay wait]]] fork. \n<\/lang>\n\n==[[:Category:SNOBOL4|SNOBOL4]][[Category:SNOBOL4]]==\n\n'''unoptimized'''\n<lang snobol4>\n\t\tDEFINE('PASS(A,I),O')\t\t:(PASS.END)\nPASS\t\tO = 0\nPASS.LOOP\tO = O + I\n\t\tEQ(A<O>,1)\t\t\t:S(PASS.1)F(PASS.0)\nPASS.0\t\tA<O> = 1\t\t\t:S(PASS.LOOP)F(RETURN)\nPASS.1\t\tA<O> = 0\t\t\t:S(PASS.LOOP)F(RETURN)\nPASS.END\n \nMAIN\t\tD = ARRAY(100,0)\n\t\tI = 0\n \nMAIN.LOOP\tI = LE(I,100) I + 1\t\t:F(OUTPUT)\n\t\tPASS(D,I)\t\t\t:(MAIN.LOOP)\n \nOUTPUT\t\tI = 1 ; OPEN = 'Opened doors are: '\nOUTPUT.LOOP\tOPEN = OPEN EQ(D<I>,1) \" \" I\n\t\tI = LE(I,100) I + 1\t\t:S(OUTPUT.LOOP)F(OUTPUT.WRITE)\nOUTPUT.WRITE\tOUTPUT = OPEN\n\nEND\n<\/lang>\n\nA run of this using CSNOBOL4 looks like this:\n<code><pre>\n$ snobol4 100doors.sno \nThe Macro Implementation of SNOBOL4 in C (CSNOBOL4) Version 1.3+\n    by Philip L. Budne, January 23, 2011\nSNOBOL4 (Version 3.11, May 19, 1975)\n    Bell Telephone Laboratories, Incorporated\n\nNo errors detected in source program\n\nOpened doors are:  1 4 9 16 25 36 49 64 81 100\nNormal termination at level 0\n100doors.sno:18: Last statement executed was 19\n<\/pre><\/code>\n\n(There are command flags to remove the header and the summary, but these have been left in to keep the original SNOBOL4 experience intact.)\n\n'''optimized'''\n<lang snobol4>\nMAIN\t\tD = ARRAY(100,0)\n\t\tI = 1\n\nMAIN.LOOP\tLE(I, 10)\t\t\t:F(OUTPUT)\n\t\tD<I ** 2> = 1\t\t\n\t\tI = I + 1\t\t\t:(MAIN.LOOP)\n\nOUTPUT\t\tI = 1 ; O = 'Opened doors are: '\nOUTPUT.LOOP\tO = O EQ(D<I>,1) \" \" I\n\t\tI = LE(I,100) I + 1\t\t:S(OUTPUT.LOOP)F(OUTPUT.WRITE)\nOUTPUT.WRITE\tOUTPUT = O\nEND\n<\/lang>\n\nThe output of this version is almost identical to the above.\n\n==[[:Category:Tcl|Tcl]][[Category:Tcl]]==\n\n'''unoptimized'''\n\n<lang tcl>package require Tcl 8.5\nset n 100\nset doors [concat - [lrepeat $n 0]]\nfor {set step 1} {$step <= $n} {incr step} {\n    for {set i $step} {$i <= $n} {incr i $step} {\n        lset doors $i [expr { ! [lindex $doors $i]}]\n    }\n}\nfor {set i 1} {$i <= $n} {incr i} {\n    puts [format \"door %d is %s\" $i [expr {[lindex $doors $i] ? \"open\" : \"closed\"}]]\n}<\/lang>\n\n'''optimized'''\n\n<lang tcl>package require Tcl 8.5\nset doors [lrepeat [expr {$n + 1}] closed]\nfor {set i 1} {$i <= sqrt($n)} {incr i} {\n    lset doors [expr {$i ** 2}] open\n}\nfor {set i 1} {$i <= $n} {incr i} {\n    puts [format \"door %d is %s\" $i [lindex $doors $i]]\n}<\/lang>\n\n'''graphical'''\n\n<div class=\"examplemeta libheader\">'''Library:''' [[SMW::off]][[:Category:Tk|Tk]][[Category:Tk]][[SMW::on]]<\/div>\nInspired by the E solution, here's a visual representation\n<lang tcl>package require Tcl 8.5\npackage require Tk\n\narray set door_status {}\n\n# create the gui\nset doors [list x]\nfor {set i 0} {$i < 10} {incr i} {\n    for {set j 0} {$j < 10} {incr j} {\n        set k [expr {1 + $j + 10*$i}]\n        lappend doors [radiobutton .d_$k -text $k -variable door_status($k) \\\n                         -indicatoron no -offrelief flat -width 3 -value open]\n        grid [lindex $doors $k] -column $j -row $i\n    }\n}\n\n# create the controls\nbutton .start -command go -text Start\nlabel .i_label -text \" door:\"\nentry .i -textvariable i -width 4\nlabel .step_label -text \" step:\"\nentry .step -textvariable step -width 4\ngrid .start - .i_label - .i - .step_label - .step - -row $i\ngrid configure .start -sticky ew\ngrid configure .i_label .step_label -sticky e\ngrid configure .i .step -sticky w\n\nproc go {} {\n    global doors door_status i step\n\n    # initialize the door_status (all closed)\n    for {set d 1} {$d <= 100} {incr d} {\n        set door_status($d) closed\n    }\n    \n    # now, begin opening and closing\n    for {set step 1} {$step <= 100} {incr step} {\n        for {set i 1} {$i <= 100} {incr i} {\n            if {$i % $step == 0} {\n                [lindex $doors $i] [expr {$door_status($i) eq \"open\" ? \"deselect\" : \"select\"}]\n                update\n                after 50\n            }\n        }\n    }\n}<\/lang>\n\n==[[:Category:TI-83 BASIC|TI-83 BASIC]][[Category:TI-83 BASIC]]==\n===Unoptimized===\n<lang ti83b>PROGRAM:DOORS100\n:ClrHome\n:Disp \"SETTING UP LIST\"\n:Disp \"PLEASE WAIT...\"\n:For(I,1,100,1)\n:0\u2192L1(I)\n:End\n:ClrHome\n:Disp \"Pass\"\n:For(I,1,100,1)\n:For(J,I,100,I)\n:Output(2,1,I)\n:not(L1(J))\u2192L1(J)\n:End\n:End\n:ClrHome\n<\/lang>\n===Optimized===\n<lang ti83b>PROGRAM:DOORSOPT\n:For(I,1,100,1)\n:not(fPart(\u221a(I)))\u2192L1(I)\n:End\n<\/lang>\n\n\n==[[:Category:TI-89 BASIC|TI-89 BASIC]][[Category:TI-89 BASIC]]==\n<lang ti89b>Define doors(fast) = Func\n  Local doors,i,j\n  seq(false,x,1,100) \u2192 doors\n  If fast Then\n    For i,1,10,1\n      true \u2192 doors[i^2]\n    EndFor\n  Else\n    For i,1,100,1\n      For j,i,100,i\n        not doors[j] \u2192 doors[j]\n      EndFor\n    EndFor\n  EndIf\n  Return doors\nEndFunc<\/lang>\n\n==[[:Category:TUSCRIPT|TUSCRIPT]][[Category:TUSCRIPT]]==\n<lang tuscript>\n$$ MODE TUSCRIPT\nDICT doors create\nCOMPILE\nLOOP door=1,100\n LOOP pass=1,100\n SET go=MOD (door,pass)\n DICT doors lookup door,num,cnt,status\n   IF (num==0) THEN\n     SET status=\"open\"\n     DICT doors add  door,num,cnt,status\n   ELSE\n    IF (go==0) THEN\n       IF (status==\"closed\") THEN\n         SET status=\"open\"\n       ELSE\n         SET status=\"closed\"\n       ENDIF\n     DICT doors update door,num,cnt,status\n     ENDIF\n   ENDIF\n ENDLOOP\nENDLOOP\nENDCOMPILE\nDICT doors unload door,num,cnt,status\n<\/lang>\nOutput (variable status):\n<pre style=\"height:30ex;overflow:scroll\">\n status       = *\n           1 = open\n           2 = closed\n           3 = closed\n           4 = open\n           5 = closed\n           6 = closed\n           7 = closed\n           8 = closed\n           9 = open\n          10 = closed\n          11 = closed\n          12 = closed\n          13 = closed\n          14 = closed\n          15 = closed\n          16 = open\n          17 = closed\n          18 = closed\n          19 = closed\n          20 = closed\n          21 = closed\n          22 = closed\n          23 = closed\n          24 = closed\n          25 = open\n          26 = closed\n          27 = closed\n          28 = closed\n          29 = closed\n          30 = closed\n          31 = closed\n          32 = closed\n          33 = closed\n          34 = closed\n          35 = closed\n          36 = open\n          37 = closed\n          38 = closed\n          39 = closed\n          40 = closed\n          41 = closed\n          42 = closed\n          43 = closed\n          44 = closed\n          45 = closed\n          46 = closed\n          47 = closed\n          48 = closed\n          49 = open\n          50 = closed\n          51 = closed\n          52 = closed\n          53 = closed\n          54 = closed\n          55 = closed\n          56 = closed\n          57 = closed\n          58 = closed\n          59 = closed\n          60 = closed\n          61 = closed\n          62 = closed\n          63 = closed\n          64 = open\n          65 = closed\n          66 = closed\n          67 = closed\n          68 = closed\n          69 = closed\n          70 = closed\n          71 = closed\n          72 = closed\n          73 = closed\n          74 = closed\n          75 = closed\n          76 = closed\n          77 = closed\n          78 = closed\n          79 = closed\n          80 = closed\n          81 = open\n          82 = closed\n          83 = closed\n          84 = closed\n          85 = closed\n          86 = closed\n          87 = closed\n          88 = closed\n          89 = closed\n          90 = closed\n          91 = closed\n          92 = closed\n          93 = closed\n          94 = closed\n          95 = closed\n          96 = closed\n          97 = closed\n          98 = closed\n          99 = closed\n         100 = open\n<\/pre>\n\n==[[:Category:TXR|TXR]][[Category:TXR]]==\n<lang txr>@(do (defun 100-doors ()\n       (let ((doors (vector 100)))\n         (each ((i (range 0 99)))\n           (for ((j i)) ((< j 100)) ((inc j (+ i 1)))\n             (flip [doors j])))\n         doors))\n     (each ((counter (range 1))\n            (door (list-vector (100-doors))))\n        (format t \"door ~a is ~a\\n\" counter (if door \"open\" \"closed\"))))<\/lang>\n\n==[[:Category:UNIX Shell|UNIX Shell]][[Category:UNIX Shell]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Bourne Again SHell]][[SMW::on]]<\/div>\n<lang bash>#! \/bin\/bash\n\ndeclare -a doors\nfor((i=1; i <= 100; i++)); do\n    doors[$i]=0\ndone\n\nfor((i=1; i <= 100; i++)); do\n    for((j=i; j <= 100; j += i)); do\n\techo $i $j\n\tdoors[$j]=$(( doors[j] ^ 1 ))\n    done\ndone\n\nfor((i=1; i <= 100; i++)); do\n    if [[ ${doors[$i]} -eq 0 ]]; then\n\top=\"closed\"\n    else\n\top=\"open\"\n    fi\n    echo $i $op\ndone<\/lang>\n\nOptimised version\n<lang bash>#!\/bin\/bash\n\nfor i in {1..100}; do\n  door[$i*$i]=1\n  [ -z ${door[$i]} ] && echo \"$i closed\" || echo \"$i open\"\ndone<\/lang>\n\n==[[:Category:Ursala|Ursala]][[Category:Ursala]]==\n\nThe doors are represented as a list of 100 booleans initialized to false. The pass function takes a number and a door list to a door list with doors toggled at indices that are multiples of the number. The main program folds the pass function (to the right) over the list of pass numbers from 100 down to 1, numbers the result, and filters out the numbers of the open doors.\n<lang Ursala>#import std\n#import nat\n\ndoors = 0!* iota 100\n\npass(\"n\",\"d\") = remainder\\\"n\"?l(~&r,not ~&r)* num \"d\"\n\n#cast %nL\n\nmain = ~&rFlS num pass=>doors nrange(100,1)<\/lang>\noptimized version:\n<lang Ursala>#import nat\n\n#cast %nL\n\nmain = product*tiiXS iota10<\/lang>\noutput:\n<pre>\n<1,4,9,16,25,36,49,64,81>\n<\/pre>\n\n==[[:Category:Vala|Vala]][[Category:Vala]]==\n'''Unoptimized'''\n<lang vala>int main() {\n\tbool doors_open[101];\n\tfor(int i = 1; i < doors_open.length; i++) {\n\t\tfor(int j = 1; i*j < doors_open.length; j++) {\n\t\t\tdoors_open[i*j] = !doors_open[i*j];\n\t\t}\n\t\tstdout.printf(\"%d: %s\\n\", i, (doors_open[i] ? \"open\" : \"closed\"));\n\t}\n\treturn 0;\n}<\/lang>\nOutput:\n<pre>1: open\n2: closed\n3: closed\n4: open\n5: closed\n6: closed\n7: closed\n8: closed\n9: open\n10: closed\n11: closed\n...<\/pre>\n'''Optimized'''\n<lang vala>int main() {\n\tint i = 1;\n\twhile(i*i <= 100) {\n\t\tstdout.printf(\"${i*i} open\\n\");\n\t\ti++;\n\t}\n\treturn 0;\n}<\/lang>\nOutput:\n<pre>1 open\n4 open\n9 open\n16 open\n25 open\n36 open\n49 open\n64 open\n81 open\n100 open<\/pre>\n\n==[[:Category:VBScript|VBScript]][[Category:VBScript]]==\n\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Windows Script Host]] version 5.7[[SMW::on]]<\/div>\n'''Unoptimized'''\n<lang VBScript>Dim doorIsOpen(100), pass, currentDoor, text\n\nFor currentDoor = 0 To 99\n\tdoorIsOpen(currentDoor) = False\nNext\n\nFor pass = 0 To 99\n\tFor currentDoor = pass To 99 Step pass + 1\n\t\tdoorIsOpen(currentDoor) = Not doorIsOpen(currentDoor)\n\tNext\nNext\n\nFor currentDoor = 0 To 99\n\ttext = \"Door #\" & currentDoor + 1 & \" is \"\n\tIf doorIsOpen(currentDoor) Then\n\t\ttext = text & \"open.\"\n\tElse\n\t\ttext = text & \"closed.\"\n\tEnd If\n\tWScript.Echo(text)\nNext<\/lang>\n\n\n==[[:Category:Vedit macro language|Vedit macro language]][[Category:Vedit macro language]]==\n'''Unoptimized'''\nThis implementation uses a free edit buffer as data array and for displaying the results.<br>\nA closed door is represented by a character <tt>'-'<\/tt> and an open door by character <tt>'O'<\/tt>.\n<lang vedit>Buf_Switch(Buf_Free)\nIns_Char('-', COUNT, 100)                      \/\/ All doors closed\nfor (#1 = 1; #1 <= 100; #1++) {\n    for (#2 = #1; #2 <= 100; #2 += #1) {\n        Goto_Col(#2)\n        Ins_Char((Cur_Char^0x62), OVERWRITE)   \/\/ Toggle between '-' and 'O'\n    }\n}<\/lang>\n\n'''Optimized'''\n<lang vedit>Buf_Switch(Buf_Free)\nIns_Char('-', COUNT, 100)\nfor (#1=1; #1 <= 10; #1++) {\n    Goto_Col(#1*#1)\n    Ins_Char('O', OVERWRITE)\n}<\/lang>\n\nOutput:\n<pre>\nO--O----O------O--------O----------O------------O--------------O----------------O------------------O\n<\/pre>\n\n==[[:Category:VHDL|VHDL]][[Category:VHDL]]==\n'''unoptimized'''\n<lang vhdl>library IEEE;\nuse IEEE.STD_LOGIC_1164.ALL;\n\nentity DOORS is\n\tport (CLK: in std_logic; OUTPUT: out std_logic_vector(1 to 100));\nend DOORS;\n\narchitecture Behavioral of DOORS is\nbegin\n\tprocess (CLK)\n\tvariable TEMP: std_logic_vector(1 to 100);\n\tbegin\n\t\t--setup closed doors\n\t\tTEMP := (others => '0');\n\t\t\n\t\t--looping through\n\t\tfor i in 1 to TEMP'length loop\n\t\t\tfor j in i to TEMP'length loop\n\t\t\t\tif (j mod i) = 0 then\n\t\t\t\t\tTEMP(j) := not TEMP(j);\n\t\t\t\tend if;\n\t\t\tend loop;\n\t\tend loop;\n\t\t\n\t\t--assign output\n\t\tOUTPUT <= TEMP;\n\tend process;\nend Behavioral;\n<\/lang>\n\n==[[:Category:Visual Basic .NET|Visual Basic .NET]][[Category:Visual Basic .NET]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Visual Basic .NET]] version 9.0+[[SMW::on]]<\/div>\n'''unoptimized'''\n<lang vbnet>Module Module1\n\n   Sub Main()\n       Dim doors(100) As Boolean 'Door 1 is at index 0\n\n       For pass = 1 To 100\n           For door = pass - 1 To 99 Step pass\n               doors(door) = Not doors(door)\n           Next\n       Next\n\n       For door = 0 To 99\n           Console.WriteLine(\"Door # \" & (door + 1) & \" is \" & If(doors(door), \"Open\", \"Closed\"))\n       Next\n\n       Console.ReadLine()\n   End Sub\n\nEnd Module<\/lang>\n'''optimized'''\n<lang vbnet>Module Module1\n\n   Sub Main()\n       Dim doors(100) As Boolean 'Door 1 is at index 0\n\n       For i = 1 To 10\n           doors(i ^ 2 - 1) = True\n       Next\n\n       For door = 0 To 99\n           Console.WriteLine(\"Door # \" & (door + 1) & \" is \" & If(doors(door), \"Open\", \"Closed\"))\n       Next\n\n       Console.ReadLine()\n   End Sub\n\nEnd Module<\/lang>\n\n==[[:Category:Wrapl|Wrapl]][[Category:Wrapl]]==\n'''Unoptimized'''\n<lang wrapl>MOD Doors;\n\nIMP Agg.Table;\nIMP Std.String;\nIMP IO.Terminal USE Out;\n\nVAR door <- {}; EVERY door[1:to(100), \"closed\"];\n\nDEF toggle(num) door[num] <- door[num] = \"open\" => \"closed\" \/\/ \"open\";\n\nEVERY WITH pass <- 1:to(100), num <- pass:to(100, pass) DO toggle(num);\n\nOut:write('Doors {door @ String.T}.');\n\nEND Doors.<\/lang>\n'''Optimized'''\n<lang wrapl>MOD Doors;\n\nIMP IO.Terminal USE Out;\n\nDEF open <- ALL 1:to(100) ^ 2 \\ $ <= 100;\nDEF closed <- ALL 1:to(100) \\ NOT $ IN open;\n\nOut:write('Doors {open} are open.\\n');\nOut:write('Doors {closed} are closed.\\n');\n\nEND Doors.<\/lang>\n\n==[[:Category:XPL0|XPL0]][[Category:XPL0]]==\n<lang XPL0>include c:\\cxpl\\codes;          \\intrinsic 'code' declarations\nint     Door(100);              \\You have 100 doors in a row\ndefine  Open, Closed;\nint     D, Pass, Step;\n\n[for D:= 0 to 100-1 do          \\that are all initially closed\n        Door(D):= Closed;\n\nStep:= 1;                       \\The first time through, you visit every door\nfor Pass:= 1 to 100 do          \\You make 100 passes by the doors\n        [D:= Step-1;\n        repeat  \\if the door is closed, you open it; if it is open, you close it\n                if Door(D)=Closed then Door(D):= Open else Door(D):= Closed;\n                D:= D+Step;\n        until   D>=100;\n        Step:= Step+1;          \\The second time you only visit every 2nd door\n        ];                      \\The third time, every 3rd door\n                                \\until you only visit the 100th door\n\\What state are the doors in after the last pass?\nText(0, \"Open: \");              \\Which are open?\nfor D:= 0 to 100-1 do \n        if Door(D)=Open then [IntOut(0, D+1); ChOut(0,^ )];\nCrLf(0);\n\nText(0, \"Closed: \");            \\Which are closed?\nfor D:= 0 to 100-1 do \n        if Door(D)=Closed then [IntOut(0, D+1); ChOut(0,^ )];\nCrLf(0);\n\n\\Optimized: The only doors that remain open are those that are perfect squares\nText(0, \"Open: \");\nD:= 1;\nrepeat  IntOut(0, D*D); ChOut(0,^ );\n        D:= D+1;\nuntil   D*D>100;\nCrLf(0);\n]<\/lang>\n\n==[[:Category:XSLT|XSLT]][[Category:XSLT]]==\nSee: [[100 doors\/XSLT]]\n\n==[[:Category:Yorick|Yorick]][[Category:Yorick]]==\n\n'''Unoptimized, iterative'''\n<lang yorick>doors = array(0, 100);\nfor(i = 1; i <= 100; i++)\n    for(j = i; j <= 100; j += i)\n        doors(j) ~= 1;\nprint, where(doors);<\/lang>\n\n'''Unoptimized, vectorized'''\n<lang yorick>doors = array(0, 100);\nfor(i = 1; i <= 100; i++)\n    doors(i::i) ~= 1;\nprint, where(doors);<\/lang>\n\n'''Optimized'''\n<lang yorick>print, indgen(1:long(sqrt(100)))^2<\/lang>\n\nAll of the above output:\n<pre>\n[1,4,9,16,25,36,49,64,81,100]\n<\/pre>\n\n[[Category:GUISS\/Omit]]"}]}}}}