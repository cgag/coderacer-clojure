{"query":{"pages":{"8846":{"pageid":8846,"ns":0,"title":"Anonymous recursion","revisions":[{"*":"<div class=\"infobox\" style=\"width: 2in\">[[File:Rcode-button-task-crushed.png|64px|left|alt=Task|link=Category:Solutions by Programming Task]]'''Anonymous recursion'''<br\/>\nYou are encouraged to [[Rosetta Code:Solve a Task|solve this task]] according to the task description, using any language you may know.[[Category:Programming Tasks]][[Category:Recursion]]<\/div>\nWhile implementing a recursive function, it often happens that we must resort to a separate \"helper function\" to handle the actual recursion.\n\nThis is usually the case when directly calling the current function would waste too many resources (stack space, execution time), cause unwanted side-effects, and\/or the function doesn't have the right arguments and\/and return values.\n\nSo we end up inventing some silly name like \"foo2\" or \"foo_helper\". I have always found it painful to come up with a proper name, and see a quite some disadvantages:\n\n* You have to think up a name, which then pollutes the namespace\n* A function is created which is called from nowhere else\n* The program flow in the source code is interrupted\n\nSome languages allow you to embed recursion directly in-place. This might work via a label, a local ''gosub'' instruction, or some special keyword.\n\nAnonymous recursion can also be accomplished using the [[Y combinator]].\n\nIf possible, demonstrate this by writing the recursive version of the fibonacci function (see [[Fibonacci sequence]]) which checks for a negative argument before doing the actual recursion.\n\n==[[:Category:Ada|Ada]][[Category:Ada]]==\nIn Ada you can define functions local to other functions\/procedures. This makes it invisible to outside and prevents namespace pollution.\n\nBetter would be to use type Natural instead of Integer, which lets Ada do the magic of checking the valid range.\n<lang Ada>   function Fib (X: in Integer) return Integer is\n      function Actual_Fib (N: in Integer) return Integer is\n      begin\n         if N < 2 then\n            return N;\n         else\n            return Actual_Fib (N-1) + Actual_Fib (N-2);\n         end if;\n      end Actual_Fib;\n   begin\n      if X < 0 then\n         raise Constraint_Error;\n      else\n         return Actual_Fib (X);\n      end if;\n   end Fib;<\/lang>\n\n==[[:Category:AutoHotkey|AutoHotkey]][[Category:AutoHotkey]]==\n{| class=\"messagebox\" style=\"text-align: center; background-color: #ffc8c8; clear: both;\"\n| This example is '''incorrect'''.  The check for a negative argument is not outside the recursion.  Please fix the code and remove this message.\n|}[[Category:AutoHotkey examples needing attention]][[Category:Examples needing attention]]\n\nIf:\n<lang ahk>fib(n)\n{       if(n < 0)\n                return error\n        else if(n < 2)\n                return 1\n        else\n                return n * fib(n-1)\n}<\/lang>\nTernary:\n<lang ahk>fib(n)\n{       return n < 0 ? \"error\" : n < 2 ? 1 : n * fib(n-1)\n}<\/lang>\n\n==[[:Category:Bracmat|Bracmat]][[Category:Bracmat]]==\n===lambda 'light'===\nThe first solution uses macro substitution. In an expression headed by an apostrophe operator with an empty lhs all subexpressions headed by a dollar operator with empty lhs are replaced by the values that the rhs are bound to, without otherwise evaluating the expression. Example: if <code>(x=7) & (y=4)<\/code> then <code>'($x+3+$y)<\/code> becomes <code>=7+3+4<\/code>. Notice that the solution below utilises no other names than <code>arg<\/code>, the keyword that always denotes a function's argument. The test for negative or non-numeric arguments is outside the recursive part. The function fails if given negative input.\n<lang bracmat>( (\n  =\n    .   !arg:#:~<0\n      &   ( (=.!arg$!arg)\n          $ (\n            =\n              .\n                ' (\n                  .   !arg:<2\n                    |   (($arg)$($arg))$(!arg+-2)\n                      + (($arg)$($arg))$(!arg+-1)\n                  )\n            )\n          )\n        $ !arg\n  )\n$ 30\n)\n<\/lang>\nAnswer:\n<pre>832040<\/pre>\n===pure lambda calculus===\n(See http:\/\/en.wikipedia.org\/wiki\/Lambda_calculus). The following solution works almost the same way as the previous solution, but uses lambda calculus\n<lang bracmat>( \/(\n   ' ( x\n     .   $x:#:~<0\n       &   ( \/('(f.($f)$($f)))\n           $ \/(\n              ' ( r\n                . \/(\n                   ' ( n\n                     .   $n:<2\n                       |   (($r)$($r))$($n+-2)\n                         + (($r)$($r))$($n+-1)\n                     )\n                   )\n                )\n              )\n           )\n         $ ($x)\n     )\n   )\n$ 30\n)<\/lang>\nAnswer:\n<pre>832040<\/pre>\n\n==[[:Category:C|C]][[Category:C]]==\nUsing scoped function fib_i inside fib, with GCC:\n<lang C>#include <stdio.h>\n\nlong fib(long x)\n{\n        long fib_i(long n) { return n < 2 ? n : fib_i(n - 2) + fib_i(n - 1); };\n        if (x < 0) {\n                printf(\"Bad argument: fib(%ld)\\n\", x);\n                return -1;\n        }\n        return fib_i(x);\n}\n\nlong fib_i(long n) \/* just to show the fib_i() inside fib() has no bearing outside it *\/\n{\n        printf(\"This is not the fib you are looking for\\n\");\n        return -1;\n}\n\nint main()\n{\n        long x;\n        for (x = -1; x < 4; x ++)\n                printf(\"fib %ld = %ld\\n\", x, fib(x));\n\n        printf(\"calling fib_i from outside fib:\\n\");\n        fib_i(3);\n\n        return 0;\n}<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>Bad argument: fib(-1)\nfib -1 = -1\nfib 0 = 0\nfib 1 = 1\nfib 2 = 1\nfib 3 = 2\ncalling fib_i from outside fib:\nThis is not the fib you are looking for<\/pre>\n\n==[[:Category:C++|C++]][[Category:C++]]==\nIn C++ (as of the 2003 version of the standard, possibly earlier), we can declare class within a function scope. By giving that class a public static member function, we can create a function whose symbol name is only known to the function in which the class was derived.\n<lang cpp>double fib(const double n)\n{\n  if(n < 0)\n  {\n    throw \"Invalid argument passed to fib\";\n  }\n  else\n  {\n    class actual_fib\n    {\n      public:\n        static double calc(const double n)\n        {\n          if(n < 2)\n          {\n            return n;\n          }\n          else\n          {\n            return calc(n-1) + calc(n-2);\n          }\n        }\n    };\n\n    return actual_fib::calc(n);\n  }\n}<\/lang>\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[C++11]][[SMW::on]]<\/div>\n<lang cpp>#include <functional>\nusing namespace std;\n\ndouble fib(double n)\n{\n  if(n < 0)\n    throw \"Invalid argument\";\n  \n  function<double(double)> actual_fib = [&](double n)\n  {\n    if(n < 2) return n;\n    return actual_fib(n-1) + actual_fib(n-2);\n  };\n\n  return actual_fib(n);\n}<\/lang>\n\n==[[:Category:Clojure|Clojure]][[Category:Clojure]]==\nThe JVM as of now has no Tail call optimization so the default way of looping in Clojure uses anonymous recursion so not to be confusing.\n<lang clojure>\n(defn fib [n]\n  (when (neg? n)\n    (throw (new IllegalArgumentException \"n should be > 0\")))\n  (loop [n n, v1 1, v2 1] \n    (if (< n 2)\n      v2\n      (recur (dec n) v2 (+ v1 v2)))))\n<\/lang>\nUsing an anonymous function\n\n==[[:Category:CoffeeScript|CoffeeScript]][[Category:CoffeeScript]]==\n<lang coffeescript># This is a rather obscure technique to have an anonymous\n# function call itself.\nfibonacci = (n) ->\n  throw \"Argument cannot be negative\" if n < 0\n  do (n) ->\n      return n if n <= 1\n      arguments.callee(n-2) + arguments.callee(n-1)\n\n# Since it's pretty lightweight to assign an anonymous\n# function to a local variable, the idiom below might be\n# more preferred.\nfibonacci2 = (n) ->\n  throw \"Argument cannot be negative\" if n < 0\n  recurse = (n) ->\n      return n if n <= 1\n      recurse(n-2) + recurse(n-1)\n  recurse(n)\n<\/lang>\n\n==[[:Category:Common Lisp|Common Lisp]][[Category:Common Lisp]]==\n\n===Using labels===\n\nThis puts a function in a local label. The function is not anonymous, but the name <tt>fib1<\/tt> is local and never pollutes the outside namespace.\n<lang lisp>(defun fib (number)\n  \"Fibonacci sequence function.\"\n  (if (< number 0)\n      (error \"Error. The number entered: ~A is negative\" number)\n      (labels ((fib1 (n a b)\n                 (if (= n 0)\n                     a\n                     (fib1 (- n 1) b (+ a b)))))\n        (fib1 number 0 1))))<\/lang>\nAlthough name space polution isn't an issue, in recognition of the obvious convenience of anonymous recursive helpers, here is another solution: add the language feature for anonymously recursive blocks: the operator RECURSIVE, with a built-in local operator RECURSE to make recursive calls.\n\nHere is <code>fib<\/code> rewritten to use RECURSIVE:\n<lang lisp>(defun fib (number)\n  \"Fibonacci sequence function.\"\n  (if (< number 0)\n      (error \"Error. The number entered: ~A is negative\" number)\n      (recursive ((n number) (a 0) (b 1))\n         (if (= n 0)\n            a\n            (recurse (- n 1) b (+ a b))))))<\/lang>\nImplementation of RECURSIVE:\n<lang lisp>(defmacro recursive ((&rest parm-init-pairs) &body body)\n  (let ((hidden-name (gensym \"RECURSIVE-\")))\n    `(macrolet ((recurse (&rest args) `(,',hidden-name ,@args)))\n       (labels ((,hidden-name (,@(mapcar #'first parm-init-pairs)) ,@body))\n         (,hidden-name ,@(mapcar #'second parm-init-pairs))))))<\/lang>\nRECURSIVE works by generating a local function with LABELS, but with a machine-generated unique name. Furthermore, it provides syntactic sugar so that the initial call to the recursive function takes place implicitly, and the initial values are specified using LET-like syntax.  Of course, if RECURSIVE blocks are nested, each RECURSE refers to its own function. There is no way for an inner RECURSIVE to specify recursion to an other RECURSIVE. That is what names are for!\n\nExercises for reader:\n# In the original <code>fib<\/code>, the recursive local function can obtain a reference to itself using <code>#'fib<\/code>. This would allow it to, for instance, <code>(apply #'fib list-of-args)<\/code>. Add a way for RECURSIVE blocks to obtain a reference to themselves.\n# Add support for &optional and &rest parameters. Optional: also &key and &aux.\n# Add LOOPBACK operator whose syntax resembles RECURSE, but which simply assigns the variables and performs a branch back to the top rather than a recursive call.\n# Tail recursion optimization is compiler-dependent in Lisp. Modify RECURSIVE so that it walks the expressions and identifies tail-recursive RECURSE calls, rewriting these to use looping code. Be careful that unevaluated literal lists which resemble RECURSE calls are not rewritten, and that RECURSE calls belonging to any nested RECURSIVE invocation are not accidentally treated.\n\n===Using the Y combinator===\n\n<lang lisp>(setf (symbol-function '!)  (symbol-function 'funcall)\n      (symbol-function '!!) (symbol-function 'apply))\n\n(defmacro ? (args &body body)\n  `(lambda ,args ,@body))\n\n(defstruct combinator\n  (name     nil :type symbol)\n  (function nil :type function))\n\n(defmethod print-object ((combinator combinator) stream)\n  (print-unreadable-object (combinator stream :type t)\n    (format stream \"~A\" (combinator-name combinator))))\n\n(defconstant +y-combinator+\n  (make-combinator\n   :name     'y-combinator\n   :function (? (f) (! (? (g) (! g g))\n                       (? (g) (! f (? (&rest a)\n                                     (!! (! g g) a))))))))\n\n(defconstant +z-combinator+\n  (make-combinator\n   :name     'z-combinator\n   :function (? (f) (! (? (g) (! f (? (x) (! (! g g) x))))\n                       (? (g) (! f (? (x) (! (! g g) x))))))))\n\n(defparameter *default-combinator* +y-combinator+)\n\n(defmacro with-y-combinator (&body body)\n  `(let ((*default-combinator* +y-combinator+))\n     ,@body))\n\n(defmacro with-z-combinator (&body body)\n  `(let ((*default-combinator* +z-combinator+))\n     ,@body))\n\n(defun x-call (x-function &rest args)\n  (apply (funcall (combinator-function *default-combinator*) x-function) args))\n\n(defmacro x-function ((name &rest args) &body body)\n  `(lambda (,name)\n     (lambda ,args\n       (macrolet ((,name (&rest args)\n                    `(funcall ,',name ,@args)))\n         ,@body))))\n\n(defmacro x-defun (name args &body body)\n  `(defun ,name ,args\n     (x-call (x-function (,name ,@args) ,@body) ,@args)))\n\n;;;; examples\n\n(x-defun factorial (n)\n  (if (zerop n)\n      1 \n      (* n (factorial (1- n)))))\n\n(x-defun fib (n)\n  (case n\n    (0 0)\n    (1 1)\n    (otherwise (+ (fib (- n 1))\n                  (fib (- n 2))))))<\/lang>\n\n==[[:Category:D|D]][[Category:D]]==\nIn D anonymous delegates\/functions can't refer themselves. Here an anonymous class is created, and by using opCall member function, the anonymous class object can take arguments and act like an anonymous function. The recursion is done by calling opCall inside itself.\n<lang d>import std.stdio;\n\nint fib(in int n) pure nothrow {\n    assert(n >= 0);\n\n    return (new class {\n        static int opCall(in int m) pure nothrow {\n            if (m < 2)\n                return m;\n            else\n                return opCall(m - 1) + opCall(m - 2);\n        }\n    })(n);\n}\n\nvoid main() {\n    writeln(fib(39));\n}<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>63245986<\/pre>\n\n==[[:Category:Ela|Ela]][[Category:Ela]]==\nUsing fix-point combinator:\n<lang ela>let fib n | n < 0 = fail \"Negative n\"\n          | else = fix (\\f n -> if n < 2 then n else f (n-1) + f (n-2)) n<\/lang>\nFunction 'fix' is defined in standard Prelude as follows:\n<lang ela>let fix f = f (& fix f)<\/lang>\n\n==[[:Category:Elena|Elena]][[Category:Elena]]==\n<lang elena>#define std'dictionary'*.\n#define std'patterns'*.\n\n#symbol fibo =\n{\n    evaluate : aValue\n    [\n        Control ifNot:(aValue < 0).\n\n        ^ aValue then: aValue => [\n              #if(aValue < 2)\n                ? [ ^ aValue. ]\n                | [ ^ $self evaluate:(aValue - 2) + $self evaluate:(aValue - 1). ].\n          ].\n    ]\n}.\n\n#symbol Program =>\n[\n    loop::{ &for:-1 &to:5 } run: anN =>\n    [\n        'program'output << \"%nfib(\" << anN << \")=\" << (fibo eval:anN | back:\"failed\").\n    ].\n].<\/lang>\n\n==[[:Category:F#|F#]][[Category:F#]]==\n'''Using a nested function:'''\n\nThe function 'fib2' is only visible inside the 'fib' function.\n<lang fsharp>let fib = function\n    | n when n < 0 -> None\n    | n -> let rec fib2 = function\n               | 0 | 1 -> 1\n               | n -> fib2 (n-1) + fib2 (n-2)\n            in Some (fib2 n)<\/lang>\n'''Using a fixed point combinator:'''\n<lang fsharp>let rec fix f x = f (fix f) x\n\nlet fib = function\n    | n when n < 0 -> None\n    | n -> Some (fix (fun f -> (function | 0 | 1 -> 1 | n -> f (n-1) + f (n-2))) n)<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\nBoth functions have the same output.\n<lang fsharp>[-1..5] |> List.map fib |> printfn \"%A\"\n[null; Some 1; Some 1; Some 2; Some 3; Some 5; Some 8]<\/lang>\n\n==[[:Category:Factor|Factor]][[Category:Factor]]==\nOne would never use anonymous recursion. The better way defines a private word, like <code>fib2<\/code>, and recurse by name. This private word would pollute the namespace of one source file.\n\nTo achieve anonymous recursion, this solution has a recursive quotation.\n<lang factor>USING: kernel math ;\nIN: rosettacode.fibonacci.ar\n\n: fib ( n -- m )\n    dup 0 < [ \"fib of negative\" throw ] when\n    [\n        ! If n < 2, then drop q, else find q(n - 1) + q(n - 2).\n        [ dup 2 < ] dip swap [ drop ] [\n            [ [ 1 - ] dip dup call ]\n            [ [ 2 - ] dip dup call ] 2bi +\n        ] if\n    ] dup call( n q -- m ) ;<\/lang>\nThe name ''q'' in the stack effect has no significance; <code>call( x x -- x )<\/code> would still work.\n\nThe recursive quotation has 2 significant disadvantages:\n\n# To enable the recursion, a reference to the quotation stays on the stack. This ''q'' impedes access to other things on the stack. This solution must use <code>dip<\/code> and <code>swap<\/code> to move ''q'' out of the way. To simplify the code, one might move ''q'' to a local variable, but then the recursion would not be anonymous.\n# Factor cannot infer the stack effect of a recursive quotation. The last line must have <code>call( n q -- m )<\/code> instead of plain <code>call<\/code>; but <code>call( n q -- m )<\/code> defers the stack effect check until runtime. So if the quotation has a wrong stack effect, the compiler would miss the error; only a run of <code>fib<\/code> would detect the error.\n\n==[[:Category:Falcon|Falcon]][[Category:Falcon]]==\nFalcon allows a function to refer to itself by use of the fself keyword which is always set to the currently executing function.\n<lang falcon>function fib(x)\n   if x < 0\n      raise ParamError(description|\"Negative argument invalid\", extra|\"Fibbonacci sequence is undefined for negative numbers\")\n   else\n      return (function(y)\n         if y == 0\n            return 0\n         elif y == 1\n            return 1\n         else\n            return fself(y-1) + fself(y-2)\n         end\n      end)(x)  \n   end\nend\n \n   \ntry \n>fib(2)\n>fib(3)\n>fib(4)\n>fib(-1)\ncatch in e\n> e\nend<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>\n1\n2\n3\nParamError SS0000 at falcon.core.ParamError._init:(PC:ext.c): Negative argument invalid (Fibbonacci sequence is undefined for negative numbers)\n  Traceback:\n   falcon.core.ParamError._init:0(PC:ext.c)\n   \"\/home\/uDTVwo\/prog.fam\" prog.fib:3(PC:56)\n   \"\/home\/uDTVwo\/prog.fam\" prog.__main__:22(PC:132)\n<\/pre>\n\n==[[:Category:Forth|Forth]][[Category:Forth]]==\nRecursion is always anonymous in Forth, allowing it to be used in anonymous functions.  However, definitions can't be defined during a definition (there are no 'local functions'), and the data stack can't be portably used to get data into a definition being defined.\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[SwiftForth]][[SMW::on]]<\/div> - and any Forth in which colon-sys consumes zero cells on the data stack.\n<lang forth>:noname ( n -- n' )\n  dup 2 < ?exit\n  1- dup recurse swap 1- recurse + ; ( xt )\n\n: fib ( +n -- n' )\n  dup 0< abort\" Negative numbers don't exist.\"\n  [ ( xt from the :NONAME above ) compile, ] ;<\/lang>\nPortability is achieved with a once-off variable (or any temporary-use space with a constant address - i.e., not PAD):\n<lang forth>( xt from :noname in the previous example )\nvariable pocket  pocket !\n: fib ( +n -- n' )\n  dup 0< abort\" Negative numbers don't exist.\"\n  [ pocket @ compile, ] ;<\/lang>\n\n==[[:Category:Fortran|Fortran]][[Category:Fortran]]==\nSince a hidden named function instead of an anonymous one seems to be ok with implementors, here is the Fortran version:\n<lang Fortran>integer function fib(n)\n  integer, intent(in) :: n\n  if (n < 0 ) then\n    write (*,*) 'Bad argument: fib(',n,')'\n    stop\n  else\n    fib = purefib(n)\n  end if\ncontains\n  recursive pure integer function purefib(n) result(f)\n    integer, intent(in) :: n\n    if (n < 2 ) then\n      f = n\n    else\n      f = purefib(n-1) + purefib(n-2)\n    end if\n  end function purefib\nend function fib<\/lang>\n\n==[[:Category:Go|Go]][[Category:Go]]==\nY combinator solution.  Go has no special support for anonymous recursion.\n<lang go>package main\n\nimport \"fmt\"\n\nfunc main() {\n    for _, n := range []int{0, 1, 2, 3, 4, 5, 10, 40, -1} {\n        f, ok := arFib(n)\n        if ok {\n            fmt.Printf(\"fib %d = %d\\n\", n, f)\n        } else {\n            fmt.Println(\"fib undefined for negative numbers\")\n        }\n    }\n}\n\nfunc arFib(n int) (int, bool) {\n    switch {\n    case n < 0:\n        return 0, false\n    case n < 2:\n        return n, true\n    }\n    return yc(func(recurse fn) fn {\n        return func(left, term1, term2 int) int {\n            if left == 0 {\n                return term1+term2\n            }\n            return recurse(left-1, term1+term2, term1)\n        }\n    })(n-2, 1, 0), true\n}\n\ntype fn func(int, int, int) int\ntype ff func(fn) fn\ntype fx func(fx) fn\n\nfunc yc(f ff) fn {\n    return func(x fx) fn {\n        return f(func(a1, a2, a3 int) int {\n            return x(x)(a1, a2, a3)\n        })\n    }(func(x fx) fn {\n        return f(func(a1, a2, a3 int) int {\n            return x(x)(a1, a2, a3)\n        })\n    })\n}<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>\nfib 0 = 0\nfib 1 = 1\nfib 2 = 1\nfib 3 = 2\nfib 4 = 3\nfib 5 = 5\nfib 10 = 55\nfib 40 = 102334155\n<\/pre>\n\n==[[:Category:Groovy|Groovy]][[Category:Groovy]]==\nGroovy does not explicitly support anonymous recursion. This solution is a kludgy trick that takes advantage of the \"owner\" scoping variable (reserved word) for closures.\n<lang groovy>def fib = {\n    assert it > -1\n    {i -> i < 2 ? i : {j -> owner.call(j)}(i-1) + {k -> owner.call(k)}(i-2)}(it)\n}<\/lang>\nTest:\n<lang groovy>def fib0to20 = (0..20).collect(fib)\nprintln fib0to20\n\ntry {\n    println fib(-25)\n} catch (Throwable e) {\n    println \"KABOOM!!\"\n    println e.message\n}<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765]\nKABOOM!!\nassert it > -1\n       |  |\n       |  false\n       -25<\/pre>\n\n==[[:Category:Haskell|Haskell]][[Category:Haskell]]==\nHaskell has two ways to use anonymous recursion. Both methods hide the 'anonymous' function from the containing module, however the first method is actually using a named function.\n\n'''Named function:'''\n\nWe're defining a function 'real' which is only available from within the fib function.\n<lang haskell>fib :: Integer -> Maybe Integer\nfib n\n  | n < 0 = Nothing\n  | otherwise = Just $ real n\n              where real 0 = 1\n                    real 1 = 1\n                    real n = real (n-1) + real (n-2)<\/lang>\n\n'''Anonymous function:'''\n\nThis uses the 'fix' function to find the fixed point of the anonymous function.\n<lang haskell>import Data.Function (fix)\n\nfib :: Integer -> Maybe Integer\nfib n \n  | n < 0 = Nothing\n  | otherwise = Just $ fix (\\f -> (\\n -> if n > 1 then f (n-1) + f (n-2) else 1)) n<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\nBoth functions provide the same output when run in GHCI. \n<lang haskell>ghci> map fib [-4..10]\n[Nothing,Nothing,Nothing,Nothing,Just 1,Just 1,Just 2,Just 3,Just 5,Just 8,Just 13,Just 21,Just 34,Just 55,Just 89]<\/lang>\n\n==[[:Category:Icon|Icon]][[Category:Icon]] and [[:Category:Unicon|Unicon]][[Category:Unicon]]==\nThe following solution works in both languages.  A cache is used to improve performance.\n\nThis example is more a case of can it even be done, and just because we CAN do something - doesn't mean we should do it.  The use of co-expressions for this purpose was probably never intended by the language designers and is more than a little bit intensive and definitely NOT recommended. \n\nThis example does accomplish the goals of hiding the procedure inside ''fib'' so that the type and value checking is outside the recursion.  It also does not require an identifier to reference the inner procedure; but, it requires a local variable to remember our return point.  Also, each recursion will result in the current co-expression being refreshed, essentially copied, placing a heavy demand on co-expression resources.  \n<lang Icon>procedure main(A)\n   every write(\"fib(\",a := numeric(!A),\")=\",fib(a))\nend\n \nprocedure fib(n)\n   local  source, i\n   static cache\n   initial {\n      cache := table()\n      cache[0] := 0\n      cache[1] := 1\n      }\n   if type(n) == \"integer\" & n >= 0 then\n      return n @ makeProc {{\n         i := @(source := &source)                                          # 1\n         \/cache[i] := ((i-1)@makeProc(^&current)+(i-2)@makeProc(^&current)) # 2\n         cache[i] @ source                                                  # 3\n         }}\nend\n\nprocedure makeProc(A)\n   A := if type(A) == \"list\" then A[1]\n   return (@A, A)                    # prime and return\nend<\/lang>\nSome of the code requires some explaining:\n* The double curly brace syntax after ''makeProc'' serves two different purposes, the outer set is used in the call to create a co-expression.  The inner one binds all the expressions together as a single unit.\n* At #1 we remember where we came from and receive ''n'' from our caller\n* At #2 we transmit the new parameters to refreshed copies of the current co-expression setup to act as a normal procedure and cache the result.\n* At #3 we transmit the result back to our caller.\n* The procedure ''makeProc'' consumes the the first transmission to the co-expression which is ignored.  Essentially this primes the co-expression to behave like a regular procedure.\n\nFor reference, here is the non-cached version:\n<lang Icon>procedure fib(n)\n   local  source, i\n   if type(n) == \"integer\" & n >= 0 then\n      return n @ makeProc {{\n         i := @(source := &source)\n         if i = (0|1) then i@source\n         ((i-1)@makeProc(^&current) + (i-2)@makeProc(^&current)) @ source\n         }}\nend<\/lang>\nThe performance of this second version is 'truly impressive'.  And I mean that in a really bad way.  By way of example, using default memory settings on a current laptop, a simple recursive non-cached ''fib'' out distanced the non-cached ''fib'' above by a factor of 20,000.  And a simple recursive cached version out distanced the cached version above by a factor of 2,000.\n\n==[[:Category:J|J]][[Category:J]]==\nCopied directly from the [[Fibonacci_sequence#J|fibonacci sequence]] task, which in turn copied from one of several implementations in an [[j:Essays\/Fibonacci_Sequence|essay]] on the J Wiki:\n<lang j>   fibN=: (-&2 +&$: -&1)^:(1&<) M.\"0<\/lang>\nNote that this is an identity function for arguments less than 1 (and 1 (and 5)).\n\n'''Examples:'''\n<lang j>   fibN 12\n144\n   fibN  i.31\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368 75025 121393 196418 317811 514229 832040<\/lang>\n(This implementation is doubly recursive except that results are cached across function calls.)\n\n<code>$:<\/code> is an anonymous reference to the largest containing verb in the sentence.\n\n==[[:Category:Java|Java]][[Category:Java]]==\nCreates an anonymous inner class to do the dirty work. While it does keep the recursive function out of the namespace of the class, it does seem to violate the spirit of the task in that the function is still named.\n\n<lang java>public static long fib(int n)\n{\n  if (n < 0)\n    throw new IllegalArgumentException(\"n can not be a negative number\");\n  return new Object() {\n    private long fibInner(int n)\n    {  return (n < 2) ? n : (fibInner(n - 1) + fibInner(n - 2));  }\n  }.fibInner(n);\n}<\/lang>\n\n==[[:Category:JavaScript|JavaScript]][[Category:JavaScript]]==\n<lang javascript>function fibo(n) {\n  if (n < 0)\n    throw \"Argument cannot be negative\";\n  else\n    return (function(n) {\n      if (n < 2)\n        return 1;\n      else\n        return arguments.callee(n-1) + arguments.callee(n-2);\n    })(n);\n}<\/lang>\nNote that <code>arguments.callee<\/code> will not be available in ES5 Strict mode.\n\n==[[:Category:K|K]][[Category:K]]==\n<lang k>fib: {:[x<0; \"Error Negative Number\"; {:[x<2;x;_f[x-2]+_f[x-1]]}x]}<\/lang>\n'''Examples:'''\n<lang k>  fib'!10\n0 1 1 2 3 5 8 13 21 34\n  fib -1\n\"Error Negative Number\"<\/lang>\n\n==[[:Category:Lua|Lua]][[Category:Lua]]==\nUsing a [[Y combinator]].\n<lang lua>local function Y(x) return (function (f) return f(f) end)(function(y) return x(function(z) return y(y)(z) end) end) end\n\nreturn Y(function(fibs)\n  return function(n)\n    return n < 2 and 1 or fibs(n - 1) + fibs(n - 2)\n  end\nend)<\/lang>\nusing a metatable (also achieves memoization)\n<lang lua>return setmetatable({1,1},{__index = function(self, n)\n  self[n] = self[n-1] + self[n-2]\n  return self[n]\nend})<\/lang>\n\n==[[:Category:Mathematica|Mathematica]][[Category:Mathematica]]==\nAn anonymous reference to a function from within itself is named #0, arguments to that function are named #1,#2..#n, n being the position of the argument. The first argument may also be referenced as a # without a following number, the list of all arguments is referenced with ##. Anonymous functions are also known as [http:\/\/reference.wolfram.com\/mathematica\/tutorial\/PureFunctions.html pure functions] in Mathematica.\n<lang Mathematica>check := #<0&\nfib := If[check[#],Throw[\"Negative Argument\"],If[#<=1,1,#0[#-2]+#0[#-1]]&[#]]&\nfib \/@ Range[0,10]\n\n{1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89}<\/lang>\nMaking sure that the check is only performed once.\n<lang Mathematica>check := (Print[#];#<0)&\nfib \/@ Range[0,4]\n0\n1\n2\n3\n4\n\n{1, 1, 2, 3, 5}<\/lang>\n\n==[[:Category:Nemerle|Nemerle]][[Category:Nemerle]]==\nNot anonymous exactly, but using inner function solves all problems stated in task description.\n* name is basically the same as outer function and doesn't pollute the namespace\n* inner function not expected to be called from anywhere else\n* nesting maintains program flow in source code\n<lang Nemerle>using System;\nusing System.Console;\n\nmodule Fib\n{\n    Fib(n : long) : long\n    {\n        def fib(m : long)\n        {\n            |0 => 1\n            |1 => 1\n            |_ => fib(m - 1) + fib(m - 2)\n        }\n        \n        match(n)\n        {\n            |n when (n < 0) => throw ArgumentException(\"Fib() not defined on negative numbers\")\n            |_ => fib(n)\n        }\n    }\n    \n    Main() : void\n    {\n        foreach (i in [-2 .. 10])\n        {\n            try {WriteLine(\"{0}\", Fib(i));}\n            catch {|e is ArgumentException => WriteLine(e.Message)}\n        }\n    }\n}<\/lang>\n\n==[[:Category:Objective-C|Objective-C]][[Category:Objective-C]]==\nThis shows how a method (not regular function) can recursively call itself without explicitly putting its name in the code.\n<lang objc>#import <Foundation\/Foundation.h>\n\n@interface AnonymousRecursion : NSObject { }\n- (NSNumber *)fibonacci:(NSNumber *)n;\n@end\n\n@implementation AnonymousRecursion\n- (NSNumber *)fibonacci:(NSNumber *)n {\n  int i = [n intValue];\n  if (i < 0)\n    @throw [NSException exceptionWithName:NSInvalidArgumentException\n                                 reason:@\"fibonacci: no negative numbers\"\n                               userInfo:nil];\n  int result;\n  if (i < 2)\n    result = 1;\n  else\n    result = [[self performSelector:_cmd withObject:[NSNumber numberWithInt:i-1]] intValue]\n           + [[self performSelector:_cmd withObject:[NSNumber numberWithInt:i-2]] intValue];\n  return [NSNumber numberWithInt:result];\n}\n@end\n\nint main (int argc, const char *argv[]) {\n  NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];\n  \n  AnonymousRecursion *dummy = [[AnonymousRecursion alloc] init];\n  NSLog(@\"%@\", [dummy fibonacci:[NSNumber numberWithInt:8]]);\n  [dummy release];\n\n  [pool release];\n  return 0;\n}<\/lang>\n\n;With internal named recursive block:\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Mac OS X]] version 10.6+[[SMW::on]]<\/div>\n<lang php>#import <Foundation\/Foundation.h>\n\nint fib(int n) {\n    if (n < 0)\n        @throw [NSException exceptionWithName:NSInvalidArgumentException\n                                 reason:@\"fib: no negative numbers\"\n                               userInfo:nil];\n    __block int (^f)(int);\n    f = ^(int n) {\n        if (n < 2)\n            return 1;\n        else\n            return f(n-1) + f(n-2);\n    };\n    return f(n);\n}\n\nint main (int argc, const char *argv[]) {\n  NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];\n  \n  NSLog(@\"%d\", fib(8));\n\n  [pool release];\n  return 0;\n}<\/lang>\n\n==[[:Category:OCaml|OCaml]][[Category:OCaml]]==\n<div class=\"examplemeta translation\">'''Translation of''': [[Anonymous recursion#Haskell|Haskell]]<\/div>\nOCaml has two ways to use anonymous recursion. Both methods hide the 'anonymous' function from the containing module, however the first method is actually using a named function.\n\n'''Named function:'''\n\nWe're defining a function 'real' which is only available from within the fib function.\n<lang ocaml>let fib n =\n  let rec real = function\n      0 -> 1\n    | 1 -> 1\n    | n -> real (n-1) + real (n-2)\n  in\n  if n < 0 then\n    None\n  else\n    Some (real n)<\/lang>\n\n'''Anonymous function:'''\n\nThis uses the 'fix' function to find the fixed point of the anonymous function.\n<lang ocaml>let rec fix f x = f (fix f) x\n\nlet fib n =\n  if n < 0 then\n    None\n  else\n    Some (fix (fun f -> fun n -> if n <= 1 then 1 else f (n-1) + f (n-2)) n)<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre># fib 8;;\n- : int option = Some 34<\/pre>\n\n==[[:Category:Perl|Perl]][[Category:Perl]]==\n<div class=\"examplemeta translation\">'''Translation of''': [[Anonymous recursion#PicoLisp|PicoLisp]]<\/div>\n<code>recur<\/code> isn't built into Perl, but it's easy to implement.\n<lang perl>sub recur (&@) {\n    my $f = shift;\n    local *recurse = $f;\n    $f->(@_);\n}\n\nsub fibo {\n    my $n = shift;\n    $n < 0 and die 'Negative argument';\n    recur {\n        my $m = shift;\n        $m < 3 ? 1 : recurse($m - 1) + recurse($m - 2);\n    } $n;\n}<\/lang>\nAlthough for this task, it would be fine to use a lexical variable (closure) to hold an anonymous sub reference, we can also just push it onto the args stack and use it from there:\n<lang perl>sub fib {\n\tmy ($n) = @_;\n\tdie \"negative arg $n\" if $n < 0;\n\t# put anon sub on stack and do a magic goto to it\n\t@_ = ($n, sub {\n\t\tmy ($n, $f) = @_;\n\t\t# anon sub recurs with the sub ref on stack\n\t\t$n < 2 ? $n : $f->($n - 1, $f) + $f->($n - 2, $f)\n\t});\n\tgoto $_[1];\n}\n\nprint(fib($_), \" \") for (0 .. 10);<\/lang>\nOne can also use <code>caller<\/code> to get the name of the current subroutine as a string, then call the sub with that string. But this won't work if the current subroutine is anonymous: <code>caller<\/code> will just return <code>'__ANON__'<\/code> for the name of the subroutine. Thus, the below program must check the sign of the argument every call, failing the task. Note that under stricture, the line <code>no strict 'refs';<\/code> is needed to permit using a string as a subroutine.\n<lang perl>sub fibo {\n    my $n = shift;\n    $n < 0 and die 'Negative argument';\n    no strict 'refs';\n    $n < 3 ? 1 : (caller(0))[3]->($n - 1) + (caller(0))[3]->($n - 2);\n}<\/lang>\n\n==[[:Category:Perl 6|Perl 6]][[Category:Perl 6]]==\nIn addition to the methods in the [[Perl]] entry above, and the Y-combinator described in [[Y_combinator]], you may also refer to an anonymous block or function from the inside:\n<lang perl6>sub fib($n) {\n    die \"Naughty fib\" if $n < 0;\n    return {\n        $_ < 2\n            ?? $_\n            !!  &?BLOCK($_-1) + &?BLOCK($_-2);\n    }($n);\n}\n\nsay fib(10);<\/lang>\nHowever, using any of these methods is insane, when Perl\u00a06 provides a sort of inside-out combinator that lets you define lazy infinite constants, where the demand for a particular value is divorced from dependencies on more primitive values.  This operator, known as the sequence operator, does in a sense provide anonymous recursion to a closure that refers to more primitive values.\n<lang perl6>constant @fib = 0, 1, *+* ... *;\nsay @fib[10];<\/lang>\nHere the closure, <tt>*+*<\/tt>, is just a quick way to write a lambda, <tt>-> $a, $b { $a + $b }<\/tt>.  The sequence operator implicitly maps the two arguments to the -2nd and -1st elements of the sequence.  So the sequence operator certainly applies an anonymous lambda, but whether it's recursion or not depends on whether you view a sequence as iteration or as simply a convenient way of memoizing a recursion.  Either view is justifiable.\n\nAt this point someone may complain that the solution is doesn't fit the specified task because the sequence operator doesn't do the check for negative.  True, but the sequence operator is not the whole of the solution; this check is supplied by the subscripting operator itself when you ask for <tt>@fib[-1]<\/tt>.  Instead of scattering all kinds of arbitrary boundary conditions throughout your functions, the sequence operator maps them quite naturally to the boundary of definedness at the start of a list.\n\n==[[:Category:PHP|PHP]][[Category:PHP]]==\nDon't know if this counts, but...\n<lang php><?php\nfunction fib($n) {\n    if ($n < 0)\n        throw new Exception('Negative numbers not allowed');\n    else if ($n < 2)\n        return 1;\n    else {\n        $f = __FUNCTION__;\n        return $f($n-1) + $f($n-2);\n    }\n}\necho fib(8), \"\\n\";\n?><\/lang>\nHowever, <tt>__FUNCTION__<\/tt> won't work for anonymous functions created with <tt>create_function()<\/tt> or closures in PHP 5.3+.\n\n;With internal named recursive function:\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[PHP]] version 5.3+[[SMW::on]]<\/div>\n<lang php><?php\nfunction fib($n) {\n    if ($n < 0)\n        throw new Exception('Negative numbers not allowed');\n    $f = function($n) use (&$f) {\n        if ($n < 2)\n            return 1;\n        else\n            return $f($n-1) + $f($n-2);\n    };\n    return $f($n);\n}\necho fib(8), \"\\n\";\n?><\/lang>\n\n==[[:Category:PicoLisp|PicoLisp]][[Category:PicoLisp]]==\n<lang PicoLisp>(de fibo (N)\n   (if (lt0 N)\n      (quit \"Illegal argument\" N) )\n   (recur (N)\n      (if (> 2 N)\n         1\n         (+ (recurse (dec N)) (recurse (- N 2))) ) ) )<\/lang>\nExplanation: The above uses the '[http:\/\/software-lab.de\/doc\/refR.html#recur recur]' \/ '[http:\/\/software-lab.de\/doc\/refR.html#recurse recurse]' function pair, which is defined as a standard language extensions as\n<lang PicoLisp>(de recur recurse\n   (run (cdr recurse)) )<\/lang>\nNote how 'recur' dynamically defines the function 'recurse' at runtime, by binding the rest of the expression (i.e. the body of the 'recur' statement) to the symbol 'recurse'.\n\n==[[:Category:PostScript|PostScript]][[Category:PostScript]]==\n<div class=\"examplemeta libheader\">'''Library:''' [[SMW::off]][[:Category:initlib|initlib]][[Category:initlib]][[SMW::on]]<\/div>\nPostscript can make use of the higher order combinators to provide recursion.\n<lang postscript>% primitive recursion\n\/pfact {\n  {1} {*} primrec}.\n\n%linear recursion\n\/lfact {\n   {dup 0 eq}\n   {pop 1}\n   {dup pred} \n   {*}\n   linrec}.\n\n% general recursion\n\/gfact {\n    {0 eq}\n    {succ}\n    {dup pred}\n    {i *}\n    genrec}.\n\n% binary recursion\n\/fib {\n    {2 lt} {} {pred dup pred} {+} binrec}.<\/lang>\n\n==[[:Category:Prolog|Prolog]][[Category:Prolog]]==\nWorks with SWI-Prolog and module <b>lambda<\/b>, written by <b>Ulrich Neumerkel<\/b> found there http:\/\/www.complang.tuwien.ac.at\/ulrich\/Prolog-inedit\/lambda.pl\nThe code is inspired from this page : http:\/\/www.complang.tuwien.ac.at\/ulrich\/Prolog-inedit\/ISO-Hiord#Hiord (p 106). It uses the Y combinator.\n<lang prolog>:- use_module(lambda).\n\nfib(N, _F) :-\n\tN < 0, !,\n\twrite('fib is undefined for negative numbers.'), nl.\n\nfib(N, F) :-\n    % code of Fibonacci\n    PF     = \\Nb^R^Rr1^(Nb < 2 ->\n\t\t\t  R = Nb\n                        ;\n\t\t\t  N1 is Nb - 1,\n\t\t\t  N2 is Nb - 2,\n\t\t\t  call(Rr1,N1,R1,Rr1),\n\t\t\t  call(Rr1,N2,R2,Rr1),\n\t\t\t  R is R1 + R2\n\t\t\t),\n\n    % The Y combinator.\n\n    Pred = PF +\\Nb2^F2^call(PF,Nb2,F2,PF),\n\n    call(Pred,N,F).<\/lang>\n\n==[[:Category:Python|Python]][[Category:Python]]==\n<lang python>>>> Y = lambda f: (lambda x: x(x))(lambda y: f(lambda *args: y(y)(*args)))\n>>> fib = lambda f: lambda n: None if n < 0 else (0 if n == 0 else (1 if n == 1 else f(n-1) + f(n-2)))\n>>> [ Y(fib)(i) for i in range(-2, 10) ]\n[None, None, 0, 1, 1, 2, 3, 5, 8, 13, 21, 34]<\/lang>\n\nSame thing as the above, but modified so that the function is uncurried:\n<lang python>>>> Y = lambda f: (lambda x: x(x))(lambda y: lambda *args: f(y(y), *args))\n>>> fib = lambda f, n: None if n < 0 else (0 if n == 0 else (1 if n == 1 else f(n-1) + f(n-2)))\n>>> [ Y(fib)(i) for i in range(-2, 10) ]\n[None, None, 0, 1, 1, 2, 3, 5, 8, 13, 21, 34]<\/lang>\n\nA different approach: the function always receives itself as the first argument, and when recursing, makes sure to pass the called function as the first argument also\n<lang python>>>> from functools import partial\n>>> Y = lambda f: partial(f, f)\n>>> fib = lambda f, n: None if n < 0 else (0 if n == 0 else (1 if n == 1 else f(f, n-1) + f(f, n-2)))\n>>> [ Y(fib)(i) for i in range(-2, 10) ]\n[None, None, 0, 1, 1, 2, 3, 5, 8, 13, 21, 34]<\/lang>\n\n==[[:Category:Qi|Qi]][[Category:Qi]]==\n\nUse of anonymous recursive functions is not common in Qi. The philosophy of Qi\nseems to be that using a \"silly name\" like \"foo2\" or \"foo_helper\" makes the code clearer than using anonymous recursive functions.\n\nHowever, it can be done, for instance like this:\n\n<lang Qi>\n(define fib\n  N -> (let A (\/. A N\n                  (if (< N 2)\n                      N\n                      (+ (A A (- N 2))\n                         (A A (- N 1)))))\n         (A A N)))\n<\/lang>\n\n==[[:Category:R|R]][[Category:R]]==\nR provides Recall() as a wrapper which finds the calling function, with limitations; Recall will not work if passed to another function as an argument.\n<lang R>fib2 <- function(n) {\n  (n >= 0) || stop(\"bad argument\")\n  ( function(n) if (n <= 1) 1 else Recall(n-1)+Recall(n-2) )(n)\n}<\/lang>\n\n==[[:Category:REXX|REXX]][[Category:REXX]]==\n[As per the Fortran example:]\n<br>since a hidden named function instead of an anonymous function seems\nto be OK with implementors, here is the REXX version:\n<lang rexx>\/*REXX program to show anonymous recursion  (of a function\/subroutine). *\/\nnumeric digits 1e6                     \/*in case the user goes kaa-razy.*\/\n       do j=0 to word(arg(1) 12,1)     \/*use argument or the default: 12*\/\n       say 'fibonacci('j\") =\" fib(j)   \/*show Fibonacci sequence: 0\u2500\u2500>x *\/\n       end\nexit\n\nfib: procedure; if arg(1)>=0 then return .(arg(1))\nsay \"***error!*** argument can't be negative.\"; exit\n.:procedure; arg _; if _<2 then return _; return .(_-1)+.(_-2)<\/lang>\nOutput when using the default input (<tt> 12 <\/tt>):\n<pre style=\"height:15ex;overflow:scroll\">\nfibonacci(0) = 0\nfibonacci(1) = 1\nfibonacci(2) = 1\nfibonacci(3) = 2\nfibonacci(4) = 3\nfibonacci(5) = 5\nfibonacci(6) = 8\nfibonacci(7) = 13\nfibonacci(8) = 21\nfibonacci(9) = 34\nfibonacci(10) = 55\nfibonacci(11) = 89\nfibonacci(12) = 144\n<\/pre>\n\n==[[:Category:Ruby|Ruby]][[Category:Ruby]]==\nRuby has no keyword for anonymous recursion.\n\nWe can recurse a block of code, but we must provide the block with a reference to itself. The easiest solution is to use a local variable.\n===Ruby with local variable===\n<lang ruby>def fib(n)\n  raise RangeError, \"fib of negative\" if n < 0\n  (fib2 = proc { |m| m < 2 ? m : fib2[m - 1] + fib2[m - 2] })[n]\nend<\/lang>\n\n<lang ruby>(-2..12).map { |i| fib i rescue :error }\n=> [:error, :error, 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144]<\/lang>\n\nHere 'fib2' is a local variable of the fib() method. Only the fib() method, or a block inside the fib() method, can call this 'fib2'. The rest of this program cannot call this 'fib2', but it can use the name 'fib2' for other things.\n\n* The fib() method has two local variables 'fib2' and 'n'.\n* The block has a local variable 'm' and closes on both 'fib2' and 'n'.\n\n'''Caution!''' The recursive block has a difference from Ruby 1.8 to Ruby 1.9. Here is the same method, except changing the block parameter from 'm' to 'n', so that block 'n' and method 'n' have the same name.\n<lang ruby>def fib(n)\n  raise RangeError, \"fib of negative\" if n < 0\n  (fib2 = proc { |n| n < 2 ? n : fib2[n - 1] + fib2[n - 2] })[n]\nend<\/lang>\n<lang ruby># Ruby 1.9\n(-2..12).map { |i| fib i rescue :error }\n=> [:error, :error, 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144]\n\n# Ruby 1.8\n(-2..12).map { |i| fib i rescue :error }\n=> [:error, :error, 0, 1, 0, -3, -8, -15, -24, -35, -48, -63, -80, -99, -120]<\/lang>\nRuby 1.9 still shows the correct answer, but Ruby 1.8 shows the wrong answer. With Ruby 1.9, 'n' is still a local variable of the block. With Ruby 1.8, 'n' of the block closes on 'n' of the fib() method. All calls to the block share the 'n' of one call to the method. So <tt>fib2[n - 1]<\/tt> changes the value of 'n', and <tt>fib2[n - 2]<\/tt> uses the wrong value of 'n', thus the wrong answer.\n===Ruby with Hash===\n<lang ruby>def fib(n)\n  raise RangeError, \"fib of negative\" if n < 0\n  Hash.new { |fib2, m|\n    fib2[m] = (m < 2 ? m : fib2[m - 1] + fib2[m - 2]) }[n]\nend<\/lang>\nThis uses a Hash to memoize the recursion. After <tt>fib2[m - 1]<\/tt> returns, <tt>fib2[m - 2]<\/tt> uses the value in the Hash, without redoing the calculations.\n\n* The fib() method has one local variable 'n'.\n* The block has two local variables 'fib2' and 'm', and closes on 'n'.\n===Ruby with recur\/recurse===\n<div class=\"examplemeta translation\">'''Translation of''': [[Anonymous recursion#PicoLisp|PicoLisp]]<\/div>\n<div class=\"examplemeta libheader\">'''Library:''' [[SMW::off]][[:Category:continuation|continuation]][[Category:continuation]][[SMW::on]]<\/div>\n<lang ruby>require 'continuation' unless defined? Continuation\n\nmodule Kernel\n  module_function\n\n  def recur(*args, &block)\n    cont = catch(:recur) { return block[*args] }\n    cont[block]\n  end\n\n  def recurse(*args)\n    block = callcc { |cont| throw(:recur, cont) }\n    block[*args]\n  end\nend\n\ndef fib(n)\n  raise RangeError, \"fib of negative\" if n < 0\n  recur(n) { |m| m < 2 ? m : (recurse m - 1) + (recurse m - 2) }\nend<\/lang>\n\nOur recursive block now lives in the 'block' variable of the Kernel#recur method.\n\nTo start, Kernel#recur calls the block once. From inside the block, Kernel#recurse calls the block again. To find the block, recurse() plays a trick. First, Kernel#callcc creates a Continuation. Second, throw(:recur, cont) unwinds the call stack until it finds a matching Kernel#catch(:recur), which returns our Continuation. Third, Kernel#recur uses our Continuation to continue the matching Kernel#callcc, which returns our recursive block.\n\n===Ruby with arguments.callee===\n<div class=\"examplemeta translation\">'''Translation of''': [[Anonymous recursion#JavaScript|JavaScript]]<\/div>\n<div class=\"examplemeta libheader\">'''Library:''' [[SMW::off]][[:Category:continuation|continuation]][[Category:continuation]][[SMW::on]]<\/div>\n<lang ruby>require 'continuation' unless defined? Continuation\n\nmodule Kernel\n  module_function\n\n  def function(&block)\n    f = (proc do |*args|\n           (class << args; self; end).class_eval do\n             define_method(:callee) { f }\n           end\n           ret = nil\n           cont = catch(:function) { ret = block.call(*args); nil }\n           cont[args] if cont\n           ret\n         end)\n  end\n\n  def arguments\n    callcc { |cont| throw(:function, cont) }\n  end\nend\n\ndef fib(n)\n  raise RangeError, \"fib of negative\" if n < 0\n  function { |m|\n    if m < 2\n      m\n    else\n      arguments.callee[m - 1] + arguments.callee[m - 2]\n    end\n  }[n]\nend<\/lang>\nOur recursive block now lives in the 'block' variable of the Kernel#function method. Another block 'f' wraps our original block and sets up the 'arguments' array. Kernel#function returns this wrapper block. Kernel#arguments plays a trick to get the array of arguments from 'f'; this array has an extra singleton method #callee which returns 'f'.\n\n==[[:Category:Scala|Scala]][[Category:Scala]]==\nUsing a Y-combinator:\n<lang scala>def Y[A, B](f: (A \u21d2 B) \u21d2 (A \u21d2 B)): A \u21d2 B = f(Y(f))(_)\n  \ndef fib(n: Int): Option[Int] =\n  if (n < 0) None\n  else Some(Y[Int, Int](f \u21d2 i \u21d2\n    if (i < 2) 1\n    else f(i - 1) + f(i - 2))(n))\n      \n-2 to 5 map (n \u21d2 (n, fib(n))) foreach println<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>\n(-2,None)\n(-1,None)\n(0,Some(1))\n(1,Some(1))\n(2,Some(2))\n(3,Some(3))\n(4,Some(5))\n(5,Some(8))\n<\/pre>\n\n==[[:Category:Scheme|Scheme]][[Category:Scheme]]==\nThis uses named let to create a function (aux) that only exists inside of fibonacci:\n<lang scheme>(define (fibonacci n)\n  (if (> 0 n)\n      \"Error: argument must not be negative.\"\n      (let aux ((a 1) (b 0) (count n))\n        (if (= count 0)\n            b\n            (aux (+ a b) a (- count 1))))))\n\n(map fibonacci '(1 2 3 4 5 6 7 8 9 10))<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>'(1 1 2 3 5 8 13 21 34 55)<\/pre>\n\n==[[:Category:Tcl|Tcl]][[Category:Tcl]]==\nThis solution uses Tcl 8.5's lambda terms, extracting the current term from the call stack using introspection (storing it in a local variable only for convenience, with that ''not'' in any way being the name of the lambda term; just what it is stored in, and only as a convenience that keeps the code shorter). The lambda terms are applied with the <code>apply<\/code> command.\n<lang tcl>proc fib n {\n    # sanity checks\n    if {[incr n 0] < 0} {error \"argument may not be negative\"}\n    apply {x {\n\tif {$x < 2} {return $x}\n\t# Extract the lambda term from the stack introspector for brevity\n\tset f [lindex [info level 0] 1]\n\texpr {[apply $f [incr x -1]] + [apply $f [incr x -1]]}\n    }} $n\n}<\/lang>\nDemonstrating:\n<lang tcl>puts [fib 12]<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>}\n<pre>144<\/pre>\nThe code above can be written without even using a local variable to hold the lambda term, though this is generally less idiomatic because the code ends up longer and clumsier:\n<lang tcl>proc fib n {\n    if {[incr n 0] < 0} {error \"argument may not be negative\"}\n    apply {x {expr {\n        $x < 2\n          ? $x\n          : [apply [lindex [info level 0] 1] [incr x -1]]\n            + [apply [lindex [info level 0] 1] [incr x -1]]\n    }}} $n\n}<\/lang>\nHowever, we can create a <code>recurse<\/code> function that makes this much more straight-forward:\n<lang tcl># Pick the lambda term out of the introspected caller's stack frame\nproc tcl::mathfunc::recurse args {apply [lindex [info level -1] 1] {*}$args}\nproc fib n {\n    if {[incr n 0] < 0} {error \"argument may not be negative\"}\n    apply {x {expr {\n        $x < 2 ? $x : recurse([incr x -1]) + recurse([incr x -1])\n    }}} $n\n}<\/lang>\n\n==[[:Category:UNIX Shell|UNIX Shell]][[Category:UNIX Shell]]==\nThe shell does not have anonymous functions. Every function must have a name. However, one can create a subshell such that some function, which has a name in the subshell, is effectively anonymous to the parent shell.\n<lang bash>fib() {\n  if test 0 -gt \"$1\"; then\n    echo \"fib: fib of negative\" 1>&2\n    return 1\n  else\n    (\n      fib2() {\n        if test 2 -gt \"$1\"; then\n          echo \"$1\"\n        else\n          echo $(( $(fib2 $(($1 - 1)) ) + $(fib2 $(($1 - 2)) ) ))\n        fi\n      }\n      fib2 \"$1\"\n    )\n  fi\n}<\/lang>\n<lang bash>$ for i in -2 -1 0 1 2 3 4 5 6 7 8 9 10 11 12; do\n>   fib $i\n> done\nfib: fib of negative\nfib: fib of negative\n0\n1\n1\n2\n3\n5\n8\n13\n21\n34\n55\n89\n144<\/lang>\n\n==[[:Category:Ursala|Ursala]][[Category:Ursala]]==\n<lang Ursala>#import nat\n\nfib =\n\n~&izZB?(                    # test the sign bit of the argument\n   <'fib of negative'>!%,   # throw an exception if it's negative\n   {0,1}^?<a(               # test the argument to a recursively defined function\n      ~&a,                  # if the argument was a member of {0,1}, return it\n      sum^|W(               # otherwise return the sum of two recursive calls\n         ~&,                # to the function thus defined\n         predecessor^~(     # with the respective predecessors of\n            ~&,             # the given argument\n            predecessor)))) # and the predecessor thereof<\/lang>\nAnonymous recursion is often achieved using the recursive conditional operator, <code>( _ )^?( _ , _ )<\/code>, which takes a predicate on the left and a pair of functions on the right, typically one for the base and one for the inductive case in a recursive definition. The form <code>^?<<\/code> can be used if the relevant predicate is given by membership of the argument in a constant set, in which case only the set needs to be specified rather than the whole predicate.\n\nThe recursive conditional operator <code>^?<\/code> differs from the ordinary conditional <code>?<\/code> seen at the outermost level by arranging for its predicate and component functions to be given an input of the form <math>(f,a)<\/math> where <math>a<\/math> is the original argument, and <math>f<\/math> is a copy of the whole function. Code within the function body may then access itself anonymously according to all the usual language idioms pertaining to deconstruction of tuples, and call itself by any of several recursion combinators, such as the pairwise recursion form <code>W<\/code> seen above.\n\n==[[:Category:XPL0|XPL0]][[Category:XPL0]]==\nIn XPL0 you can nest functions\/procedures inside other\nfunctions\/procedures up to eight levels deep. This makes those nested\nfunctions invisible to the outside, thus preventing namespace pollution.\n\n<lang XPL0>include c:\\cxpl\\codes;\n\nfunc Fib(X);\nint X;\n        func ActualFib(N);\n        int N;\n        [if N<2 then return N\n        else return ActualFib(N-1) + ActualFib(N-2);\n        ]; \\ActualFib;\n\n[if X<0 then [Text(0, \"Error \"); return 0]\nelse return ActualFib(X);\n]; \\Fib;\n\n[IntOut(0, Fib(8));  CrLf(0);\n IntOut(0, Fib(-2)); CrLf(0);\n]<\/lang>\n\nOutput:\n<pre>\n21\nError 0\n<\/pre>\n\n\n[[Category:ACL2\/Omit]]\n[[Category:PureBasic\/Omit]]"}]}}},"query-continue":{"revisions":{"rvstartid":137733}}}