{"query-continue":{"search":{"gsroffset":1},"revisions":{"rvstartid":137086}},"query":{"pages":{"1639":{"pageid":1639,"ns":0,"title":"Apply a callback to an array","revisions":[{"*":"<div class=\"infobox\" style=\"width: 2in\">[[File:Rcode-button-task-crushed.png|64px|left|alt=Task|link=Category:Solutions by Programming Task]]'''Apply a callback to an array'''<br\/>\nYou are encouraged to [[Rosetta Code:Solve a Task|solve this task]] according to the task description, using any language you may know.[[Category:Programming Tasks]][[Category:Basic language learning]]<\/div>[[Category:Iteration]]\nIn this task, the goal is to take a combined set of elements and apply a function to each element.\n\n==[[:Category:ACL2|ACL2]][[Category:ACL2]]==\n\nACL2 does not have first-class functions; this is close, however:\n\n<lang lisp>(defun sq-each (xs)\n   (if (endp xs)\n       nil\n       (cons (* (first xs) (first xs))\n             (sq-each (rest xs)))))<\/lang>\n\n==[[:Category:ActionScript|ActionScript]][[Category:ActionScript]]==\n<lang actionscript>package\n{\n    public class ArrayCallback\n    {\n        public function main():void\n        {\n            var nums:Array = new Array(1, 2, 3);\n            nums.map(function(n:Number, index:int, arr:Array):void { trace(n * n * n); });\n            \n            \/\/ You can also pass a function reference\n            nums.map(cube);\n        }\n        \n        private function cube(n:Number, index:int, arr:Array):void\n        {\n            trace(n * n * n);\n        }\n    }\n}<\/lang>\n\n==[[:Category:Ada|Ada]][[Category:Ada]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[GNAT]] version GPL 2005[[SMW::on]]<\/div>\n<lang ada>with Ada.Text_Io;\n with Ada.Integer_text_IO;\n \n procedure Call_Back_Example is\n    -- Purpose: Apply a callback to an array\n    -- Output: Prints the squares of an integer array to the console\n   \n    -- Define the callback procedure\n    procedure Display(Location : Positive; Value : Integer) is\n    begin\n       Ada.Text_Io.Put(\"array(\");\n       Ada.Integer_Text_Io.Put(Item => Location, Width => 1);\n       Ada.Text_Io.Put(\") = \");\n       Ada.Integer_Text_Io.Put(Item => Value * Value, Width => 1);\n       Ada.Text_Io.New_Line;\n    end Display;\n   \n    -- Define an access type matching the signature of the callback procedure\n    type Call_Back_Access is access procedure(L : Positive; V : Integer);\n   \n    -- Define an unconstrained array type\n    type Value_Array is array(Positive range <>) of Integer;\n   \n    -- Define the procedure performing the callback\n    procedure Map(Values : Value_Array; Worker : Call_Back_Access) is\n    begin\n       for I in Values'range loop\n          Worker(I, Values(I));\n       end loop;\n    end Map;\n   \n    -- Define and initialize the actual array\n    Sample : Value_Array := (5,4,3,2,1);\n   \n begin\n    Map(Sample, Display'access);   \n end Call_Back_Example;<\/lang>\n\n==[[:Category:Aime|Aime]][[Category:Aime]]==\n<lang aime>void\nmap(list l, void (*fp) (object))\n{\n    integer i;\n\n    i = 0;\n    while (i < l_length(l)) {\n\tfp(l_query(l, i));\n\ti += 1;\n    }\n}\n\n\nvoid\nout(object o)\n{\n    o_integer(o);\n    o_byte(10);\n}\n\n\ninteger\nmain(void)\n{\n    list l;\n\n    l_append(l, 0);\n    l_append(l, 1);\n    l_append(l, 2);\n    l_append(l, 3);\n\n    map(l, out);\n\n    return 0;\n}<\/lang>\n\n==[[:Category:ALGOL 68|ALGOL 68]][[Category:ALGOL 68]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[ALGOL 68]] version Revision 1 - no extensions to language used[[SMW::on]]<\/div>\n\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[ALGOL 68G]] version Any - tested with release [http:\/\/sourceforge.net\/projects\/algol68\/files\/algol68g\/algol68g-1.18.0\/algol68g-1.18.0-9h.tiny.el5.centos.fc11.i386.rpm\/download 1.18.0-9h.tiny][[SMW::on]]<\/div>\n\n<lang algol68> PROC call back proc = (INT location, INT value)VOID:\n (\n   printf(($\"array[\"g\"] = \"gl$, location, value))\n );\n\n PROC map = (REF[]INT array, PROC (INT,INT)VOID call back)VOID:\n (\n   FOR i FROM LWB array TO UPB array DO\n      call back(i, array[i])\n   OD\n );\n \n main:\n (\n   [4]INT array := ( 1, 4, 9, 16 );\n   map(array, call back proc)\n )<\/lang>\nOutput:\n<pre>\narray[         +1] =          +1\narray[         +2] =          +4\narray[         +3] =          +9\narray[         +4] =         +16\n<\/pre>\n\n==[[:Category:AutoHotkey|AutoHotkey]][[Category:AutoHotkey]]==\n<lang AutoHotkey>map(\"callback\", \"3,4,5\")\n\ncallback(array){\n  Loop, Parse, array, `,\n    MsgBox % (2 * A_LoopField)\n}\n \nmap(callback, array){\n  %callback%(array)\n}<\/lang>\n\n==[[:Category:AWK|AWK]][[Category:AWK]]==\n<lang awk>$ awk 'func psqr(x){print x,x*x}BEGIN{split(\"1 2 3 4 5\",a);for(i in a)psqr(a[i])}'\n4 16\n5 25\n1 1\n2 4\n3 9<\/lang>\n\n==[[:Category:Brat|Brat]][[Category:Brat]]==\n\n<lang brat>#Print out each element in array\n[:a :b :c :d :e].each { element |\n\tp element\n}<\/lang>\n\nAlternatively:\n\n<lang brat>[:a :b :c :d :e].each ->p<\/lang>\n\n==[[:Category:C|C]][[Category:C]]==\n\n'''callback.h'''\n<lang c>#ifndef CALLBACK_H\n#define CALLBACK_H\n\n\/*\n * By declaring the function in a separate file, we allow\n * it to be used by other source files.\n *\n * It also stops ICC from complaining.\n *\n * If you don't want to use it outside of callback.c, this\n * file can be removed, provided the static keyword is prepended\n * to the definition.\n *\/\nvoid map(int* array, int len, void(*callback)(int,int));\n\n#endif<\/lang>\n\n'''callback.c'''\n<lang c>#include <stdio.h>\n#include \"callback.h\"\n\n\/*\n * We don't need this function outside of this file, so\n * we declare it static.\n *\/\nstatic void callbackFunction(int location, int value)\n{\n  printf(\"array[%d] = %d\\n\", location, value);\n} \n\nvoid map(int* array, int len, void(*callback)(int,int))\n{\n  int i;\n  for(i = 0; i < len; i++)\n  {\n     callback(i, array[i]);\n  }\n} \n\nint main()\n{\n  int array[] = { 1, 2, 3, 4 };\n  map(array, 4, callbackFunction);\n  return 0;\n}<\/lang>\n\n'''Output'''\n\n  array[0] = 1\n  array[1] = 2\n  array[2] = 3\n  array[3] = 4\n\n==<span id=\"C sharp\">[[:Category:C sharp|C#]]<\/span>[[Category:C sharp]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[C sharp|C#]] version 2.0+[[SMW::on]]<\/div>\n\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Visual C sharp|Visual C#]] version 2005[[SMW::on]]<\/div>\n<lang csharp>using System; \n\nstatic class Program\n{\n  \/\/ Purpose: Apply a callback (or anonymous method) to an Array\n  \/\/ Output: Prints the squares of an int array to the console.\n  \/\/ Compiler: Visual Studio 2005\n  \/\/ Framework: .net 2\n   \n  [STAThread]\n  public static void Main() \n  {\n    int[] intArray = { 1, 2, 3, 4, 5 };\n\n    \/\/ Using a callback,\n    Console.WriteLine(\"Printing squares using a callback:\");\n    Array.ForEach<int>(intArray, PrintSquare);\n\n    \/\/ or using an anonymous method:\n    Console.WriteLine(\"Printing squares using an anonymous method:\");\n    Array.ForEach<int>\n    (\n      intArray,\n      delegate(int value) \n      {\n        Console.WriteLine(value * value);    \n      });\n  }\n\n  public static void PrintSquare(int value) \n  { \n    Console.WriteLine(value * value);\n  }\n}<\/lang>\n\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[C sharp|C#]] version 3.0+[[SMW::on]]<\/div>\nThis version uses the C# 3 lambda notation. \n\n<lang csharp>int[] intArray = { 1, 2, 3, 4, 5 };\nArray.ForEach(intArray, i => Console.WriteLine(i * i));<\/lang>\n\n==[[:Category:C++|C++]][[Category:C++]]==\n\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[g++]] version 4.1.1[[SMW::on]]<\/div>    \n===C-Style Array===\n<lang cpp>#include <iostream> \/\/cout for printing\n#include <algorithm> \/\/for_each defined here\n\n\/\/create the function (print the square)\nvoid print_square(int i) {\n  std::cout << i*i << \" \";\n}\n\nint main() {\n  \/\/create the array\n  int ary[]={1,2,3,4,5};\n  \/\/stl for_each\n  std::for_each(ary,ary+5,print_square);\n  return 0;\n}\n\/\/prints 1 4 9 16 25<\/lang>\n\n===std::vector===\n<div class=\"examplemeta libheader\">'''Library:''' [[SMW::off]][[:Category:STL|STL]][[Category:STL]][[SMW::on]]<\/div>\n<lang cpp>#include <iostream>  \/\/ cout for printing\n#include <algorithm> \/\/ for_each defined here\n#include <vector>    \/\/ stl vector class\n\n\/\/ create the function (print the square)\nvoid print_square(int i) {\n  std::cout << i*i << \" \";\n}\n\nint main() {\n  \/\/ create the array\n  std::vector<int> ary;\n  ary.push_back(1);\n  ary.push_back(2);\n  ary.push_back(3);\n  ary.push_back(4);\n  ary.push_back(5);\n  \/\/ stl for_each\n  std::for_each(ary.begin(),ary.end(),print_square);\n  return 0;\n}\n\/\/prints 1 4 9 16 25<\/lang>\n\nMore tricky with binary function\n<lang cpp>#include <iostream>   \/\/ cout for printing\n#include <algorithm>  \/\/ for_each defined here\n#include <vector>     \/\/ stl vector class\n#include <functional> \/\/ bind and ptr_fun\n\n\/\/ create a binary function (print any two arguments together)\ntemplate<class type1,class type2>\nvoid print_juxtaposed(type1 x, type2 y) {\n  std::cout << x << y;\n}\n\nint main() {\n  \/\/ create the array\n  std::vector<int> ary;\n  ary.push_back(1);\n  ary.push_back(2);\n  ary.push_back(3);\n  ary.push_back(4);\n  ary.push_back(5);\n  \/\/ stl for_each, using binder and adaptable unary function\n  std::for_each(ary.begin(),ary.end(),std::bind2nd(std::ptr_fun(print_juxtaposed<int,std::string>),\"x \"));\n  return 0;\n}\n\/\/prints 1x 2x 3x 4x 5x<\/lang>\n\n===Boost.Lambda===\n<div class=\"examplemeta libheader\">'''Library:''' [[SMW::off]][[:Category:Boost|Boost]][[Category:Boost]][[SMW::on]]<\/div>\n<lang cpp>using namespace std;\nusing namespace boost::lambda;\nvector<int> ary(10);\nint i = 0;\nfor_each(ary.begin(), ary.end(), _1 = ++var(i)); \/\/ init array\ntransform(ary.begin(), ary.end(), ostream_iterator<int>(cout, \" \"), _1 * _1); \/\/ square and output<\/lang>\n\n==[[:Category:Clean|Clean]][[Category:Clean]]==\n\nDefine a function and an initial (unboxed) array.\n\n<lang clean>square x = x * x\n\nvalues :: {#Int}\nvalues = {x \\\\ x <- [1 .. 10]}<\/lang>\n\nOne can easily define a map for arrays, which is overloaded and works for all kinds of arrays (lazy, strict, unboxed).\n\n<lang clean>mapArray f array = {f x \\\\ x <-: array}<\/lang>\n\nApply the function to the initial array (using a comprehension) and print result.\n\n<lang clean>Start :: {#Int}\nStart = mapArray square values<\/lang>\n\n==[[:Category:CoffeeScript|CoffeeScript]][[Category:CoffeeScript]]==\n<lang coffeescript>\nmap = (arr, f) -> (f(e) for e in arr)\narr = [1, 2, 3, 4, 5]\nf = (x) -> x * x\nconsole.log map arr, f # prints [1, 4, 9, 16, 25]\n<\/lang>\n\n\n==[[:Category:Common Lisp|Common Lisp]][[Category:Common Lisp]]==\n\nImperative: print 1, 2, 3, 4 and 5:\n\n<lang lisp>(map nil #'print #(1 2 3 4 5))<\/lang>\n\nFunctional: collect squares into new vector that is returned:\n\n<lang lisp>(defun square (x) (* x x))\n(map 'vector #'square #(1 2 3 4 5))<\/lang>\n\nDestructive, like the Javascript example; add 1 to every slot of vector *a*:\n\n<lang lisp>(defvar *a* (vector 1 2 3))\n(map-into *a* #'1+ *a*)<\/lang>\n\n==[[:Category:Clojure|Clojure]][[Category:Clojure]]==\n\n<lang lisp>;; apply a named function, inc\n(map inc [1 2 3 4])<\/lang>\n\n<lang lisp>;; apply a function\n(map (fn [x] (* x x)) [1 2 3 4])<\/lang>\n\n<lang lisp>;; shortcut syntax for a function\n(map #(* % %) [1 2 3 4])<\/lang>\n\n==[[:Category:D|D]][[Category:D]]==\n<lang d>import std.stdio, std.algorithm;\n\nvoid main() {\n    auto items = [1, 2, 3, 4, 5];\n    auto m = items.map!(x => x + 5)();\n    writeln(m);\n}<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>[6, 7, 8, 9, 10]<\/pre>\n\n==[[:Category:Delphi|Delphi]][[Category:Delphi]]==\n<lang Delphi>\n\/\/ Declare the callback function\nprocedure callback(const AInt:Integer);\nbegin\n  WriteLn(AInt);\nend;\n\nconst\n  \/\/ Declare a static array\n  myArray:Array[0..4] of Integer=(1,4,6,8,7);\nvar\n  \/\/ Declare interator variable\n  i:Integer;\nbegin\n  \/\/ Iterate the array and apply callback\n  for i:=0 to length(myArray)-1 do\n    callback(myArray[i]);\nend.\n<\/lang>\n\n\n==[[:Category:E|E]][[Category:E]]==\n\n<lang e>def array := [1,2,3,4,5]\ndef square(value) { \n    return value * value\n}<\/lang>\n\nExample of builtin iteration:\n\n<lang e>def callback(index, value) { \n    println(`Item $index is $value.`)\n}\narray.iterate(callback)<\/lang>\n\nThere is no built-in map function '''yet'''. The following is one of the ways one could be implemented, returning a plain list (which is usually an array in implementation).\n\n<lang e>def map(func, collection) {\n    def output := [].diverge()\n    for item in collection {\n        output.push(func(item))\n    }\n    return output.snapshot()\n}\nprintln(map(square, array))<\/lang>\n\n==[[:Category:Efene|Efene]][[Category:Efene]]==\n\n<lang efene>square = fn (N) {\n    N * N\n}\n\n# list comprehension\nsquares1 = fn (Numbers) {\n    [square(N) for N in Numbers]\n}\n\n# functional form\nsquares2a = fn (Numbers) {\n    lists.map(fn square:1, Numbers)\n}\n\n# functional form with lambda\nsquares2b = fn (Numbers) {\n    lists.map(fn (N) { N * N }, Numbers)\n}\n\n# no need for a function\nsquares3 = fn (Numbers) {\n    [N * N for N in Numbers]\n}\n\n@public\nrun = fn () {\n    Numbers = [1, 3, 5, 7]\n    io.format(\"squares1 : ~p~n\", [squares1(Numbers)])\n    io.format(\"squares2a: ~p~n\", [squares2a(Numbers)])\n    io.format(\"squares2b: ~p~n\", [squares2b(Numbers)])\n    io.format(\"squares3 : ~p~n\", [squares3(Numbers)])\n}\n<\/lang>\n\n==[[:Category:Elena|Elena]][[Category:Elena]]==\n\n<lang elena>#define std'patterns'*.\n#define std'routines'*.\n#define std'dictionary'*.\n\n#symbol PrintSecondPower\n    = aNumber => ('program'output << aNumber * aNumber << \"%n\").\n\n#symbol Program =>\n[\n    \/\/ first version\n    Scan::(1, 2, 3, 4, 5) run:PrintSecondPower.\n        \n    \/\/ second version\n    (ArrayEnumerator::(6, 7, 8, 9, 10))~foreach run: anItem => (PrintSecondPower eval:anItem).\n].\n<\/lang>\n\n==[[:Category:Erlang|Erlang]][[Category:Erlang]]==\nA list would be more commonly used in Erlang rather than an array.\n\n<lang Erlang>\n1> L = [1,2,3].\n[1,2,3]\n<\/lang>\n\nYou can use lists:foreach\/2 if you just want to apply the callback to each element of the list.\n\n<lang>\n2> lists:foreach(fun(X) -> io:format(\"~w \",[X]) end, L).\n1 2 3 ok\n<\/lang>\n\nOr you can use lists:map\/2 if you want to create a new list with the result of the callback on each element.\n\n<lang Erlang>\n3> lists:map(fun(X) -> X + 1 end, L).\n[2,3,4]\n<\/lang>\n\nOr you can use lists:foldl\/3 if you want to accumulate the result of the callback on each element into one value.\n\n<lang Erlang>\n4> lists:foldl(fun(X, Sum) -> X + Sum end, 0, L).\n6\n<\/lang>\n\n==[[:Category:Euphoria|Euphoria]][[Category:Euphoria]]==\n<lang euphoria>function apply_to_all(sequence s, integer f)\n    -- apply a function to all elements of a sequence\n    sequence result\n    result = {}\n    for i = 1 to length(s) do\n\t-- we can call add1() here although it comes later in the program\n\tresult = append(result, call_func(f, {s[i]}))\n    end for\n    return result\nend function\n\nfunction add1(atom x)\n    return x + 1\nend function\n\n-- add1() is visible here, so we can ask for its routine id\n? apply_to_all({1, 2, 3}, routine_id(\"add1\"))\n-- displays {2,3,4}<\/lang>\nThis is also \"Example 2\" in the Euphoria documentation for <code>routine_id()<\/code>.\nNote that this example will not work for multi-dimensional sequences.\n\n==[[:Category:Factor|Factor]][[Category:Factor]]==\nPrint each element squared:\n<lang factor>{ 1 2 3 4 } [ sq . ] each<\/lang>\n\nCollect return values:\n<lang factor>{ 1 2 3 4 } [ sq ] map<\/lang>\n\n==[[:Category:Fantom|Fantom]][[Category:Fantom]]==\n\nIn Fantom, functions can be passed to a collection iterator, such as 'each'.  'map' is used similarly, and the results are collected into a list.\n\n<lang fantom>\nclass Main\n{\n  public static Void main ()\n  {\n    [1,2,3,4,5].each |Int i| { echo (i) }\n    Int[] result := [1,2,3,4,5].map |Int i->Int| { return i * i }\n    echo (result) \n  }\n}\n<\/lang>\n\nOutput:\n<pre>\n1\n2\n3\n4\n5\n[1, 4, 9, 16, 25]\n<\/pre>\n\n==[[:Category:Forth|Forth]][[Category:Forth]]==\n\nThis is a word that will call a given function on each cell in an array.\n\n<lang forth>: map ( addr n fn -- )\n   -rot cells bounds do  i @ over execute i !  cell +loop ;<\/lang>\n\nExample usage:\n\n<lang forth>create data 1 , 2 , 3 , 4 , 5 ,\ndata 5 ' 1+ map  \\ adds one to each element of data<\/lang>\n\n==[[:Category:Fortran|Fortran]][[Category:Fortran]]==\nElemental functions.\n\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Fortran]] version ISO 95 and later[[SMW::on]]<\/div>\n<lang fortran>module arrCallback\ncontains\n    elemental function cube( x )\n        implicit none\n        real :: cube\n        real, intent(in) :: x\n        cube = x * x * x\n    end function cube\nend module arrCallback<\/lang>\n\n<lang fortran>program testAC\n    use arrCallback\n    implicit none\n    integer :: i, j\n    real, dimension(3,4) :: b, &\n        a = reshape( (\/ ((10 * i + j, i = 1, 3), j = 1, 4) \/), (\/ 3,4 \/) )\n     \n    do i = 1, 3\n        write(*,*) a(i,:)\n    end do\n     \n    b = cube( a )  ! Applies CUBE to every member of a,\n                   ! and stores each result in the equivalent element of b\n    do i = 1, 3\n        write(*,*) b(i,:)\n    end do\nend program testAC<\/lang>\n\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[ANSI FORTRAN]] version  77 (with MIL-STD-1753 structured DO) and later[[SMW::on]]<\/div>\n<lang fortran>      program test\nC\nC--   Declare array:\n      integer a(5)\nC\nC--   Fill it with Data\n      data a \/45,22,67,87,98\/\nC\nC--   Do something with all elements (in this case: print their squares)\n      do i=1,5\n        print *,a(i)*a(i)\n      end do\nC\n      end<\/lang>\n\n==[[:Category:FP|FP]][[Category:FP]]==\n<lang fp>{square * . [id, id]}\n& square: <1,2,3,4,5><\/lang>\n\n==<span id=\"F_Sharp\">[[:Category:F_Sharp|F#]]<\/span>[[Category:F_Sharp]]==\nApply a named function to each member of the array. The result is a new array of the same size as the input.\n<lang fsharp>let evenp x = x % 2 = 0\nlet result = Array.map evenp [| 1; 2; 3; 4; 5; 6 |]<\/lang>\nThe same can be done using anonymous functions, this time squaring the members of the input array.\n<lang fsharp>let result = Array.map (fun x -> x * x) [|1; 2; 3; 4; 5|]<\/lang>\nUse ''iter'' if the applied function does not return a value.\n<lang fsharp>Array.iter (fun x -> printfn \"%d\" x) [|1; 2; 3; 4; 5|]<\/lang>\n==[[:Category:GAP|GAP]][[Category:GAP]]==\n<lang gap>a := [1 .. 4];\nb := ShallowCopy(a);\n\n# Apply and replace values\nApply(a, n -> n*n);\na;\n# [ 1, 4, 9, 16 ]\n\n# Apply and don't change values\nPerform(b, Display);\n1\n2\n3\n4\n\nb;\n# [ 1 .. 4 ]<\/lang>\n\n==[[:Category:Go|Go]][[Category:Go]]==\n<div class=\"examplemeta translation\">'''Translation of''': [[Apply a callback to an array#Ruby|Ruby]]<\/div>\nThe task was originally written with a Ruby example, so here are Go versions of the current Ruby examples.\n\nPerhaps in contrast to Ruby, it is idiomatic in Go to use the for statement:\n<lang go>package main\n\nimport \"fmt\"\n\nfunc main() {\n    for _, i := range []int{1, 2, 3, 4, 5} {\n        fmt.Println(i * i)\n    }\n}<\/lang>\n\nAlternatively though, an array-like type can be defined and callback-style methods can be defined on it to apply a function to the elements.\n<lang go>package main\n\nimport \"fmt\"\n\ntype intSlice []int\n\nfunc (s intSlice) each(f func(int)) {\n    for _, i := range s {\n        f(i)\n    }\n}\n\nfunc (s intSlice) Map(f func(int) int) intSlice {\n    r := make(intSlice, len(s))\n    for j, i := range s {\n        r[j] = f(i)\n    }\n    return r\n}\n\nfunc main() {\n    s := intSlice{1, 2, 3, 4, 5}\n\n    s.each(func(i int) {\n        fmt.Println(i * i)\n    })\n\n    fmt.Println(s.Map(func(i int) int {\n        return i * i\n    }))\n}<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>\n1\n4\n9\n16\n25\n[1 4 9 16 25]\n<\/pre>\n\n==[[:Category:Groovy|Groovy]][[Category:Groovy]]==\n\nPrint each value in a list\n<lang groovy>[1,2,3,4].each { println it }<\/lang>\n\nCreate a new list containing the squares of another list\n<lang groovy>[1,2,3,4].collect { it * it }<\/lang>\n\n==[[:Category:Haskell|Haskell]][[Category:Haskell]]==\n\n===List===\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[GHC]][[SMW::on]]<\/div>\n<lang haskell>let square x = x*x\nlet values = [1..10]\nmap square values<\/lang>\n\nUsing list comprehension to generate a list of the squared values\n<lang haskell>[square x | x <- values]<\/lang>\n\nUsing function composition to create a function that will print the squares of a list\n<lang haskell>let printSquares = mapM_ (print.square)\nprintSquares values<\/lang>\n\n===Array===\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[GHC]][[SMW::on]]<\/div>\n<lang haskell>import Data.Array.IArray\nlet square x = x*x\nlet values = array (1,10) [(i,i)|i <- [1..10]] :: Array Int Int\namap square values<\/lang>\n\n==[[:Category:Icon|Icon]][[Category:Icon]] and [[:Category:Unicon|Unicon]][[Category:Unicon]]==\n<lang icon>procedure main()\n   local lst\n   lst := [10, 20, 30, 40]\n   every callback(write,!lst)\nend\n\nprocedure callback(p,arg)\n   return p(\" -> \", arg)\nend<\/lang>\n\n==[[:Category:IDL|IDL]][[Category:IDL]]==\n\nHard to come up with an example that isn't completely contrived. IDL doesn't really distinguish between a scalar and an array; thus\n\n<lang idl>b = a^3<\/lang>\n\nwill yield a scalar if <tt>a<\/tt> is scalar or a vector if <tt>a<\/tt> is a vector or an n-dimensional array if <tt>a<\/tt> is an n-dimensional array\n\n==[[:Category:Io|Io]][[Category:Io]]==\n<lang io>list(1,2,3,4,5) map(squared)<\/lang>\n\n==[[:Category:J|J]][[Category:J]]==\n\n'''Solution''':\n<lang j>   \"_1<\/lang>\n\n'''Example''':\n<lang j>   callback =:  *:\n   array    =:  1 2 3 4 5\n   \n   callback\"_1 array\n1 4 9 16 25<\/lang>\n\nBut note that this is a trivial example since <code>*: 1 2 3 4 5<\/code> would get the same result.  Then again, this is something of a trivial exercise in J since all of J is designed around the idea of applying functions usefully to arrays.\n\n==[[:Category:Java|Java]][[Category:Java]]==\n\nAs of the current version of Java, you have to define an interface for each type of function you want to use. The next version of Java will introduce function types.\n\nSo if you want to perform an action (which doesn't return anything) on an array of int's:\n\n<lang java>interface IntToVoid {\n    void run(int x);\n}\n\nfor (int z : myIntArray) {\n    new IntToVoid() {\n        public void run(int x) {\n            System.out.println(x);\n        }\n    }.run(z);\n}<\/lang>\n\nOr if you want to perform \"map\" - return an array of the results of function applications:\n\n<lang java>interface IntToInt {\n    int run(int x);\n}\n\nint[] result = new int[myIntArray.length];\nfor (int i = 0; i < myIntArray.length; i++) {\n    result[i] =\n        new IntToInt() {\n            public int run(int x) {\n                return x * x;\n            }\n        }.run(myIntArray[i]);\n}<\/lang>\n\n==[[:Category:JavaScript|JavaScript]][[Category:JavaScript]]==\n\nPortable technique:\n\n<lang javascript>function map(a, func) {\n  for (var i in a)\n    a[i] = func(a[i]);\n}\n\nvar a = [1, 2, 3, 4, 5];\nmap(a, function(v) { return v * v; });<\/lang>\n\n<div class=\"examplemeta libheader\">'''Library:''' [[SMW::off]][[:Category:BeyondJS|BeyondJS]][[Category:BeyondJS]][[SMW::on]]<\/div>\nWith the [http:\/\/w3future.com\/html\/beyondJS\/ BeyondJS] library:\n\n<lang javascript>var a = (1).to(10).collect(Math.pow.curry(undefined,2));<\/lang>\n\nWith Firefox 2.0:\n\n<lang javascript>function cube(num) {\n  return Math.pow(num, 3);\n}\n\nvar numbers = [1, 2, 3, 4, 5];\n\n\/\/ get results of calling cube on every element\nvar cubes1 = numbers.map(cube);\n\n\/\/ display each result in a separate dialog\ncubes1.forEach(alert);\n\n\/\/ array comprehension\nvar cubes2 = [cube(n) for each (n in numbers)];\nvar cubes3 = [n * n * n for each (n in numbers)];<\/lang>\n\n<div class=\"examplemeta libheader\">'''Library:''' [[SMW::off]][[:Category:Functional|Functional]][[Category:Functional]][[SMW::on]]<\/div>\n<lang javascript>Functional.map('x*x*x', [1,2,3,4,5])<\/lang>\n\n==[[:Category:TIScript|TIScript]][[Category:TIScript]]==\n\nJavaScript alike:\n\n<lang javascript>var a = [1, 2, 3, 4, 5];\na.map(function(v) { return v * v; })\n<\/lang>\n\nUsing short form of lambda notation:\n<lang javascript>var a = [1, 2, 3, 4, 5];\na.map( :v: v*v );\n<\/lang>\n\n==[[:Category:Joy|Joy]][[Category:Joy]]==\n<lang joy>[1 2 3 4 5] [dup *] map.<\/lang>\n\n==[[:Category:Lisaac|Lisaac]][[Category:Lisaac]]==\n<lang Lisaac>+ a : ARRAY(INTEGER);\n+ b : {INTEGER;};\n\na := ARRAY(INTEGER).create 1 to 3;\n1.to 3 do { i : INTEGER;\n  a.put i to i;\n};\n\nb := { arg : INTEGER;\n  (arg * arg).print;\n  '\\n'.print;\n};\n\na.foreach b;<\/lang>\n\n==[[:Category:Logo|Logo]][[Category:Logo]]==\n<lang logo>to square :x\n  output :x * :x\nend\nshow map \"square [1 2 3 4 5]  ; [1 4 9 16 25]\nshow map [? * ?] [1 2 3 4 5]  ; [1 4 9 16 25]\nforeach [1 2 3 4 5] [print square ?]  ; 1 4 9 16 25, one per line<\/lang>\n\n==[[:Category:Lua|Lua]][[Category:Lua]]==\n\nSay we have an array:\n<lang lua>myArray = {1, 2, 3, 4, 5}<\/lang>\nA map function for this would be\n<lang lua>map = function(f, data)\n   local result = {}\n   for k,v in ipairs(data) do\n      result[k] = f(v)\n   end\n   return result\nend<\/lang>\nTogether with our array and a square function this yields:\n<lang lua>myFunc = function(x) return x*x end\n\nprint(unpack( map(myFunc, myArray) ))\n--> 1   4   9   16  25<\/lang>\nIf you used pairs() instead of ipairs(), this would even work on a hash table in general.\nHowever, remember that hash table do not have an implicit ordering on their elements, like arrays do,\nso pairs() is not guaranteed to return the elements in the same order as ipairs()\n\n==[[:Category:M4|M4]][[Category:M4]]==\n<lang M4>define(`foreach', `pushdef(`$1')_foreach($@)popdef(`$1')')dnl\ndefine(`_arg1', `$1')dnl\ndefine(`_foreach', `ifelse(`$2', `()', `',\n   `define(`$1', _arg1$2)$3`'$0(`$1', (shift$2), `$3')')')dnl\ndnl\ndefine(`apply',`foreach(`x',$1,`$2(x)')')dnl\ndnl\ndefine(`z',`eval(`$1*2') ')dnl\napply(`(1,2,3)',`z')<\/lang>\n\nOutput:\n<pre>\n2 4 6\n<\/pre>\n\n==[[:Category:Mathematica|Mathematica]][[Category:Mathematica]]==\n<lang Mathematica>(#*#)& \/@ {1, 2, 3, 4}\n\nMap[Function[#*#], {1, 2, 3, 4}]<\/lang>\n\n==[[:Category:MATLAB|MATLAB]][[Category:MATLAB]]==\nThere are two types of arrays in MATLAB: arrays and cell arrays. MATLAB includes two functions, one for each of these data types, that accomplish the specification for this task. For arrays, we use \"arrayfun()\"; for cell arrays we use \"cellfun()\".<br \/>\nExample:\nFor both of these function the first argument is a function handle for the function we would like to apply to each element. The second argument is the array whose elements are modified by the function. The function can be any function, including user defined functions.\n<lang MATLAB>>> array = [1 2 3 4 5]\n\narray =\n\n     1     2     3     4     5\n\n>> arrayfun(@sin,array)\n\nans =\n\n  Columns 1 through 4\n\n   0.841470984807897   0.909297426825682   0.141120008059867  -0.756802495307928\n\n  Column 5\n\n  -0.958924274663138\n\n>> cellarray = {1,2,3,4,5}\n\ncellarray = \n\n    [1]    [2]    [3]    [4]    [5]\n\n>> cellfun(@tan,cellarray)\n\nans =\n\n  Columns 1 through 4\n\n   1.557407724654902  -2.185039863261519  -0.142546543074278   1.157821282349578\n\n  Column 5\n\n  -3.380515006246586<\/lang>\n\n==[[:Category:Modula-3|Modula-3]][[Category:Modula-3]]==\n<lang modula3>MODULE Callback EXPORTS Main;\n\nIMPORT IO, Fmt;\n\nTYPE CallBack = PROCEDURE (a: CARDINAL; b: INTEGER);\n     Values = REF ARRAY OF INTEGER;\n\nVAR sample := ARRAY [1..5] OF INTEGER {5, 4, 3, 2, 1};\n    callback := Display;\n\nPROCEDURE Display(loc: CARDINAL; val: INTEGER) =\n  BEGIN\n    IO.Put(\"array[\" & Fmt.Int(loc) & \"] = \" & Fmt.Int(val * val) & \"\\n\");\n  END Display;\n\nPROCEDURE Map(VAR values: ARRAY OF INTEGER; size: CARDINAL; worker: CallBack) =\n  VAR lvalues := NEW(Values, size);\n  BEGIN\n    FOR i := FIRST(lvalues^) TO LAST(lvalues^) DO\n      worker(i, values[i]);\n    END;\n  END Map;\n\nBEGIN\n  Map(sample, NUMBER(sample), callback);\nEND Callback.<\/lang>\n\n==[[:Category:NewLISP|NewLISP]][[Category:NewLISP]]==\n\n<lang NewLISP>> (map (fn (x) (* x x)) '(1 2 3 4))\n(1 4 9 16)\n<\/lang>\n\n==[[:Category:Nial|Nial]][[Category:Nial]]==\n\n<lang nial>each (* [first, first] ) 1 2 3 4\n=1 4 9 16<\/lang>\n\n==[[:Category:Objeck|Objeck]][[Category:Objeck]]==\n<lang objeck>\nuse Structure;\n\nbundle Default {\n  class Test {\n    function : Main(args : String[]) ~ Nil {\n      Run();\n    }\n\n    function : native : Run() ~ Nil {\n      values := IntVector->New([1, 2, 3, 4, 5]);\n      squares := values->Apply(Square(Int) ~ Int);\n      each(i : squares) {\n        squares->Get(i)->PrintLine();\n      };\n    }\n    \n    function : Square(value : Int) ~ Int {\n      return value * value;\n    }\n  }\n}\n<\/lang>\n\n==[[:Category:OCaml|OCaml]][[Category:OCaml]]==\nThis function is part of the standard library:\n\n<lang ocaml>Array.map<\/lang>\n\nUsage example:\n<lang ocaml>let square x = x * x;;\nlet values = Array.init 10 ((+) 1);;\nArray.map square values;;<\/lang>\n\nOr with lists (which are more typical in OCaml):\n<lang ocaml>let values = [1;2;3;4;5;6;7;8;9;10];;\nList.map square values;;<\/lang>\n\nUse <tt>iter<\/tt> if the applied function does not return a value.\n\n<lang ocaml>Array.iter (fun x -> Printf.printf \"%d\" x) [|1; 2; 3; 4; 5|];;<\/lang>\n<lang ocaml>List.iter (fun x -> Printf.printf \"%d\" x) [1; 2; 3; 4; 5];;<\/lang>\n\nwith partial application we can also write:\n\n<lang ocaml>Array.iter (Printf.printf \"%d\") [|1; 2; 3; 4; 5|];;<\/lang>\n<lang ocaml>List.iter (Printf.printf \"%d\") [1; 2; 3; 4; 5];;<\/lang>\n\n==[[:Category:Octave|Octave]][[Category:Octave]]==\n\nAlmost all the built-in can operate on each element of a vector or matrix; e.g. sin([pi\/2, pi, 2*pi]) computes the function sin on pi\/2, pi and 2*pi (returning a vector). If a function does not accept vectors\/matrices as arguments, the <tt>arrayfun<\/tt> can be used.\n\n<lang octave>function e = f(x, y)\n  e = x^2 + exp(-1\/(y+1));\nendfunction\n\n% f([2,3], [1,4]) gives and error, but\narrayfun(@f, [2, 3], [1,4])\n% works<\/lang>\n\n(The function <tt>f<\/tt> can be rewritten so that it can accept vectors as argument simply changing operators to their dot ''relatives'': <code>e = x.^2 + exp(-1 .\/ (y.+1))<\/code>)\n\n\n==[[:Category:Oz|Oz]][[Category:Oz]]==\n<lang oz>declare\n  fun{Square A}\n    A*A\n  end\n\n  Lst = [1 2 3 4 5]\n  \n  %% apply a PROCEDURE to every element\n  {ForAll Lst Show}\n\n  %% apply a FUNCTION to every element\n  Result = {Map Lst Square}\n  {Show Result}<\/lang>\n\n==[[:Category:PARI\/GP|PARI\/GP]][[Category:PARI\/GP]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[PARI\/GP]] version 2.4.3 and above[[SMW::on]]<\/div>\n:This code uses the [http:\/\/pari.math.u-bordeaux.fr\/dochtml\/html\/Programming_in_GP:_other_specific_functions.html#select select]() function, which was added in PARI version 2.4.2.  The order of the arguments changed between versions; to use in 2.4.2 change <code>select(function, vector)<\/code> to <code>select(vector, function)<\/code>.\n<lang parigp>callback(n)=n+n;\napply(callback, [1,2,3,4,5])<\/lang>\n\n==[[:Category:Pascal|Pascal]][[Category:Pascal]]==\nSee [[Apply_a_callback_to_an_array#Delphi | Delphi]]\n\n==[[:Category:Perl|Perl]][[Category:Perl]]==\n<lang perl># create array\nmy @a = (1, 2, 3, 4, 5);\n\n# create callback function\nsub mycallback {\n  return 2 * shift;\n}\n\n# use array indexing\nfor (my $i = 0; $i < scalar @a; $i++) {\n  print \"mycallback($a[$i]) = \", mycallback($a[$i]), \"\\n\";\n}\n\n# using foreach\nforeach my $x (@a) {\n  print \"mycallback($x) = \", mycallback($x), \"\\n\";\n}\n\n# using map (useful for transforming an array)\nmy @b = map mycallback($_), @a;                # @b is now (2, 4, 6, 8, 10)\n\n# and the same using an anonymous function\nmy @c = map { $_ * 2 } @a;                     # @c is now (2, 4, 6, 8, 10)\n\n# use a callback stored in a variable\nmy $func = \\&mycallback;\nmy @d = map $func->($_), @a;                  # @d is now (2, 4, 6, 8, 10)\n\n# filter an array \nmy @e = grep { $_ % 2 == 0 } @a;               # @e is now (2, 4)<\/lang>\n\n==[[:Category:Perl 6|Perl 6]][[Category:Perl 6]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Rakudo]] version #21 \"Seattle\"[[SMW::on]]<\/div>\n\n<lang perl6>my $function = { 2 * $^x + 3 };\nmy @array = 1 .. 5;\n\n# via map function\n.say for map $function, @array;\n\n# via map method\n.say for @array.map($function);\n\n# via for loop\nfor @array {\n    say $function($_);\n}\n\n# via the \"hyper\" metaoperator and method indirection\nsay @array\u00bb.$function;<\/lang>\n\n==[[:Category:PHP|PHP]][[Category:PHP]]==\n<lang php>function cube($n)\n{\n   return($n * $n * $n);\n}\n\n$a = array(1, 2, 3, 4, 5);\n$b = array_map(\"cube\", $a);\nprint_r($b);<\/lang>\n\n==[[:Category:PicoLisp|PicoLisp]][[Category:PicoLisp]]==\n<lang PicoLisp>: (mapc println (1 2 3 4 5))  # Print numbers\n1\n2\n3\n4\n5\n-> 5\n\n: (mapcar '((N) (* N N)) (1 2 3 4 5))  # Calculate squares\n-> (1 4 9 16 25)\n\n: (mapcar ** (1 2 3 4 5) (2 .))  # Same, using a circular list\n-> (1 4 9 16 25)\n\n: (mapcar if '(T NIL T NIL) '(1 2 3 4) '(5 6 7 8))  # Conditional function\n-> (1 6 3 8)<\/lang>\n\n==[[:Category:Pike|Pike]][[Category:Pike]]==\n<lang pike>int cube(int n)\n{\n    return n*n*n;\n}\n\narray(int) a = ({ 1,2,3,4,5 });\narray(int) b = cube(a[*]);      \/\/ automap operator\narray(int) c = map(a, cube);    \/\/ conventional map function<\/lang>\n\n==[[:Category:PL\/SQL|PL\/SQL]][[Category:PL\/SQL]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Oracle]][[SMW::on]]<\/div>\n<lang plsql>set serveroutput on\ndeclare\n      type myarray is table of number index by binary_integer;\n      x myarray;\n      i pls_integer;\nbegin\n      -- populate array\n      for i in 1..5 loop\n              x(i) := i;\n      end loop;\n      i := x.first;\n      -- square array\n      while i is not null loop\n              x(i) := x(i)*x(i);\n              dbms_output.put_line(x(i));\n              i := x.next(i);\n      end loop;\nend;\n\/<\/lang>\n\n==[[:Category:Pop11|Pop11]][[Category:Pop11]]==\n\n<lang pop11>;;; Define a procedure\ndefine proc(x);\n    printf(x*x, '%p,');\nenddefine;\n\n;;; Create array\nlvars ar = { 1 2 3 4 5};\n\n;;; Apply procedure to array\nappdata(ar, proc);<\/lang>\n\nIf one wants to create a new array consisting of transformed values then procedure mapdata may be more convenient.\n\n==[[:Category:PostScript|PostScript]][[Category:PostScript]]==\nThe <code>forall<\/code> operator applies a procedure to each element of an array, a packed array or a string.\n<lang postscript>[1 2 3 4 5] { dup mul = } forall<\/lang>\nIn this case the respective square numbers for the elements are printed.\n\nTo create a new array from the results above code can simply be wrapped in <code>[]<\/code>:\n<lang postscript>[ [1 2 3 4 5] { dup mul } forall ]<\/lang>\n\n<div class=\"examplemeta libheader\">'''Library:''' [[SMW::off]][[:Category:initlib|initlib]][[Category:initlib]][[SMW::on]]<\/div>\n<lang postscript>\n[1 2 3 4 5] {dup *} map\n<\/lang>\n\n==[[:Category:PowerShell|PowerShell]][[Category:PowerShell]]==\nThis can be done in PowerShell with the <code>ForEach-Object<\/code> cmdlet which applies a scriptblock to each element of an array:\n<lang powershell>1..5 | ForEach-Object { $_ * $_ }<\/lang>\nTo recreate a ''map'' function, found in other languages the same method applies:\n<lang powershell>function map ([array] $a, [scriptblock] $s) {\n    $a | ForEach-Object $s\n}<\/lang>\n\n==[[:Category:Prolog|Prolog]][[Category:Prolog]]==\nProlog doesn't have arrays, but we can do it with lists. This can be done in the console mode. \n<lang Prolog> ?- assert((fun(X, Y) :- Y is 2 * X)).\ntrue.\n\n?- maplist(fun, [1,2,3,4,5], L).\nL = [2,4,6,8,10].\n<\/lang>\n\n==[[:Category:PureBasic|PureBasic]][[Category:PureBasic]]==\n<lang PureBasic>Procedure Cube(Array param.i(1))\n    Protected n.i\n    For n = 0 To ArraySize(param())\n        Debug Str(param(n)) + \"^3 = \" + Str(param(n) * param(n) * param(n))\n    Next \nEndProcedure \n\nDim AnArray.i(4)\n\nFor n = 0 To ArraySize(AnArray()) \n    AnArray(n) = Random(99)\nNext \n\nCube(AnArray()) <\/lang>\n\n==[[:Category:Python|Python]][[Category:Python]]==\n<lang python>def square(n):\n    return n * n\n  \nnumbers = [1, 3, 5, 7]\n\nsquares1 = [square(n) for n in numbers]     # list comprehension\n\nsquares2a = map(square, numbers)            # functional form\n\nsquares2b = map(lambda x: x*x, numbers)     # functional form with `lambda`\n\nsquares3 = [n * n for n in numbers]         # no need for a function,\n                                            # anonymous or otherwise\n\nisquares1 = (n * n for n in numbers)        # iterator, lazy\n\nimport itertools\nisquares2 = itertools.imap(square, numbers) # iterator, lazy<\/lang>\nTo print squares of integers in the range from 0 to 9, type:\n<lang python>print \" \".join(str(n * n) for n in range(10))<\/lang>\nOr:\n<lang python>print \" \".join(map(str, map(square, range(10))))<\/lang>\nResult:\n<lang python>0 1 4 9 16 25 36 49 64 81<\/lang>\n\n==[[:Category:R|R]][[Category:R]]==\nMany functions can take advantage of implicit vectorisation, e.g.\n<lang R>cube <- function(x) x*x*x\nelements <- 1:5\ncubes <- cube(elements)<\/lang>\nExplicit looping over array elements is also possible.\n<lang R>cubes <- numeric(5)\nfor(i in seq_along(cubes))\n{\n   cubes[i] <- cube(elements[i])\n}<\/lang>\nLoop syntax can often simplified using the [http:\/\/stat.ethz.ch\/R-manual\/R-patched\/library\/base\/html\/apply.html *apply] family of functions.\n<lang R>elements2 <- list(1,2,3,4,5)\ncubes <- sapply(elements2, cube)<\/lang>\nIn each case above, the value of 'cubes' is \n 1   8  27  64 125\n\n==[[:Category:Raven|Raven]][[Category:Raven]]==\n<lang raven># To print the squared elements\n[1 2 3 4 5] each dup * print<\/lang>\n\n<lang raven># To obtain a new array\ngroup [1 2 3 4 5] each\n  dup *\nlist<\/lang>\n\n==[[:Category:REBOL|REBOL]][[Category:REBOL]]==\n<lang REBOL>REBOL [\n    Title: \"Array Callback\"\n    Date: 2010-01-04\n    Author: oofoe\n    URL: http:\/\/rosettacode.org\/wiki\/Apply_a_callback_to_an_Array\n]\n\nmap: func [\n\t\"Apply a function across an array.\"\n\tf [native! function!] \"Function to apply to each element of array.\"\n\ta [block!] \"Array to process.\"\n\t\/local x\n][x: copy []  forall a [append x do [f a\/1]]  x]\n\nsquare: func [x][x * x]\n\n; Tests:\n\nassert: func [code][print [either do code [\"  ok\"][\"FAIL\"]  mold code]]\n\nprint \"Simple loop, modify in place:\"\nassert [[1 100 81] = (a: [1 10 9]  forall a [a\/1: square a\/1]  a)]\n\nprint [crlf \"Functional style with 'map':\"]\nassert [[4 16 36] = map :square [2 4 6]]\n\nprint [crlf \"Applying native function with 'map':\"]\nassert [[2 4 6] = map :square-root [4 16 36]]<\/lang>\n\nOutput:\n\n<pre>Simple loop, modify in place:\n  ok [[1 100 81] = (a: [1 100 81] forall a [a\/1: square a\/1] a)]\n\nFunctional style with 'map':\n  ok [[4 16 36] = map :square [2 4 6]]\n\nApplying native function with 'map':\n  ok [[2 4 6] = map :square-root [4 16 36]]<\/pre>\n\n==[[:Category:Retro|Retro]][[Category:Retro]]==\nUsing the '''array'''' library to multiply each value in an array by 10 and display the results:\n\n<lang Retro>[ 1 2 3 4 5 ] ^array'fromQuote [ 10 * ] ^array'map ^array'display<\/lang>\n\nRetro also provides '''^array'apply''' for use when you don't want to alter the contents of the array:\n\n<lang Retro>[ \"Hello\" \"World\" \"Foo\" ] ^array'fromQuote [ \"%s \" puts ] ^array'apply<\/lang>\n\n==[[:Category:REXX|REXX]][[Category:REXX]]==\n<lang rexx>\/*REXX program to apply a callback to an array.  *\/\n        a.=;   b.=\n a.0= 0\n a.1= 1\n a.2= 2\n a.3= 3\n a.4= 4\n a.5= 5\n a.6= 6\n a.7= 7\n a.8= 8\n a.9= 9\na.10=10\n\ncall listab 'before'\ncall bangit 'a','b'      \/*factorialize the A array, store results in B *\/\ncall listab ' after'\nexit\n\/*\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500BANGIT subroutine\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500*\/\nbangit:   do j=0\n          _=value(arg(1)'.'j); if _=='' then return\n          call value arg(2)'.'j,fact(_)\n          end\n\/*\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500FACT subroutine\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500*\/\nfact: procedure; !=1; do j=2 to arg(1); !=!*j; end; return !\n\n\/*\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500LISTAB subroutine\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500*\/\nlistab: do j=0 while a.j\\==''\n        say arg(1) 'a.'j\"=\"a.j\n        end\nsay\n        do j=0 while b.j\\==''\n        say arg(1) 'b.'j\"=\"b.j\n        end\nreturn<\/lang>\n'''output'''\n<pre style=\"height:30ex;overflow:scroll\">\nbefore a.0=0\nbefore a.1=1\nbefore a.2=2\nbefore a.3=3\nbefore a.4=4\nbefore a.5=5\nbefore a.6=6\nbefore a.7=7\nbefore a.8=8\nbefore a.9=9\nbefore a.10=10\n\n after a.0=0\n after a.1=1\n after a.2=2\n after a.3=3\n after a.4=4\n after a.5=5\n after a.6=6\n after a.7=7\n after a.8=8\n after a.9=9\n after a.10=10\n\n after b.0=1\n after b.1=1\n after b.2=2\n after b.3=6\n after b.4=24\n after b.5=120\n after b.6=720\n after b.7=5040\n after b.8=40320\n after b.9=362880\n after b.10=3628800\n<\/pre>\n\n==[[:Category:RLaB|RLaB]][[Category:RLaB]]==\nRLaB has two type of arrays: 'standard' or 1-dimensional, that can be a row-\nor a column-vectory; and, 'associative' which are called lists.\nFor standard array its entry identifier (index) is an integer in\nrange 1:N where N is the size of the array.\nFor associative array its entry identifier is a string consisting of printable\nASCII characters.\n\nAll scalar mathematical functions are 'matrix-optimized' meaning that if the argument\nto a function is a matrix, then the return value of the function is a matrix of the\nsame size as the input argument, where the function is applied to the individual entries\nof the matrix.\nConsider an example:\n\n<lang RLaB>\n>> x = rand(2,4)\n 0.707213207   0.275298961   0.396757763   0.232312312\n 0.215619868   0.207078017   0.565700032   0.666090571\n>> sin(x)\n 0.649717845   0.271834652   0.386430003   0.230228332\n 0.213952984   0.205601224   0.536006923   0.617916954\n<\/lang>\n\nThis can be done on entry-by-entry basis, but one has to keep in mind that the\n'for' or 'while' loops are slow in interpreted languages, and RLaB is no exception.\n\n<lang RLaB>\nx = rand(2,4);\ny = zeros(2,4);\nfor (i in 1:2)\n{\n  for (j in 1:4)\n  {\n    y[i;j] = sin( x[i;j] );\n  }\n}\n<\/lang>\n\n\nThe functions can take lists as arguments, but then it has to be specified within the body\nof the function what to do with the list elements. Given a list call it 'x' there is a RLaB \nfunction 'members' which returns a string vector with the names of the elements of the list.\n\n<lang RLaB>\nx = <<>>;\nfor (i in 1:9)\n{\n  x.[i] = rand();\n}\n\ny = <<>>;\nfor (i in members(x))\n{\n  y.[i] = sin( x.[i] );\n}\n<\/lang>\n\n==[[:Category:Ruby|Ruby]][[Category:Ruby]]==\nYou could use a traditional \"for i in arr\" approach like below:\n<lang ruby>for i in [1,2,3,4,5] do\n   puts i**2\nend<\/lang>\n\nOr you could  the more preferred ruby way of an iterator (which is borrowed from SmallTalk)\n<lang ruby>[1,2,3,4,5].each{ |i| puts i**2 }<\/lang>\n\nTo create a new array of each value squared\n<lang ruby>[1,2,3,4,5].map{ |i| i**2 }<\/lang>\n\n==[[:Category:Salmon|Salmon]][[Category:Salmon]]==\n\nThese examples apply the square function to a list of the numbers from 0 through 9 to produce a new list of their squares, then iterate over the resulting list and print the squares.\n\n<lang Salmon>function apply(list, ageless to_apply)\n  (comprehend(x; list) (to_apply(x)));\n\nfunction square(x) (x*x);\n\niterate(x; apply([0...9], square))\n    x!;<\/lang>\n\nWith short identifiers:\n\n<lang Salmon>include \"short.salm\";\n\nfun apply(list, ageless to_apply)\n  (comp(x; list) (to_apply(x)));\n\nfun square(x) (x*x);\n\niter(x; apply([0...9], square))\n    x!;<\/lang>\n\nWith the numbers given as a list of individual elements:\n\n<lang Salmon>function apply(list, to_apply)\n  (comprehend(x; list) (to_apply(x)));\n\nfunction square(x) (x*x);\n\niterate(x; apply([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], square))\n    x!;<\/lang>\n\n==[[:Category:Sather|Sather]][[Category:Sather]]==\n<lang sather>class MAIN is\n  do_something(i:INT):INT is\n    return i * i;\n  end;\n\n  main is\n    a:ARRAY{INT} := |1, 2, 3, 4, 5|;\n    -- we use an anonymous closure to apply our do_something \"callback\"\n    a.map(bind(do_something(_)));\n    loop #OUT + a.elt! + \"\\n\"; end;\n  end;\nend;<\/lang>\n\n==[[:Category:Scala|Scala]][[Category:Scala]]==\n<lang scala>val l = List(1,2,3,4)\nl.foreach {i => println(i)}<\/lang>\n\nWhen the argument appears only once -as here, i appears only one in println(i) - it may be shortened to\n<lang scala>l.foreach(println(_))<\/lang>\nSame for an array\n<lang scala>val a = Array(1,2,3,4)\na.foreach {i => println(i)}\na.foreach(println(_))  '' \/\/ same as previous line''<\/lang>\n\nOr for an externally defined function:\n<lang scala>def doSomething(in: int) = {println(\"Doing something with \"+in)}\nl.foreach(doSomething)<\/lang>\n\nThere is also a ''for'' syntax, which is internally rewritten to call foreach. A foreach method must be defined on ''a''\n<lang scala>for(val i <- a) println(i)<\/lang>\n\nIt is also possible to apply a function on each item of an list to get a new list (same on array and most collections)\n<lang scala>val squares = l.map{i => i * i} ''\/\/squares is''  List(1,4,9,16)<\/lang>\n\nOr the equivalent ''for'' syntax, with the additional keyword ''yield'', map is called instead of foreach\n<lang scala>val squares = for (val i <- l) yield i * i<\/lang>\n\n==[[:Category:Scheme|Scheme]][[Category:Scheme]]==\n<lang scheme>(define (square n) (* n n))\n(define x #(1 2 3 4 5))\n(map square (vector->list x))<\/lang>\n\nA single-line variation\n<lang scheme>(map (lambda (n) (* n n)) '(1 2 3 4 5))<\/lang>\n\nFor completeness, the <tt>map<\/tt> function (which is R5RS standard) can be coded as follows:\n<lang scheme>(define (map f L)\n  (if (null? L)\n      L\n      (cons (f (car L)) (map f (cdr L)))))<\/lang>\n\n==[[:Category:Slate|Slate]][[Category:Slate]]==\n<lang slate>#( 1 2 3 4 5 ) collect: [| :n | n * n].<\/lang>\n\n==[[:Category:Smalltalk|Smalltalk]][[Category:Smalltalk]]==\n<lang smalltalk>#( 1 2 3 4 5 ) collect: [:n | n * n].<\/lang>\n\n==[[:Category:Standard ML|Standard ML]][[Category:Standard ML]]==\n<lang Standard ML>\nmap f l\n<\/lang>\ni.e.\n<lang Standard ML>\nmap (fn x=>x+1) [1,2,3];; (* [2,3,4] *)\n<\/lang>\n\n==[[:Category:SuperCollider|SuperCollider]][[Category:SuperCollider]]==\nActually, there is a builtin <tt>squared<\/tt> operator:\n<lang SuperCollider>[1, 2, 3].squared;  \/\/ returns [1, 4, 9]<\/lang>\nAnything that is a <tt>Collection<\/tt> can be used with <tt>collect<\/tt>:\n<lang SuperCollider>[1, 2, 3].collect({ arg x; x*x });<\/lang>\n[[List Comprehension#SuperCollider|List comprehension]] combined with a higher-order function can also be used:\n<lang SuperCollider>var square = {\n  arg x;\n  x*x;\n};\nvar map = {\n  arg fn, xs;\n  all {: fn.value(x), x <- xs };\n};\nmap.value(square,[1,2,3]);<\/lang>\n\n==[[:Category:Tcl|Tcl]][[Category:Tcl]]==\n\nIf I wanted to call \"<tt>myfunc<\/tt>\" on each element of <tt>dat<\/tt> and <tt>dat<\/tt> were a list:\n<lang tcl>foreach var $dat {\n    myfunc $var\n}<\/lang>\nThis does not retain any of the values returned by <tt>myfunc<\/tt>.\n\nif <tt>dat<\/tt> were an (associative) array, however:\n<lang tcl>foreach name [array names dat] {\n    myfunc $dat($name)\n}<\/lang>\n\nMore functional, with a simple <code>map<\/code> function:\n<lang Tcl>proc map {f list} {\n   set res {}\n   foreach e $list {lappend res [$f $e]}\n   return $res\n}\nproc square x {expr {$x*$x}}\n\n% map square {1 2 3 4 5}\n1 4 9 16 25<\/lang>\n\n==[[:Category:TI-89 BASIC|TI-89 BASIC]][[Category:TI-89 BASIC]]==\n\n<lang ti89b>\u00a9 For no return value\nDefine foreach(fe_cname,fe_list) = Prgm\n  Local fe_i\n  For fe_i,1,dim(fe_list)\n    #fe_cname(fe_list[fe_i])\n  EndFor\nEndPrgm\n\n\u00a9 For a list of results\nDefine map(map_cnam,map_list) = seq(#map_cnam(map_list[map_i]),map_i,1,dim(map_list))\n\nDefine callback(elem) = Prgm\n  Disp elem\nEndPrgm\n\nforeach(\"callback\", {1,2,3,4,5})\nDisp map(\"\u221a\", {1,2,3,4,5})<\/lang>\n\nOutput:\n\n<math>1<\/math><br>\n<math>2<\/math><br>\n<math>3<\/math><br>\n<math>4<\/math><br>\n<math>5<\/math><br>\n<math>\\begin{Bmatrix}1 & \\sqrt{2} & \\sqrt{3} & 2 & \\sqrt{5}\\end{Bmatrix}<\/math>\n\n==[[:Category:Toka|Toka]][[Category:Toka]]==\n\n<lang toka>( array count function -- )\n{\n  value| array fn |\n  [ i array ] is I\n  [ to fn swap to array 0 swap [ I array.get :stack fn invoke I array.put ] countedLoop ]\n} is map-array\n\n( Build an array )\n5 cells is-array a\n10 0 a array.put\n11 1 a array.put\n12 2 a array.put\n13 3 a array.put\n14 4 a array.put\n\n( Add 1 to each item in the array )\na 5  [ 1 + ] map-array<\/lang>\n\n==[[:Category:TXR|TXR]][[Category:TXR]]==\n\nPrint 1 through 10:\n\n<lang txr>@(do\n   (defun mapvec (vec fun)\n     (each ((i (range 0 (- (length vec) 1))))\n       [fun [vec i]]))\n\n   (mapvec #(1 2 3 4 5 6 7 8 9 10)\n           (lambda (x) (format t \"~a\\n\" x))))<\/lang>\n\n==[[:Category:UNIX Shell|UNIX Shell]][[Category:UNIX Shell]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Bourne Shell]][[SMW::on]]<\/div>\n<lang bash>map() {\n\tmap_command=$1\n\tshift\n\tfor i do \"$map_command\" \"$i\"; done\n}\nlist=1:2:3\n(IFS=:; map echo $list)<\/lang>\n\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[ksh93]][[SMW::on]]<\/div>\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[pdksh]][[SMW::on]]<\/div>\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[zsh]][[SMW::on]]<\/div>\n<lang bash>map() {\n\ttypeset command=$1\n\tshift\n\tfor i do \"$command\" \"$i\"; done\n}\nset -A ary 1 2 3\nmap print \"${ary[@]}\"<\/lang>\n\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[zsh]][[SMW::on]]<\/div>\n<lang bash>map(){for i ($*[2,-1]) $1 $i}\na=(1 2 3)\nmap print $a<\/lang>\n\n==[[:Category:Ursala|Ursala]][[Category:Ursala]]==\nThe * is a built-in map operator.\nThis example shows a map of the successor function over a list of natural numbers.\n<lang Ursala>#import nat\n\n#cast %nL\n\ndemo = successor* <325,32,67,1,3,7,315><\/lang>\noutput:\n<pre>\n<326,33,68,2,4,8,316>\n<\/pre>\n\n==[[:Category:V|V]][[Category:V]]==\napply squaring (dup *) to each member of collection\n<lang v>[1 2 3 4] [dup *] map<\/lang>\n\n==[[:Category:VBScript|VBScript]][[Category:VBScript]]==\nI really have my doubts as to whether this really counts as a callback. I used the same thing in the solution to Amb.\n\n=====Implementation=====\n<lang vb>\nclass callback\n\tdim sRule\n\n\tpublic property let rule( x )\n\t\tsRule = x\n\tend property\n\t\n\tpublic default function applyTo(a)\n\t\tdim p1\n\t\tfor i = lbound( a ) to ubound( a )\n\t\t\tp1 = a( i )\n\t\t\ta( i ) = eval( sRule )\n\t\tnext\n\t\tapplyTo = a\n\tend function\nend class\n<\/lang>\n\n=====Invocation=====\n<lang vb>\ndim a1\ndim cb\nset cb = new callback\n\ncb.rule = \"ucase(p1)\"\na1 = split(\"my dog has fleas\", \" \" )\ncb.applyTo a1\nwscript.echo join( a1, \" \" )\n\ncb.rule = \"p1 ^ p1\"\na1 = array(1,2,3,4,5,6,7,8,9,10)\ncb.applyto a1\nwscript.echo join( a1, \", \" )\n\n<\/lang>\n\n=====Output=====\n<pre>\nMY DOG HAS FLEAS\n1, 4, 27, 256, 3125, 46656, 823543, 16777216, 387420489, 10000000000\n<\/pre>\n\n==[[:Category:Vorpal|Vorpal]][[Category:Vorpal]]==\nGiven and array, A, and a function, F, mapping F over the elements of A is simple:\n<lang vorpal>A.map(F)<\/lang>\nIf F takes 2 arguments, x and , then simply pass them to map.  They will be passed to F when as it is applied to each element of A.\n<lang vorpal>A.map(F, x, y)<\/lang>\n\n[[Category:gnuplot\/Omit]]\n[[Category:LaTeX\/Omit]]\n[[Category:Make\/Omit]]\n[[Category:NSIS\/Omit]]\n[[Category:PlainTeX\/Omit]]"}]}}}}