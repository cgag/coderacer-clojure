{"query-continue":{"search":{"gsroffset":1},"revisions":{"rvstartid":134889}},"query":{"pages":{"3370":{"pageid":3370,"ns":0,"title":"Arithmetic\/Rational","revisions":[{"*":"<div class=\"infobox\" style=\"width: 2in\">[[File:Rcode-button-task-crushed.png|64px|left|alt=Task|link=Category:Solutions by Programming Task]]'''Arithmetic\/Rational'''<br\/>\nYou are encouraged to [[Rosetta Code:Solve a Task|solve this task]] according to the task description, using any language you may know.[[Category:Programming Tasks]][[Category:Arithmetic operations]]<\/div>[[Category:Arithmetic]]\nThe objective of this task is to create a reasonably complete implementation of rational arithmetic in the particular language using the idioms of the language.\n\nFor example:\nDefine a new type called '''frac''' with binary operator \"\/\/\" of two integers that returns a '''structure''' made up of the numerator and the denominator (as per a rational number).\n\nFurther define the appropriate rational unary '''operators''' '''abs''' and '-', with the binary '''operators''' for addition '+', subtraction '-', multiplication '&times;', division '\/', integer division '&divide;', modulo division, the comparison operators (e.g. '<', '&le;', '>', & '&ge;') and equality operators (e.g. '=' & '&ne;').\n\nDefine standard coercion '''operators''' for casting '''int''' to '''frac''' etc.\n\nIf space allows, define standard increment and decrement '''operators''' (e.g. '+:=' & '-:=' etc.).\n\nFinally test the operators:\nUse the new type '''frac''' to find all [[Perfect Numbers|perfect numbers]] less than 2<sup>19<\/sup> by summing the reciprocal of the factors.\n\n'''See also'''\n* [[Perfect Numbers]]\n\n==[[:Category:Ada|Ada]][[Category:Ada]]==\n<div style=\"text-align:right;font-size:7pt\">''<nowiki>[<\/nowiki>This section is included from [[Arithmetic\/Rational\/Ada|a subpage]] and should be edited there, not here.<nowiki>]<\/nowiki>''<\/div>\n\nThe generic package specification:\n<lang ada>generic\n   type Number is range <>;\npackage Generic_Rational is\n   type Rational is private;\n   \n   function \"abs\"   (A : Rational) return Rational;\n   function \"+\"     (A : Rational) return Rational;\n   function \"-\"     (A : Rational) return Rational;\n   function Inverse (A : Rational) return Rational;\n   \n   function \"+\" (A : Rational; B : Rational) return Rational;\n   function \"+\" (A : Rational; B : Number  ) return Rational;\n   function \"+\" (A : Number;   B : Rational) return Rational;\n\n   function \"-\" (A : Rational; B : Rational) return Rational;\n   function \"-\" (A : Rational; B : Number  ) return Rational;\n   function \"-\" (A : Number;   B : Rational) return Rational;\n\n   function \"*\" (A : Rational; B : Rational) return Rational;\n   function \"*\" (A : Rational; B : Number  ) return Rational;\n   function \"*\" (A : Number;   B : Rational) return Rational;\n\n   function \"\/\" (A : Rational; B : Rational) return Rational;\n   function \"\/\" (A : Rational; B : Number  ) return Rational;\n   function \"\/\" (A : Number;   B : Rational) return Rational;\n   function \"\/\" (A : Number;   B : Number)   return Rational;\n   \n   function \">\"  (A : Rational; B : Rational) return Boolean;\n   function \">\"  (A : Number;   B : Rational) return Boolean;\n   function \">\"  (A : Rational; B : Number)   return Boolean;\n\n   function \"<\"  (A : Rational; B : Rational) return Boolean;\n   function \"<\"  (A : Number;   B : Rational) return Boolean;\n   function \"<\"  (A : Rational; B : Number)   return Boolean;\n\n   function \">=\" (A : Rational; B : Rational) return Boolean;\n   function \">=\" (A : Number;   B : Rational) return Boolean;\n   function \">=\" (A : Rational; B : Number)   return Boolean;\n\n   function \"<=\" (A : Rational; B : Rational) return Boolean;\n   function \"<=\" (A : Number;   B : Rational) return Boolean;\n   function \"<=\" (A : Rational; B : Number)   return Boolean;\n\n   function \"=\"  (A : Number;   B : Rational) return Boolean;\n   function \"=\"  (A : Rational; B : Number)   return Boolean;\n\n   function Numerator   (A : Rational) return Number;\n   function Denominator (A : Rational) return Number;\n             \n   Zero : constant Rational;\n   One  : constant Rational;\nprivate\n   type Rational is record\n      Numerator   : Number;\n      Denominator : Number;\n   end record;\n\n   Zero : constant Rational := (0, 1);\n   One  : constant Rational := (1, 1);\nend Generic_Rational;<\/lang>\nThe package can be instantiated with any integer type. It provides rational numbers represented by a numerator and denominator cleaned from the common divisors. Mixed arithmetic of the base integer type and the rational type is supported. Division to zero raises Constraint_Error. The implementation of the specification above is as follows:\n<lang ada>package body Generic_Rational is\n\n   function GCD (A, B : Number) return Number is\n   begin\n      if A = 0 then\n         return B;\n      end if;\n      if B = 0 then\n         return A;\n      end if;\n      if A > B then\n         return GCD (B, A mod B);\n      else\n         return GCD (A, B mod A);\n      end if;\n   end GCD;\n\n   function Inverse (A : Rational) return Rational is\n   begin\n      if A.Numerator > 0 then\n         return (A.Denominator, A.Numerator);\n      elsif A.Numerator < 0 then\n         return (-A.Denominator, -A.Numerator);\n      else\n         raise Constraint_Error;\n      end if;\n   end Inverse;\n\n   function \"abs\" (A : Rational) return Rational is\n   begin\n      return (abs A.Numerator, A.Denominator);\n   end \"abs\";\n\n   function \"+\" (A : Rational) return Rational is\n   begin\n      return A;\n   end \"+\";\n\n   function \"-\" (A : Rational) return Rational is\n   begin\n      return (-A.Numerator, A.Denominator);\n   end \"-\";\n   \n   function \"+\" (A : Rational; B : Rational) return Rational is\n      Common        : constant Number := GCD (A.Denominator, B.Denominator);\n      A_Denominator : constant Number := A.Denominator \/ Common; \n      B_Denominator : constant Number := B.Denominator \/ Common; \n   begin\n      return (A.Numerator * B_Denominator + B.Numerator * A_Denominator) \/\n             (A_Denominator * B.Denominator);\n   end \"+\";\n\n   function \"+\" (A : Rational; B : Number) return Rational is\n   begin\n      return (A.Numerator + B * A.Denominator) \/ A.Denominator;\n   end \"+\";\n\n   function \"+\" (A : Number; B : Rational) return Rational is\n   begin\n      return B + A;\n   end \"+\";\n\n   function \"-\" (A : Rational; B : Rational) return Rational is\n   begin\n      return A + (-B);\n   end \"-\";\n\n   function \"-\" (A : Rational; B : Number) return Rational is\n   begin\n      return A + (-B);\n   end \"-\";\n\n   function \"-\" (A : Number; B : Rational) return Rational is\n   begin\n      return A + (-B);\n   end \"-\";\n\n   function \"*\" (A : Rational; B : Rational) return Rational is\n   begin\n      return (A.Numerator * B.Numerator) \/ (A.Denominator * B.Denominator);\n   end \"*\";\n\n   function \"*\" (A : Rational; B : Number) return Rational is\n      Common : constant Number := GCD (A.Denominator, abs B);\n   begin\n      return (A.Numerator * B \/ Common, A.Denominator \/ Common);\n   end \"*\";\n\n   function \"*\" (A : Number; B : Rational) return Rational is\n   begin\n      return B * A;\n   end \"*\";\n\n   function \"\/\" (A : Rational; B : Rational) return Rational is\n   begin\n      return A * Inverse (B);\n   end \"\/\";\n\n   function \"\/\" (A : Rational; B : Number) return Rational is\n      Common : constant Number := GCD (abs A.Numerator, abs B);\n   begin\n      if B > 0 then\n         return (A.Numerator \/ Common, A.Denominator * (B \/ Common));\n      else\n         return ((-A.Numerator) \/ Common, A.Denominator * ((-B) \/ Common));\n      end if;\n   end \"\/\";\n\n   function \"\/\" (A : Number; B : Rational) return Rational is\n   begin\n      return Inverse (B) * A;\n   end \"\/\";\n\n   function \"\/\" (A : Number; B : Number) return Rational is\n      Common : constant Number := GCD (abs A, abs B);\n   begin\n      if B = 0 then\n         raise Constraint_Error;\n      elsif A = 0 then\n         return (0, 1);\n      elsif A > 0 xor B > 0 then\n         return (-(abs A \/ Common), abs B \/ Common);\n      else\n         return (abs A \/ Common, abs B \/ Common);\n      end if;\n   end \"\/\";\n   \n   function \">\" (A, B : Rational) return Boolean is\n      Diff : constant Rational := A - B;\n   begin\n      return Diff.Numerator > 0;\n   end \">\";\n\n   function \">\" (A : Number; B : Rational) return Boolean is\n      Diff : constant Rational := A - B;\n   begin\n      return Diff.Numerator > 0;\n   end \">\";\n\n   function \">\" (A : Rational; B : Number) return Boolean is\n      Diff : constant Rational := A - B;\n   begin\n      return Diff.Numerator > 0;\n   end \">\";\n\n   function \"<\" (A, B : Rational) return Boolean is\n      Diff : constant Rational := A - B;\n   begin\n      return Diff.Numerator < 0;\n   end \"<\";\n\n   function \"<\" (A : Number; B : Rational) return Boolean is\n      Diff : constant Rational := A - B;\n   begin\n      return Diff.Numerator < 0;\n   end \"<\";\n   \n   function \"<\" (A : Rational; B : Number) return Boolean is\n      Diff : constant Rational := A - B;\n   begin\n      return Diff.Numerator < 0;\n   end \"<\";\n\n   function \">=\" (A, B : Rational) return Boolean is\n      Diff : constant Rational := A - B;\n   begin\n      return Diff.Numerator >= 0;\n   end \">=\";\n\n   function \">=\" (A : Number; B : Rational) return Boolean is\n      Diff : constant Rational := A - B;\n   begin\n      return Diff.Numerator >= 0;\n   end \">=\";\n\n   function \">=\" (A : Rational; B : Number) return Boolean is\n      Diff : constant Rational := A - B;\n   begin\n      return Diff.Numerator >= 0;\n   end \">=\";\n\n   function \"<=\" (A, B : Rational) return Boolean is\n      Diff : constant Rational := A - B;\n   begin\n      return Diff.Numerator <= 0;\n   end \"<=\";\n\n   function \"<=\" (A : Number; B : Rational) return Boolean is\n      Diff : constant Rational := A - B;\n   begin\n      return Diff.Numerator <= 0;\n   end \"<=\";\n\n   function \"<=\" (A : Rational; B : Number) return Boolean is\n      Diff : constant Rational := A - B;\n   begin\n      return Diff.Numerator <= 0;\n   end \"<=\";\n\n   function \"=\" (A : Number; B : Rational) return Boolean is\n      Diff : constant Rational := A - B;\n   begin\n      return Diff.Numerator = 0;\n   end \"=\";\n\n   function \"=\" (A : Rational; B : Number) return Boolean is\n      Diff : constant Rational := A - B;\n   begin\n      return Diff.Numerator = 0;\n   end \"=\";\n\n   function Numerator (A : Rational) return Number is\n   begin\n      return A.Numerator;\n   end Numerator;\n\n   function Denominator (A : Rational) return Number is\n   begin\n      return A.Denominator;\n   end Denominator;\n\nend Generic_Rational;<\/lang>\nThe implementation uses solution of the [[greatest common divisor]] task. Here is the implementation of the test:\n<lang ada>with Ada.Numerics.Elementary_Functions;  use Ada.Numerics.Elementary_Functions;\nwith Ada.Text_IO;                        use Ada.Text_IO;\nwith Generic_Rational;\n\nprocedure Test_Rational is\n   package Integer_Rational is new Generic_Rational (Integer);\n   use Integer_Rational;\nbegin\n   for Candidate in 2..2**15 loop\n      declare\n         Sum  : Rational := 1 \/ Candidate;\n      begin\n         for Divisor in 2..Integer (Sqrt (Float (Candidate))) loop\n            if Candidate mod Divisor = 0 then -- Factor is a divisor of Candidate\n               Sum := Sum + One \/ Divisor + Rational'(Divisor \/ Candidate);\n            end if;\n         end loop;\n         if Sum = 1 then\n            Put_Line (Integer'Image (Candidate) & \" is perfect\");\n         end if;\n      end;\n   end loop;\nend Test_Rational;<\/lang>\nThe perfect numbers are searched by summing of the reciprocal of each of the divisors of a candidate except 1. This sum must be 1 for a perfect number.\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>\n 6 is perfect\n 28 is perfect\n 496 is perfect\n 8128 is perfect\n<\/pre>\n\n==[[:Category:ALGOL 68|ALGOL 68]][[Category:ALGOL 68]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[ALGOL 68]] version Standard - no extensions to language used[[SMW::on]]<\/div>\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[ALGOL 68G]] version Any - tested with release mk15-0.8b.fc9.i386[[SMW::on]]<\/div>\n<lang algol68> MODE FRAC = STRUCT( INT num #erator#,  den #ominator#);\n FORMAT frac repr = $g(-0)\"\/\/\"g(-0)$;\n \n PROC gcd = (INT a, b) INT: # greatest common divisor #\n   (a = 0 | b |: b = 0 | a |: ABS a > ABS b  | gcd(b, a MOD b) | gcd(a, b MOD a));\n \n PROC lcm = (INT a, b)INT: # least common multiple #\n   a OVER gcd(a, b) * b;\n \n PROC raise not implemented error = ([]STRING args)VOID: (\n   put(stand error, (\"Not implemented error: \",args, newline));\n   stop\n );\n \n PRIO \/\/ = 9; # higher then the ** operator #\n OP \/\/ = (INT num, den)FRAC: ( # initialise and normalise #\n   INT common = gcd(num, den);\n   IF den < 0 THEN\n     ( -num OVER common, -den OVER common)\n   ELSE\n     ( num OVER common, den OVER common)\n   FI\n );\n \n OP + = (FRAC a, b)FRAC: (\n   INT common = lcm(den OF a, den OF b);\n   FRAC result := ( common OVER den OF a * num OF a + common OVER den OF b * num OF b, common );\n   num OF result\/\/den OF result\n );\n \n OP - = (FRAC a, b)FRAC: a + -b,\n    * = (FRAC a, b)FRAC: (\n   INT num = num OF a * num OF b,\n       den = den OF a * den OF b;\n   INT common = gcd(num, den);\n   (num OVER common) \/\/ (den OVER common)\n );\n \n OP \/  = (FRAC a, b)FRAC: a * FRAC(den OF b, num OF b),# real division #\n    %  = (FRAC a, b)INT: ENTIER (a \/ b),               # integer divison #\n    %* = (FRAC a, b)FRAC: a\/b - FRACINIT ENTIER (a\/b), # modulo division #\n    ** = (FRAC a, INT exponent)FRAC: \n     IF exponent >= 0 THEN\n       (num OF a ** exponent, den OF a ** exponent )\n     ELSE\n       (den OF a ** exponent, num OF a ** exponent )\n     FI;\n \n OP REALINIT = (FRAC frac)REAL: num OF frac \/ den OF frac,\n    FRACINIT = (INT num)FRAC: num \/\/ 1,\n    FRACINIT = (REAL num)FRAC: (\n      # express real number as a fraction # # a future execise! #\n      raise not implemented error((\"Convert a REAL to a FRAC\",\"!\"));\n      SKIP\n    );\n \n OP <  = (FRAC a, b)BOOL: num OF (a - b) <  0,\n    >  = (FRAC a, b)BOOL: num OF (a - b) >  0,\n    <= = (FRAC a, b)BOOL: NOT ( a > b ),\n    >= = (FRAC a, b)BOOL: NOT ( a < b ),\n    =  = (FRAC a, b)BOOL: (num OF a, den OF a) = (num OF b, den OF b),\n    \/= = (FRAC a, b)BOOL: (num OF a, den OF a) \/= (num OF b, den OF b);\n \n # Unary operators #\n OP - = (FRAC frac)FRAC: (-num OF frac, den OF frac),\n    ABS = (FRAC frac)FRAC: (ABS num OF frac, ABS den OF frac),\n    ENTIER = (FRAC frac)INT: (num OF frac OVER den OF frac) * den OF frac;\n \n COMMENT Operators for extended characters set, and increment\/decrement:\n OP +:= = (REF FRAC a, FRAC b)REF FRAC: ( a := a + b ),\n    +=: = (FRAC a, REF FRAC b)REF FRAC: ( b := a + b ),\n    -:= = (REF FRAC a, FRAC b)REF FRAC: ( a := a - b ),\n    *:= = (REF FRAC a, FRAC b)REF FRAC: ( a := a * b ),\n    \/:= = (REF FRAC a, FRAC b)REF FRAC: ( a := a \/ b ),\n    %:= = (REF FRAC a, FRAC b)REF FRAC: ( a := FRACINIT (a % b) ),\n    %*:= = (REF FRAC a, FRAC b)REF FRAC: ( a := a %* b );\n \n # OP aliases for extended character sets (eg: Unicode, APL, ALCOR and GOST 10859) #\n OP \u00d7  = (FRAC a, b)FRAC: a * b,\n    \u00f7  = (FRAC a, b)INT: a OVER b,\n    \u00f7\u00d7 = (FRAC a, b)FRAC: a MOD b,\n    \u00f7* = (FRAC a, b)FRAC: a MOD b,\n    %\u00d7 = (FRAC a, b)FRAC: a MOD b,\n    \u2264  = (FRAC a, b)FRAC: a <= b,\n    \u2265  = (FRAC a, b)FRAC: a >= b,\n    \u2260  = (FRAC a, b)BOOL: a \/= b,\n    \u2191  = (FRAC frac, INT exponent)FRAC: frac ** exponent,\n \n    \u00f7\u00d7:= = (REF FRAC a, FRAC b)REF FRAC: ( a := a MOD b ),\n    %\u00d7:= = (REF FRAC a, FRAC b)REF FRAC: ( a := a MOD b ),\n    \u00f7*:= = (REF FRAC a, FRAC b)REF FRAC: ( a := a MOD b );\n \n # BOLD aliases for CPU that only support uppercase for 6-bit bytes  - wrist watches #\n OP OVER = (FRAC a, b)INT: a % b,\n    MOD = (FRAC a, b)FRAC: a %*b,\n    LT = (FRAC a, b)BOOL: a <  b,\n    GT = (FRAC a, b)BOOL: a >  b,\n    LE = (FRAC a, b)BOOL: a <= b,\n    GE = (FRAC a, b)BOOL: a >= b,\n    EQ = (FRAC a, b)BOOL: a =  b,\n    NE = (FRAC a, b)BOOL: a \/= b,\n    UP = (FRAC frac, INT exponent)FRAC: frac**exponent;\n \n # the required standard assignment operators #\n OP PLUSAB  = (REF FRAC a, FRAC b)REF FRAC: ( a +:= b ), # PLUS #\n    PLUSTO  = (FRAC a, REF FRAC b)REF FRAC: ( a +=: b ), # PRUS #\n    MINUSAB = (REF FRAC a, FRAC b)REF FRAC: ( a *:= b ),\n    DIVAB   = (REF FRAC a, FRAC b)REF FRAC: ( a \/:= b ),\n    OVERAB  = (REF FRAC a, FRAC b)REF FRAC: ( a %:= b ),\n    MODAB   = (REF FRAC a, FRAC b)REF FRAC: ( a %*:= b );\n \nEND COMMENT\nExample: searching for Perfect Numbers.\n FRAC sum:= FRACINIT 0; \n FORMAT perfect = $b(\" perfect!\",\"\")$;\n \n FOR i FROM 2 TO 2**19 DO \n   INT candidate := i;\n   FRAC sum := 1 \/\/ candidate;\n   REAL real sum := 1 \/ candidate;\n   FOR factor FROM 2 TO ENTIER sqrt(candidate) DO\n     IF candidate MOD factor = 0 THEN\n       sum :=  sum + 1 \/\/ factor + 1 \/\/ ( candidate OVER factor);\n       real sum +:= 1 \/ factor + 1 \/ ( candidate OVER factor)\n     FI\n   OD;\n   IF den OF sum  = 1 THEN\n     printf(($\"Sum of reciprocal factors of \"g(-0)\" = \"g(-0)\" exactly, about \"g(0,real width) f(perfect)l$, \n             candidate, ENTIER sum, real sum, ENTIER sum = 1))\n   FI\n OD<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>\nSum of reciprocal factors of 6 = 1 exactly, about 1.0000000000000000000000000001 perfect!\nSum of reciprocal factors of 28 = 1 exactly, about 1.0000000000000000000000000001 perfect!\nSum of reciprocal factors of 120 = 2 exactly, about 2.0000000000000000000000000002\nSum of reciprocal factors of 496 = 1 exactly, about 1.0000000000000000000000000001 perfect!\nSum of reciprocal factors of 672 = 2 exactly, about 2.0000000000000000000000000001\nSum of reciprocal factors of 8128 = 1 exactly, about 1.0000000000000000000000000001 perfect!\nSum of reciprocal factors of 30240 = 3 exactly, about 3.0000000000000000000000000002\nSum of reciprocal factors of 32760 = 3 exactly, about 3.0000000000000000000000000003\nSum of reciprocal factors of 523776 = 2 exactly, about 2.0000000000000000000000000005\n<\/pre>\n\n==[[:Category:C|C]][[Category:C]]==\nC does not have overloadable operators. The following implementation <u>''does not define all operations''<\/u> so as to keep the example short. Note that the code passes around struct values instead of pointers to keep it simple, a practice normally avoided for efficiency reasons.\n<lang c>#include <stdio.h>\n#include <stdlib.h>\n#define FMT \"%lld\"\ntypedef long long int fr_int_t;\ntypedef struct { fr_int_t num, den; } frac;\n\nfr_int_t gcd(fr_int_t m, fr_int_t n)\n{\n\tfr_int_t t;\n\twhile (n) { t = n; n = m % n; m = t; }\n\treturn m;\n}\n\nfrac frac_new(fr_int_t num, fr_int_t den)\n{\n\tfrac a;\n\tif (!den) {\n\t\tprintf(\"divide by zero: \"FMT\"\/\"FMT\"\\n\", num, den);\n\t\tabort();\n\t}\n\n\tint g = gcd(num, den);\n\n\tif (g)\t{ num \/= g; den \/= g; }\n\telse\t{ num = 0; den = 1;   }\n\n\tif (den < 0) {\n\t\tden = -den;\n\t\tnum = -num;\n\t}\n\ta.num = num; a.den = den;\n\treturn a;\n}\n\n#define BINOP(op, n, d) frac frac_##op(frac a, frac b) { return frac_new(n,d); }\nBINOP(add, a.num * b.den + b.num * a.den, a.den * b.den);\nBINOP(sub, a.num * b.den - b.num + a.den, a.den * b.den);\nBINOP(mul, a.num * b.num, a.den * b.den);\nBINOP(div, a.num * b.den, a.den * b.num);\n\nint frac_cmp(frac a, frac b) {\n\tint l = a.num * b.den, r = a.den * b.num;\n\treturn l < r ? -1 : l > r;\n}\n#define frac_cmp_int(a, b) frac_cmp(a, frac_new(b, 1))\nint frtoi(frac a) { return a.den \/ a.num; }\ndouble frtod(frac a) { return (double)a.den \/ a.num; }\n\nint main()\n{\n\tint n, k;\n\tfrac sum, kf;\n\n\tfor (n = 2; n < 1<<19; n++) {\n\t\tsum = frac_new(1, n);\n\n\t\tfor (k = 2; k * k < n; k++) {\n\t\t\tif (n % k) continue;\n\t\t\tkf = frac_new(1, k);\n\t\t\tsum = frac_add(sum, kf);\n\n\t\t\tkf = frac_new(1, n \/ k);\n\t\t\tsum = frac_add(sum, kf);\n\t\t}\n\t\tif (frac_cmp_int(sum, 1) == 0) printf(\"%d\\n\", n);\n\t}\n\n\treturn 0;\n}<\/lang>\nSee [[Rational Arithmetic\/C]]\n\n==<span id=\"C sharp\">[[:Category:C sharp|C#]]<\/span>[[Category:C sharp]]==\n<div style=\"text-align:right;font-size:7pt\">''<nowiki>[<\/nowiki>This section is included from [[Arithmetic\/Rational\/C sharp|a subpage]] and should be edited there, not here.<nowiki>]<\/nowiki>''<\/div>\n\n<lang csharp>using System;\n\nstruct Fraction : IEquatable<Fraction>, IComparable<Fraction>\n{\n    public readonly long Num;\n    public readonly long Denom;\n\n    public Fraction(long num, long denom)\n    {\n        if (num == 0)\n        {\n            denom = 0;\n        }\n        else if (denom == 0)\n        {\n            throw new ArgumentException(\"Denominator may not be zero\", \"denom\");\n        }\n        else if (denom < 0)\n        {\n            num = -num;\n            denom = -denom;\n        }\n\n        long d = GCD(num, denom);\n        this.Num = num \/ d;\n        this.Denom = denom \/ d;\n    }\n\n    private static long GCD(long x, long y)\n    {\n        return y == 0 ? x : GCD(y, x % y);\n    }\n\n    private static long LCM(long x, long y)\n    {\n        return x \/ GCD(x, y) * y;\n    }\n\n    public Fraction Abs()\n    {\n        return new Fraction(Math.Abs(Num), Denom);\n    }\n\n    public Fraction Reciprocal()\n    {\n        return new Fraction(Denom, Num);\n    }\n\n    #region Conversion Operators\n\n    public static implicit operator Fraction(long i)\n    {\n        return new Fraction(i, 1);\n    }\n\n    public static explicit operator double(Fraction f)\n    {\n        return f.Num == 0 ? 0 : (double)f.Num \/ f.Denom;\n    }\n\n    #endregion\n\n    #region Arithmetic Operators\n\n    public static Fraction operator -(Fraction f)\n    {\n        return new Fraction(-f.Num, f.Denom);\n    }\n\n    public static Fraction operator +(Fraction a, Fraction b)\n    {\n        long m = LCM(a.Denom, b.Denom);\n        long na = a.Num * m \/ a.Denom;\n        long nb = b.Num * m \/ b.Denom;\n        return new Fraction(na + nb, m);\n    }\n\n    public static Fraction operator -(Fraction a, Fraction b)\n    {\n        return a + (-b);\n    }\n\n    public static Fraction operator *(Fraction a, Fraction b)\n    {\n        return new Fraction(a.Num * b.Num, a.Denom * b.Denom);\n    }\n\n    public static Fraction operator \/(Fraction a, Fraction b)\n    {\n        return a * b.Reciprocal();\n    }\n\n    public static Fraction operator %(Fraction a, Fraction b)\n    {\n        long l = a.Num * b.Denom, r = a.Denom * b.Num;\n        long n = l \/ r;\n        return new Fraction(l - n * r, a.Denom * b.Denom);\n    }\n\n    #endregion\n\n    #region Comparison Operators\n\n    public static bool operator ==(Fraction a, Fraction b)\n    {\n        return a.Num == b.Num && a.Denom == b.Denom;\n    }\n\n    public static bool operator !=(Fraction a, Fraction b)\n    {\n        return a.Num != b.Num || a.Denom != b.Denom;\n    }\n\n    public static bool operator <(Fraction a, Fraction b)\n    {\n        return (a.Num * b.Denom) < (a.Denom * b.Num);\n    }\n\n    public static bool operator >(Fraction a, Fraction b)\n    {\n        return (a.Num * b.Denom) > (a.Denom * b.Num);\n    }\n\n    public static bool operator <=(Fraction a, Fraction b)\n    {\n        return !(a > b);\n    }\n\n    public static bool operator >=(Fraction a, Fraction b)\n    {\n        return !(a < b);\n    }\n\n    #endregion\n\n    #region Object Members\n\n    public override bool Equals(object obj)\n    {\n        if (obj is Fraction)\n            return ((Fraction)obj) == this;\n        else\n            return false;\n    }\n\n    public override int GetHashCode()\n    {\n        return Num.GetHashCode() ^ Denom.GetHashCode();\n    }\n\n    public override string ToString()\n    {\n        return Num.ToString() + \"\/\" + Denom.ToString();\n    }\n\n    #endregion\n\n    #region IEquatable<Fraction> Members\n\n    public bool Equals(Fraction other)\n    {\n        return other == this;\n    }\n\n    #endregion\n\n    #region IComparable<Fraction> Members\n\n    public int CompareTo(Fraction other)\n    {\n        return (this.Num * other.Denom).CompareTo(this.Denom * other.Num);\n    }\n\n    #endregion\n}<\/lang>\nTest program:\n<lang csharp>using System;\n\nstatic class Program\n{\n    static void Main(string[] args)\n    {\n        int max = 1 << 19;\n        for (int candidate = 2; candidate < max; candidate++)\n        {\n            Fraction sum = new Fraction(1, candidate);\n            int max2 = (int)Math.Sqrt(candidate);\n            for (int factor = 2; factor <= max2; factor++)\n            {\n                if (candidate % factor == 0)\n                {\n                    sum += new Fraction(1, factor);\n                    sum += new Fraction(1, candidate \/ factor);\n                }\n            }\n\n            if (sum == 1)\n                Console.WriteLine(\"{0} is perfect\", candidate);\n        }\n    }\n}<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>6 is perfect\n28 is perfect\n496 is perfect\n8128 is perfect<\/pre>\n\n==[[:Category:C++|C++]][[Category:C++]]==\n<div class=\"examplemeta libheader\">'''Library:''' [[SMW::off]][[:Category:Boost|Boost]][[Category:Boost]][[SMW::on]]<\/div>\nBoost provides a rational number template.\n<lang cpp>#include <iostream>\n#include \"math.h\"\n#include \"boost\/rational.hpp\"\n\ntypedef  boost::rational<int> frac;\n\nbool is_perfect(int c)\n{\n    frac sum(1, c);\n    for (int f = 2;f < sqrt(static_cast<float>(c)); ++f){\n\n        if (c % f == 0) sum += frac(1,f) + frac(1, c\/f);\n    }\n    if (sum.denominator() == 1){\n \treturn (sum == 1);\n    }\n    return false;\n}\n\nint main()\n{\n    for (int candidate = 2; candidate < 0x80000; ++candidate){\n        if (is_perfect(candidate)) \n\t        std::cout << candidate << \" is perfect\" << std::endl;\n    }\n    return 0;\n}<\/lang>\n\n==[[:Category:Clojure|Clojure]][[Category:Clojure]]==\nRatios are built in to Clojure and support math operations already.  They automatically reduce and become Integers if possible.\n<lang Clojure>user> 22\/7\n22\/7\nuser> 34\/2\n17\nuser> (+ 37\/5 42\/9)\n181\/15<\/lang>\n\n==[[:Category:Common Lisp|Common Lisp]][[Category:Common Lisp]]==\nCommon Lisp has rational numbers built-in and integrated with all other number types. Common Lisp's number system is not extensible so reimplementing rational arithmetic would require all-new operator names.\n<lang lisp>(loop for candidate from 2 below (expt 2 19)\n      for sum = (+ (\/ candidate)\n                   (loop for factor from 2 to (isqrt candidate)\n                         when (zerop (mod candidate factor))\n                           sum (+ (\/ factor) (\/ (floor candidate factor)))))\n      when (= sum 1)\n        collect candidate)<\/lang>\n\n==[[:Category:D|D]][[Category:D]]==\nRational implementation based on BigInt.\n<lang d>import std.bigint, std.traits, std.conv;\n\nT gcd(T)(\/*in*\/ T a, \/*in*\/ T b) \/*pure nothrow*\/ {\n    \/\/ std.numeric.gcd doesn't work with BigInt\n    return (b != 0) ? gcd(b, a % b) : (a < 0) ? -a : a;\n}\n\nT lcm(T)(\/*in*\/ T a, \/*in*\/ T b) {\n    return a \/ gcd(a, b) * b;\n}\n\nBigInt toBig(T : BigInt)(\/*const*\/ ref T n) pure nothrow { return n; }\n\nBigInt toBig(T)(const ref T n) pure nothrow if (isIntegral!T) {\n    return BigInt(n);\n}\n\nstruct Rational {\n    \/*const*\/ private BigInt num, den; \/\/ numerator & denominator\n\n    private enum Type { NegINF = -2,\n                        NegDEN = -1,\n                        NaRAT  =  0,\n                        NORMAL =  1,\n                        PosINF =  2 };\n\n    this(U : Rational)(U n) pure nothrow {\n        num = n.num;\n        den = n.den;\n    }\n\n    this(U)(in U n) pure nothrow if (isIntegral!U) {\n        num = toBig(n);\n        den = 1UL;\n    }\n\n    this(U, V)(\/*in*\/ U n, \/*in*\/ V d) \/*pure nothrow*\/ {\n        num = toBig(n);\n        den = toBig(d);\n        \/*const*\/ BigInt common = gcd(num, den);\n        if (common != 0) {\n            num \/= common;\n            den \/= common;\n        } else { \/\/ infinite or NOT a Number\n            num = (num == 0) ? 0 : (num < 0) ? -1 : 1;\n            den = 0;\n        }\n        if (den < 0) { \/\/ assure den is non-negative\n            num = -num;\n            den = -den;\n        }\n    }\n\n    BigInt nomerator() \/*const*\/ pure nothrow @property {\n        return num;\n    }\n\n    BigInt denominator() \/*const*\/ pure nothrow @property {\n        return den;\n    }\n\n    string toString() \/*const*\/ {\n        if (den == 0) {\n            if (num == 0)\n                return \"NaRat\";\n            else\n                return ((num < 0) ? \"-\" : \"+\") ~ \"infRat\";\n        }\n        return text(num) ~ (den == 1 ? \"\" : (\"\/\" ~ text(den)));\n    }\n\n    Rational opBinary(string op)(\/*in*\/ Rational r)\n    \/*const pure nothrow*\/ if (op == \"+\" || op == \"-\") {\n        BigInt common = lcm(den, r.den);\n        BigInt n = mixin(\"common \/ den * num\" ~ op ~\n                         \"common \/ r.den * r.num\" );\n        return Rational(n, common);\n    }\n\n    Rational opBinary(string op)(\/*in*\/ Rational r)\n    \/*const pure nothrow*\/ if (op == \"*\") {\n        return Rational(num * r.num, den * r.den);\n    }\n\n    Rational opBinary(string op)(\/*in*\/ Rational r)\n    \/*const pure nothrow*\/ if (op == \"\/\") {\n        return Rational(num * r.den, den * r.num);\n    }\n\n    Rational opBinary(string op, T)(in T r)\n    \/*const pure nothrow*\/ if (isIntegral!T && (op == \"+\" ||\n                               op == \"-\" || op == \"*\" || op == \"\/\")) {\n        return opBinary!op(Rational(r));\n    }\n\n    Rational opBinary(string op)(in size_t p)\n    \/*const pure nothrow*\/ if (op == \"^^\") {\n        return Rational(num ^^ p, den ^^ p);\n    }\n\n    Rational opBinaryRight(string op, T)(in T l)\n    \/*const pure nothrow*\/ if (isIntegral!T) {\n        return Rational(l).opBinary!op(Rational(num, den));\n    }\n\n    Rational opUnary(string op)()\n    \/*const pure nothrow*\/ if (op == \"+\" || op == \"-\") {\n        return Rational(mixin(op ~ \"num\"), den);\n    }\n\n    int opCmp(T)(\/*in*\/ T r) \/*const pure nothrow*\/ {\n        Rational rhs = Rational(r);\n        if (type() == Type.NaRAT || rhs.type() == Type.NaRAT)\n            throw new Exception(\"Compare invlove an NaRAT.\");\n        if (type() != Type.NORMAL ||\n            rhs.type() != Type.NORMAL) \/\/ for infinite\n            return (type() == rhs.type()) ? 0 :\n                   ((type() < rhs.type()) ? -1 : 1);\n        BigInt diff = num * rhs.den - den * rhs.num;\n        return (diff == 0) ? 0 : ((diff < 0) ? -1 : 1);\n    }\n\n    int opEquals(T)(\/*in*\/ T r) \/*const pure nothrow*\/ {\n        Rational rhs = Rational(r);\n        if (type() == Type.NaRAT || rhs.type() == Type.NaRAT)\n            return false;\n        return num == rhs.num && den == rhs.den;\n    }\n\n    Type type() \/*const pure nothrow*\/ {\n        if (den > 0) return Type.NORMAL;\n        if (den < 0) return Type.NegDEN;\n        if (num > 0) return Type.PosINF;\n        if (num < 0) return Type.NegINF;\n        return Type.NaRAT;\n    }\n}\n\n\nversion (rational_arithmetic_main) {\nvoid main() {\n    \/\/ Find perfect numbers using Rational:\n    import std.stdio, std.math;\n\n    foreach (p; 2 .. 2 ^^ 16) { \/\/ use 2^^19 for the task\n        auto sum = Rational(1, p);\n        foreach (factor; 2 .. 1 + cast(uint)sqrt(cast(real)p))\n            if (p % factor == 0)\n                sum = sum + Rational(1, factor) + Rational(factor, p);\n        if (sum.denominator == 1)\n            writefln(\"Sum of recipr. factors of %6s = %s exactly%s\",\n                     p, sum, (sum == 1) ? \", perfect.\" : \".\");\n    }\n}\n}<\/lang>\nUse the <code>-version=rational_arithmetic_main<\/code> compiler switch to run the test code.\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>Sum of recipr. factors of      6 = 1 exactly, perfect.\nSum of recipr. factors of     28 = 1 exactly, perfect.\nSum of recipr. factors of    120 = 2 exactly.\nSum of recipr. factors of    496 = 1 exactly, perfect.\nSum of recipr. factors of    672 = 2 exactly.\nSum of recipr. factors of   8128 = 1 exactly, perfect.\nSum of recipr. factors of  30240 = 3 exactly.\nSum of recipr. factors of  32760 = 3 exactly.<\/pre>\nRun-time is about 9.5 seconds. It's quite slow because in DMD v.2.060 BigInts have no memory optimizations.\n\nOutput using p up to 2^^19, as requested by the task:\n<pre>Sum of recipr. factors of      6 = 1 exactly, perfect.\nSum of recipr. factors of     28 = 1 exactly, perfect.\nSum of recipr. factors of    120 = 2 exactly.\nSum of recipr. factors of    496 = 1 exactly, perfect.\nSum of recipr. factors of    672 = 2 exactly.\nSum of recipr. factors of   8128 = 1 exactly, perfect.\nSum of recipr. factors of  30240 = 3 exactly.\nSum of recipr. factors of  32760 = 3 exactly.\nSum of recipr. factors of 523776 = 2 exactly.<\/pre>\n\n==[[:Category:Elisa|Elisa]][[Category:Elisa]]==\n<lang Elisa>component RationalNumbers;\n  type Rational;\n       Rational(Numerator = integer, Denominater = integer) -> Rational;\n\n       Rational + Rational -> Rational; \n       Rational - Rational -> Rational;\n       Rational * Rational -> Rational; \n       Rational \/ Rational -> Rational;\n \n       Rational == Rational -> boolean; \n       Rational <> Rational -> boolean; \n       Rational >= Rational -> boolean; \n       Rational <= Rational -> boolean;\n       Rational >  Rational -> boolean; \n       Rational <  Rational -> boolean;\n \n       + Rational -> Rational;\n       - Rational -> Rational;\n       abs(Rational) -> Rational;\n      \n       Rational(integer) -> Rational;\n       Numerator(Rational) -> integer;\n       Denominator(Rational) -> integer;\n  begin\n       Rational(A,B) = Rational:[A;B];\n\n       R1 + R2 = Normalize( R1.A * R2.B + R1.B * R2.A, R1.B * R2.B);\n       R1 - R2 = Normalize( R1.A * R2.B - R1.B * R2.A, R1.B * R2.B);\n       R1 * R2 = Normalize( R1.A * R2.A, R1.B * R2.B);\n       R1 \/ R2 = Normalize( R1.A * R2.B, R1.B * R2.A);\n\n       R1 == R2 = [ R = (R1 - R2); R.A == 0]; \n       R1 <> R2 = [ R = (R1 - R2); R.A <> 0];\n       R1 >= R2 = [ R = (R1 - R2); R.A >= 0];\n       R1 <= R2 = [ R = (R1 - R2); R.A <= 0];\n       R1 > R2  = [ R = (R1 - R2); R.A > 0];\n       R1 < R2  = [ R = (R1 - R2); R.A < 0];\n\n       + R = R;\n       - R = Rational(-R.A, R.B);\n\n       abs(R) = Rational(abs(R.A), abs(R.B)); \n       Rational(I) = Rational (I, 1);\n       Numerator(R) = R.A;\n       Denominator(R) = R.B;\n\n\t\t\t\t<< internal definitions >>\n\n       Normalize (A = integer, B = integer) -> Rational;\n       Normalize (A, B) = [ exception( B == 0, \"Illegal Rational Number\");\n\t                    Common = GCD(abs(A), abs(B)); \n\t\t\t    if B < 0 then Rational(-A \/ Common, -B \/ Common)\n\t\t\t             else Rational( A \/ Common,  B \/ Common) ];\n\n       GCD (A = integer, B = integer) -> integer;\n       GCD (A, B) = [ if A == 0 then return(B);   \n\t              if B == 0 then return(A); \n\t\t      if A > B  then GCD (B, mod(A,B))\n \t\t                else GCD (A, mod(B,A)) ]; \n\nend component RationalNumbers;<\/lang>\nTests\n<lang Elisa>use RationalNumbers;\n\nPerfectNumbers( Limit = integer) -> multi(integer);\nPerfectNumbers( Limit) =\n  \t      [ Candidate = 2 .. Limit; \n\t\tSum:= Rational(1,Candidate);\n\t\t[ Divisor = 2 .. integer(sqrt(real(Candidate)));\n\t\t  if mod(Candidate, Divisor) == 0 then \n\t\t\tSum := Sum + Rational(1, Divisor) + Rational(Divisor, Candidate);\n\t\t];\n\t\tif Sum == Rational(1,1) then Candidate\n              ];\n\nPerfectNumbers(10000)?<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>\n6\n28\n496\n8128\n<\/pre>\n\n==[[:Category:Forth|Forth]][[Category:Forth]]==\n<lang forth>\\ Rationals can use any double cell operations:  2!, 2@, 2dup, 2swap, etc.\n\\ Uses the stack convention of the built-in \"*\/\" for int * frac -> int\n\n: numerator  drop ;\n: denominator nip ;\n\n: s>rat      1 ;\t\t\\ integer to rational  (n\/1)\n: rat>s      \/ ;\t\t\\ integer\n: rat>frac   mod ;\t\t\\ fractional part\n: rat>float  swap s>f s>f f\/ ;\n\n: rat.  swap 1 .r [char] \/ emit . ;\n\n\\ normalize: factors out gcd and puts sign into numerator\n: gcd ( a b -- gcd ) begin ?dup while tuck mod repeat ;\n: rat-normalize ( rat -- rat ) 2dup gcd tuck \/ >r \/ r> ;\n\n: rat-abs     swap abs    swap ;\n: rat-negate  swap negate swap ;\n: 1\/rat       over 0< if negate swap negate else swap then ;\n\n: rat+ ( a b c d -- ad+bc bd )\n  rot 2dup * >r\n   rot * >r * r> +\n  r> rat-normalize ;\n: rat-  rat-negate rat+ ;\n\n: rat* ( a b c d -- ac bd )\n  rot * >r * r> rat-normalize ;\n: rat\/  swap rat* ;\n\n: rat-equal  d= ;\n: rat-less ( a b c d -- ad<bc )\n  -rot * >r * r> < ;\n: rat-more  2swap rat-less ;\n\n: rat-inc  tuck + swap ;\n: rat-dec  tuck - swap ;<\/lang>\n\n==[[:Category:Fortran|Fortran]][[Category:Fortran]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Fortran]] version 90 and later[[SMW::on]]<\/div>\n<lang fortran>module module_rational\n\n  implicit none\n  private\n  public :: rational\n  public :: rational_simplify\n  public :: assignment (=)\n  public :: operator (\/\/)\n  public :: operator (+)\n  public :: operator (-)\n  public :: operator (*)\n  public :: operator (\/)\n  public :: operator (<)\n  public :: operator (<=)\n  public :: operator (>)\n  public :: operator (>=)\n  public :: operator (==)\n  public :: operator (\/=)\n  public :: abs\n  public :: int\n  public :: modulo\n  type rational\n    integer :: numerator\n    integer :: denominator\n  end type rational\n  interface assignment (=)\n    module procedure assign_rational_int, assign_rational_real\n  end interface\n  interface operator (\/\/)\n    module procedure make_rational\n  end interface\n  interface operator (+)\n    module procedure rational_add\n  end interface\n  interface operator (-)\n    module procedure rational_minus, rational_subtract\n  end interface\n  interface operator (*)\n    module procedure rational_multiply\n  end interface\n  interface operator (\/)\n    module procedure rational_divide\n  end interface\n  interface operator (<)\n    module procedure rational_lt\n  end interface\n  interface operator (<=)\n    module procedure rational_le\n  end interface\n  interface operator (>)\n    module procedure rational_gt\n  end interface\n  interface operator (>=)\n    module procedure rational_ge\n  end interface\n  interface operator (==)\n    module procedure rational_eq\n  end interface\n  interface operator (\/=)\n    module procedure rational_ne\n  end interface\n  interface abs\n    module procedure rational_abs\n  end interface\n  interface int\n    module procedure rational_int\n  end interface\n  interface modulo\n    module procedure rational_modulo\n  end interface\n\ncontains\n\n  recursive function gcd (i, j) result (res)\n    integer, intent (in) :: i\n    integer, intent (in) :: j\n    integer :: res\n    if (j == 0) then\n      res = i\n    else\n      res = gcd (j, modulo (i, j))\n    end if\n  end function gcd\n\n  function rational_simplify (r) result (res)\n    type (rational), intent (in) :: r\n    type (rational) :: res\n    integer :: g\n    g = gcd (r % numerator, r % denominator)\n    res = r % numerator \/ g \/\/ r % denominator \/ g\n  end function rational_simplify\n\n  function make_rational (numerator, denominator) result (res)\n    integer, intent (in) :: numerator\n    integer, intent (in) :: denominator\n    type (rational) :: res\n    res = rational (numerator, denominator)\n  end function make_rational\n\n  subroutine assign_rational_int (res, i)\n    type (rational), intent (out), volatile :: res\n    integer, intent (in) :: i\n    res = i \/\/ 1\n  end subroutine assign_rational_int\n\n  subroutine assign_rational_real (res, x)\n    type (rational), intent(out), volatile :: res\n    real, intent (in) :: x\n    integer :: x_floor\n    real :: x_frac\n    x_floor = floor (x)\n    x_frac = x - x_floor\n    if (x_frac == 0) then\n      res = x_floor \/\/ 1\n    else\n      res = (x_floor \/\/ 1) + (1 \/\/ floor (1 \/ x_frac))\n    end if\n  end subroutine assign_rational_real\n\n  function rational_add (r, s) result (res)\n    type (rational), intent (in) :: r\n    type (rational), intent (in) :: s\n    type (rational) :: res\n    res = r % numerator * s % denominator + r % denominator * s % numerator \/\/ &\n        & r % denominator * s % denominator\n  end function rational_add\n\n  function rational_minus (r) result (res)\n    type (rational), intent (in) :: r\n    type (rational) :: res\n    res = - r % numerator \/\/ r % denominator\n  end function rational_minus\n\n  function rational_subtract (r, s) result (res)\n    type (rational), intent (in) :: r\n    type (rational), intent (in) :: s\n    type (rational) :: res\n    res = r % numerator * s % denominator - r % denominator * s % numerator \/\/ &\n        & r % denominator * s % denominator\n  end function rational_subtract\n\n  function rational_multiply (r, s) result (res)\n    type (rational), intent (in) :: r\n    type (rational), intent (in) :: s\n    type (rational) :: res\n    res = r % numerator * s % numerator \/\/ r % denominator * s % denominator\n  end function rational_multiply\n\n  function rational_divide (r, s) result (res)\n    type (rational), intent (in) :: r\n    type (rational), intent (in) :: s\n    type (rational) :: res\n    res = r % numerator * s % denominator \/\/ r % denominator * s % numerator\n  end function rational_divide\n\n  function rational_lt (r, s) result (res)\n    type (rational), intent (in) :: r\n    type (rational), intent (in) :: s\n    type (rational) :: r_simple\n    type (rational) :: s_simple\n    logical :: res\n    r_simple = rational_simplify (r)\n    s_simple = rational_simplify (s)\n    res = r_simple % numerator * s_simple % denominator < &\n        & s_simple % numerator * r_simple % denominator\n  end function rational_lt\n\n  function rational_le (r, s) result (res)\n    type (rational), intent (in) :: r\n    type (rational), intent (in) :: s\n    type (rational) :: r_simple\n    type (rational) :: s_simple\n    logical :: res\n    r_simple = rational_simplify (r)\n    s_simple = rational_simplify (s)\n    res = r_simple % numerator * s_simple % denominator <= &\n        & s_simple % numerator * r_simple % denominator\n  end function rational_le\n\n  function rational_gt (r, s) result (res)\n    type (rational), intent (in) :: r\n    type (rational), intent (in) :: s\n    type (rational) :: r_simple\n    type (rational) :: s_simple\n    logical :: res\n    r_simple = rational_simplify (r)\n    s_simple = rational_simplify (s)\n    res = r_simple % numerator * s_simple % denominator > &\n        & s_simple % numerator * r_simple % denominator\n  end function rational_gt\n\n  function rational_ge (r, s) result (res)\n    type (rational), intent (in) :: r\n    type (rational), intent (in) :: s\n    type (rational) :: r_simple\n    type (rational) :: s_simple\n    logical :: res\n    r_simple = rational_simplify (r)\n    s_simple = rational_simplify (s)\n    res = r_simple % numerator * s_simple % denominator >= &\n        & s_simple % numerator * r_simple % denominator\n  end function rational_ge\n\n  function rational_eq (r, s) result (res)\n    type (rational), intent (in) :: r\n    type (rational), intent (in) :: s\n    logical :: res\n    res = r % numerator * s % denominator == s % numerator * r % denominator\n  end function rational_eq\n\n  function rational_ne (r, s) result (res)\n    type (rational), intent (in) :: r\n    type (rational), intent (in) :: s\n    logical :: res\n    res = r % numerator * s % denominator \/= s % numerator * r % denominator\n  end function rational_ne\n\n  function rational_abs (r) result (res)\n    type (rational), intent (in) :: r\n    type (rational) :: res\n    res = sign (r % numerator, r % denominator) \/\/ r % denominator\n  end function rational_abs\n\n  function rational_int (r) result (res)\n    type (rational), intent (in) :: r\n    integer :: res\n    res = r % numerator \/ r % denominator\n  end function rational_int\n\n  function rational_modulo (r) result (res)\n    type (rational), intent (in) :: r\n    integer :: res\n    res = modulo (r % numerator, r % denominator)\n  end function rational_modulo\n\nend module module_rational<\/lang>\nExample:\n<lang fortran>program perfect_numbers\n\n  use module_rational\n  implicit none\n  integer, parameter :: n_min = 2\n  integer, parameter :: n_max = 2 ** 19 - 1\n  integer :: n\n  integer :: factor\n  type (rational) :: sum\n\n  do n = n_min, n_max\n    sum = 1 \/\/ n\n    factor = 2\n    do\n      if (factor * factor >= n) then\n        exit\n      end if\n      if (modulo (n, factor) == 0) then\n        sum = rational_simplify (sum + (1 \/\/ factor) + (factor \/\/ n))\n      end if\n      factor = factor + 1\n    end do\n    if (sum % numerator == 1 .and. sum % denominator == 1) then\n      write (*, '(i0)') n\n    end if\n  end do\n\nend program perfect_numbers<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>6\n28\n496\n8128<\/pre>\n\n==[[:Category:GAP|GAP]][[Category:GAP]]==\nRational numbers are built-in.\n<lang gap>2\/3 in Rationals;\n# true\n2\/3 + 3\/4;\n# 17\/12<\/lang>\n\n==[[:Category:Go|Go]][[Category:Go]]==\nGo's <code>big<\/code> package implements arbitrary-precision integers and rational numbers.\n<lang go>package main\n\nimport (\n    \"fmt\"\n    \"math\"\n    \"math\/big\"\n)\n\nfunc main() {\n    var recip big.Rat\n    max := int64(1 << 19)\n    for candidate := int64(2); candidate < max; candidate++ {\n        sum := big.NewRat(1, candidate)\n        max2 := int64(math.Sqrt(float64(candidate)))\n        for factor := int64(2); factor <= max2; factor++ {\n            if candidate%factor == 0 {\n                sum.Add(sum, recip.SetFrac64(1, factor))\n                if f2 := candidate \/ factor; f2 != factor {\n                    sum.Add(sum, recip.SetFrac64(1, f2))\n                }\n            }\n        }\n        if sum.Denom().Int64() == 1 {\n            perfectstring := \"\"\n            if sum.Num().Int64() == 1 {\n                perfectstring = \"perfect!\"\n            }\n            fmt.Printf(\"Sum of recipr. factors of %d = %d exactly %s\\n\",\n                candidate, sum.Num().Int64(), perfectstring)\n        }\n    }\n}<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>\nSum of recipr. factors of 6 = 1 exactly perfect!\nSum of recipr. factors of 28 = 1 exactly perfect!\nSum of recipr. factors of 120 = 2 exactly \nSum of recipr. factors of 496 = 1 exactly perfect!\nSum of recipr. factors of 672 = 2 exactly \nSum of recipr. factors of 8128 = 1 exactly perfect!\nSum of recipr. factors of 30240 = 3 exactly \nSum of recipr. factors of 32760 = 3 exactly \nSum of recipr. factors of 523776 = 2 exactly \n<\/pre>\n\n==[[:Category:Groovy|Groovy]][[Category:Groovy]]==\nGroovy does not provide any built-in facility for rational arithmetic. However, it does support arithmetic operator overloading. Thus it is not too hard to build a fairly robust, complete, and intuitive rational number class, such as the following:\n<lang groovy>class Rational implements Comparable {\n    final BigInteger numerator, denominator\n \n    static final Rational ONE = new Rational(1, 1)\n \n    static final Rational ZERO = new Rational(0, 1)\n \n    Rational(BigInteger whole) { this(whole, 1) }\n \n    Rational(BigDecimal decimal) {\n        this(\n            decimal.scale() < 0 ? decimal.unscaledValue()*10**(-decimal.scale()) : decimal.unscaledValue(),\n            decimal.scale() < 0 ? 1 : 10**(decimal.scale())\n        )\n    }\n \n    Rational(num, denom) {\n        assert denom != 0 : \"Denominator must not be 0\"\n        def values = denom > 0 ? [num, denom] : [-num, -denom] \/\/reduce(num, denom)\n        \n        numerator = values[0]\n        denominator = values[1]\n    }\n    \n    private List reduce(BigInteger num, BigInteger denom) {\n        BigInteger sign = ((num < 0) != (denom < 0)) ? -1 : 1\n        num = num.abs()\n        denom = denom.abs()\n        BigInteger commonFactor = gcd(num, denom)\n        \n        [num.intdiv(commonFactor) * sign, denom.intdiv(commonFactor)]\n    }\n    \n    public Rational toLeastTerms() {\n        def reduced = reduce(numerator, denominator)\n        new Rational(reduced[0], reduced[1])\n    }\n    \n    private BigInteger gcd(BigInteger n, BigInteger m) { n == 0 ? m : { while(m%n != 0) { def t=n; n=m%n; m=t }; n }() }\n \n    Rational plus (Rational r) { new Rational(numerator*r.denominator + r.numerator*denominator, denominator*r.denominator) }\n \n    Rational plus (BigInteger n) { new Rational(numerator + n*denominator, denominator) }\n \n    Rational next () { new Rational(numerator + denominator, denominator) }\n \n    Rational minus (Rational r) { new Rational(numerator*r.denominator - r.numerator*denominator, denominator*r.denominator) }\n \n    Rational minus (BigInteger n) { new Rational(numerator - n*denominator, denominator) }\n \n    Rational previous () { new Rational(numerator - denominator, denominator) }\n \n    Rational multiply (Rational r) { new Rational(numerator*r.numerator, denominator*r.denominator) }\n \n    Rational multiply (BigInteger n) { new Rational(numerator*n, denominator) }\n \n    Rational div (Rational r) { new Rational(numerator*r.denominator, denominator*r.numerator) }\n \n    Rational div (BigInteger n) { new Rational(numerator, denominator*n) }\n \n    BigInteger intdiv (BigInteger n) { numerator.intdiv(denominator*n) }\n \n    Rational negative () { new Rational(-numerator, denominator) }\n \n    Rational abs () { new Rational(numerator.abs(), denominator) }\n \n    Rational reciprocal() { new Rational(denominator, numerator) }\n \n    Rational power(BigInteger n) { new Rational(numerator ** n, denominator ** n) }\n    \n    boolean asBoolean() { numerator != 0 }\n    \n    BigDecimal toBigDecimal() { (numerator as BigDecimal)\/(denominator as BigDecimal) }\n    \n    BigInteger toBigInteger() { numerator.intdiv(denominator) }\n    \n    Double toDouble() { toBigDecimal().toDouble() }\n    \n    double doubleValue() { toDouble() as double }\n    \n    Float toFloat() { toBigDecimal().toFloat() }\n    \n    float floatValue() { toFloat() as float }\n    \n    Integer toInteger() { toBigInteger().toInteger() }\n    \n    int intValue() { toInteger() as int }\n    \n    Long toLong() { toBigInteger().toLong() }\n    \n    long longValue() { toLong() as long }\n    \n    Object asType(Class type) {\n        switch (type) {\n            case this.getClass():     return this\n            case Boolean.class:       return asBoolean()\n            case BigDecimal.class:    return toBigDecimal()\n            case BigInteger.class:    return toBigInteger()\n            case Double.class:        return toDouble()\n            case Float.class:         return toFloat()\n            case Integer.class:       return toInteger()\n            case Long.class:          return toLong()\n            case String.class:        return toString()\n            default:                  throw new ClassCastException(\"Cannot convert from type Rational to type \" + type)\n        }\n    }\n \n    boolean equals(o) {\n        compareTo(o) == 0\n    }\n    \n    int compareTo(o) {\n        o instanceof Rational \\\n            ? compareTo(o as Rational) \\\n            : o instanceof Number \\\n                ? compareTo(o as Number)\\\n                : (Double.NaN as int)\n    }\n    \n    int compareTo(Rational r) { numerator*r.denominator <=> denominator*r.numerator }\n    \n    int compareTo(Number n) { numerator <=> denominator*(n as BigInteger) }\n \n    int hashCode() { [numerator, denominator].hashCode() }\n \n    String toString() {\n        def reduced = reduce(numerator, denominator)\n        \"${reduced[0]}\/\/${reduced[1]}\"\n    }\n}<\/lang>\nThe following script tests some of this class's features:\n<lang groovy>def x = new Rational(5, 20)\ndef y = new Rational(9, 12)\ndef z = new Rational(0, 10000)\n\nprintln x\nprintln y\nprintln z\nprintln (x <=> y)\nprintln ((x as Rational).compareTo(y))\nassert x*3 == y\nassert (z + 1) <= y*4\nassert x != y\n\nprintln \"x + y == ${x} + ${y} == ${x + y}\"\nprintln \"x + z == ${x} + ${z} == ${x + z}\"\nprintln \"x - y == ${x} - ${y} == ${x - y}\"\nprintln \"x - z == ${x} - ${z} == ${x - z}\"\nprintln \"x * y == ${x} * ${y} == ${x * y}\"\nprintln \"y ** 3 == ${y} ** 3 == ${y ** 3}\"\nprintln \"x * z == ${x} * ${z} == ${x * z}\"\nprintln \"x \/ y == ${x} \/ ${y} == ${x \/ y}\"\ntry { print \"x \/ z == ${x} \/ ${z} == \"; println \"${x \/ z}\" }\ncatch (Throwable t) { println t.message }\n\nprintln \"-x == -${x} == ${-x}\"\nprintln \"-y == -${y} == ${-y}\"\nprintln \"-z == -${z} == ${-z}\"\n\nprint \"x as int == ${x} as int == \"; println x.intValue()\nprint \"x as double == ${x} as double == \"; println x.doubleValue()\nprint \"1 \/ x as int == 1 \/ ${x} as int == \"; println x.reciprocal().intValue()\nprint \"1.0 \/ x == 1.0 \/ ${x} == \"; println x.reciprocal().doubleValue()\nprint \"y as int == ${y} as int == \"; println y.intValue()\nprint \"y as double == ${y} as double == \"; println y.doubleValue()\nprint \"1 \/ y as int == 1 \/ ${y} as int == \"; println y.reciprocal().intValue()\nprint \"1.0 \/ y == 1.0 \/ ${y} == \"; println y.reciprocal().doubleValue()\nprint \"z as int == ${z} as int == \"; println z.intValue()\nprint \"z as double == ${z} as double == \"; println z.doubleValue()\ntry { print \"1 \/ z as int == 1 \/ ${z} as int == \"; println z.reciprocal().intValue() }\ncatch (Throwable t) { println t.message }\ntry { print \"1.0 \/ z == 1.0 \/ ${z} == \"; println z.reciprocal().doubleValue() }\ncatch (Throwable t) { println t.message }\n\nprintln \"++x == ++ ${x} == ${++x}\"\nprintln \"++y == ++ ${y} == ${++y}\"\nprintln \"++z == ++ ${z} == ${++z}\"\nprintln \"-- --x == -- -- ${x} == ${-- (--x)}\"\nprintln \"-- --y == -- -- ${y} == ${-- (--y)}\"\nprintln \"-- --z == -- -- ${z} == ${-- (--z)}\"\nprintln x\nprintln y\nprintln z\n\nprintln (x <=> y)\nassert x*3 == y\nassert (z + 1) <= y*4\nassert (x < y)\n\nprintln (new Rational(25))\nprintln (new Rational(25.0))\nprintln (new Rational(0.25))\n\nprintln Math.PI\nprintln (new Rational(Math.PI))\nprintln ((new Rational(Math.PI)).toBigDecimal())\nprintln ((new Rational(Math.PI)) as BigDecimal)\nprintln ((new Rational(Math.PI)) as Double)\nprintln ((new Rational(Math.PI)) as double)\nprintln ((new Rational(Math.PI)) as boolean)\nprintln (z as boolean)\ntry { println ((new Rational(Math.PI)) as Date) }\ncatch (Throwable t) { println t.message }\ntry { println ((new Rational(Math.PI)) as char) }\ncatch (Throwable t) { println t.message }<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre style=\"height:30ex;overflow:scroll;\">1\/\/4\n3\/\/4\n0\/\/1\n-1\n-1\nx + y == 1\/\/4 + 3\/\/4 == 1\/\/1\nx + z == 1\/\/4 + 0\/\/1 == 1\/\/4\nx - y == 1\/\/4 - 3\/\/4 == -1\/\/2\nx - z == 1\/\/4 - 0\/\/1 == 1\/\/4\nx * y == 1\/\/4 * 3\/\/4 == 3\/\/16\ny ** 3 == 3\/\/4 ** 3 == 27\/\/64\nx * z == 1\/\/4 * 0\/\/1 == 0\/\/1\nx \/ y == 1\/\/4 \/ 3\/\/4 == 1\/\/3\nx \/ z == 1\/\/4 \/ 0\/\/1 == Denominator must not be 0. Expression: (denom != 0). Values: denom = 0\n-x == -1\/\/4 == -1\/\/4\n-y == -3\/\/4 == -3\/\/4\n-z == -0\/\/1 == 0\/\/1\nx as int == 1\/\/4 as int == 0\nx as double == 1\/\/4 as double == 0.25\n1 \/ x as int == 1 \/ 1\/\/4 as int == 4\n1.0 \/ x == 1.0 \/ 1\/\/4 == 4.0\ny as int == 3\/\/4 as int == 0\ny as double == 3\/\/4 as double == 0.75\n1 \/ y as int == 1 \/ 3\/\/4 as int == 1\n1.0 \/ y == 1.0 \/ 3\/\/4 == 1.3333333333\nz as int == 0\/\/1 as int == 0\nz as double == 0\/\/1 as double == 0.0\n1 \/ z as int == 1 \/ 0\/\/1 as int == Denominator must not be 0. Expression: (denom != 0). Values: denom = 0\n1.0 \/ z == 1.0 \/ 0\/\/1 == Denominator must not be 0. Expression: (denom != 0). Values: denom = 0\n++x == ++ 1\/\/4 == 5\/\/4\n++y == ++ 3\/\/4 == 7\/\/4\n++z == ++ 0\/\/1 == 1\/\/1\n-- --x == -- -- 5\/\/4 == -3\/\/4\n-- --y == -- -- 7\/\/4 == -1\/\/4\n-- --z == -- -- 1\/\/1 == -1\/\/1\n1\/\/4\n3\/\/4\n0\/\/1\n-1\n25\/\/1\n25\/\/1\n1\/\/4\n3.141592653589793\n884279719003555\/\/281474976710656\n3.141592653589793115997963468544185161590576171875\n3.141592653589793115997963468544185161590576171875\n3.141592653589793\n3.141592653589793\ntrue\nfalse\nCannot convert from type Rational to type class java.util.Date\nCannot convert from type Rational to type class java.lang.Character<\/pre>\nThe following uses the Rational class to find all perfect numbers less than 2<sup>19<\/sup>:\n<lang groovy>def factorize = { target -> \n    if (target == 1L) {\n        return [1L]\n    } else if ([2L, 3L].contains(target)) {\n        return [1L, target]\n    }\n    def targetSqrt = Math.ceil(Math.sqrt(target)) as long\n    def lowfactors = (2L..(targetSqrt)).findAll { (target % it) == 0 }\n    \n    if (lowfactors.isEmpty()) {\n        return [1L, target]\n    }\n    \n    def nhalf = lowfactors.size() - ((lowfactors[-1] == targetSqrt) ? 1 : 0)\n    \n    return ([1L] + lowfactors + ((nhalf-1)..0).collect { target.intdiv(lowfactors[it]) } + [target]).unique()\n}\n\n1.upto(2**19) {\n    if ((it % 100000) == 0) { println \"HT\" }\n    else if ((it % 1000) == 0) { print \".\" }\n    \n    def factors = factorize(it)\n    def isPerfect = factors.collect{ factor -> new Rational( factor ).reciprocal() }.sum() == new Rational(2)\n    if (isPerfect) { println() ; println ([perfect: it, factors: factors]) }\n}<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>[perfect:6, factors:[1, 2, 3, 6]]\n\n[perfect:28, factors:[1, 2, 4, 7, 14, 28]]\n\n[perfect:496, factors:[1, 2, 4, 8, 16, 31, 62, 124, 248, 496]]\n........\n[perfect:8128, factors:[1, 2, 4, 8, 16, 32, 64, 127, 254, 508, 1016, 2032, 4064, 8128]]\n...........................................................................................HT\n...................................................................................................HT\n...................................................................................................HT\n...................................................................................................HT\n...................................................................................................HT\n........................<\/pre>\n\n==[[:Category:Haskell|Haskell]][[Category:Haskell]]==\nHaskell provides a <code>Rational<\/code> type, which is really an alias for <code>Ratio Integer<\/code> (<code>Ratio<\/code> being a polymorphic type implementing rational numbers for any <code>Integral<\/code> type of numerators and denominators). The fraction is constructed using the <code>%<\/code> operator.\n<lang haskell>import Data.Ratio\n\n-- simply prints all the perfect numbers\nmain = mapM_ print [candidate\n                   | candidate <- [2 .. 2^19],\n                     getSum candidate == 1]\n  where getSum candidate = 1 % candidate +\n                           sum [1 % factor + 1 % (candidate `div` factor)\n                               | factor <- [2 .. floor(sqrt(fromIntegral(candidate)))],\n                                 candidate `mod` factor == 0]<\/lang>\n\nFor a sample implementation of <code>Ratio<\/code>, see [http:\/\/www.haskell.org\/onlinereport\/ratio.html the Haskell 98 Report].\n\n==[[:Category:Icon|Icon]][[Category:Icon]] and [[:Category:Unicon|Unicon]][[Category:Unicon]]==\nThe IPL provides support for rational arithmetic  \n*  The data type is called 'rational' not 'frac'.\n*  Use the record constructor 'rational' to create a rational.  Sign must be 1 or -1.\n*  Neither Icon nor Unicon supports operator overloading.  Augmented assignments make little sense w\/o this.\n*  Procedures include 'negrat' (unary -), 'addrat' (+), 'subrat' (-), 'mpyrat' (*), 'divrat' (modulo \/).\nAdditional procedures are implemented here to complete the task:\n*  'makerat' (make), 'absrat' (abs), 'eqrat' (=), 'nerat' (~=), 'ltrat' (<), 'lerat' (<=), 'gerat' (>=), 'gtrat' (>)\n<lang Icon>procedure main()\n   limit := 2^19\n\n   write(\"Perfect numbers up to \",limit,\" (using rational arithmetic):\")\n   every write(is_perfect(c := 2 to limit))\n   write(\"End of perfect numbers\")\n\n   # verify the rest of the implementation\n\n   zero := makerat(0)          # from integer\n   half := makerat(0.5)        # from real\n   qtr  := makerat(\"1\/4\")      # from strings ...\n   one  := makerat(\"1\")\n   mone := makerat(\"-1\")\n\n   verifyrat(\"eqrat\",zero,zero)\n   verifyrat(\"ltrat\",zero,half)\n   verifyrat(\"ltrat\",half,zero)\n   verifyrat(\"gtrat\",zero,half)\n   verifyrat(\"gtrat\",half,zero)\n   verifyrat(\"nerat\",zero,half)\n   verifyrat(\"nerat\",zero,zero)\n   verifyrat(\"absrat\",mone,)\n\nend\n\nprocedure is_perfect(c)       #: test for perfect numbers using rational arithmetic\n   rsum := rational(1, c, 1)\n   every f := 2 to sqrt(c) do \n      if 0 = c % f then \n         rsum := addrat(rsum,addrat(rational(1,f,1),rational(1,integer(c\/f),1)))   \n   if rsum.numer = rsum.denom = 1 then \n      return c\nend<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>Perfect numbers up to 524288 (using rational arithmetic):\n6\n28\n496\n8128\nEnd of perfect numbers\nTesting eqrat( (0\/1), (0\/1) ) ==> returned (0\/1)\nTesting ltrat( (0\/1), (1\/2) ) ==> returned (1\/2)\nTesting ltrat( (1\/2), (0\/1) ) ==> failed\nTesting gtrat( (0\/1), (1\/2) ) ==> failed\nTesting gtrat( (1\/2), (0\/1) ) ==> returned (0\/1)\nTesting nerat( (0\/1), (1\/2) ) ==> returned (1\/2)\nTesting nerat( (0\/1), (0\/1) ) ==> failed\nTesting absrat( (-1\/1),  ) ==> returned (1\/1)<\/pre>\nThe following task functions are missing from the IPL: \n<lang Icon>procedure verifyrat(p,r1,r2)  #: verification tests for rational procedures\nreturn write(\"Testing \",p,\"( \",rat2str(r1),\", \",rat2str(\\r2) | &null,\" ) ==> \",\"returned \" || rat2str(p(r1,r2)) | \"failed\")  \nend\n\nprocedure makerat(x)          #: make rational (from integer, real, or strings)\nlocal n,d\nstatic c\ninitial c := &digits++'+-'\n\n   return case type(x) of {\n             \"real\"    : real2rat(x)\n             \"integer\" : ratred(rational(x,1,1))\n             \"string\"  : if x ? ( n := integer(tab(many(c))), =\"\/\", d := integer(tab(many(c))), pos(0)) then  \n                            ratred(rational(n,d,1)) \n                         else \n                            makerat(numeric(x))  \n          }\nend\n\nprocedure absrat(r1)          #: abs(rational)\n   r1 := ratred(r1)\n   r1.sign := 1\n   return r1\nend\n\ninvocable all                 #  for string invocation\n\nprocedure xoprat(op,r1,r2)    #: support procedure for binary operations that cross denominators\n   local numer, denom, div\n\n   r1 := ratred(r1)\n   r2 := ratred(r2)\n\n   return if op(r1.numer * r2.denom,r2.numer * r1.denom) then r2   # return right argument on success\nend\n\nprocedure eqrat(r1,r2)        #: rational r1 = r2\nreturn xoprat(\"=\",r1,r2)\nend\n\nprocedure nerat(r1,r2)        #: rational r1 ~= r2\nreturn xoprat(\"~=\",r1,r2)\nend\n\nprocedure ltrat(r1,r2)        #: rational r1 < r2\nreturn xoprat(\"<\",r1,r2)\nend\n\nprocedure lerat(r1,r2)        #: rational r1 <= r2\nreturn xoprat(\"<=\",r1,r2)\nend\n\nprocedure gerat(r1,r2)        #: rational r1 >= r2\nreturn xoprat(\">=\",r1,r2)\nend\n\nprocedure gtrat(r1,r2)        #: rational r1 > r2\nreturn xoprat(\">\",r1,r2)\nend\n\nlink rational<\/lang>\nThe <div class=\"examplemeta libheader\">'''Library:''' [[SMW::off]][[:Category:Icon Programming Library|Icon Programming Library]][[Category:Icon Programming Library]][[SMW::on]]<\/div> provides [http:\/\/www.cs.arizona.edu\/icon\/library\/src\/procs\/rational.icn rational] and [http:\/\/www.cs.arizona.edu\/icon\/library\/src\/procs\/numbers.icn gcd in numbers].  Record definition and usage is shown below:\n<lang Icon>   record rational(numer, denom, sign)        # rational type\n\n   addrat(r1,r2) # Add rational numbers r1 and r2.\n   divrat(r1,r2) # Divide rational numbers r1 and r2.\n   medrat(r1,r2) # Form mediant of r1 and r2.\n   mpyrat(r1,r2) # Multiply rational numbers r1 and r2.\n   negrat(r)     # Produce negative of rational number r.\n   rat2real(r)   # Produce floating-point approximation of r\n   rat2str(r)    # Convert the rational number r to its string representation.\n   real2rat(v,p) # Convert real to rational with precision p (default 1e-10). Warning: excessive p gives ugly fractions\n   reciprat(r)   # Produce the reciprocal of rational number r.\n   str2rat(s)    # Convert the string representation (such as \"3\/2\") to a rational number\n   subrat(r1,r2) # Subtract rational numbers r1 and r2.\n\n   gcd(i, j)     # returns greatest common divisor of i and j<\/lang>\n\n==[[:Category:J|J]][[Category:J]]==\nJ implements rational numbers:\n<lang j>   3r4*2r5\n3r10<\/lang>\nThat said, note that J's floating point numbers work just fine for the stated problem:\n<lang j>   is_perfect_rational=: 2 = (1 + i.) +\/@:%@([ #~ 0 = |) ]<\/lang>\nFaster version (but the problem, as stated, is still tremendously inefficient):\n<lang j>factors=: *\/&>@{@((^ i.@>:)&.>\/)@q:~&__\nis_perfect_rational=: 2= +\/@:%@,@factors<\/lang>\nExhaustive testing would take forever:\n<lang j>   I.is_perfect_rational@\"0 i.2^19\n6 28 496 8128\n   I.is_perfect_rational@x:@\"0 i.2^19x\n6 28 496 8128<\/lang>\nMore limited testing takes reasonable amounts of time:\n<lang j>   (#~ is_perfect_rational\"0) (* <:@+:) 2^i.10x\n6 28 496 8128<\/lang>\n\n==[[:Category:Java|Java]][[Category:Java]]==\nUses BigRational class: [[Arithmetic\/Rational\/Java]]\n<lang java>class BigRationalFindPerfectNumbers {\n  public static void main(String[] args) {\n    System.out.println(\"Running BigRational built-in tests\");\n    if (BigRational.testFeatures()) {\n      int MAX_NUM = (1 << 19);\n      System.out.println();\n      System.out.println(\"Searching for perfect numbers in the range [1, \" + (MAX_NUM - 1) + \"]\");\n      BigRational TWO = BigRational.valueOf(2);\n      for (int i = 1; i < MAX_NUM; i++) {\n        BigRational reciprocalSum = BigRational.ONE;\n        if (i > 1)\n          reciprocalSum = reciprocalSum.add(BigRational.valueOf(i).reciprocal());\n        int maxDivisor = (int)Math.sqrt(i);\n        if (maxDivisor >= i)\n          maxDivisor--;\n        for (int divisor = 2; divisor <= maxDivisor; divisor++) {\n          if ((i % divisor) == 0) {\n            reciprocalSum = reciprocalSum.add(BigRational.valueOf(divisor).reciprocal());\n            int dividend = i \/ divisor;\n            if (divisor != dividend)\n              reciprocalSum = reciprocalSum.add(BigRational.valueOf(dividend).reciprocal());\n          }\n        }\n        if (reciprocalSum.equals(TWO))\n          System.out.println(String.valueOf(i) + \" is a perfect number\");\n      }\n    }\n    return;\n  }\n}<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>Running BigRational built-in tests\nPASS: BaseConstructor-1\nPASS: BaseConstructor-2\nPASS: BaseConstructor-3\nPASS: BaseConstructor-4\nPASS: Inequality-1\nPASS: Inequality-2\nPASS: IntegerConstructor-1\nPASS: IntegerConstructor-2\n...(omitted for brevity)...\nPASS: Reciprocal-4\nPASS: Signum-1\nPASS: Signum-2\nPASS: Signum-3\nPASS: Numerator-1\nPASS: Numerator-2\nPASS: Denominator-1\nPASS: Denominator-2\nPassed all tests\n\nSearching for perfect numbers in the range [1, 524287]\n6 is a perfect number\n28 is a perfect number\n496 is a perfect number\n8128 is a perfect number<\/pre>\n\n==[[:Category:JavaScript|JavaScript]][[Category:JavaScript]]==\n<div style=\"text-align:right;font-size:7pt\">''<nowiki>[<\/nowiki>This section is included from [[Arithmetic\/Rational\/JavaScript|a subpage]] and should be edited there, not here.<nowiki>]<\/nowiki>''<\/div>\n\n;The core of the Rational class\n<lang javascript>\/\/ the constructor\nfunction Rational(numerator, denominator) {\n    if (denominator === undefined)\n        denominator = 1;\n    else if (denominator == 0)\n        throw \"divide by zero\";\n\n    this.numer = numerator;\n    if (this.numer == 0)\n        this.denom = 1;\n    else\n        this.denom = denominator;\n\n    this.normalize();\n}\n\n\/\/ getter methods\nRational.prototype.numerator   = function() {return this.numer};\nRational.prototype.denominator = function() {return this.denom};\n\n\/\/ clone a rational\nRational.prototype.dup = function() {\n    return new Rational(this.numerator(), this.denominator()); \n};\n\n\/\/ conversion methods\nRational.prototype.toString = function() {\n    if (this.denominator() == 1) {\n        return this.numerator().toString();\n    } else {\n        \/\/ implicit conversion of numbers to strings\n        return this.numerator() + '\/' + this.denominator()\n    }\n};\nRational.prototype.toFloat  = function() {return eval(this.toString())}\nRational.prototype.toInt    = function() {return Math.floor(this.toFloat())};\n\n\/\/ reduce \nRational.prototype.normalize = function() {\n    \/\/ greatest common divisor\n    var a=Math.abs(this.numerator()), b=Math.abs(this.denominator())\n    while (b != 0) {\n        var tmp = a;\n        a = b;\n        b = tmp % b;\n    }\n    \/\/ a is the gcd\n\n    this.numer \/= a;\n    this.denom \/= a;\n    if (this.denom < 0) {\n        this.numer *= -1;\n        this.denom *= -1;\n    }\n    return this;\n}\n\n\/\/ absolute value\n\/\/ returns a new rational\nRational.prototype.abs = function() {\n    return new Rational(Math.abs(this.numerator()), this.denominator());\n};\n\n\/\/ inverse\n\/\/ returns a new rational\nRational.prototype.inv = function() {\n    return new Rational(this.denominator(), this.numerator());\n};\n\n\/\/\n\/\/ arithmetic methods\n\n\/\/ variadic, modifies receiver\nRational.prototype.add = function() {\n    for (var i = 0; i < arguments.length; i++) {\n        this.numer = this.numer * arguments[i].denominator() + this.denom * arguments[i].numerator();\n        this.denom = this.denom * arguments[i].denominator();\n    }\n    return this.normalize();\n};\n\n\/\/ variadic, modifies receiver\nRational.prototype.subtract = function() {\n    for (var i = 0; i < arguments.length; i++) {\n        this.numer = this.numer * arguments[i].denominator() - this.denom * arguments[i].numerator();\n        this.denom = this.denom * arguments[i].denominator();\n    }\n    return this.normalize();\n};\n\n\/\/ unary \"-\" operator\n\/\/ returns a new rational\nRational.prototype.neg = function() {\n    return (new Rational(0)).subtract(this);\n};\n\n\/\/ variadic, modifies receiver\nRational.prototype.multiply = function() {\n    for (var i = 0; i < arguments.length; i++) {\n        this.numer *= arguments[i].numerator();\n        this.denom *= arguments[i].denominator();\n    }\n    return this.normalize();\n};\n\n\/\/ modifies receiver\nRational.prototype.divide = function(rat) {\n    return this.multiply(rat.inv());\n}\n\n\n\/\/ increment\n\/\/ modifies receiver\nRational.prototype.inc = function() {\n    this.numer += this.denominator();\n    return this.normalize();\n}\n\n\/\/ decrement\n\/\/ modifies receiver\nRational.prototype.dec = function() {\n    this.numer -= this.denominator();\n    return this.normalize();\n}\n\n\/\/\n\/\/ comparison methods\n\nRational.prototype.isZero = function() {\n    return (this.numerator() == 0);\n}\nRational.prototype.isPositive = function() {\n    return (this.numerator() > 0);\n}\nRational.prototype.isNegative = function() {\n    return (this.numerator() < 0);\n}\n\nRational.prototype.eq = function(rat) {\n    return this.dup().subtract(rat).isZero();\n}\nRational.prototype.ne = function(rat) {\n    return !(this.eq(rat));\n}\nRational.prototype.lt = function(rat) {\n    return this.dup().subtract(rat).isNegative();\n}\nRational.prototype.gt = function(rat) {\n    return this.dup().subtract(rat).isPositive();\n}\nRational.prototype.le = function(rat) {\n    return !(this.gt(rat));\n}\nRational.prototype.ge = function(rat) {\n    return !(this.lt(rat));\n}<\/lang>\n;Testing\n<lang javascript>function assert(cond, msg) { if (!cond) throw msg; }\n\nprint('testing')\nvar a, b, c, d, e, f;\n\n\/\/test creation\na = new Rational(0); assert(a.toString() == \"0\", \"Rational(0).toString() == '0'\")\na = new Rational(2); assert(a.toString() == \"2\", \"Rational(2).toString() == '2'\")\na = new Rational(1,2); assert(a.toString() == \"1\/2\", \"Rational(1,2).toString() == '1\/2'\")\nb = new Rational(2,-12); assert(b.toString() == \"-1\/6\", \"Rational(1,6).toString() == '1\/6'\")\nf = new Rational(0,9)\n\na = new Rational(1,3)\nb = new Rational(1,2)\nc = new Rational(1,3)\n\nassert(!(a.eq(b)), \"1\/3 == 1\/2\")\nassert(a.eq(c), \"1\/3 == 1\/3\")\nassert(a.ne(b), \"1\/3 != 1\/2\")\nassert(!(a.ne(c)), \"1\/3 != 1\/3\")\nassert(a.lt(b), \"1\/3 < 1\/2\")\nassert(!(b.lt(a)), \"1\/2 < 1\/3\")\nassert(!(a.lt(c)), \"1\/3 < 1\/3\")\nassert(!(a.gt(b)), \"1\/3 > 1\/2\")\nassert(b.gt(a), \"1\/2 > 1\/3\")\nassert(!(a.gt(c)), \"1\/3 > 1\/3\")\n\nassert(a.le(b), \"1\/3 <= 1\/2\")\nassert(!(b.le(a)), \"1\/2 <= 1\/3\")\nassert(a.le(c), \"1\/3 <= 1\/3\")\nassert(!(a.ge(b)), \"1\/3 >= 1\/2\")\nassert(b.ge(a), \"1\/2 >= 1\/3\")\nassert(a.ge(c), \"1\/3 >= 1\/3\")\n\na = new Rational(1,2)\nb = new Rational(1,6)\na.add(b); assert(a.eq(new Rational(2,3)), \"1\/2 + 1\/6 == 2\/3\")\nc = a.neg(); assert(a.eq(new Rational(2,3)), \"neg(1\/2) == -1\/2\")\n             assert(c.eq(new Rational(2,-3)), \"neg(1\/2) == -1\/2\")\nd = c.abs(); assert(c.eq(new Rational(-2,3)), \"abs(neg(1\/2)) == 1\/2\")\n             assert(d.eq(new Rational(2,3)), \"abs(neg(1\/2)) == 1\/2\")\nb.subtract(a); assert(b.eq(new Rational(-1,2)), \"1\/6 - 1\/2 == -1\/3\")\n\nc = a.neg().abs(); assert(c.eq(a), \"abs(neg(1\/2)) == 1\/2\")\nc = (new Rational(-1,3)).inv(); assert(c.toString() == '-3', \"inv(1\/6 - 1\/2) == -3\")\ntry {\n    e = f.inv();\n    throw \"should have been an error: \" +f + '.inv() = ' + e\n} catch (e) {\n    assert(e == \"divide by zero\", \"0.inv() === error\")\n}\n\nb = new Rational(1,6)\nb.add(new Rational(2,3), new Rational(4,2)); assert(b.toString() == \"17\/6\", \"1\/6+2\/3+4\/2 == 17\/6\");\n\na = new Rational(1,3);\nb = new Rational(1,6)\nc = new Rational(5,6);\nd = new Rational(1\/5);\ne = new Rational(2);\nf = new Rational(0,9);\n\n\nassert(c.dup().multiply(d).eq(b), \"5\/6 * 1\/5 = 1\/6\")\nassert(c.dup().multiply(d,e).eq(a), \"5\/6 * 1\/5 *2 = 1\/3\")\nassert(c.dup().multiply(d,e,f).eq(f), \"5\/6 * 1\/5 *2*0 = 0\")\n\nc.divide(new Rational(5));\nassert(c.eq(b), \"5\/6 \/ 5 = 1\/6b\")\n\ntry {\n    e = c.divide(f)\n    throw \"should have been an error: \" + c + \"\/\" + f + '= ' + e\n} catch (e) {\n    assert(e == \"divide by zero\", \"0.inv() === error\")\n}\n\n\nprint('all tests passed');<\/lang>\n\n;Finding perfect numbers\n<lang javascript>function factors(num) {\n    var factors = new Array();\n    var sqrt = Math.floor(Math.sqrt(num)); \n    for (var i = 1; i <= sqrt; i++) {\n        if (num % i == 0) {\n            factors.push(i);\n            if (num \/ i != i) \n                factors.push(num \/ i);\n        }\n    }\n    factors.sort(function(a,b){return a-b});  \/\/ numeric sort\n    return factors;\n}\n\nfunction isPerfect(n) {\n    var sum = new Rational(0);\n    var fctrs = factors(n);\n    for (var i = 0; i < fctrs.length; i++) \n        sum.add(new Rational(1, fctrs[i]));\n\n    \/\/ note, fctrs includes 1, so sum should be 2\n    return sum.toFloat() == 2.0;\n}\n\n\/\/ find perfect numbers less than 2^19\nfor (var n = 2; n < Math.pow(2,19); n++)\n    if (isPerfect(n))\n        print(\"perfect: \" + n);\n\n\/\/ test 5th perfect number\nvar n = Math.pow(2,12) * (Math.pow(2,13) - 1);\nif (isPerfect(n))\n    print(\"perfect: \" + n);<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>perfect: 6\nperfect: 28\nperfect: 496\nperfect: 8128\nperfect: 33550336<\/pre>\n\n==[[:Category:Lua|Lua]][[Category:Lua]]==\n<lang lua>function gcd(a,b) return a == 0 and b or gcd(b % a, a) end\n\ndo\n  local function coerce(a, b)\n    if type(a) == \"number\" then return rational(a, 1), b end\n    if type(b) == \"number\" then return a, rational(b, 1) end\n    return a, b\n  end\n  rational = setmetatable({\n  __add = function(a, b)\n      local a, b = coerce(a, b)\n      return rational(a.num * b.den + a.den * b.num, a.den * b.den)\n    end,\n  __sub = function(a, b)\n      local a, b = coerce(a, b)\n      return rational(a.num * b.den - a.den * b.num, a.den * b.den)\n    end,\n  __mul = function(a, b)\n      local a, b = coerce(a, b)\n      return rational(a.num * b.num, a.den * b.den)\n    end,\n  __div = function(a, b)\n      local a, b = coerce(a, b)\n      return rational(a.num * b.den, a.den * b.num)\n    end,\n  __pow = function(a, b)\n      if type(a) == \"number\" then return a ^ (b.num \/ b.den) end\n      return rational(a.num ^ b, a.den ^ b) --runs into a problem if these aren't integers\n    end,\n  __concat = function(a, b)\n      if getmetatable(a) == rational then return a.num .. \"\/\" .. a.den .. b end\n      return a .. b.num .. \"\/\" .. b.den\n    end,\n  __unm = function(a) return rational(-a.num, -a.den) end}, {\n  __call = function(z, a, b) return setmetatable({num = a \/ gcd(a, b),den = b \/ gcd(a, b)}, z) end} )\nend\n\nprint(rational(2, 3) + rational(3, 5) - rational(1, 10) .. \"\") --> 7\/6\nprint((rational(4, 5) * rational(5, 9)) ^ rational(1, 2) .. \"\") --> 2\/3\nprint(rational(45, 60) \/ rational(5, 2) .. \"\") --> 3\/10\nprint(5 + rational(1, 3) .. \"\") --> 16\/3\n\nfunction findperfs(n)\n  local ret = {}\n  for i = 1, n do\n    sum = rational(1, i)\n    for fac = 2, i^.5 do\n      if i % fac == 0 then\n        sum = sum + rational(1, fac) + rational(fac, i)\n      end\n    end\n    if sum.den == sum.num then\n      ret[#ret + 1] = i\n    end\n  end\n  return table.concat(ret, '\\n')\nend\nprint(findperfs(2^19))<\/lang>\n\n==[[:Category:Mathematica|Mathematica]][[Category:Mathematica]]==\nMathematica has full support for fractions built-in. If one divides two exact numbers it will be left as a fraction if it can't be simplified. Comparison, addition, division, product et cetera are built-in:\n<lang Mathematica>4\/16\n3\/8  \n8\/4\n4Pi\/2\n16!\/10!\nSqrt[9\/16]\nSqrt[3\/4]\n(23\/12)^5\n2 + 1\/(1 + 1\/(3 + 1\/4))\n\n1\/2+1\/3+1\/5\n8\/Pi+Pi\/8 \/\/Together\n13\/17 + 7\/31\nSum[1\/n,{n,1,100}]      (*summation of 1\/1 + 1\/2 + 1\/3 + 1\/4+ .........+ 1\/99 + 1\/100*)\n\n1\/2-1\/3\na=1\/3;a+=1\/7\n\n1\/4==2\/8\n1\/4>3\/8\nPi\/E >23\/20\n1\/3!=123\/370\nSin[3]\/Sin[2]>3\/20\n\nNumerator[6\/9]\nDenominator[6\/9]<\/lang>\ngives back:\n<pre>1\/4\n3\/8\n2\n2 Pi\n5765760\n3\/4\nSqrt[3]\/2\n6436343 \/ 248832\n47\/17\n\n31\/30\n(64+Pi^2) \/ (8 Pi)\n522 \/ 527\n14466636279520351160221518043104131447711 \/ 2788815009188499086581352357412492142272\n\n1\/6\n10\/21\n\nTrue\nFalse\nTrue\nTrue\nTrue\n\n2\n3<\/pre>\nAs you can see, Mathematica automatically handles fraction as exact things, it doesn't evaluate the fractions to a float. It only does this when either the numerator or the denominator is not exact. I only showed integers above, but Mathematica can handle symbolic fraction in the same and complete way:\n<lang Mathematica>c\/(2 c)\n(b^2 - c^2)\/(b - c)  \/\/ Cancel\n1\/2 + b\/c \/\/ Together<\/lang>\ngives back:\n<lang Mathematica>1\/2\nb+c\n(2 b+c) \/ (2 c)<\/lang>\nMoreover it does simplification like Sin[x]\/Cos[x] => Tan[x]. Division, addition, subtraction, powering and multiplication of a list (of any dimension) is automatically threaded over the elements:\n<lang Mathematica>1+2*{1,2,3}^3<\/lang>\ngives back:\n<lang Mathematica>{3, 17, 55}<\/lang>\nTo check for perfect numbers in the range 1 to 2^25 we can use:\n<lang Mathematica>found={};\nCheckPerfect[num_Integer]:=If[Total[1\/Divisors[num]]==2,AppendTo[found,num]];\nDo[CheckPerfect[i],{i,1,2^25}];\nfound<\/lang>\ngives back:\n<lang Mathematica>{6, 28, 496, 8128, 33550336}<\/lang>\nFinal note; approximations of fractions to any precision can be found using the function N.\n\n==[[:Category:Modula-2|Modula-2]][[Category:Modula-2]]==\n<div style=\"text-align:right;font-size:7pt\">''<nowiki>[<\/nowiki>This section is included from [[Arithmetic\/Rational\/Modula-2|a subpage]] and should be edited there, not here.<nowiki>]<\/nowiki>''<\/div>\n\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[FST Modula-2 v4.0]] version no object oriented code used[[SMW::on]]<\/div>\n\nThis is incomplete as the Perfect Numbers task has not been addressed.\n\n;Definition Module\n<lang modula2>DEFINITION MODULE Rational;\n    TYPE RAT =  RECORD\n                    numerator : INTEGER;\n                    denominator : INTEGER;\n                END;\n\n    PROCEDURE IGCD( i : INTEGER; j : INTEGER ) : INTEGER;\n    PROCEDURE ILCM( i : INTEGER; j : INTEGER ) : INTEGER;\n    PROCEDURE IABS( i : INTEGER ) : INTEGER;\n\n    PROCEDURE RNormalize( i : RAT ) : RAT;\n    PROCEDURE RCreate( num : INTEGER; dem : INTEGER ) : RAT;\n    PROCEDURE RAdd( i : RAT; j : RAT ) : RAT;\n    PROCEDURE RSubtract( i : RAT; j : RAT ) : RAT;\n    PROCEDURE RMultiply( i : RAT; j : RAT ) : RAT;\n    PROCEDURE RDivide( i : RAT; j : RAT ) : RAT;\n    PROCEDURE RAbs( i : RAT ) : RAT;\n    PROCEDURE RInv( i : RAT ) : RAT;\n    PROCEDURE RNeg( i : RAT ) : RAT;\n\n    PROCEDURE RInc( i : RAT ) : RAT;\n    PROCEDURE RDec( i : RAT ) : RAT;\n    \n    PROCEDURE REQ( i : RAT; j : RAT ) : BOOLEAN;\n    PROCEDURE RNE( i : RAT; j : RAT ) : BOOLEAN;\n    PROCEDURE RLT( i : RAT; j : RAT ) : BOOLEAN;\n    PROCEDURE RLE( i : RAT; j : RAT ) : BOOLEAN;\n    PROCEDURE RGT( i : RAT; j : RAT ) : BOOLEAN;\n    PROCEDURE RGE( i : RAT; j : RAT ) : BOOLEAN;\n\n    PROCEDURE RIsZero( i : RAT ) : BOOLEAN;\n    PROCEDURE RIsNegative( i : RAT ) : BOOLEAN;\n    PROCEDURE RIsPositive( i : RAT ) : BOOLEAN;\n\n    PROCEDURE RToString( i : RAT; VAR S : ARRAY OF CHAR );\n    PROCEDURE RToRational( s : ARRAY OF CHAR ) : RAT;\n\n    PROCEDURE WriteRational( i : RAT );\n\nEND Rational.<\/lang>\n\n;Implementation Module\n<lang modula2>IMPLEMENTATION MODULE Rational;\n\n    FROM Strings IMPORT Assign, Append, Pos, Copy, Length;\n    FROM NumberConversion IMPORT IntToString, StringToInt;\n\n    FROM InOut IMPORT WriteString (*, WriteCard,WriteLine, WriteInt, WriteLn *);\n\n    PROCEDURE IGCD( i : INTEGER; j : INTEGER ) : INTEGER;\n    VAR\n        res : INTEGER;\n    BEGIN\n        IF j = 0 THEN\n            res := i;\n        ELSE\n            res := IGCD( j, i MOD j );\n        END;\n\n        RETURN res;\n    END IGCD;\n\n    PROCEDURE ILCM( i : INTEGER; j : INTEGER ) : INTEGER;\n    VAR\n        res : INTEGER;\n    BEGIN\n        res := (i DIV IGCD( i, j ) ) * j;\n        RETURN res;\n    END ILCM;\n\n    PROCEDURE IABS( i : INTEGER ) : INTEGER;\n    VAR\n        res : INTEGER;\n    BEGIN\n        IF i < 0 THEN\n            res := i * (-1);\n        ELSE\n            res := i;\n        END;\n        RETURN res;\n    END IABS;\n\n    PROCEDURE RNormalize( i : RAT ) : RAT;\n    VAR\n        gcd : INTEGER;\n        res : RAT;\n    BEGIN\n        gcd := IGCD( ABS( i.numerator ), ABS( i.denominator ) );\n        IF gcd <> 0 THEN\n            res.numerator := i.numerator DIV gcd;\n            res.denominator := i.denominator DIV gcd;\n            IF ( res.denominator < 0 ) THEN\n                res.numerator := res.numerator * (-1);\n                res.denominator := res.denominator * (-1);\n            END;\n        ELSE\n            WITH res DO\n                numerator := 0;\n                denominator := 0;\n            END;\n        END;\n        RETURN res;\n    END RNormalize;\n\n    PROCEDURE RCreate( num : INTEGER; dem : INTEGER ) : RAT;\n    VAR\n        rat : RAT;\n    BEGIN\n        WITH rat DO\n            numerator := num;\n            denominator := dem;\n        END;\n        RETURN RNormalize(rat);\n    END RCreate;\n\n    PROCEDURE RAdd( i : RAT; j : RAT ) : RAT;\n    BEGIN\n        RETURN RCreate( i.numerator * j.denominator + j.numerator * i.denominator, i.denominator * j.denominator );\n    END RAdd;\n\n    PROCEDURE RSubtract( i : RAT; j : RAT ) : RAT;\n    BEGIN\n        RETURN RCreate( i.numerator * j.denominator - j.numerator * i.denominator, i.denominator * j.denominator );\n    END RSubtract;\n\n    PROCEDURE RMultiply( i : RAT; j : RAT ) : RAT;\n    BEGIN\n        RETURN RCreate( i.numerator * j.numerator, i.denominator * j.denominator );\n    END RMultiply;\n\n    PROCEDURE RDivide( i : RAT; j : RAT ) : RAT;\n    BEGIN\n        RETURN RCreate( i.numerator * j.denominator, i.denominator * j.numerator );\n    END RDivide;\n\n    PROCEDURE RAbs( i : RAT ) : RAT;\n    BEGIN\n        RETURN RCreate( IABS( i.numerator ), i.denominator );\n    END RAbs;\n\n    PROCEDURE RInv( i : RAT ) : RAT;\n    BEGIN\n        RETURN RCreate( i.denominator, i.numerator );\n    END RInv;\n\n    PROCEDURE RNeg( i : RAT ) : RAT;\n    BEGIN\n        RETURN RCreate( i.numerator * (-1), i.denominator );\n    END RNeg;\n\n    PROCEDURE RInc( i : RAT ) : RAT;\n    BEGIN\n        RETURN RCreate( i.numerator + i.denominator, i.denominator );\n    END RInc;\n\n    PROCEDURE RDec( i : RAT ) : RAT;\n    BEGIN\n        RETURN RCreate( i.numerator - i.denominator, i.denominator );\n    END RDec;\n\n    PROCEDURE REQ( i : RAT; j : RAT ) : BOOLEAN;\n    VAR\n        ii : RAT;\n        jj : RAT;\n    BEGIN\n        ii := RNormalize( i );\n        jj := RNormalize( j );\n        RETURN ( ( ii.numerator = jj.numerator ) AND ( ii.denominator = jj.denominator ) );\n    END REQ;\n\n    PROCEDURE RNE( i : RAT; j : RAT ) : BOOLEAN;\n    BEGIN\n        RETURN NOT REQ( i, j );\n    END RNE;\n\n    PROCEDURE RLT( i : RAT; j : RAT ) : BOOLEAN;\n    BEGIN\n        RETURN RIsNegative( RSubtract( i, j ) );\n    END RLT;\n\n    PROCEDURE RLE( i : RAT; j : RAT ) : BOOLEAN;\n    BEGIN\n        RETURN NOT RGT( i, j );\n    END RLE;\n\n    PROCEDURE RGT( i : RAT; j : RAT ) : BOOLEAN;\n    BEGIN\n        RETURN RIsPositive( RSubtract( i, j ) );\n    END RGT;\n\n    PROCEDURE RGE( i : RAT; j : RAT ) : BOOLEAN;\n    BEGIN\n        RETURN NOT RLT( i, j );\n    END RGE;\n\n    PROCEDURE RIsZero( i : RAT ) : BOOLEAN;\n    BEGIN\n        RETURN i.numerator = 0;\n    END RIsZero;\n\n    PROCEDURE RIsNegative( i : RAT ) : BOOLEAN;\n    BEGIN\n        RETURN i.numerator < 0;\n    END RIsNegative;\n\n    PROCEDURE RIsPositive( i : RAT ) : BOOLEAN;\n    BEGIN\n        RETURN i.numerator > 0;\n    END RIsPositive;\n\n    PROCEDURE RToString( i : RAT; VAR S : ARRAY OF CHAR );\n    VAR\n        num : ARRAY [1..15] OF CHAR;\n        den : ARRAY [1..15] OF CHAR;\n    BEGIN\n        IF RIsZero( i ) THEN\n            Assign(\"0\", S );\n        ELSE\n            IntToString( i.numerator, num, 1 );\n            Assign( num, S );\n            IF ( i.denominator <> 1 ) THEN\n                IntToString( i.denominator, den, 1 );\n                Append( S, \"\/\" );\n                Append( S, den );\n            END;\n        END;\n    END RToString;\n\n    PROCEDURE RToRational( s : ARRAY OF CHAR ) : RAT;\n    VAR\n        n : CARDINAL;\n        numer : INTEGER;\n        denom : INTEGER;\n        LHS, RHS : ARRAY [ 1..20 ] OF CHAR;\n        Flag : BOOLEAN;\n    BEGIN\n        numer := 0;\n        denom := 0;\n        n := Pos( \"\/\", s );\n\n        IF n > HIGH( s ) THEN\n            StringToInt( s, numer, Flag );\n            IF Flag THEN\n                denom := 1;\n            END;\n        ELSE\n            Copy( s, 0, n, LHS );\n            Copy( s, n+1, Length( s ), RHS );\n            StringToInt( LHS, numer, Flag );\n            IF Flag THEN\n                StringToInt( RHS, denom, Flag );\n            END;\n        END;\n        RETURN RCreate( numer, denom );\n    END RToRational;\n\n    PROCEDURE WriteRational( i : RAT );\n    VAR\n        res : ARRAY [0 .. 80] OF CHAR;\n    BEGIN\n        RToString( i, res );\n        WriteString( res );\n    END WriteRational;\n\nEND Rational.<\/lang>\n\n;Test Program\n<lang modula2>MODULE TestRat;\n       FROM InOut IMPORT WriteString, WriteLine;\n       FROM Terminal IMPORT KeyPressed;\n       FROM Strings IMPORT CompareStr;\n       FROM Rational IMPORT RAT, IGCD, RCreate, RToString, RIsZero, RNormalize,\n                            RToRational, REQ, RNE, RLT, RLE, RGT, RGE, WriteRational,\n                            RAdd, RSubtract, RMultiply, RDivide, RAbs, RNeg, RInv;\nVAR\n    res : INTEGER;\n    a, b, c, d, e, f : RAT;\n    ans : ARRAY [1..100] OF CHAR;\n\nPROCEDURE Assert( F : BOOLEAN; S : ARRAY OF CHAR );\nBEGIN\n    IF ( NOT F) THEN\n        WriteLine( S );\n    END;\nEND Assert;\n\nBEGIN\n\n    a := RCreate( 0, 0 );\n    Assert( RIsZero( a ), \"RIsZero( a )\");\n\n    a := RToRational(\"2\");\n    RToString( a, ans );\n    res := CompareStr( ans, \"2\" );\n    Assert( (res = 0), \"CompareStr( RToString( a ), '2' ) = 0\");\n\n    a := RToRational(\"1\/2\");\n    RToString( a, ans );\n    res := CompareStr( ans, \"1\/2\");\n    Assert( res = 0, \"CompareStr( RToString( a, ans ), '1\/2') = 0\");\n\n    b := RToRational( \"2\/-12\" );\n    RToString( b, ans );\n    res := CompareStr( ans, \"-1\/6\");\n    Assert( res = 0, \"CompareStr( RToString( b, ans ), '-1\/6') = 0\");\n\n    f := RCreate( 0, 9 ); (* rationalizes internally to zero *)\n\n    a := RToRational(\"1\/3\");\n    b := RToRational(\"1\/2\");\n    c := RCreate( 1, 3 );\n\n    Assert( NOT REQ( a, b ), \"1\/3 == 1\/2\" );\n    Assert( REQ( a, c ), \"1\/3 == 1\/3\" );\n    Assert( RNE( a, b ), \"1\/3 != 1\/2\" );\n    Assert( RLT( a, b ), \"1\/3 < 1\/2\" );\n    Assert( NOT RLT(b,a), \"1\/2 < 1\/3\" );\n    Assert( NOT RLT(a,c), \"1\/3 < 1\/3\" );\n    Assert( NOT RGT(a,b), \"1\/3 > 1\/2\" );\n    Assert( RGT(b,a), \"1\/2 > 1\/3\" );\n    Assert( NOT RGT(a,c), \"1\/3 > 1\/3\" );\n\n    Assert( RLE( a, b ), \"1\/3 <= 1\/2\" );\n    Assert( NOT RLE( b, a ), \"1\/2 <= 1\/3\" );\n    Assert( RLE( a, c ), \"1\/3 <= 1\/3\" );\n    Assert( NOT RGE(a,b), \"1\/3 >= 1\/2\" );\n    Assert( RGE(b,a), \"1\/2 >= 1\/3\" );\n    Assert( RGE( a,c ), \"1\/3 >= 1\/3\" );\n\n    a := RCreate(1,2);\n    b := RCreate(1,6);\n    a := RAdd( a, b );\n    Assert( REQ( a, RToRational(\"2\/3\")), \"1\/2 + 1\/6 == 2\/3\" );\n\n    c := RNeg( a );\n    Assert( REQ( a, RCreate( 2,3)), \"2\/3 == 2\/3\" );\n    Assert( REQ( c, RCreate( 2,-3)), \"Neg 1\/2 == -1\/2\" );\n    a := RCreate( 2,-3);\n\n    d := RAbs( c );\n    Assert( REQ( d, RCreate( 2,3 ) ), \"abs(neg(1\/2))==1\/2\" );\n\n    a := RToRational( \"1\/2\");\n    b := RSubtract( b, a );\n\n    Assert( REQ( b, RCreate(-1,3) ), \"1\/6 - 1\/2 == -1\/3\" );\n\n    c := RInv(b);\n    RToString( c, ans );\n    res := CompareStr( ans, \"-3\" );\n    Assert( res = 0, \"inv(1\/6 - 1\/2) == -3\" );\n\n    f := RInv( f ); (* as f normalized to zero, the reciprocal is still zero *)\n\n\n    b := RCreate( 1, 6);\n    b := RAdd( b, RAdd( RCreate( 2,3), RCreate( 4,2 )));\n    RToString( b, ans );\n    res := CompareStr( ans, \"17\/6\" );\n    Assert( res = 0, \"1\/6 + 2\/3 + 4\/2 = 17\/6\" );\n\n    a := RCreate(1,3);\n    b := RCreate(1,6);\n    c := RCreate(5,6);\n    d := RToRational(\"1\/5\");\n    e := RToRational(\"2\");\n    f := RToRational(\"0\/9\");\n\n    Assert( REQ( RMultiply( c, d ), b ), \"5\/6 * 1\/5 = 1\/6\" );\n    Assert( REQ( RMultiply( c, RMultiply( d, e ) ), a ), \"5\/6 * 1\/5 * 2 = 1\/3\" );\n    Assert( REQ( RMultiply( c, RMultiply( d, RMultiply( e, f ) ) ), f ), \"5\/6 * 1\/5 * 2 * 0\" );\n    Assert( REQ( b, RDivide( c, RToRational(\"5\" ) ) ), \"5\/6 \/ 5 = 1\/6\" );\n\n    e := RDivide( c, f ); (* RDivide multiplies so no divide by zero *)\n\n    WriteString(\"Press any key...\"); WHILE NOT KeyPressed() DO END;\nEND TestRat.<\/lang>\n\n==[[:Category:Objective-C|Objective-C]][[Category:Objective-C]]==\n<div style=\"text-align:right;font-size:7pt\">''<nowiki>[<\/nowiki>This section is included from [[Arithmetic\/Rational\/Objective-C|a subpage]] and should be edited there, not here.<nowiki>]<\/nowiki>''<\/div>\n\n;File <tt>frac.h<\/tt>\n<lang objc>#import <Foundation\/Foundation.h>\n\n@interface RCRationalNumber : NSObject\n{\n @private\n  int numerator;\n  int denominator;\n  BOOL autoSimplify;\n  BOOL withSign;\n}\n+(RCRationalNumber *)valueWithNumerator:(int)num andDenominator: (int)den;\n+(RCRationalNumber *)valueWithDouble: (double)fnum;\n+(RCRationalNumber *)valueWithInteger: (int)inum;\n+(RCRationalNumber *)valueWithRational: (RCRationalNumber *)rnum;\n-(id)init;\n-(id)initWithNumerator: (int)num andDenominator: (int)den;\n-(id)initWithDouble: (double)fnum precision: (int)prec;\n-(id)initWithInteger: (int)inum;\n-(id)initWithRational: (RCRationalNumber *)rnum;\n-(NSComparisonResult)compare: (RCRationalNumber *)rnum;\n-(id)simplify: (BOOL)act;\n-(void)setAutoSimplify: (BOOL)v;\n-(void)setWithSign: (BOOL)v;\n-(BOOL)autoSimplify;\n-(BOOL)withSign;\n-(NSString *)description;\n\/\/ ops\n-(id)multiply: (RCRationalNumber *)rnum;\n-(id)divide: (RCRationalNumber *)rnum;\n-(id)add: (RCRationalNumber *)rnum;\n-(id)sub: (RCRationalNumber *)rnum;\n-(id)abs;\n-(id)neg;\n-(id)mod: (RCRationalNumber *)rnum;\n-(int)sign;\n-(BOOL)isNegative;\n-(id)reciprocal;\n\/\/ getter\n-(int)numerator;\n-(int)denominator;\n\/\/setter\n-(void)setNumerator: (int)num;\n-(void)setDenominator: (int)num;\n\/\/ defraction\n-(double)number;\n-(int)integer;\n@end<\/lang>\n;File <tt>frac.m<\/tt>\n<lang objc>#import <Foundation\/Foundation.h>\n#import <math.h>\n#import \"frac.h\"\n\n\/\/ gcd: [[Greatest common divisor#Recursive_Euclid_algorithm]]\n\/\/ if built in as \"private\" function, add static.\n\nstatic int lcm(int a, int b)\n{\n  return a \/ gcd(a,b) * b;\n}\n\n@implementation RCRationalNumber\n\/\/ initializers\n-(id)init\n{\n  NSLog(@\"initialized to unity\");\n  return [self initWithInteger: 1];\n}\n\n-(id)initWithNumerator: (int)num andDenominator: (int)den\n{\n  if ((self = [super init]) != nil) {\n    if (den == 0) {\n      NSLog(@\"denominator is zero\");\n      return nil;\n    }\n    [self setNumerator: num];\n    [self setDenominator: den];\n    [self setWithSign: YES];\n    [self setAutoSimplify: YES];\n    [self simplify: YES];\n  }\n  return self;\n}\n\n-(id)initWithInteger:(int)inum\n{\n  return [self initWithNumerator: inum andDenominator: 1];\n}\n\n-(id)initWithDouble: (double)fnum precision: (int)prec\n{\n  if ( prec > 9 ) prec = 9;\n  double p = pow(10.0, (double)prec);\n  int nd = (int)(fnum * p);\n  return [self initWithNumerator: nd andDenominator: (int)p ];\n}\n\n-(id)initWithRational: (RCRationalNumber *)rnum\n{\n  return [self initWithNumerator: [rnum numerator] andDenominator: [rnum denominator]];\n}\n\n\/\/ comparing\n-(NSComparisonResult)compare: (RCRationalNumber *)rnum\n{\n  if ( [self number] > [rnum number] ) return NSOrderedDescending;\n  if ( [self number] < [rnum number] ) return NSOrderedAscending;\n  return NSOrderedSame;\n}\n\n\/\/ string rapresentation of the Q\n-(NSString *)description\n{\n  [self simplify: [self autoSimplify]];\n  return [NSString stringWithFormat: @\"%@%d\/%d\", [self isNegative] ? @\"-\" : \n\t\t     ( [self withSign] ? @\"+\" : @\"\" ),\n\t\t   abs([self numerator]), [self denominator]];\n}\n\n\/\/ setter options\n-(void)setAutoSimplify: (BOOL)v\n{\n  autoSimplify = v;\n  [self simplify: v];\n}\n-(void)setWithSign: (BOOL)v\n{\n  withSign = v;\n}\n\n\/\/ getter for options\n-(BOOL)autoSimplify\n{\n  return autoSimplify;\n}\n\n-(BOOL)withSign\n{\n  return withSign;\n}\n\n\/\/ \"simplify\" the fraction ...\n-(id)simplify: (BOOL)act\n{\n  if ( act ) {\n    int common = gcd([self numerator], [self denominator]);\n    [self setNumerator: [self numerator]\/common];\n    [self setDenominator: [self denominator]\/common];\n  }\n  return self;\n}\n\n\/\/ diadic operators\n-(id)multiply: (RCRationalNumber *)rnum\n{\n  int newnum = [self numerator] * [rnum numerator];\n  int newden = [self denominator] * [rnum denominator];\n  return [RCRationalNumber valueWithNumerator: newnum\n\t\t\t   andDenominator: newden];\n}\n\n-(id)divide: (RCRationalNumber *)rnum\n{\n  return [self multiply: [rnum reciprocal]];\n}\n \n-(id)add: (RCRationalNumber *)rnum\n{\n  int common = lcm([self denominator], [rnum denominator]);\n  int resnum = common \/ [self denominator] * [self numerator] +\n    common \/ [rnum denominator] * [rnum numerator];\n  return [RCRationalNumber valueWithNumerator: resnum andDenominator: common];\n}\n\n-(id)sub: (RCRationalNumber *)rnum\n{\n  return [self add: [rnum neg]];\n}\n\n-(id)mod: (RCRationalNumber *)rnum\n{\n  return [[self divide: rnum] \n\t   sub: [RCRationalNumber valueWithInteger: [[self divide: rnum] integer]]];\n}\n\n\/\/ unary operators\n-(id)neg\n{\n  return [RCRationalNumber valueWithNumerator: -1*[self numerator]\n\t\t\t   andDenominator: [self denominator]];\n}\n\n-(id)abs\n{\n  return [RCRationalNumber valueWithNumerator: abs([self numerator])\n\t\t\t   andDenominator: [self denominator]];\n}\n\n-(id)reciprocal\n{\n  return [RCRationalNumber valueWithNumerator: [self denominator]\n\t\t\t   andDenominator: [self numerator]];\n}\n\n\/\/ get the sign\n-(int)sign\n{\n  return ([self numerator] < 0) ? -1 : 1;\n}\n\n\/\/ or just test if negativ\n-(BOOL)isNegative\n{\n  return ([self numerator] < 0) ? YES : NO;\n}\n\n\/\/ Q as real floating point\n-(double)number\n{\n  return (double)[self numerator] \/ (double)[self denominator];\n}\n\n\/\/ Q as (truncated) integer\n-(int)integer\n{\n  return [self numerator] \/ [self denominator];\n}\n\n\/\/ set num and den indipendently, fixing sign accordingly\n-(void)setNumerator: (int)num\n{\n  numerator = num;\n}\n\n-(void)setDenominator: (int)num\n{\n  if ( num < 0 ) numerator = -numerator;\n  denominator = abs(num);\n}\n\n\/\/ getter\n-(int)numerator\n{\n  return numerator;\n}\n\n-(int)denominator\n{\n  return denominator;\n}\n\n\/\/ class method\n+(RCRationalNumber *)valueWithNumerator:(int)num andDenominator: (int)den\n{\n  return [[[RCRationalNumber alloc] initWithNumerator: num andDenominator: den] autorelease];\n}\n\n+(RCRationalNumber *)valueWithDouble: (double)fnum\n{\n  return [[[RCRationalNumber alloc] initWithDouble: fnum] autorelease];\n}\n\n+(RCRationalNumber *)valueWithInteger: (int)inum\n{\n  return [[[RCRationalNumber alloc] initWithInteger: inum] autorelease];\n}\n\n+(RCRationalNumber *)valueWithRational: (RCRationalNumber *)rnum\n{\n  return [[[RCRationalNumber alloc] initWithRational: rnum] autorelease];\n}\n@end<\/lang>\n;Testing\n<lang objc>#import <Foundation\/Foundation.h>\n#import \"frac.h\"\n#import <math.h>\n\nint main()\n{\n  NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];\n\n  int i;\n  for(i=2; i < 0x80000; i++) {\n    int candidate = i;\n    RCRationalNumber *sum = [RCRationalNumber valueWithNumerator: 1\n \t\t\t                          andDenominator: candidate];\n    int factor;\n    for(factor=2; factor < sqrt((double)candidate); factor++) {\n      if ( (candidate % factor) == 0 ) {\n \tsum = [[sum add: [RCRationalNumber valueWithNumerator: 1\n\t\t\t\t\t       andDenominator: factor]]\n\t\tadd: [RCRationalNumber valueWithNumerator: 1\n\t\t\t\t\t   andDenominator: (candidate\/factor)]];\n      }\n    }\n    if ( [sum denominator] == 1 ) {\n      printf(\"Sum of recipr. factors of %d = %d exactly %s\\n\",\n\t     candidate, [sum integer], ([sum integer]==1) ? \"perfect!\" : \"\");\n    }\n  }\n\n  [pool release];\n  return 0;\n}<\/lang>\n\n==[[:Category:OCaml|OCaml]][[Category:OCaml]]==\nOCaml's Num library implements arbitrary-precision rational numbers:\n<lang ocaml>#load \"nums.cma\";;\nopen Num;;\n\nfor candidate = 2 to 1 lsl 19 do\n  let sum = ref (num_of_int 1 \/\/ num_of_int candidate) in\n  for factor = 2 to truncate (sqrt (float candidate)) do\n    if candidate mod factor = 0 then\n      sum := !sum +\/ num_of_int 1 \/\/ num_of_int factor\n                  +\/ num_of_int 1 \/\/ num_of_int (candidate \/ factor)\n  done;\n  if is_integer_num !sum then\n    Printf.printf \"Sum of recipr. factors of %d = %d exactly %s\\n%!\"\n        candidate (int_of_num !sum) (if int_of_num !sum = 1 then \"perfect!\" else \"\")\ndone;;<\/lang>\n[http:\/\/forge.ocamlcore.org\/projects\/pa-do\/ Delimited overloading] can be used to make the arithmetic expressions more readable:\n<lang ocaml>let () =\n  for candidate = 2 to 1 lsl 19 do\n    let sum = ref Num.(1 \/ of_int candidate) in\n    for factor = 2 to truncate (sqrt (float candidate)) do\n      if candidate mod factor = 0 then\n        sum := Num.(!sum + 1 \/ of_int factor + of_int factor \/ of_int candidate)\n    done;\n    if Num.is_integer_num !sum then\n      Printf.printf \"Sum of recipr. factors of %d = %d exactly %s\\n%!\"\n        candidate Num.(to_int !sum) (if Num.(!sum = 1) then \"perfect!\" else \"\")\n  done<\/lang>\nIt might be implemented like this:\n\n[insert implementation here]\n\n==[[:Category:PARI\/GP|PARI\/GP]][[Category:PARI\/GP]]==\nPari handles rational arithmetic natively.\n<lang parigp>for(n=2,1<<19,\n  s=0;\n  fordiv(n,d,s+=1\/d);\n  if(s==2,print(n))\n)<\/lang>\n\n==[[:Category:Perl|Perl]][[Category:Perl]]==\nPerl's <code>Math::BigRat<\/code> core module implements arbitrary-precision rational numbers. The <code>bigrat<\/code> pragma can be used to turn on transparent BigRat support:\n<lang perl>use bigrat;\n\nforeach my $candidate (2 .. 2**19) {\n    my $sum = 1 \/ $candidate;\n    foreach my $factor (2 .. sqrt($candidate)+1) {\n        if ($candidate % $factor == 0) {\n            $sum += 1 \/ $factor + 1 \/ ($candidate \/ $factor);\n        }\n    }\n    if ($sum->denominator() == 1) {\n        print \"Sum of recipr. factors of $candidate = $sum exactly \", ($sum == 1 ? \"perfect!\" : \"\"), \"\\n\";\n    }\n}<\/lang>\nIt might be implemented like this:\n\n[insert implementation here]\n\n==[[:Category:Perl 6|Perl 6]][[Category:Perl 6]]==\nPerl 6 supports rational arithmetic natively.\n<lang perl6>for 2..2**19 -> $candidate {\n    my $sum = 1 \/ $candidate;\n    for 2 .. ceiling(sqrt($candidate)) -> $factor {\n        if $candidate %% $factor {\n            $sum += 1 \/ $factor + 1 \/ ($candidate \/ $factor);\n        }\n    }\n    if $sum.denominator == 1 {\n        say \"Sum of reciprocal factors of $candidate = $sum exactly\", ($sum == 1 ?? \", perfect!\" !! \".\");\n    }\n}<\/lang>\nNote also that ordinary decimal literals are stored as Rats, so the following loop always stops exactly on 10 despite 0.1 not being exactly representable in floating point:\n<lang perl6>for 1.0, 1.1, 1.2 ... 10 { .say }<\/lang>\nThe arithmetic is all done in rationals, which are converted to floating-point just before display so that people don't have to puzzle out what 53\/10 means.\n\n==[[:Category:PicoLisp|PicoLisp]][[Category:PicoLisp]]==\n<lang PicoLisp>(load \"@lib\/frac.l\")\n\n(for (N 2  (> (** 2 19) N)  (inc N))\n   (let (Sum (frac 1 N)  Lim (sqrt N))\n      (for (F 2  (>= Lim F) (inc F))\n         (when (=0 (% N F))\n            (setq Sum\n               (f+ Sum\n                  (f+ (frac 1 F) (frac 1 (\/ N F))) ) ) ) )\n      (when (= 1 (cdr Sum))\n         (prinl\n            \"Perfect \" N\n            \", sum is \" (car Sum)\n            (and (= 1 (car Sum)) \": perfect\") ) ) ) )<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>Perfect 6, sum is 1: perfect\nPerfect 28, sum is 1: perfect\nPerfect 120, sum is 2\nPerfect 496, sum is 1: perfect\nPerfect 672, sum is 2\nPerfect 8128, sum is 1: perfect\nPerfect 30240, sum is 3\nPerfect 32760, sum is 3\nPerfect 523776, sum is 2<\/pre>\n\n==[[:Category:Python|Python]][[Category:Python]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Python]] version 3.0[[SMW::on]]<\/div>\nPython 3's standard library already implements a Fraction class:\n<lang python>from fractions import Fraction\n\nfor candidate in range(2, 2**19):\n  sum = Fraction(1, candidate)\n  for factor in range(2, int(candidate**0.5)+1):\n    if candidate % factor == 0:\n      sum += Fraction(1, factor) + Fraction(1, candidate \/\/ factor)\n  if sum.denominator == 1:\n    print(\"Sum of recipr. factors of %d = %d exactly %s\" %\n           (candidate, int(sum), \"perfect!\" if sum == 1 else \"\"))<\/lang>\nIt might be implemented like this:\n<lang python>def lcm(a, b):\n    return a \/\/ gcd(a,b) * b\n\ndef gcd(u, v):\n    return gcd(v, u%v) if v else abs(u)\n\nclass Fraction:\n    def __init__(self, numerator, denominator):\n        common = gcd(numerator, denominator)\n        self.numerator = numerator\/\/common\n        self.denominator = denominator\/\/common\n    def __add__(self, frac):\n        common = lcm(self.denominator, frac.denominator)\n        n = common \/\/ self.denominator * self.numerator + common \/\/ frac.denominator * frac.numerator\n        return Fraction(n, common)\n    def __sub__(self, frac):\n        return self.__add__(-frac)\n    def __neg__(self):\n        return Fraction(-self.numerator, self.denominator)\n    def __abs__(self):\n        return Fraction(abs(self.numerator), abs(self.denominator))\n    def __mul__(self, frac):\n        return Fraction(self.numerator * frac.numerator, self.denominator * frac.denominator)\n    def __div__(self, frac):\n        return self.__mul__(frac.reciprocal())\n    def reciprocal(self):\n        return Fraction(self.denominator, self.numerator)\n    def __cmp__(self, n):\n        return int(float(self) - float(n))\n    def __float__(self):\n        return float(self.numerator \/ self.denominator)\n    def __int__(self):\n        return (self.numerator \/\/ self.denominator)<\/lang>\n\n==[[:Category:Ruby|Ruby]][[Category:Ruby]]==\nRuby's standard library already implements a Rational class:\n<lang ruby>require 'rational'\n\nfor candidate in 2 .. 2**19:\n  sum = Rational(1, candidate)\n  for factor in 2 ... candidate**0.5\n    if candidate % factor == 0\n      sum += Rational(1, factor) + Rational(1, candidate \/ factor)\n    end\n  end\n  if sum.denominator == 1\n    puts \"Sum of recipr. factors of %d = %d exactly %s\" %\n           [candidate, sum.to_i, sum == 1 ? \"perfect!\" : \"\"]\n  end\nend<\/lang>\nIt might be implemented like this:\n\n[insert implementation here]\n\n==[[:Category:Scheme|Scheme]][[Category:Scheme]]==\nScheme has native rational numbers.\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Scheme]] version R5RS[[SMW::on]]<\/div>\n<lang scheme>; simply prints all the perfect numbers\n(do ((candidate 2 (+ candidate 1))) ((>= candidate (expt 2 19)))\n  (let ((sum (\/ 1 candidate)))\n    (do ((factor 2 (+ factor 1))) ((>= factor (sqrt candidate)))\n      (if (= 0 (modulo candidate factor))\n          (set! sum (+ sum (\/ 1 factor) (\/ factor candidate)))))\n    (if (= 1 (denominator sum))\n        (begin (display candidate) (newline)))))<\/lang>\nIt might be implemented like this:\n\n[insert implementation here]\n\n==[[:Category:Scala|Scala]][[Category:Scala]]==\n<lang scala>class Rational(n: Long, d:Long) extends Ordered[Rational]\n{\n   require(d!=0)\n   private val g:Long = gcd(n, d)\n   val numerator:Long = n\/g\n   val denominator:Long = d\/g\n\n   def this(n:Long)=this(n,1)\n\n   def +(that:Rational):Rational=new Rational(\n      numerator*that.denominator + that.numerator*denominator,\n      denominator*that.denominator)\n\n   def -(that:Rational):Rational=new Rational(\n      numerator*that.denominator - that.numerator*denominator,\n      denominator*that.denominator)\n\n   def *(that:Rational):Rational=\n      new Rational(numerator*that.numerator, denominator*that.denominator)\n\n   def \/(that:Rational):Rational=\n      new Rational(numerator*that.denominator, that.numerator*denominator)\n\n   def unary_~ :Rational=new Rational(denominator, numerator)\n\n   def unary_- :Rational=new Rational(-numerator, denominator)\n\n   def abs :Rational=new Rational(Math.abs(numerator), Math.abs(denominator))\n\n   override def compare(that:Rational):Int=\n      (this.numerator*that.denominator-that.numerator*this.denominator).toInt\n\n   override def toString()=numerator+\"\/\"+denominator\n\n   private def gcd(x:Long, y:Long):Long=\n      if(y==0) x else gcd(y, x%y)\n}\n\nobject Rational\n{\n   def apply(n: Long, d:Long)=new Rational(n,d)\n   def apply(n:Long)=new Rational(n)\n   implicit def longToRational(i:Long)=new Rational(i)\n}<\/lang>\n\n<lang scala>def find_perfects():Unit=\n{\n   for (candidate <- 2 until 1<<19)\n   {\n      var sum= ~Rational(candidate)\n      for (factor <- 2 until (Math.sqrt(candidate)+1).toInt)\n      {\n         if (candidate%factor==0)\n            sum+= ~Rational(factor)+ ~Rational(candidate\/factor)\n      }\n\n      if (sum.denominator==1 && sum.numerator==1)\n         printf(\"Perfect number %d sum is %s\\n\", candidate, sum)\n   }\n}<\/lang>\n\n==[[:Category:Slate|Slate]][[Category:Slate]]==\nSlate uses infinite-precision fractions transparently.\n<lang slate>54 \/ 7.\n20 reciprocal.\n(5 \/ 6) reciprocal.\n(5 \/ 6) as: Float.<\/lang>\n\n==[[:Category:Smalltalk|Smalltalk]][[Category:Smalltalk]]==\nSmalltalk uses ''naturally'' and transparently fractions (through the class Fraction):\n<pre>st> 54\/7\n54\/7\nst> 54\/7 + 1\n61\/7\nst> 54\/7 < 50\ntrue\nst> 20 reciprocal\n1\/20\nst> (5\/6) reciprocal\n6\/5\nst> (5\/6) asFloat\n0.8333333333333334\n<\/pre>\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[GNU Smalltalk]][[SMW::on]]<\/div>\n<lang smalltalk>| sum |\n2 to: (2 raisedTo: 19) do: [ :candidate |\n  sum := candidate reciprocal.\n  2 to: (candidate sqrt) do: [ :factor |\n     ( (candidate \\\\ factor) = 0 )\n        ifTrue: [\n           sum := sum + (factor reciprocal) + ((candidate \/ factor) reciprocal)\n        ]\n  ].\n  ( (sum denominator) = 1 )\n      ifTrue: [\n           ('Sum of recipr. factors of %1 = %2 exactly %3' %\n                     { candidate printString . \n                       (sum asInteger) printString . \n                       ( sum = 1 ) ifTrue: [ 'perfect!' ]\n                                   ifFalse: [ ' ' ] }) displayNl\n      ]\n].<\/lang>\n\n==[[:Category:Tcl|Tcl]][[Category:Tcl]]==\n<div style=\"text-align:right;font-size:7pt\">''<nowiki>[<\/nowiki>This section is included from [[Arithmetic\/Rational\/Tcl|a subpage]] and should be edited there, not here.<nowiki>]<\/nowiki>''<\/div>\n\nCode to find factors of a number not shown:\n<lang tcl>namespace eval rat {}\n\nproc rat::new {args} {\n    if {[llength $args] == 0} {\n        set args {0}\n    }\n    lassign [split {*}$args] n d\n    if {$d == 0} {\n        error \"divide by zero\"\n    }\n    if {$d < 0} {\n        set n [expr {-1 * $n}]\n        set d [expr {abs($d)}]\n    }\n    return [normalize $n $d]\n}\n\nproc rat::split {args} {\n    if {[llength $args] == 1} {\n        lassign [::split $args \/] n d\n        if {$d eq \"\"} {\n            set d 1\n        }\n    } else {\n        lassign $args n d\n    }\n    return [list $n $d]\n}\n\nproc rat::join {rat} {\n    lassign $rat n d\n    if {$n == 0} {\n        return 0\n    } elseif {$d == 1} {\n        return $n\n    } else {\n        return $n\/$d\n    }\n}\n\nproc rat::normalize {n d} {\n    set gcd [gcd $n $d]\n    return [join [list [expr {$n\/$gcd}] [expr {$d\/$gcd}]]]\n}\n\nproc rat::gcd {a b} {\n    while {$b != 0} {\n        lassign [list $b [expr {$a % $b}]] a b\n    }\n    return $a\n}\n\nproc rat::abs {rat} {\n    lassign [split $rat] n d\n    return [join [list [expr {abs($n)}] $d]]\n}\n\nproc rat::inv {rat} {\n    lassign [split $rat] n d\n    return [normalize $d $n]\n}\n\nproc rat::+ {args} {\n    set n 0\n    set d 1\n    foreach arg $args {\n        lassign [split $arg] an ad\n        set n [expr {$n*$ad + $an*$d}]\n        set d [expr {$d * $ad}]\n    }\n    return [normalize $n $d]\n}\n\nproc rat::- {args} {\n    lassign [split [lindex $args 0]] n d\n    if {[llength $args] == 1} {\n        return [join [list [expr {-1 * $n}] $d]]\n    }\n    foreach arg [lrange $args 1 end] {\n        lassign [split $arg] an ad\n        set n [expr {$n*$ad - $an*$d}]\n        set d [expr {$d * $ad}]\n    }\n    return [normalize $n $d]\n}\n\nproc rat::* {args} {\n    set n 1\n    set d 1\n    foreach arg $args {\n        lassign [split $arg] an ad\n        set n [expr {$n * $an}]\n        set d [expr {$d * $ad}]\n    }\n    return [normalize $n $d]\n}\n\nproc rat::\/ {a b} {\n    set r [* $a [inv $b]]\n    if {[string match *\/0 $r]} {\n        error \"divide by zero\"\n    }\n    return $r\n}\n\nproc rat::== {a b} {\n    return [expr {[- $a $b] == 0}]\n}\n\nproc rat::!= {a b} {\n    return [expr { ! [== $a $b]}]\n}\n\nproc rat::< {a b} {\n    lassign [split [- $a $b]] n d\n    return [expr {$n < 0}]\n}\n\nproc rat::> {a b} {\n    lassign [split [- $a $b]] n d\n    return [expr {$n > 0}]\n}\n\nproc rat::<= {a b} {\n    return [expr { ! [> $a $b]}]\n}\n\nproc rat::>= {a b} {\n    return [expr { ! [< $a $b]}]\n}\n\n################################################\nproc is_perfect {num} {\n    set sum [rat::new 0]\n    foreach factor [all_factors $num] {\n        set sum [rat::+ $sum [rat::new 1\/$factor]]\n    }\n    # note, all_factors includes 1, so sum should be 2\n    return [rat::== $sum 2]\n}\n\nproc get_perfect_numbers {} {\n    set t [clock seconds]\n    set limit [expr 2**19]\n    for {set num 2} {$num < $limit} {incr num} {\n        if {[is_perfect $num]} {\n            puts \"perfect: $num\"\n        }\n    }\n    puts \"elapsed: [expr {[clock seconds] - $t}] seconds\"\n\n    set num [expr {2**12 * (2**13 - 1)}] ;# 5th perfect number\n    if {[is_perfect $num]} {\n        puts \"perfect: $num\"\n    }\n}\n\nsource primes.tcl\nget_perfect_numbers<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>perfect: 6\nperfect: 28\nperfect: 496\nperfect: 8128\nelapsed: 477 seconds\nperfect: 33550336<\/pre>\n\n==[[:Category:TI-89 BASIC|TI-89 BASIC]][[Category:TI-89 BASIC]]==\n{| class=\"messagebox\" style=\"text-align: center; background-color: #ffc8c8; clear: both;\"\n| This example is '''incomplete'''.  Please ensure that it meets all task requirements and remove this message.\n|}[[Category:TI-89 BASIC examples needing attention]][[Category:Examples needing attention]]\nWhile TI-89 BASIC has built-in rational and symbolic arithmetic, it does not have user-defined data types."}]}}}}