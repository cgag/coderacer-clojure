{"query":{"pages":{"6812":{"pageid":6812,"ns":0,"title":"A+B","revisions":[{"*":"<div class=\"infobox\" style=\"width: 2in\">[[File:Rcode-button-task-crushed.png|64px|left|alt=Task|link=Category:Solutions by Programming Task]]'''A+B'''<br\/>\nYou are encouraged to [[Rosetta Code:Solve a Task|solve this task]] according to the task description, using any language you may know.[[Category:Programming Tasks]][[Category:Solutions by Programming Task]]<\/div>\n'''A+B''' - in programming contests, classic problem, which is given so contestants can gain familiarity with online judging system being used.\n\n'''Problem statement'''<br>\nGiven 2 integer numbers, A and B. One needs to find their sum.\n\n:'''Input data'''<br>\n:Two integer numbers are written in the input stream, separated by space.\n:<math>(-1000 \\le A,B \\le +1000)<\/math>\n\n:'''Output data'''<br>\n:The required output is one integer: the sum of A and B.\n\n:'''Example:'''<br>\n::{|class=\"standard\"\n ! Input\n ! Output\n |-\n |<tt>2 2<\/tt>\n |<tt>4<\/tt>\n |-\n |<tt>3 2<\/tt>\n |<tt>5<\/tt>\n |}\n\n==[[:Category:ABAP|ABAP]][[Category:ABAP]]==\n<lang ABAP>report z_sum_a_b.\ndata: lv_output type i.\nselection-screen begin of block input.\n  parameters:\n    p_first type i,\n    p_second type i.\nselection-screen end of block input.\n\nat selection-screen output.\n  %_p_first_%_app_%-text  = 'First Number: '.\n  %_p_second_%_app_%-text = 'Second Number: '.\n\nstart-of-selection.\n  lv_output = p_first + p_second.\n  write : \/ lv_output.<\/lang>\n\n==[[:Category:Ada|Ada]][[Category:Ada]]==\n<lang Ada>-- Standard I\/O Streams\n\nwith Ada.Integer_Text_Io;\nprocedure APlusB is\n   A, B : Integer;\nbegin\n   Ada.Integer_Text_Io.Get (Item => A);\n   Ada.Integer_Text_Io.Get (Item => B);\n   Ada.Integer_Text_Io.Put (A+B);\nend APlusB;<\/lang>\nUsing appropriate user defined types:\n<lang Ada>with Ada.Text_IO;\n\nprocedure A_Plus_B is\n   type Small_Integers is range -2_000 .. +2_000;\n   subtype Input_Values is Small_Integers range -1_000 .. +1_000;\n   package IO is new Ada.Text_IO.Integer_IO (Num => Small_Integers);\n   A, B : Input_Values;\nbegin\n   IO.Get (A);\n   IO.Get (B);\n   IO.Put (A + B, Width => 4, Base => 10);\nend A_Plus_B;<\/lang>\n\n==[[:Category:ALGOL 68|ALGOL 68]][[Category:ALGOL 68]]==\n<div class=\"examplemeta translation\">'''Translation of''': [[A+B#python|python]]<\/div>\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[ALGOL 68]] version Standard - no extensions to language used[[SMW::on]]<\/div>\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[ALGOL 68G]] version Any - tested with release [http:\/\/sourceforge.net\/projects\/algol68\/files\/algol68g\/algol68g-1.18.0\/algol68g-1.18.0-9h.tiny.el5.centos.fc11.i386.rpm\/download 1.18.0-9h.tiny][[SMW::on]]<\/div>\n\n===Console===\n<lang algol68>print((read int + read int))<\/lang>\nInput:\n<pre>\n1 2\n<\/pre>\nOutput:\n<pre>\n         +3\n<\/pre>\n===File===\n<lang algol68>open(stand in, \"input.txt\", stand in channel);\nopen(stand out, \"output.txt\", stand out channel);\nprint((read int + read int))<\/lang>\nInput \"input.txt\":\n<pre>\n3 4\n<\/pre>\nOutput \"output.txt\":\n<pre>\n         +7\n<\/pre>\n==[[:Category:ANTLR|ANTLR]][[Category:ANTLR]]==\n[[File:Aplusb.jpg|left|aplusb]]\n[[File:Num.png|left|aplusb]]\n<br clear=both>\n===[[:Category:Java|Java]][[Category:Java]]===\n<lang>\ngrammar aplusb ;\n\noptions {\n\tlanguage = Java;\n}\n\naplusb\t:\t(WS* e1=Num WS+ e2=Num NEWLINE {System.out.println($e1.text + \" + \" + $e2.text + \" = \" + (Integer.parseInt($e1.text) + Integer.parseInt($e2.text)));})+\n\t;\nNum\t:\t'-'?('0'..'9')+\n\t;\nWS\t:\t(' ' | '\\t')\n\t;\nNEWLINE\t:\tWS* '\\r'? '\\n'\n        ;\n<\/lang>\nProduces:\n<pre>\n>java Test\n1 2\n23 89\n13 567\n-75 6\n-75 -29\n^Z\n1 + 2 = 3\n23 + 89 = 112\n13 + 567 = 580\n-75 + 6 = -69\n-75 + -29 = -104\n<\/pre>\n\n==[[:Category:Argile|Argile]][[Category:Argile]]==\n<div class=\"examplemeta translation\">'''Translation of''': [[A+B#C|C]]<\/div>\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Argile]] version 1.0.0[[SMW::on]]<\/div>\n<lang Argile>(: Standard input-output streams :)\nuse std, array\nCfunc scanf \"%d%d\" (&val int a) (&val int b)\nprintf \"%d\\n\" (a + b)<\/lang>\n<lang Argile>(: Input file : input.txt :)\n(: Output file: output.txt :)\nuse std, array\nlet  in = fopen \"input.txt\" \"r\"\nlet out = fopen \"output.txt\" \"w\"\nlet int x, y.\nCfunc fscanf in \"%d%d\" (&x) (&y) (:fscanf not yet defined in std.arg:)\nfprintf out \"%d\\n\" (x+y)\nfclose in\nfclose out<\/lang>\n\n==[[:Category:AutoHotkey|AutoHotkey]][[Category:AutoHotkey]]==\n<lang AutoHotkey>InputBox, input , A+B, Two integer numbers`, separated by space.\nStringSplit, output, input, %A_Space%\nmsgbox, % output1 . \"+\" . output2 \"=\" output1+output2<\/lang>\n\n==[[:Category:AutoIt|AutoIt]][[Category:AutoIt]]==\n<lang AutoIt>;AutoIt Version: 3.2.10.0\n$num = \"45  54\" \nconsolewrite (\"Sum of \" & $num & \" is: \" & sum($num))\nFunc sum($numbers)\n   $numm = StringSplit($numbers,\" \")\n   Return $numm[1]+$numm[$numm[0]]\nEndFunc<\/lang>\n\n==[[:Category:AWK|AWK]][[Category:AWK]]==\n<lang awk>{print $1 + $2}<\/lang>\n\n==[[:Category:Batch File|Batch File]][[Category:Batch File]]==\nPrompts version\n<lang dos>::aplusb.cmd\n@echo off\nsetlocal\nset \/p a=\"A: \"\nset \/p b=\"B: \"\nset \/a c=a+b\necho %c%\nendlocal<\/lang>\nAll on the commandline version\n<lang dos>::aplusb.cmd\n@echo off\nsetlocal\nset a=%1\nset b=%2\nset \/a c=a+b\necho %c%\nendlocal<\/lang>\nFormula on the command line version\n<lang dos>::aplusb.cmd\n@echo off\nsetlocal\nset \/a c=%~1\necho %c%\nendlocal<\/lang>\nExample of 'Formula on the command line version'\n<pre>\n>aplusb 123+456\n579\n>aplusb \"1+999\"\n1000\n<\/pre>\nParse the input stream version (thanks to Tom Lavedas on alt.msdos.batch.nt)\n<lang dos>::aplusb.cmd\n@echo off\nsetlocal\nset \/p a=\"Input stream: \"\ncall :add %a%\necho %res%\nendlocal\ngoto :eof\n\n:add\nset \/a res=res+%1\nshift\nif \"%1\" neq \"\" goto :add<\/lang>\nExample of 'parse the input stream version'\n<pre>>aplusb\nInput stream: 1234 5678\n6912\n>aplusb\nInput stream: 123 234 345 456 567 678 789 890\n4082<\/pre>\n\n==[[:Category:BASIC|BASIC]][[Category:BASIC]]==\n<lang qbasic>DEFINT A-Z\n\ntryagain:\nbackhere = CSRLIN\nINPUT \"\", i$\ni$ = LTRIM$(RTRIM$(i$))\nwhere = INSTR(i$, \" \")\nIF where THEN\n    a = VAL(LEFT$(i$, where - 1))\n    b = VAL(MID$(i$, where + 1))\n    c = a + b\n    LOCATE backhere, LEN(i$) + 1\n    PRINT c\nELSE\n    GOTO tryagain\nEND IF<\/lang>\n\n==[[:Category:BBC BASIC|BBC BASIC]][[Category:BBC BASIC]]==\n<lang bbc>      REPEAT\n        hereY% = VPOS\n        INPUT LINE \"\" q$\n        hereX% = LEN(q$) + 1\n        WHILE LEFT$(q$, 1) = \" \"\n          q$ = MID$(q$, 2)\n        ENDWHILE\n        space% = INSTR(q$, \" \")\n        IF space% THEN\n          a = VAL(LEFT$(q$, space% - 1))\n          b = VAL(MID$(q$, space% + 1))\n          PRINT TAB(hereX%, hereY%) ; a + b\n        ENDIF\n      UNTIL FALSE<\/lang>\nThat seems overly complicated. What's wrong with:\n<lang bbc>      REPEAT\n        INPUT LINE \"\" q$\n        space% = INSTR(q$,\" \")\n        PRINT VAL LEFT$(q$,space%-1) + VAL MID$(q$,space%+1)\n      UNTIL FALSE<\/lang>\n\n==[[:Category:Befunge|Befunge]][[Category:Befunge]]==\n<lang befunge>&&+.@<\/lang>\n\n==[[:Category:Bracmat|Bracmat]][[Category:Bracmat]]==\n<code>filter<\/code> is a pattern that checks that input is a non-fractional number not less than -1000 and not greater than 1000. The filter is applied to each input. \n<lang bracmat>( out\n$ (   put$\"Enter two integer numbers between -1000 and 1000:\"\n    & (filter=~\/#%:~<-1000:~>1000)\n    & get':(!filter:?a) (!filter:?b)\n    & !a+!b\n  | \"Invalid input. Try again\"\n  )\n);<\/lang>\n\n==[[:Category:Brainf***|Brainf***]][[Category:Brainf***]]==\n{| class=\"messagebox\" style=\"text-align: center; background-color: #ffc8c8; clear: both;\"\n| This example is '''incorrect'''.  It does not parse ASCII numerals, recognize a space delimiter, account for overflow, etc.  Please fix the code and remove this message.\n|}[[Category:Brainf*** examples needing attention]][[Category:Examples needing attention]]\n\n<lang brainf***>,>,[-<+>]<.<\/lang>\n\n==[[:Category:Brat|Brat]][[Category:Brat]]==\n<lang brat>numbers = g.split[0,1].map(:to_i)\np numbers[0] + numbers[1]  #Prints the sum of the input<\/lang>\n\n==[[:Category:C|C]][[Category:C]]==\n<lang c>\/\/ Standard input-output streams\n#include <stdio.h>\nint main()\n{\n   int a, b;\n   scanf(\"%d%d\", &a, &b);\n   printf(\"%d\\n\", a + b);\n   return 0;\n}<\/lang>\n<lang c>\/\/ Input file: input.txt\n\/\/ Output file: output.txt\n#include <stdio.h>\nint main()\n{\n   freopen(\"input.txt\", \"rt\", stdin);\n   freopen(\"output.txt\", \"wt\", stdout);\n   int a, b;\n   scanf(\"%d%d\", &a, &b);\n   printf(\"%d\\n\", a + b);\n   return 0;\n}<\/lang>\n\n==<span id=\"C sharp\">[[:Category:C sharp|C#]]<\/span>[[Category:C sharp]]==\n<lang csharp>using System;\nusing System.Linq;\n\nclass Program\n{\n    static void Main()\n    {\n        Console.WriteLine(Console.ReadLine().Split().Select(int.Parse).Sum());\n    }\n}<\/lang>\nAnother way (not recommended since it does not work with more than two numbers):\n<lang csharp>using System;\n\nclass Program\n    {\n        static void Main()\n        {\n            start:\n            string input = Console.ReadLine();\n            int index = input.IndexOf(\" \");\n            string num1 = input.Substring(0, index);\n            string num2 = input.Substring(index + 1);\n            int sum = int.Parse(num1) + int.Parse(num2);\n            Console.WriteLine(sum.ToString());\n            goto start;\n            \n        }\n    }<\/lang>\n\n==[[:Category:C++|C++]][[Category:C++]]==\n<lang cpp>\/\/ Standard input-output streams\n#include <iostream>\nusing namespace std;\nvoid main()\n{\n   int a, b;\n   cin >> a >> b;\n   cout << a + b << endl;\n}<\/lang>\n<lang cpp>\/\/ Input file: input.txt\n\/\/ Output file: output.txt\n#include <fstream>\nusing namespace std;\nint main()\n{\n   ifstream in(\"input.txt\");\n   ofstream out(\"output.txt\");\n   int a, b;\n   in >> a >> b;\n   out << a + b << endl;\n   return 0;\n}<\/lang>\n\n==[[:Category:Clojure|Clojure]][[Category:Clojure]]==\n<lang clojure>(println (+ (Integer\/parseInt (read-line)) (Integer\/parseInt (read-line))))\n3\n4\n=>7<\/lang>\n<lang clojure>(eval (read-string (str \"(+ \" (read-line) \" )\") ))\n3 3\n6<\/lang>\n\n==[[:Category:CoffeeScript|CoffeeScript]][[Category:CoffeeScript]]==\n<div class=\"examplemeta translation\">'''Translation of''': [[A+B#JavaScript|JavaScript]]<\/div>\n<lang html4strict><html>\n<script type=\"text\/javascript\" src=\"http:\/\/jashkenas.github.com\/coffee-script\/extras\/coffee-script.js\"><\/script>\n<script type=\"text\/coffeescript\">\na = window.prompt 'enter A number', ''\nb = window.prompt 'enter B number', ''\ndocument.getElementById('input').innerHTML = a + ' ' + b\nsum = parseInt(a) + parseInt(b)\ndocument.getElementById('output').innerHTML = sum\n<\/script>\n<body>\n<div id='input'><\/div>\n<div id='output'><\/div>\n<\/body>\n<\/html><\/lang>\n\n==[[:Category:Common Lisp|Common Lisp]][[Category:Common Lisp]]==\n<lang lisp>(format t (write-to-string (+ (read) (read))))<\/lang>\n\n==[[:Category:D|D]][[Category:D]]==\n===From Console===\n<lang d>import std.stdio, std.conv, std.string;\n\nvoid main() {\n    string[] r;\n    try\n        r = readln().split();\n    catch (StdioException e)\n        r = [\"10\", \"20\"];\n\n    writeln(to!int(r[0]) + to!int(r[1]));\n}<\/lang>\n<div>\n;Output<nowiki>:<\/nowiki><\/div>\n<pre>30<\/pre>\n===From File===\n<lang d>import std.stdio, std.conv, std.string;\n\nvoid main() {\n    auto fin = File(\"sum_input.txt\", \"r\");\n    auto r = fin.readln().split();\n    auto fout = File(\"sum_output.txt\", \"w\");\n    fout.writeln(to!int(r[0]) + to!int(r[1]));\n}<\/lang>\n\n==[[:Category:dc|dc]][[Category:dc]]==\n<lang dc>? + psz<\/lang>\n\nThe question mark ''?'' reads and executes a line of input. The user must enter a dc program that pushes two numbers to the stack, such as ''2 3'' or ''5 _1''. (The user must use underscore ''_'' for negative numbers.)\n\n==[[:Category:Delphi|Delphi]][[Category:Delphi]]==\nConsole version.\n<lang delphi>program SUM;\n\n{$APPTYPE CONSOLE}\n\nuses\n  SysUtils;\n\nvar\n  s1, s2:string;\nbegin\n  ReadLn(s1);\n  Readln(s2);\n  Writeln(StrToIntDef(s1, 0) + StrToIntDef(s2,0));\nend.<\/lang>\n\n==[[:Category:DMS|DMS]][[Category:DMS]]==\n<lang DMS>number a = GetNumber( \"Please input 'a'\", a, a )    \/\/ prompts for 'a'\nnumber b = GetNumber( \"Please input 'b'\", b, b )    \/\/ prompts for 'b'\nResult( a + b + \"\\n\" )<\/lang>\n\n==[[:Category:DWScript|DWScript]][[Category:DWScript]]==\nGhetto GUI version\n<lang delphi>var a := StrToInt(InputBox('A+B', 'Enter 1st number', '0'));\nvar b := StrToInt(InputBox('A+B', 'Enter 2nd number', '0'));\nShowMessage('Sum is '+IntToStr(a+b));<\/lang>\n\n==[[:Category:Ela|Ela]][[Category:Ela]]==\n<lang ela>open Con\nopen Core\nopen String\n\nreadn! |> split (\" \",) |> map toInt |> sum<\/lang>\n\nOutput:\n\n<pre>1 2 3 4 5 6\n21<\/pre>\n\n==[[:Category:Elena|Elena]][[Category:Elena]]==\n<lang elena>#define std'basic'*.\n#define ext'io'*.\n\n#symbol Console =>\n[\n    #var anOutput := __wrap(ELineInput, 'program'input).\n    #var A := anOutput >> Integer.\n    #var B := anOutput >> Integer.\n    \n    'program'output << A + B.\n].<\/lang>\n\n==[[:Category:Erlang|Erlang]][[Category:Erlang]]==\n<lang erlang>-module(aplusb).\n-export([start\/0]).\n\nstart() ->\n    case io:fread(\"\",\"~d~d\") of\n        eof -> ok;\n        {ok, [A,B]} ->\n            io:format(\"~w~n\",[A+B]),\n            start()\n    end.<\/lang>\n\n==[[:Category:Euphoria|Euphoria]][[Category:Euphoria]]==\n<lang euphoria>include get.e\n\nfunction snd(sequence s)\n    return s[2]\nend function\n\ninteger a,b\n\na = snd(get(0))\nb = snd(get(0))\n\nprintf(1,\" %d\\n\",a+b)<\/lang>\n\n==<span id=\"F Sharp\">[[:Category:F Sharp|F#]]<\/span>[[Category:F Sharp]]==\n<lang fsharp>open System\nlet plus = (fun (a:string) (b:string) -> Console.WriteLine(int(a)+int(b))) (Console.ReadLine()) (Console.ReadLine());;<\/lang>\n\n==[[:Category:Factor|Factor]][[Category:Factor]]==\n<lang factor>USING: math.parser splitting ;\n: a+b ( -- )\n    readln \" \" split1\n    [ string>number ] bi@ +\n    number>string print ;<\/lang>\n<pre>\n( scratchpad ) a+b\n2 2\n4\n<\/pre>\n\n==[[:Category:FALSE|FALSE]][[Category:FALSE]]==\n<lang false>[0[^$$'9>'0@>|~]['0-\\10*+]#%]n:  {read an integer}\nn;!n;!+.<\/lang>\n\n==[[:Category:Fantom|Fantom]][[Category:Fantom]]==\n<lang fantom>class APlusB\n{\n  public static Void main () \n  {\n    echo (\"Enter two numbers: \")\n    Str input := Env.cur.in.readLine\n    Int sum := 0\n    input.split.each |n| { sum += n.toInt }\n    echo (sum)\n  }\n}<\/lang>\n\n==[[:Category:Forth|Forth]][[Category:Forth]]==\n<lang Forth>pad dup 80 accept evaluate + .<\/lang>\n\n==[[:Category:Fortran|Fortran]][[Category:Fortran]]==\n<lang fortran>program a_plus_b\n\n  implicit none\n  integer :: a\n  integer :: b\n\n  read (*, *) a, b\n  write (*, '(i0)') a + b\n\nend program a_plus_b<\/lang>\n\n==[[:Category:GML|GML]][[Category:GML]]==\n<lang GML>add = argument0 \/\/ get the string with the numbers to add\na = real(string_copy(add, 1, string_pos(\" \", add)))\nb = real(string_copy(add, string_pos(\" \", add) + 1, string_length(add) - string_pos(\" \", add)))\nreturn(a + b)<\/lang>\n\n==[[:Category:Go|Go]][[Category:Go]]==\n<lang go>package main\n\nimport \"fmt\"\n\nfunc main() {\n    var a, b int\n    fmt.Scanf(\"%d %d\", &a, &b)\n    fmt.Printf(\"%d\\n\", a+b)\n}<\/lang>\n\n==[[:Category:Golfscript|Golfscript]][[Category:Golfscript]]==\n<lang golfscript>~+<\/lang>\n\n==[[:Category:Groovy|Groovy]][[Category:Groovy]]==\n<lang groovy>def abAdder = {\n    def reader = new Scanner(System.in)\n    def a = reader.nextInt();\n    def b = reader.nextInt();\n    assert (-1000..1000).containsAll([a,b]) : \"both numbers must be between -1000 and 1000 (inclusive)\"\n    a + b\n}\nabAdder()<\/lang>\n\n==[[:Category:GUISS|GUISS]][[Category:GUISS]]==\nWe cannot use variables, but we can find the sum of two numbers.Here we add 3 + 2:\n<lang guiss>Start,Programs,Accessories,Calculator,Button:3,Button:[plus],\nButton:2,Button:[equals]<\/lang>\n\n==[[:Category:Haskell|Haskell]][[Category:Haskell]]==\n<lang haskell>main = getLine >>= print . sum . map read . words<\/lang>\n\n==[[:Category:HicEst|HicEst]][[Category:HicEst]]==\nA and B are input via edit controls with spinners limiting inputs to +-1000.\n<lang HicEst>DLG(Edit=A, DNum, MIn=-1000, MAx=1000, E=B, DN, MI=-1000, MA=1000)\nWRITE(Messagebox, Name) A, B, \"Sum = \", A+B<\/lang>\n\n==[[:Category:Icon|Icon]][[Category:Icon]] and [[:Category:Unicon|Unicon]][[Category:Unicon]]==\n<lang icon>procedure main()\n     numChars := '-'++&digits\n     read() ? {\n         A := (tab(upto(numChars)), integer(tab(many(numChars))))\n         B := (tab(upto(numChars)), integer(tab(many(numChars))))\n         }\n     write((\\A + \\B) | \"Bad input\")\nend<\/lang>\n\n==[[:Category:J|J]][[Category:J]]==\nTypically, in J, you would find the sum of two numbers (let us say 2 and 3) by entering both of them on a line with a + sign between them:\n<lang J>   2+3\n5<\/lang>\nIn the following expression, <tt>1!:1(3)<\/tt> reads a line from STDIN; <tt>-.LF<\/tt> drops the line ending character; <tt>\".<\/tt> converts the remaining text to a sequence of numbers which are then summed using <tt>+\/<\/tt>.\n<lang J>+\/\". (1!:1(3))-.LF<\/lang>\nHere's a little script, called \"a+b.ijs\":\n<lang J>#!\/Applications\/j602\/bin\/jconsole\necho +\/\". (1!:1(3))-.LF\nexit ''<\/lang>\nHere is the execution of the script:\n<lang bash>echo 2 3 | .\/a+b.ijs\n5<\/lang>\n\n==[[:Category:Java|Java]][[Category:Java]]==\n<lang java>import java.util.*;\n\npublic class Sum2 {\n   public static void main(String[] args) {\n      Scanner in = new Scanner(System.in); \/\/ Standard input\n      System.out.println(in.nextInt() + in.nextInt()); \/\/ Standard output\n   }\n}<\/lang>\nObject of [[class]] Scanner works slow enough, because of that contestants prefer to avoid its use. Often, longer solution works faster and easily scales to problems.\n<lang java>import java.io.*;\nimport java.util.*;\n\npublic class SumDif {\n   StreamTokenizer in;\n   PrintWriter out;\n\n   public static void main(String[] args) throws IOException {\n      new SumDif().run();\n   }\n\n   private int nextInt() throws IOException {\n      in.nextToken();\n      return (int)in.nval;\n   }\n\n   public void run() throws IOException {\n      in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in))); \/\/ Standard input\n      out = new PrintWriter(new OutputStreamWriter(System.out)); \/\/ Standard output\n      solve();\n      out.flush();\n   }\n\n   private void solve() throws IOException {\n      out.println(nextInt() + nextInt());\n   }\n}<\/lang>\n<lang java>import java.io.*; \n\npublic class AplusB {\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tStreamTokenizer in = new StreamTokenizer(new FileReader(\"input.txt\"));\n\t\t\tin.nextToken();\n\t\t\tint a = (int) in.nval;\n\t\t\tin.nextToken();\n\t\t\tint b = (int) in.nval;\n\t\t\tFileWriter outFile = new FileWriter(\"output.txt\");\n\t\t\toutFile.write(Integer.toString(a + b));\n\t\t\toutFile.close();\n\t\t}\n\t\tcatch (IOException e) {\n\t\t\tSystem.out.println(\"IO error\");\n\t\t}\n\t}\n}<\/lang>\n\n==[[:Category:JavaScript|JavaScript]][[Category:JavaScript]]==\n\nClient side:\n\n<lang html4strict><html>\n<body>\n<div id='input'><\/div>\n<div id='output'><\/div>\n<script type='text\/javascript'>\nvar a = window.prompt('enter A number', '');\nvar b = window.prompt('enter B number', '');\ndocument.getElementById('input').innerHTML = a + ' ' + b;\n\nvar sum = Number(a) + Number(b);\ndocument.getElementById('output').innerHTML = sum;\n<\/script>\n<\/body>\n<\/html><\/lang>\n\nServer side (with [http:\/\/nodejs.org node.js]):\n\n<lang javascript>process.openStdin().on (\n    'data',\n    function (line) {\n        var xs = String(line).match(\/^\\s*(\\d+)\\s+(\\d+)\\s*\/)\n        console.log (\n            xs ? Number(xs[1]) + Number(xs[2]) : 'usage: <integer> <integer>'\n        )\n        process.exit()\n    }\n)<\/lang>\n\n $ node io.js\n 2 3\n 5\n $ node io.js\n x 3\n usage: <integer> <integer>\n\n==[[:Category:Joy|Joy]][[Category:Joy]]==\n===Console===\n<lang Joy>get get +.<\/lang>\n===File===\n<lang Joy>\"input.txt\" include\n\"output.txt\" \"w\" fopen\nget get + fput pop quit.<\/lang>\n\n==[[:Category:Liberty BASIC|Liberty BASIC]][[Category:Liberty BASIC]]==\n<lang lb>input, n$\nprint  eval(word$(n$,1);\" + \";word$(n$,2))<\/lang>\n\n==[[:Category:Lisaac|Lisaac]][[Category:Lisaac]]==\n<lang lisaac>Section Header\n + name := A_PLUS_B\n\nSection Public\n - main <- (    (IO.read_integer; IO.last_integer) +\n                (IO.read_integer; IO.last_integer) ).println;<\/lang>\n\n==[[:Category:Logo|Logo]][[Category:Logo]]==\n<lang logo>show apply \"sum readlist<\/lang>\n\n==[[:Category:Lua|Lua]][[Category:Lua]]==\n<lang Lua>a,b = io.read(\"*number\", \"*number\")\nprint(a+b)<\/lang>\n\n==[[:Category:Kite|Kite]][[Category:Kite]]==\n<lang Kite>#!\/usr\/bin\/kite\n\nimport \"System.file\";\n\nin = System.file.stdin;\nline = in|readline;\nwhile(not (line is null)) [\n    arry = line|split(\" \");\n    result = (arry[0])|int + (arry[1])|int;\n    result|print;\n\n    line = in|readline;\n];<\/lang>\nOutput:\n<lang Kite>\n$ kite a_plus_b.kt <<EOF\n5 6\nEOF\n11\n$<\/lang>\n\n==[[:Category:Mathematica|Mathematica]][[Category:Mathematica]]==\nInteractive in a notebook\n<lang Mathematica>Input[] + Input[]<\/lang>\n\n==[[:Category:MATLAB|MATLAB]][[Category:MATLAB]]==\n<lang MATLAB>function sumOfInputs = APlusB()\n    inputStream = input('Enter two numbers, separated by a space: ', 's');\n    numbers = str2num(inputStream);                         %#ok<ST2NM>\n    if any(numbers < -1000 | numbers > 1000)\n        warning('APlusB:OutOfRange', 'Some numbers are outside the range');\n    end\n    sumOfInputs = sum(numbers);    \nend<\/lang>\n\n==[[:Category:Mercury|Mercury]][[Category:Mercury]]==\n<lang>:- module a_plus_b.\n:- interface.\n\n:- import_module io.\n:- pred main(io::di, io::uo) is det.\n\n:- implementation.\n:- import_module int, list, string.\n\nmain(!IO) :-\n   io.read_line_as_string(Result, !IO),\n   ( if\n        Result = ok(Line),\n        [AStr, BStr] = string.words(Line),\n        string.to_int(AStr, A), string.to_int(BStr, B)\n     then\n        io.format(\"%d\\n\", [i(A + B)], !IO)\n     else\n        true\n    ).<\/lang>\n\n==[[:Category:ML\/I|ML\/I]][[Category:ML\/I]]==\nThe two numbers are read from 'standard input' or its equivalent.\n<lang ML\/I>MCSKIP \"WITH\" NL\n\"\" A+B\n\"\" assumes macros on input stream 1, terminal on stream 2\nMCSKIP MT,<>\nMCINS %.\nMCDEF SL SPACES NL AS <MCSET T1=%A1.\nMCSET T2=%A2.\n%T1+T2.\nMCSET S10=0\n>\nMCSKIP SL WITH *\nMCSET S1=1\n*MCSET S10=2<\/lang>\n\n==[[:Category:Modula-2|Modula-2]][[Category:Modula-2]]==\n<lang modula2>MODULE  ab;\n\nIMPORT  InOut;\n\nVAR     A, B    : INTEGER;\n\nBEGIN\n  InOut.ReadInt (A);\n  InOut.ReadInt (B);\n  InOut.WriteInt (A + B, 8);\n  InOut.WriteLn\nEND ab.<\/lang>\n\n==[[:Category:MUMPS|MUMPS]][[Category:MUMPS]]==\n<lang MUMPS>ANB\n NEW A,B,T,S\n READ !,\"Input two integers between -1000 and 1000, separated by a space: \",S\n SET A=$PIECE(S,\" \",1),B=$PIECE(S,\" \",2)\n SET T=(A>=-1000)&(A<=1000)&(B>=-1000)&(B<=1000)&(A\\1=A)&(B\\1=B) \n IF T WRITE !,(A+B)\n IF 'T WRITE !,\"Bad input\"\n QUIT<\/lang>\n \n==[[:Category:Nemerle|Nemerle]][[Category:Nemerle]]==\n<div class=\"examplemeta translation\">'''Translation of''': [[A+B#C#|C#]]<\/div>\n<lang Nemerle>using System;\nusing System.Console;\nusing System.Linq;\n\nmodule AplusB\n{\n    Main() : void\n    {\n        WriteLine(ReadLine().Split().Select(int.Parse).Sum());\n    }    \n}<\/lang>\n\n==[[:Category:NetRexx|NetRexx]][[Category:NetRexx]]==\n<lang NetRexx>\/* NetRexx *\/\n\noptions replace format comments java crossref savelog symbols binary\n\nparse ask a b .\nsay a '+' b '=' a + b<\/lang>\n\n==[[:Category:newLISP|newLISP]][[Category:newLISP]]==\n<lang newLISP>(println (apply + (map int (parse (read-line)))))<\/lang>\n\n==[[:Category:Nimrod|Nimrod]][[Category:Nimrod]]==\nA+B:\n<lang nimrod>import strutils, os\n\necho parseInt(paramStr(1)) + parseInt(paramStr(2))<\/lang>\nArbitrary number of arguments:\n<lang nimrod>import strutils, os\nvar sum = 0\nfor i in countup(1, paramCount()):\n  sum = sum + parseInt(paramStr(i))\necho sum<\/lang>\n\n==[[:Category:Objeck|Objeck]][[Category:Objeck]]==\n<lang objeck>bundle Default {\n   class Vander {\n      function : Main(args : String[]) ~ Nil {\n         values := IO.Console->ReadString()->Split(\" \");\n         if(values->Size() = 2) { \n            (values[0]->Trim()->ToInt() + values[1]->Trim()->ToInt())->PrintLine();\n         };\n      }\n   }\n}<\/lang>\n\n==[[:Category:Oberon-2|Oberon-2]][[Category:Oberon-2]]==\n<lang oberon2>MODULE  ab;\n\nIMPORT  In, Out;\n\nVAR     A, B    : INTEGER;\n\nBEGIN\n  In.Int (A);\n  In.Int (B);\n  Out.Int (A + B, 8);\n  Out.Ln\nEND ab.<\/lang>\nProducing\n<pre>\n12 34\n      46\n<\/pre>\n\n==[[:Category:OCaml|OCaml]][[Category:OCaml]]==\n<lang ocaml>Scanf.scanf \"%d %d\" (fun a b -> Printf.printf \"%d\\n\" (a + b))<\/lang>\n\n==[[:Category:OpenEdge\/Progress|OpenEdge\/Progress]][[Category:OpenEdge\/Progress]]==\n<lang progress>DEFINE VARIABLE a AS INTEGER NO-UNDO FORMAT \"->>>9\".\nDEFINE VARIABLE b AS INTEGER NO-UNDO FORMAT \"->>>9\".\n\nIF SESSION:BATCH THEN DO:\n   INPUT FROM \"input.txt\".\n   IMPORT a b.\n   INPUT CLOSE.\nEND.\nELSE\n   UPDATE a b.\n\nMESSAGE a + b VIEW-AS ALERT-BOX<\/lang>\n\n==[[:Category:Openscad|Openscad]][[Category:Openscad]]==\n<lang openscad>a = 5 + 4;\necho (a);<\/lang>\n\n==[[:Category:Oxygene|Oxygene]][[Category:Oxygene]]==\n<lang oxygene>\n\/\/ Sum 2 integers read fron standard input\n\/\/\n\/\/ Nigel Galloway - April 16th., 2012\n\/\/\nnamespace aplusb;\n \ninterface\n  uses System.Text.RegularExpressions.*;\n \ntype\n  aplusb = class\n  public\n    class method Main; \n  end;\n \nimplementation\n \nclass method aplusb.Main;\nvar \n  gc: GroupCollection;\n  m : Match;\nbegin\n  m := new Regex('^\\s*(?<a>-?[1-9]\\d{0,2}|0|-?1000)\\s+(?<b>-?[1-9]\\d{0,2}|0|-?1000)\\s*$').Match(Console.ReadLine());\n  if m.Success then\n    begin\n      gc := m.Groups;\n      Console.WriteLine(\"{0} + {1} = {2}\", gc['a'].Value, gc['b'].Value, Integer.Parse(gc['a'].Value) + Integer.Parse(gc['b'].Value));\n    end\n  else Console.WriteLine(\"Invalid Input\");\nend;\n \nend.\n<\/lang>\nProduces:\n<pre>\n>aplusb\n23 -99\n23 + -99 = -76\n<\/pre>\n\n==[[:Category:Oz|Oz]][[Category:Oz]]==\n<lang oz>declare\n  class TextFile from Open.file Open.text end\n\n  StdIn = {New TextFile init(name:stdin)}\n\n  fun {ReadInt}\n     {String.toInt {StdIn getS($)}}\n  end\nin\n  {Show {ReadInt}+{ReadInt}}<\/lang>\n\n==[[:Category:PARI\/GP|PARI\/GP]][[Category:PARI\/GP]]==\nUser input:\n<lang parigp>input()+input()<\/lang>\nFile input:\n<lang parigp>read(\"file1\")+read(\"file2\")<\/lang>\n\n==[[:Category:Pascal|Pascal]][[Category:Pascal]]==\n<lang pascal>var\n   a, b: integer;\nbegin\n   readln(a, b);\n   writeln(a + b);\nend.<\/lang>\nSame with input from file <tt>input.txt<\/tt> and output from file <tt>output.txt<\/tt>.\n<lang pascal>var\n   a, b: integer;\nbegin\n   reset(input, 'input.txt');\n   rewrite(output, 'output.txt');\n   readln(a, b);\n   writeln(a + b);\n   close(input);\n   close(output);\nend.<\/lang>\n\n==[[:Category:Perl|Perl]][[Category:Perl]]==\n<lang Perl>my ($a,$b) = split(\/\\D+\/,<STDIN>);\nprint \"$a $b \" . ($a + $b) . \"\\n\";<\/lang>\n\n==[[:Category:Perl 6|Perl 6]][[Category:Perl 6]]==\n<lang perl6>my ($a,$b) = $*IN.get.words;\nsay $a+$b;<\/lang>\n\nor, using the reduction meta operator:\n<lang perl6>say [+] $*IN.get.words<\/lang>\n\n==[[:Category:PHP|PHP]][[Category:PHP]]==\n<lang php>fscanf(STDIN, \"%d %d\\n\", $a, $b); \/\/Reads 2 numbers from STDIN\necho ($a + $b) . \"\\n\";<\/lang>\n<lang php>$in = fopen(\"input.dat\", \"r\");\nfscanf($in, \"%d %d\\n\", $a, $b); \/\/Reads 2 numbers from file $in\nfclose($in);\n\n$out = fopen(\"output.dat\", \"w\");\nfwrite($out, ($a + $b) . \"\\n\");\nfclose($out);<\/lang>\n\n==[[:Category:PicoLisp|PicoLisp]][[Category:PicoLisp]]==\n<lang PicoLisp>(+ (read) (read))\n3 4               \n-> 7<\/lang>\n\n==[[:Category:Piet|Piet]][[Category:Piet]]==\n[[File:Piet A+B.png]]\nThe code is fairly straightforward. The individual commands are as follows:\n<lang text>in(num)\nin(num)\nadd\nout(num)<\/lang>\n\n==[[:Category:Pike|Pike]][[Category:Pike]]==\n<lang Pike>string line = Stdio.stdin->gets();\nsscanf(line, \"%d %d\", int a, int b);\nwrite(a+b +\"\\n\");<\/lang>\n\n==[[:Category:PL\/I|PL\/I]][[Category:PL\/I]]==\n<lang PL\/I>get (a, b);\nput (a+b);<\/lang>\n\n==[[:Category:PostScript|PostScript]][[Category:PostScript]]==\n<lang postscript>(%stdin) (r) file  % get stdin\ndup\ntoken pop          % read A\nexch\ntoken pop          % read B\nadd\n=<\/lang>\n\n==[[:Category:PowerShell|PowerShell]][[Category:PowerShell]]==\n<lang powershell>$a,$b = -split \"$input\"\n[int]$a + [int]$b<\/lang>\nThis solution does not work interactively, while the following ''only'' works interactively:\n<lang powershell>$a,$b = -split (Read-Host)\n[int]$a + [int]$b<\/lang>\n\n==[[:Category:ProDOS|ProDOS]][[Category:ProDOS]]==\nWith the math module:\n<lang ProDOS>editvar \/newvar \/value=a \/title=Enter an integer:\neditvar \/newvar \/value=b \/title=Enter another integer:\neditvar \/newvar \/value=c \ndo add -a-,-b-=-c-\nprintline -c- <\/lang>\nWithout the math module:\n<lang ProDOS>editvar \/newvar \/value=a \/title=Enter an integer:\neditvar \/newvar \/value=b \/title=Enter another integer:\neditvar \/newvar \/value=c=-a-+-b-\nprintline -c- <\/lang>\n\n==[[:Category:Prolog|Prolog]][[Category:Prolog]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[SWI-Prolog]][[SMW::on]]<\/div>\n<lang Prolog>plus :-\n    read_line_to_codes(user_input,X),\n    atom_codes(A, X),\n    atomic_list_concat(L, ' ', A),\n    maplist(atom_number, L, LN),\n    sumlist(LN, N),\n    write(N).<\/lang>\noutput :\n<lang Prolog>?- plus.\n|: 4 5\n9\ntrue.<\/lang>\n\n==[[:Category:Pure|Pure]][[Category:Pure]]==\n<lang pure>using system;\nprintf \"%d\\n\" (x+y) when x,y = scanf \"%d %d\" end;<\/lang>\n\n==[[:Category:PureBasic|PureBasic]][[Category:PureBasic]]==\n===Console===\n<lang PureBasic>x$=Input()\na=Val(StringField(x$,1,\" \"))\nb=Val(StringField(x$,2,\" \"))\nPrintN(str(a+b))<\/lang>\n===File===\n<lang PureBasic>If ReadFile(0,\"in.txt\")\n  x$=ReadString(0)\n  a=Val(StringField(x$,1,\" \"))\n  b=Val(StringField(x$,2,\" \"))\n  If OpenFile(1,\"out.txt\")\n    WriteString(1,str(a+b))\n    CloseFile(1)\n  EndIf\n  CloseFile(0)\nEndIf <\/lang>\n\n==[[:Category:Python|Python]][[Category:Python]]==\n===Console===\n<lang python>try: raw_input\nexcept: raw_input = input\n\nprint(sum(int(x) for x in raw_input().split()))<\/lang>\n===File===\n<lang python>a = int(raw_input(\"Enter integer 1: \"))\nb = int(raw_input(\"Enter integer 2: \"))\n\nprint a + b<\/lang>\n\n==[[:Category:R|R]][[Category:R]]==\n<lang r>sum(scan(\"\", numeric(0), 2))<\/lang>\n\n==[[:Category:REBOL|REBOL]][[Category:REBOL]]==\n<lang rebol>forever [x: load input  print x\/1 + x\/2]<\/lang>\nSample output:\n<pre>1 2\n3\n2 2\n4\n3 2\n5<\/pre>\n\n==[[:Category:REXX|REXX]][[Category:REXX]]==\nThe numbers can be any valid REXX number (integer, fixed point decimal, floating point (with exponential notation, ...).\n<lang rexx>parse pull a b\nsay a+b<\/lang>\n\n==[[:Category:Retro|Retro]][[Category:Retro]]==\n<lang Retro>: try ( \"-n ) getToken toNumber getToken toNumber + putn ;<\/lang>\n<lang Retro>try 1 2<\/lang>\n\n==[[:Category:Ruby|Ruby]][[Category:Ruby]]==\n<lang ruby>puts gets.split.map{|x| x.to_i}.inject{|sum, x| sum + x}<\/lang>\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Ruby]] version 1.8.7+[[SMW::on]]<\/div>\n<lang ruby>puts gets.split.map(&:to_i).inject(&:+)<\/lang>\n==[[:Category:Run BASIC|Run BASIC]][[Category:Run BASIC]]==\n<lang runbasic>input, x$\nprint  val(word$(x$,1)) + val(word$(x$,2))<\/lang>\n==[[:Category:Scala|Scala]][[Category:Scala]]==\n<lang scala>println(readLine() split \" \" take 2 map (_.toInt) sum)<\/lang>\n\n==[[:Category:Scheme|Scheme]][[Category:Scheme]]==\n<lang scheme>(write (+ (read) (read)))<\/lang>\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Racket]][[SMW::on]]<\/div> (moved from the Racket language entry, may be redundant) \n<lang scheme>#lang racket\n\n(define (do-sum)\n    (display \"Give a number: \")\n    (let ((a (string->number (read-line))))\n      (display \"Give another number: \")\n      (let ((b (string->number (read-line))))\n        (if (and (number? a) (number? b))\n            (printf \"Sum = ~a\\n\" (+  a b))\n            (display \"a or b is not a number!\")))))\n\n(do-sum)<\/lang>\n\n==[[:Category:sed|sed]][[Category:sed]]==\nSed is for string processing and has no facility for manipulating numbers as numeric values. However, being Turing complete, sed can be coerced into performing mathematics.\n<lang sed>: Loop\n# All done\n\/^-*00* \/s\/\/\/\n\/ -*00*$\/s\/\/\/\nt\n\n# Negative Check\n\/^\\(-*\\)[0-9].* \\1[0-9]\/!b Negative\n\n# Create magic lookup table\ns\/\\(.[0-9]*\\) \\(.[0-9]*\\)\/\\1;987654321000009999000999009909 \\2;012345678999990000999000990090\/\ns\/ \\(-\\)*\\(9*;\\)\/ \\10\\2\/\n# Decrement 1st number\ns\/\\([^0]\\)\\(0*\\);[^0]*\\1\\(.\\).*\\2\\(9*\\).* \\(.*\\)\/\\3\\4 \\5\/\n# Increment 2nd\ns\/\\([^9]\\)\\(9*\\);[^9]*\\1\\(.\\).*\\2\\(0*\\).*\/\\3\\4\/\nt Loop\n\n: Negative\n# Create magic lookup table\ns\/\\(.[0-9]*\\) \\(.[0-9]*\\)\/\\1;987654321000009999000999009909 \\2;987654321000009999000999009909\/\n# Decrement 1st number\ns\/\\([^0]\\)\\(0*\\);[^0]*\\1\\(.\\).*\\2\\(9*\\).* \\(.*\\)\/\\3\\4 \\5\/\n# Decrement 2nd\ns\/\\([^0]\\)\\(0*\\);[^0]*\\1\\(.\\).*\\2\\(9*\\).*\/\\3\\4\/\nt Loop<\/lang>\n\nAnother method, based off of [http:\/\/unix.stackexchange.com\/a\/36959\/11750 this StackExchange answer]:\n<lang sed>#!\/bin\/sed -f\n\n# Add a marker in front of each digit, for tracking tens, hundreds, etc.\ns\/[0-9]\/<&\/g\n# Convert numbers to, in essence, tally marks\ns\/0\/\/g; s\/1\/|\/g; s\/2\/||\/g; s\/3\/|||\/g; s\/4\/||||\/g; s\/5\/|||||\/g\ns\/6\/||||||\/g; s\/7\/|||||||\/g; s\/8\/||||||||\/g; s\/9\/|||||||||\/g\n\n# Multiply by ten for each digit from the back they were.\n:tens \ns\/|<\/<||||||||||\/g\nt tens\n\n# We don't want the digit markers any more\ns\/<\/\/g\n\n# Negative minus negative is the negation of their absolute values.\ns\/^-\\(|*\\) *-\/-\\1\/\n# Negative plus positive equals positive plus negative, and we want the negative at the back.\ns\/^-\\(|*\\) \\+\\(|*\\)$\/\\2-\\1\/\n# Get rid of any space between the numbers \ns\/ \/\/g\n\n# A tally on each side can be canceled.\n:minus\ns\/|-|\/-\/\nt minus\ns\/-$\/\/\n\n# Convert back to digits\n:back\ns\/||||||||||\/<\/g\ns\/<\\([0-9]*\\)$\/<0\\1\/g\ns\/|||||||||\/9\/g;\ns\/|||||||||\/9\/g; s\/||||||||\/8\/g; s\/|||||||\/7\/g; s\/||||||\/6\/g;\ns\/|||||\/5\/g; s\/||||\/4\/g; s\/|||\/3\/g; s\/||\/2\/g; s\/|\/1\/g;\ns\/<\/|\/g\nt back\ns\/^$\/0\/<\/lang>\n\n==[[:Category:Seed7|Seed7]][[Category:Seed7]]==\n<lang seed7>$ include \"seed7_05.s7i\";\n\nconst proc: main is func\n  local\n    var integer: a is 0;\n    var integer: b is 0;\n  begin\n    read(a);\n    read(b);\n    writeln(a + b);\n  end func;<\/lang>\n\n==[[:Category:Shiny|Shiny]][[Category:Shiny]]==\n<lang shiny>if (io.line 'stdin').match ~(\\d+)\\s+(\\d+)~\n    say \"$a $b %(a+b)d\"\nend<\/lang>\n\n==[[:Category:SNOBOL4|SNOBOL4]][[Category:SNOBOL4]]==\nSimple-minded solution (literally \"two somethings separated by space\")\n<lang snobol>\tinput break(\" \") . a \" \" rem . b \n\toutput = a + b\nend<\/lang>\n\"Integer aware\" solution:\n<lang snobol>\tnums = \"0123456789\"\n\tinput span(nums) . a break(nums) span(nums) . b\n\toutput = a + b\nend<\/lang>\n\n==[[:Category:Smalltalk|Smalltalk]][[Category:Smalltalk]]==\nMost Smalltalk implementations do not have the notion of a standard input stream, since it has always been a GUI based programming environment.  I've included test methods to demonstrate one way to create an input stream with two integers can be created. Opening a text file would be another.\n<lang smalltalk>'From Squeak3.7 of ''4 September 2004'' [latest update: #5989] on 8 August 2011 at 3:50:55 pm'!\nObject subclass: #ABTask\n\tinstanceVariableNames: ''\n\tclassVariableNames: ''\n\tpoolDictionaries: ''\n\tcategory: 'rosettacode'!\n\n\"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- \"!\n\nABTask class\n\tinstanceVariableNames: ''!\n\n!ABTask class methodsFor: 'demo'!\nparseInteger: inputStream \n\t^ Integer readFrom: inputStream skipSeparators! !\n\n!ABTask class methodsFor: 'demo'!\nsum: inputStream \n\t^ (self parseInteger: inputStream)\n\t\t+ (self parseInteger: inputStream)! !\n\n!ABTask class methodsFor: 'demo'!\ntest2Plus2\n\t^ self\n\t\tsum: (ReadStream on: '2 2')! !\n\n!ABTask class methodsFor: 'demo'!\ntest3Plus2\n\t^ self\n\t\tsum: (ReadStream on: '3 2')! !<\/lang>\n\n==[[:Category:SPARK|SPARK]][[Category:SPARK]]==\n<lang Ada>-- By Jacob Sparre Andersen\n-- Validates with SPARK GPL 2010's Examiner\/Simplifier\n\nwith SPARK_IO; --# inherit SPARK_IO;\n\n--# main_program;\nprocedure A_Plus_B\n--# global in out SPARK_IO.Inputs, SPARK_IO.Outputs;\n--# derives SPARK_IO.Inputs  from SPARK_IO.Inputs &\n--#         SPARK_IO.Outputs from SPARK_IO.Inputs, SPARK_IO.Outputs;\nis\n   subtype Small_Integers is Integer range -1_000 .. +1_000;\n   A, B       : Integer;\n   A_OK, B_OK : Boolean;\nbegin\n   SPARK_IO.Get_Integer \n     (File  => SPARK_IO.Standard_Input,\n      Item  => A,\n      Width => 0,\n      Read  => A_OK);\n   \n   A_OK := A_OK and A in Small_Integers;\n   \n   SPARK_IO.Get_Integer \n     (File  => SPARK_IO.Standard_Input,\n      Item  => B,\n      Width => 0,\n      Read  => B_OK);\n   \n   B_OK := B_OK and B in Small_Integers;\n   \n   if A_OK and B_OK then\n      SPARK_IO.Put_Integer \n        (File  => SPARK_IO.Standard_Output,\n         Item  => A + B,\n         Width => 4,\n         Base  => 10);\n   else\n      SPARK_IO.Put_Line \n        (File => SPARK_IO.Standard_Output,\n         Item => \"Input data does not match specification.\",\n         Stop => 0);\n   end if;\nend A_Plus_B;<\/lang>\n\n==[[:Category:SQL|SQL]][[Category:SQL]]==\n<lang sql>select A+B<\/lang>\nExample:\n<lang sql>select 2+3<\/lang>\nThis should produce a result set containing the value 5.\n\nNote however that declaration of variables is outside the scope of the ANSI SQL standards, unless by variables you mean tables (which would complicate the example considerably).\n\n==[[:Category:Tcl|Tcl]][[Category:Tcl]]==\n<lang tcl>scan [gets stdin] \"%d %d\" x y\nputs [expr {$x + $y}]<\/lang>\nAlternatively:\n<lang tcl>puts [tcl::mathop::+ {*}[gets stdin]]<\/lang>\nTo\/from a file:\n<lang tcl>set in [open \"input.txt\"]\nset out [open \"output.txt\" w]\nscan [gets $in] \"%d %d\" x y\nputs $out [expr {$x + $y}]\nclose $in\nclose $out<\/lang>\n\n==[[:Category:TI-83 BASIC|TI-83 BASIC]][[Category:TI-83 BASIC]], [[:Category:TI-89 BASIC|TI-89 BASIC]][[Category:TI-89 BASIC]]==\n<lang ti83b>:Prompt A,B\n:Disp A+B<\/lang>\n\nAlternate TI-89 BASIC version (returns the result on the Home screen):\n<lang ti89b>:aplusb(a,b)\n:a+b<\/lang>\n\n==[[:Category:TUSCRIPT|TUSCRIPT]][[Category:TUSCRIPT]]==\n<lang tuscript>$$ MODE TUSCRIPT\nSET input=\"1 2\"\nSET input=SPLIT(input,\": :\")\nSET input=JOIN (input)\nSET output=SUM(input)<\/lang>\n\n==[[:Category:UNIX Shell|UNIX Shell]][[Category:UNIX Shell]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Bourne Shell]][[SMW::on]]<\/div>\n<lang sh>#!\/bin\/sh\nread a b || exit\necho `expr \"$a\" + \"$b\"`<\/lang>\n\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[bash]][[SMW::on]]<\/div>\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[ksh93]][[SMW::on]]<\/div>\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[pdksh]][[SMW::on]]<\/div>\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[zsh]][[SMW::on]]<\/div>\nScript \"a+b.sh\":\n<lang bash>#!\/bin\/bash\nread a b || exit\necho $(( a + b ))<\/lang>\nOutput:\n<lang bash>echo 2 3 | ksh a+b.sh\n5<\/lang>\n\n===[[:Category:C Shell|C Shell]][[Category:C Shell]]===\n<lang csh>set line=$<\nset input=($line)\n@ sum = $input[1] + $input[2]\necho $sum<\/lang>\n\n==[[:Category:Ursala|Ursala]][[Category:Ursala]]==\nUsing standard input and output streams:\n<lang Ursala>#import std\n#import int\n\n#executable&\n\nmain = %zP+ sum:-0+ %zp*FiNCS+ sep` @L<\/lang>\nOverwriting a text file named as a command line parameter:\n<lang Ursala>#import std\n#import int\n\n#executable -[parameterized]-\n\nmain = ~command.files.&h; <.contents:= %zP+ sum:-0+ %zp*FiNCS+ sep` @L+ ~contents><\/lang>\nCreating a new file named after the input file with suffix <code>.out<\/code>:\n<lang Ursala>#import std\n#import int\n\n#executable -[parameterized]-\n\nmain = \n\n~command.files.&h; ~&iNC+ file$[\n   contents: %zP+ sum:-0+ %zp*FiNCS+ sep` @L+ ~contents,\n   path: ~path; ^|C\\~& ~=`.-~; ^|T\/~& '.out'!]<\/lang>\n\n==[[:Category:Vala|Vala]][[Category:Vala]]==\nRead from stdin while program running:\n<lang vala>stdout.printf(\"Please enter int value for A\\n\");\nint a = int.parse(stdin.read_line());\nstdout.printf(\"Please enter int value for B\\n\");\nint b = int.parse(stdin.read_line());\n\nstdout.printf(\"A+B = %d\\n\", a+b);<\/lang>\n\n==[[:Category:VBScript|VBScript]][[Category:VBScript]]==\n<lang vb>Option Explicit\nDim a, b\nSelect Case WScript.Arguments.Count\n\tCase 0\t'No arguments, prompt for them.\n\t\tWScript.Echo \"Enter values for a and b\"\n\t\ta = WScript.Stdin.ReadLine\n\t\tif Instr(a, \" \") > 0 then\t'If two variables were passed\n\t\t\tb = Split(a)(1)\n\t\t\ta = Split(a)(0)\n\t\telse\n\t\t\tWScript.Echo \"Enter value for b\"\n\t\t\tb = WScript.Stdin.ReadLine\n\t\tend if\n\tCase 1\t'One argument, assume it's an input file, e.g. \"in.txt\"\n\t\tDim FSO : Set FSO = CreateObject(\"Scripting.FileSystemObject\")\n\t\tWith FSO.OpenTextFile(WScript.Arguments(0), 1)\n\t\t\ta = .ReadLine\n\t\t\tb = Split(a)(1)\n\t\t\ta = Split(a)(0)\n\t\t\t.Close\n\t\tEnd With\n\tCase 2 'Two arguments, assume they are values\n\t\ta = WScript.Arguments(0)\n\t\tb = WScript.Arguments(1)\nEnd Select\n'At this point, a and b are strings as entered, make them numbers\na = CInt(a)\nb = CInt(b)\n\n'Write the sum\nWscript.Echo a + b\nif 1 = WScript.Arguments.Count then\n\tWith FSO.CreateTextFile(\"out.txt\")\n\t\t.WriteLine a + b\n\t\t.Close\n\tEnd With\nend if<\/lang>\n\n==[[:Category:Visual Basic .NET|Visual Basic .NET]][[Category:Visual Basic .NET]]==\n<lang vbnet>Module Module1\n\n  Sub Main()\n    Dim s() As String = Nothing\n\n    s = Console.ReadLine().Split(\" \"c)\n    Console.WriteLine(CInt(s(0)) + CInt(s(1)))\n  End Sub\n\nEnd Module<\/lang>\n\n==[[:Category:X86 Assembly|X86 Assembly]][[Category:X86 Assembly]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[NASM]] version Linux[[SMW::on]]<\/div>\n<lang asm>section .text\n\tglobal _start\n\t\t\n\t_print:\n\t\tmov ebx, 1\n\t\tmov eax, 4\n\t\tint 0x80\n\t\tret\n\t\t\t\n\t_get_input:\n\t\tmov edx, 4\n\t\tmov ebx, 0\n\t\tmov eax, 3\n\t\tint 0x80\n\t\tret\n\t\t\n\t_start:\n\t\tmov edx, in_val_len\n\t\tmov ecx, in_val_msg\n\t\tcall _print\n\t\tmov ecx, a\n\t\tcall _get_input\n\t\t;make 'a' an actual number rather than a char.\n\t\tsub dword [a], 0x30\n\t\tmov edx, in_val_len\n\t\tmov ecx, in_val_msg\n\t\tcall _print\n\t\tmov ecx, b\n\t\tcall _get_input\n\t\t;calc real number for 'b'\n\t\tsub dword [b], 0x30\n\t\tmov eax, dword [a]\n\t\tmov ebx, dword [b]\n\t\tadd eax, ebx\n\t\t;get the character for our sum.\n\t\tadd eax, 0x30\n\t\tmov dword [sum], eax\n\t\tmov edx, out_val_len\n\t\tmov ecx, out_val_msg\n\t\tcall _print\n\t\tmov [sum+1], dword 0xa\n\t\tmov edx, 4\n\t\tmov ecx, sum\n\t\tcall _print\n\t\tpush 0x1\n\t\tmov eax, 1\n\t\tpush eax\n\t\tint 0x80\n\t\tret\n\t\t\nsection .data\nin_val_msg\tdb \"Please input an integer:\",0\nin_val_len\tequ $-in_val_msg\nout_val_msg db \"The sum of a+b is: \",0\nout_val_len\tequ $-out_val_msg\n\nsection .bss\na    \t\t\tresd 1\nb\t\t\t\tresd 1\nsum\t\t\tresd 1<\/lang>\nThis will not work on numbers over 0(from 1 to 0). This is due to the fact, numbers higher than 0(10,11, etc) are in fact strings when taken from the keyboard. A much longer conversion code is required to loop through and treat each number in the string as separate numbers. For example, The number '10' would have to be treated as a 1 and a 0.\n\n==[[:Category:XPL0|XPL0]][[Category:XPL0]]==\n<lang XPL0>include c:\\cxpl\\codes;\nint A, B;\n[A:= IntIn(0);\n B:= IntIn(0);\n IntOut(0, A+B);\n CrLf(0);\n]<\/lang>\n\n==[[:Category:Yorick|Yorick]][[Category:Yorick]]==\n<lang yorick>a = b = 0;\nread, a, b;\nwrite, a + b;<\/lang>"}]}}},"query-continue":{"revisions":{"rvstartid":137749}}}