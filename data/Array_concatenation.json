{"query-continue":{"search":{"gsroffset":1},"revisions":{"rvstartid":137836}},"query":{"pages":{"4833":{"pageid":4833,"ns":0,"title":"Array concatenation","revisions":[{"*":"<div class=\"infobox\" style=\"width: 2in\">[[File:Rcode-button-task-crushed.png|64px|left|alt=Task|link=Category:Solutions by Programming Task]]'''Array concatenation'''<br\/>\nYou are encouraged to [[Rosetta Code:Solve a Task|solve this task]] according to the task description, using any language you may know.[[Category:Programming Tasks]][[Category:Data Structures]]<\/div>Show how to concatenate two arrays in your language. If this is as simple as <code><var>array1<\/var> + <var>array2<\/var><\/code>, so be it.\n\n==[[:Category:ACL2|ACL2]][[Category:ACL2]]==\nThis is for lists, not arrays; ACL2's array support is limited.\n<lang Lisp>(append xs ys)<\/lang>\n\n==[[:Category:ActionScript|ActionScript]][[Category:ActionScript]]==\n<lang ActionScript>var array1:Array = new Array(1, 2, 3);\nvar array2:Array = new Array(4, 5, 6);\nvar array3:Array = array1.concat(array2); \/\/[1, 2, 3, 4, 5, 6]<\/lang>\n==[[:Category:Ada|Ada]][[Category:Ada]]==\nIn [[Ada]] arrays are concatenated using the operation &. It works with any one dimensioned array:\n<lang Ada>type T is array (Positive range <>) of Integer;\nX : T := (1, 2, 3);\nY : T := X & (4, 5, 6); -- Concatenate X and (4, 5, 6)<\/lang>\n\n==[[:Category:ALGOL 68|ALGOL 68]][[Category:ALGOL 68]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[ALGOL 68]] version Standard - no extensions to language used[[SMW::on]]<\/div>\n\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[ALGOL 68G]] version Any - tested with release [http:\/\/sourceforge.net\/projects\/algol68\/files\/algol68g\/algol68g-1.18.0\/algol68g-1.18.0-9h.tiny.el5.centos.fc11.i386.rpm\/download 1.18.0-9h.tiny][[SMW::on]]<\/div> \n\nIncludes operators for ''appending'' and ''prefixing'' an array to an existing flexible array:\n<lang Algol68>MODE ARGTYPE = INT;\nMODE ARGLIST = FLEX[0]ARGTYPE;\n\nOP + = (ARGLIST a, b)ARGLIST: (\n  [LWB a:UPB a - LWB a + 1 + UPB b - LWB b + 1 ]ARGTYPE out;\n  ( \n    out[LWB a:UPB a]:=a,\n    out[UPB a+1:]:=b\n  );\n  out\n);\n\n# Append #\nOP +:=    = (REF ARGLIST lhs, ARGLIST rhs)ARGLIST: lhs := lhs + rhs;\nOP PLUSAB = (REF ARGLIST lhs, ARGLIST rhs)ARGLIST: lhs := lhs + rhs;\n\n# Prefix #\nOP +=:    = (ARGLIST lhs, REF ARGLIST rhs)ARGLIST: rhs := lhs + rhs;\nOP PLUSTO = (ARGLIST lhs, REF ARGLIST rhs)ARGLIST: rhs := lhs + rhs;\n\nARGLIST a := (1,2),\n        b := (3,4,5);\n\nprint((\"a + b\",a + b, new line));\n\nVOID(a +:= b);\nprint((\"a +:= b\", a, new line));\n\nVOID(a +=: b);\nprint((\"a +=: b\", b, new line))<\/lang>\n<pre>\na + b         +1         +2         +3         +4         +5\na +:= b         +1         +2         +3         +4         +5\na +=: b         +1         +2         +3         +4         +5         +3         +4         +5\n<\/pre>\n==[[:Category:AutoHotkey|AutoHotkey]][[Category:AutoHotkey]]==\n=== True Arrays ===\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[AutoHotkey_L]][[SMW::on]]<\/div>\n<lang AHK>List1 := [1, 2, 3]\nList2 := [4, 5, 6]\ncList := Arr_concatenate(List1, List2)\nMsgBox % Arr_disp(cList) ; [1, 2, 3, 4, 5, 6]\n\nArr_concatenate(p*) {\n    res := Object()\n    For each, obj in p\n        For each, value in obj\n            res.Insert(value)\n    return res\n}\n\nArr_disp(arr) {\n    for each, value in arr\n        res .= \", \" value\n    return \"[\" SubStr(res, 3) \"]\"\n}<\/lang>\n=== Legacy versions ===\n[[AutoHotkey_Basic]] does not have real Arrays, but the user can implement them quite easily. For example:\n<lang AutoHotkey>List1 = 1,2,3\nList2 = 4,5,6\n\nList2Array(List1 , \"Array1_\")\nList2Array(List2 , \"Array2_\")\n\nConcatArrays(\"Array1_\", \"Array2_\", \"MyArray\")\nMsgBox, % Array2List(\"MyArray\")\n\n\n;---------------------------------------------------------------------------\nConcatArrays(A1, A2, A3) { ; concatenates the arrays A1 and A2 to A3\n;---------------------------------------------------------------------------\n    local i := 0\n    %A3%0 := %A1%0 + %A2%0\n    Loop, % %A1%0\n        i++, %A3%%i% := %A1%%A_Index%\n    Loop, % %A2%0\n        i++, %A3%%i% := %A2%%A_Index%\n}\n\n\n;---------------------------------------------------------------------------\nList2Array(List, Array) { ; creates an array from a comma separated list\n;---------------------------------------------------------------------------\n    global\n    StringSplit, %Array%, List, `,\n}\n\n\n;---------------------------------------------------------------------------\nArray2List(Array) { ; returns a comma separated list from an array\n;---------------------------------------------------------------------------\n    Loop, % %Array%0\n        List .= (A_Index = 1 ? \"\" : \",\") %Array%%A_Index%\n    Return, List\n}<\/lang>\nMessage box shows:\n<pre>1,2,3,4,5,6<\/pre>\n\n==[[:Category:BBC BASIC|BBC BASIC]][[Category:BBC BASIC]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[BBC BASIC for Windows]][[SMW::on]]<\/div>\n<lang bbcbasic>      DIM a(3), b(4)\n      a() = 1, 2, 3, 4\n      b() = 5, 6, 7, 8, 9\n      PROCconcat(a(), b(), c())\n      \n      FOR i% = 0 TO DIM(c(),1)\n        PRINT c(i%)\n      NEXT\n      END\n      \n      DEF PROCconcat(a(), b(), RETURN c())\n      LOCAL s%, na%, nb%\n      s% = ^a(1) - ^a(0) : REM Size of each array element\n      na% = DIM(a(),1)+1 : REM Number of elements in a()\n      nb% = DIM(b(),1)+1 : REM Number of elements in b()\n      DIM c(na%+nb%-1)\n      SYS \"RtlMoveMemory\", ^c(0), ^a(0), s%*na%\n      SYS \"RtlMoveMemory\", ^c(na%), ^b(0), s%*nb%\n      ENDPROC<\/lang>\n\n==[[:Category:C|C]][[Category:C]]==\nA way to concatenate two C arrays when you know their size (and usually so it is)\n<lang c>#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n\n#define ARRAY_CONCAT(TYPE, A, An, B, Bn) \\\n  (TYPE *)array_concat((const void *)(A), (An), (const void *)(B), (Bn), sizeof(TYPE));\n\nvoid *array_concat(const void *a, size_t an,\n                   const void *b, size_t bn, size_t s)\n{\n  char *p = malloc(s * (an + bn));\n  memcpy(p, a, an*s);\n  memcpy(p + an*s, b, bn*s);\n  return p;\n}\n\n\/\/ testing\nconst int a[] = { 1, 2, 3, 4, 5 };\nconst int b[] = { 6, 7, 8, 9, 0 };\n\nint main(void)\n{\n  unsigned int i;\n\n  int *c = ARRAY_CONCAT(int, a, 5, b, 5);\n\n  for(i = 0; i < 10; i++)\n    printf(\"%d\\n\", c[i]);\n\n  free(c);\n  return EXIT_SUCCCESS;\n}<\/lang>\n\n==[[:Category:C++|C++]][[Category:C++]]==\n<lang cpp>#include <vector>\n#include <iostream>\n\nint main()\n{\n  std::vector<int> a(3), b(4);\n  a[0] = 11; a[1] = 12; a[2] = 13;\n  b[0] = 21; b[1] = 22; b[2] = 23; b[3] = 24;\n\n  a.insert(a.end(), b.begin(), b.end());\n\n  for (int i = 0; i < a.size(); ++i)\n    std::cout << \"a[\" << i << \"] = \" << a[i] << \"\\n\";\n}<\/lang>\n\n==<span id=\"C sharp\">[[:Category:C sharp|C#]]<\/span>[[Category:C sharp]]==\n<lang csharp>using System;\n\nnamespace RosettaCode\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[] a = { 1, 2, 3 };\n            int[] b = { 4, 5, 6 };\n\n            int[] c = new int[a.Length + b.Length];\n            a.CopyTo(c, 0);\n            b.CopyTo(c, a.Length);\n\n            foreach(int n in c)\n            {\n                Console.WriteLine(n.ToString());\n            }\n        }\n    }\n}<\/lang>\n\nAlternatively, using LINQ extension methods:\n\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[C sharp|C#]] version 3[[SMW::on]]<\/div>\n<lang csharp>using System.Linq;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        int[] a = { 1, 2, 3 };\n        int[] b = { 4, 5, 6 };\n\n        int[] c = a.Concat(b).ToArray();\n    }\n}<\/lang>\n\n==[[:Category:Clojure|Clojure]][[Category:Clojure]]==\n<lang lisp>(concat [1 2 3] [4 5 6])<\/lang>\nThe inputs can be any collection, including Java arrays, and returns a lazy sequence of the elements.\n\n\n==[[:Category:CoffeeScript|CoffeeScript]][[Category:CoffeeScript]]==\n<lang coffeescript>\n# like in JavaScript\na = [1, 2, 3]\nb = [4, 5, 6]\nc = a.concat b\n<\/lang>\n\n==[[:Category:Common Lisp|Common Lisp]][[Category:Common Lisp]]==\n<code>[http:\/\/www.lispworks.com\/documentation\/HyperSpec\/Body\/f_concat.htm concatenate]<\/code> is a general function for concatenating any type of sequence. It takes the type of sequence to produce, followed by any number of sequences of any type.\n<lang lisp>(concatenate 'vector #(0 1 2 3) #(4 5 6 7))\n  => #(0 1 2 3 4 5 6 7)<\/lang>\n\n==[[:Category:D|D]][[Category:D]]==\n<lang d>import std.stdio: writeln;\n \nvoid main() {\n    int[] a = [1, 2];\n    int[] b = [4, 5, 6];\n \n    writeln(a, \" ~ \", b, \" = \", a ~ b);\n}<\/lang>\nOutput:\n<pre>[1, 2] ~ [4, 5, 6] = [1, 2, 4, 5, 6]<\/pre>\n\n==[[:Category:Delphi|Delphi]][[Category:Delphi]]==\n<lang delphi>type\n  TReturnArray = array of integer; \/\/you need to define a type to be able to return it\n\nfunction ConcatArray(a1,a2:array of integer):TReturnArray;\nvar\n  i,r:integer;\nbegin\n  { Low(array) is not necessarily 0 }\n  SetLength(result,High(a1)-Low(a1)+High(a2)-Low(a2)+2); \/\/BAD idea to set a length you won't release, just to show the idea!\n  r:=0; \/\/index on the result may be different to indexes on the sources\n  for i := Low(a1) to High(a1) do begin\n    result[r] := a1[i];\n    Inc(r);\n  end;\n  for i := Low(a2) to High(a2) do begin\n    result[r] := a2[i];\n    Inc(r);\n  end;\nend;\n\nprocedure TForm1.Button1Click(Sender: TObject);\nvar\n  a1,a2:array of integer;\n  r1:array of integer;\n  i:integer;\nbegin\n  SetLength(a1,4);\n  SetLength(a2,3);\n  for i := Low(a1) to High(a1) do\n    a1[i] := i;\n  for i := Low(a2) to High(a2) do\n    a2[i] := i;\n  TReturnArray(r1) := ConcatArray(a1,a2);\n  for i := Low(r1) to High(r1) do\n    showMessage(IntToStr(r1[i]));\n  Finalize(r1); \/\/IMPORTANT!\n  ShowMessage(IntToStr(High(r1)));\nend;<\/lang>\n\n==[[:Category:E|E]][[Category:E]]==\n\n<lang e>? [1,2] + [3,4]\n# value: [1, 2, 3, 4]<\/lang>\n\n==[[:Category:Efene|Efene]][[Category:Efene]]==\n\nusing the ++ operator and the lists.append function\n\n<lang efene>\n@public\nrun = fn () {\n    A = [1, 2, 3, 4]\n    B = [5, 6, 7, 8]\n\n    C = A ++ B\n    D = lists.append([A, B])\n\n    io.format(\"~p~n\", [C])\n    io.format(\"~p~n\", [D])\n}<\/lang>\n\n==[[:Category:Elena|Elena]][[Category:Elena]]==\n<lang elena>#define arrays'* = std'routines'arrays'*.\n\n#symbol Program =>\n[\n    #var a := (1,2,3).\n    #var b := (4,5).\n    \n    #var c := a~arrays'eops + b.\n].\n<\/lang>\n\n==[[:Category:Emacs Lisp|Emacs Lisp]][[Category:Emacs Lisp]]==\n:''See [[Comments#Scheme|Scheme]]''\n\n==[[:Category:Erlang|Erlang]][[Category:Erlang]]==\n\nIn erlang, you can use the ++ operator or lists:append, which is implemented via ++.\n\nOn the shell,\n<lang erlang>\n1> [1, 2, 3] ++ [4, 5, 6].\n[1,2,3,4,5,6]\n2> lists:append([1, 2, 3], [4, 5, 6]).\n[1,2,3,4,5,6]\n3> \n<\/lang>\n\n==[[:Category:Euphoria|Euphoria]][[Category:Euphoria]]==\n<lang Euphoria>sequence s1,s2,s3\ns1 = {1,2,3}\ns2 = {4,5,6}\ns3 = s1 & s2\n? s3<\/lang>\n\nOutput:\n {1,2,3,4,5,6}\n\n==<span id=\"F Sharp\">[[:Category:F Sharp|F#]]<\/span>[[Category:F Sharp]]==\nArray concatenation.\n<lang fsharp>let a = [|1; 2; 3|]\nlet b = [|4; 5; 6;|]\nlet c = Array.append a b<\/lang>\nList concatenation (@ and List.append are equivalent).\n<lang fsharp>let x = [1; 2; 3]\nlet y = [4; 5; 6]\nlet z1 = x @ y\nlet z2 = List.append x y<\/lang>\n\n==[[:Category:Factor|Factor]][[Category:Factor]]==\n<lang factor>append<\/lang>\n\n'''Example''':\n<lang factor>( scratchpad ) USE: sequences\n( scratchpad ) { 1 2 } { 3 4 } append .\n{ 1 2 3 4 }<\/lang>\n\n==[[:Category:Fantom|Fantom]][[Category:Fantom]]==\n\nIn fansh:\n\n<lang fantom>\n> a := [1,2,3]\n> b := [4,5,6]\n> a.addAll(b)\n> a\n[1,2,3,4,5,6]\n<\/lang>\n\nNote 'addAll' is destructive.  Write 'a.dup.addAll(b)' to create a fresh list.\n\n==[[:Category:Forth|Forth]][[Category:Forth]]==\n<lang Forth>: $!+   ( a u a' -- a'+u )  \n  2dup + >r swap move r> ;\n: cat   ( a2 u2 a1 u1 -- a3 u1+u2 )\n  align here dup >r $!+ $!+ r> tuck - dup allot ;\n\n\\ TEST\ncreate a1 1 , 2 , 3 ,\ncreate a2 4 , 5 ,\na2 2 cells a1 3 cells cat dump\n\n8018425F0: 01 00 00 00  00 00 00 00 - 02 00 00 00  00 00 00 00  ................\n801842600: 03 00 00 00  00 00 00 00 - 04 00 00 00  00 00 00 00  ................\n801842610: 05 00 00 00  00 00 00 00 -                           ........\n<\/lang>\n\n==[[:Category:Fortran|Fortran]][[Category:Fortran]]==\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Fortran]] version 90 and later[[SMW::on]]<\/div>\n<lang fortran>program Concat_Arrays\nimplicit none\n\n  integer, dimension(3) :: a = [ 1, 2, 3 ]\n  integer, dimension(3) :: b = [ 4, 5, 6 ]\n  integer, dimension(:), allocatable :: c\n  \n  allocate(c(size(a)+size(b)))\n  c(1:size(a)) = a\n  c(size(a)+1:size(a)+size(b)) = b\n\n  write(*,*) c\n\nend program Concat_Arrays<\/lang>\n\n==[[:Category:GAP|GAP]][[Category:GAP]]==\n<lang gap># Concatenate arrays\nConcatenation([1, 2, 3], [4, 5, 6], [7, 8, 9]);\n# [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]\n\n# Append to a variable\na := [1, 2, 3];\nAppend(a, [4, 5, 6);\nAppend(a, [7, 8, 9]);\na;\n# [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]<\/lang>\n\n==[[:Category:Go|Go]][[Category:Go]]==\n<lang go>package main\n\nimport \"fmt\"\n\nfunc main() {\n    \/\/ Example 1:  Idiomatic in Go is use of the append function.\n    \/\/ Elements must be of identical type.\n    a := []int{1, 2, 3}\n    b := []int{7, 12, 60}\n    c := append(a, b...)\n    fmt.Println(c)\n\n    \/\/ Example 2:  Polymorphism.\n    \/\/ interface{} is a type too, one that can reference values of any type.\n    \/\/ This allows a sort of polymorphic list.\n    i := []interface{}{1, 2, 3}\n    j := []interface{}{\"Crosby\", \"Stills\", \"Nash\", \"Young\"}\n    k := append(i, j...)\n    fmt.Println(k)\n\n    \/\/ Example 3:  Arrays, not slices.\n    \/\/ A word like \"array\" on RC often means \"whatever array means in your\n    \/\/ language.\"  In Go, the common role of \"array\" is usually filled by\n    \/\/ Go slices, as in examples 1 and 2.  If by \"array\" you really mean\n    \/\/ \"Go array,\" then you must move elements one by one.\n    l := [...]int{1, 2, 3}\n    m := [...]int{7, 12, 60}\n    var n [len(l) + len(m)]int\n    for i, x := range l {\n        n[i] = x\n    }\n    for i, x := range m {\n        n[i+len(l)] = x\n    }\n    fmt.Println(n)\n}<\/lang>\nOutput:\n<pre>\n[1 2 3 7 12 60]\n[1 2 3 Crosby Stills Nash Young]\n[1 2 3 7 12 60]\n<\/pre>\nArray concatenation needs can vary.  Here is another set of examples that illustrate different techniques.\n<lang go>package main\n\nimport (\n  \"reflect\"\n  \"fmt\"\n)\n\n\/\/ Generic version\n\/\/ Easier to make the generic version accept any number of arguments,\n\/\/ and loop trough them. Otherwise there will be lots of code duplication.\nfunc ArrayConcat(arrays ...interface{}) interface{} {\n  if len(arrays) == 0 {\n    panic(\"Need at least one arguemnt\")\n  }\n  var vals = make([]*reflect.SliceValue, len(arrays))\n  var arrtype *reflect.SliceType\n  var totalsize int\n  for i,a := range arrays {\n    v := reflect.NewValue(a)\n    switch t := v.Type().(type) {\n    case *reflect.SliceType:\n      if arrtype == nil {\n        arrtype = t\n      } else if t != arrtype {\n        panic(\"Unequal types\")\n      }\n      vals[i] = v.(*reflect.SliceValue)\n      totalsize += vals[i].Len()\n    default: panic(\"not a slice\")\n    }\n  }\n  ret := reflect.MakeSlice(arrtype,totalsize,totalsize)\n  targ := ret\n  for _,v := range vals {\n    reflect.Copy(targ, v)\n    targ = targ.Slice(v.Len(),targ.Len())\n  }\n  return ret.Interface()\n}\n\n\/\/ Type specific version\nfunc ArrayConcatInts(a, b []int) []int {\n  ret := make([]int, len(a) + len(b))\n  copy(ret, a)\n  copy(ret[len(a):], b)\n  return ret\n}\n\nfunc main() {\n  test1_a, test1_b := []int{1,2,3}, []int{4,5,6}\n  test1_c := ArrayConcatInts(test1_a, test1_b)\n  fmt.Println(test1_a, \" + \", test1_b, \" = \", test1_c)\n\n  test2_a, test2_b := []string{\"a\",\"b\",\"c\"}, []string{\"d\",\"e\",\"f\"}\n  test2_c := ArrayConcat(test2_a, test2_b).([]string)\n  fmt.Println(test2_a, \" + \", test2_b, \" = \", test2_c)\n}<\/lang>\nOutput:\n<pre>\n[1 2 3]  +  [4 5 6]  =  [1 2 3 4 5 6]\n[a b c]  +  [d e f]  =  [a b c d e f]\n<\/pre>\n\n==[[:Category:Gosu|Gosu]][[Category:Gosu]]==\n\n<lang gosu>\nvar listA = { 1, 2, 3 }\nvar listB = { 4, 5, 6 }\n\nvar listC = listA.concat( listB )\n\nprint( listC ) \/\/ prints [1, 2, 3, 4, 5, 6]\n<\/lang>\n\n==[[:Category:Groovy|Groovy]][[Category:Groovy]]==\nSolution:\n<lang groovy>def list = [1, 2, 3] + [\"Crosby\", \"Stills\", \"Nash\", \"Young\"]<\/lang>\n\nTest:\n<lang groovy>println list<\/lang>\n\nOutput:\n<pre>[1, 2, 3, Crosby, Stills, Nash, Young]<\/pre>\n\n==[[:Category:Haskell|Haskell]][[Category:Haskell]]==\nA list is in Haskell one of the most common composite data types (constructed from other types). In the documentation we read for the append operation ++:\n<lang haskell>(++) :: [a] -> [a] -> [a]<\/lang>\nAppend two lists, i.e.:<pre> \n[x1, ..., xm] ++ [y1, ..., yn] == [x1, ..., xm, y1, ..., yn]\n[x1, ..., xm] ++ [y1, ...] == [x1, ..., xm, y1, ...]<\/pre>\nIf the first list is not finite, the result is the first list.\n\n==[[:Category:HicEst|HicEst]][[Category:HicEst]]==\n<lang HicEst>REAL :: a(7), b(3), c(10)\n\nc = a\nDO i = 1, LEN(b)\n   c(i + LEN(a)) = b(i)\nENDDO<\/lang>\n\n==[[:Category:Icon|Icon]][[Category:Icon]] and [[:Category:Unicon|Unicon]][[Category:Unicon]]==\nBoth languages have list concatenation built in. Lists are fully dynamic arrays which can be truncated or extended at either end.\n<lang icon>\nprocedure main()\n    L1 := [1, 2, 3, 4]\n    L2 := [11, 12, 13, 14]\n    L3 := L1 ||| L2\n\n    sep := \"\"\n    every writes(sep, !L3) do\n        sep := \", \"\n    write()\nend\n<\/lang>\n\n==[[:Category:IDL|IDL]][[Category:IDL]]==\n\nArray concatenation can mean different things, depending on the number of dimensions of the arguments and the result. In the simplest case, with 1-dimensional arrays to begin with, there are two obvious ways to concatenate them. If my arrays are these:\n<lang IDL>\n > a = [1,2,3]\n > b = [4,5,6]\n > help,a\n      A               INT       = Array[3]\n > help,b\n      B               INT       = Array[3]\n > print,a\n      1       2       3\n > print,b\n      4       5       6\n<\/lang>\nThen they can be concatenated \"at the ends\":\n<lang IDL>\n > help,[a,b]\n      <Expression>    INT       = Array[6]\n > print,[a,b]\n       1       2       3       4       5       6\n<\/lang>\nor \"at the sides\":\n<lang IDL>\n > help,[[a],[b]]\n      <Expression>    INT       = Array[3, 2]\n > print,[[a],[b]]\n       1       2       3\n       4       5       6\n<\/lang>\nNote that this requires that the arrays have the same size at the side at which they are concatenated:\n<lang IDL>\n > b = transpose(b)\n > help,b\n      B               INT       = Array[1, 3]\n > print,b\n       4\n       5\n       6\n > print,[a,b]\n Unable to concatenate variables because the dimensions do not agree: B.\n Execution halted at: $MAIN$          \n > print,[[a],[b]]\n Unable to concatenate variables because the dimensions do not agree: B.\n Execution halted at: $MAIN$    \n<\/lang>\nThis can get a lot more complicated as a 3x4x5-element three-dimensional array can be concatenated with a 5x2x3-element array at exactly two \"surfaces\".\n\n==[[:Category:Inform 7|Inform 7]][[Category:Inform 7]]==\n<lang inform7>let A be {1, 2, 3};\nlet B be {4, 5, 6};\nadd B to A;<\/lang>\n\n==[[:Category:Ioke|Ioke]][[Category:Ioke]]==\n<lang ioke>iik> [1,2,3] + [3,2,1]\n[1,2,3] + [3,2,1]\n+> [1, 2, 3, 3, 2, 1]<\/lang>\n\n==[[:Category:J|J]][[Category:J]]==\n'''Solution''':   <code> , <\/code>\n\n'''Example''':\n<lang j>   array1 =: 1 2 3\n   array2 =: 4 5 6\n   array1 , array2\n1 2 3 4 5 6<\/lang>\n\nOf course, in J, array concatenation works (consistently) on arrays of any rank or dimension.\n\nThe verb <code>,<\/code> concatenates by treating the argument array with the largest number of dimensions as a list. Other primary verbs concatenate along other axes.\n\n<lang j>   ]ab=: 3 3 $ 'aaabbbccc'\naaa\nbbb\nccc\n   ]wx=: 3 3 $ 'wxyz'\nwxy\nzwx\nyzw\n   ab , wx\naaa\nbbb\nccc\nwxy\nzwx\nyzw\n   ab ,. wx\naaawxy\nbbbzwx\ncccyzw\n   ab ,: wx\naaa\nbbb\nccc\n\nwxy\nzwx\nyzw\n   $ ab , wx    NB. applies to first (highest) axis\n6 3\n   $ ab ,. wx   NB. applies to last (atomic) axis\n3 6\n   $ ab ,: wx   NB. applies to new (higher) axis\n2 3 3<\/lang>\n\n==[[:Category:Java|Java]][[Category:Java]]==\nFrom [http:\/\/forums.sun.com\/thread.jspa?messageID=1762690#1762690]:\n<lang java5>public static Object[] objArrayConcat(Object[] o1, Object[] o2)\n{\n  Object[] ret = new Object[o1.length + o2.length];\n\n  System.arraycopy(o1, 0, ret, 0, o1.length);\n  System.arraycopy(o2, 0, ret, o1.length, o2.length);\n \n  return ret;\n}<\/lang>\n\nOr with <code>Collection<\/code>s simply call <code>addAll<\/code>:\n<lang java5>Collection list1, list2, list1And2;\n\/\/...list1 and list2 are instantiated...\nlist1And2 = new ArrayList(list1); \/\/or any other Collection you want\nlist1And2.addAll(list2);<\/lang>\n\n==[[:Category:JavaScript|JavaScript]][[Category:JavaScript]]==\nThe <code>Array.concat()<\/code> method returns a new array comprised of this array joined with other array(s) and\/or value(s). \n<lang javascript>var\n a = [1,2,3],\n b = [4,5,6],\n c = a.concat(b);  \/\/ [1,2,3,4,5,6]<\/lang>\n\n==[[:Category:K|K]][[Category:K]]==\n<lang K>\n    a: 1 2 3\n    b: 4 5 6\n    a,b\n1 2 3 4 5 6<\/lang>\n\nConcatenations on larger dimensions also use \",\", often combined with other operations.\n\n<lang K>\n   ab:3 3#\"abcdefghi\"\n(\"abc\"\n \"def\"\n \"ghi\")\n\n   dd:3 3#\"012345678\"\n(\"012\"\n \"345\"\n \"678\")\n\n   ab,dd   \n(\"abc\"\n \"def\"\n \"ghi\"\n \"012\"\n \"345\"\n \"678\")\n\n   +ab,dd   \/ flip (transpose) join\n(\"adg036\"\n \"beh147\"\n \"cfi258\")\n\n   ab,'dd   \/ eachpair join\n(\"abc012\"\n \"def345\"\n \"ghi678\")\n\n   +(+ab),dd\n(\"abc036\"\n \"def147\"\n \"ghi258\")<\/lang>\n\n==[[:Category:LabVIEW|LabVIEW]][[Category:LabVIEW]]==\nUse the Build Array function.<br\/>This image is a [http:\/\/zone.ni.com\/devzone\/cda\/tut\/p\/id\/9330 VI Snippet], an executable image of [[LabVIEW]] code. The LabVIEW version is shown on the top-right hand corner. You can download it, then drag-and-drop it onto the LabVIEW block diagram from a file browser, and it will appear as runnable, editable code.<br\/>\n[[File:LabVIEW_Array_concatenation.png]]\n==[[:Category:Liberty BASIC|Liberty BASIC]][[Category:Liberty BASIC]]==\n<lang lb>    x=10\n    y=20\n    dim array1(x)\n    dim array2(y)\n\n[concatenate]\n    dim array3(x + y)\n    for i = 1 to x\n        array3(i) = array1(i)\n    next\n    for i = 1 to y\n        array3(i + x) = array2(i)\n    next\n\n[print]\n    for i = 1 to x + y\n        print array3(i)\n    next<\/lang>\n\n==[[:Category:Logo|Logo]][[Category:Logo]]==\nCOMBINE is used to combine lists or words. SENTENCE is used to combine lists and words into a single list.\n<lang logo>\nto combine-arrays :a1 :a2        \n  output listtoarray sentence arraytolist :a1 arraytolist :a2\nend\nshow combine-arrays {1 2 3} {4 5 6}   ; {1 2 3 4 5 6}\n<\/lang>\n\n==[[:Category:Lua|Lua]][[Category:Lua]]==\n<lang lua>a = {1,2,3}\nb = {4,5,6}\ntable.foreach(b,function(i,v)table.insert(a,i)end)\nfor i,v in next,a do io.write (v..' ') end<\/lang>\n\n==[[:Category:Mathematica|Mathematica]][[Category:Mathematica]]==\n<lang Mathematica>Join[{1,2,3}, {4,5,6}]\n\n-> {1, 2, 3, 4, 5, 6}<\/lang>\n\n==[[:Category:MATLAB|MATLAB]][[Category:MATLAB]]==\nTwo arrays are concatenated by placing the two arrays between a pair of square brackets. A space between the two array names will concatenate them horizontally, and a semi-colon between array names will concatenate vertically.\n<lang MATLAB>>> a = [1 2 3]\n\na =\n\n     1     2     3\n\n>> b = [4 5 6]\n\nb =\n\n     4     5     6\n\n>> concat = [a b]\n\nconcat =\n\n     1     2     3     4     5     6\n\n>> concat = [a;b]\n\nconcat =\n\n     1     2     3\n     4     5     6<\/lang>\n\nFor multi-dimensional arrays, there is also the function cat():\n<lang MATLAB>>> c = randn([3,4,5]);\n>> d = randn([3,4,7]);\n>> e = cat(3,c,d);\n>> size(e) \n   ans =\n\n    3    4   12\n\n<\/lang>\n\n==[[:Category:Maxima|Maxima]][[Category:Maxima]]==\n<lang>u: [1, 2, 3, 4]$\nv: [5, 6, 7, 8, 9, 10]$\nappend(u, v);\n\/* [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] *\/\n\n\/* There are also functions for matrices *\/\n\na: matrix([6, 1, 8],\n          [7, 5, 3],\n          [2, 9, 4])$\n\naddcol(a, ident(3));\n\/* matrix([6, 1, 8, 1, 0, 0],\n          [7, 5, 3, 0, 1, 0],\n          [2, 9, 4, 0, 0, 1]) *\/\n\naddrow(a, ident(3));\n\/* matrix([6, 1, 8],\n          [7, 5, 3],\n          [2, 9, 4],\n          [1, 0, 0],\n          [0, 1, 0],\n          [0, 0, 1]) *\/<\/lang>\n\n==[[:Category:Mercury|Mercury]][[Category:Mercury]]==\n\n<lang Mercury>A `append` B = C<\/lang>\n\nIt ''could'' be \"as simple as array1 + array2\", but the 'array' module names the operation 'append' rather than '+'.  It's tempting to just say that Mercury supports ad-hoc polymorphism - it can infer that a bare '+' refers to 'float.+' or 'int.+' (or that the 'append' above is array.append, rather than list.append), by the types involved - but it also handles other ambiguities in the same way.  For instance, Mercury (like Prolog and Erlang) treats the arity of a function as part of its name, where ''a(1, 2)'' and ''a(1)'' involve the distinct functions a\/2 and a\/1.  But Mercury also (unlike Prolog and Erlang) supports currying, where ''a(1)'' is a function that accepts a\/2's second argument.  So, is ''[a(X), a(Y), a(Z)]'' a list of whatever type a\/1 evaluates to, or is it a list of curried a\/2?\n\n==[[:Category:Nemerle|Nemerle]][[Category:Nemerle]]==\n<lang Nemerle>using System.Console;\nusing Nemerle.Collections;\n\nmodule ArrayCat\n{\n    Main() : void\n    {\n        def arr1 = array[1, 2, 3]; def arr2 = array[4, 5, 6];\n        def arr12 = arr1.Append(arr2);                       \/\/ <----\n        foreach (i in arr12) Write($\"$i  \");\n    }\n}<\/lang>\n\n==[[:Category:NewLISP|NewLISP]][[Category:NewLISP]]==\n<lang NewLISP>; file:   arraycon.lsp\n; url:    http:\/\/rosettacode.org\/wiki\/Array_concatenation\n; author: oofoe 2012-01-28\n\n(println \"Append lists:  \" (append '(3 a 5 3) (sequence 1 9)))\n\n(println \"Multi append:  \" \n         (append '(this is)\n                 '(a test)\n                 '(of the emergency)\n                 (sequence 3 1)))\n\n(println \"Append arrays: \" \n         (append '((x 56) (b 99)) '((z 34) (c 23) (r 88))))\n\n(exit)<\/lang>\n\nSample output:\n\n<pre>Append lists:  (3 a 5 3 1 2 3 4 5 6 7 8 9)\nMulti append:  (this is a test of the emergency 3 2 1)\nAppend arrays: ((x 56) (b 99) (z 34) (c 23) (r 88))\n<\/pre>\n\n==[[:Category:Objeck|Objeck]][[Category:Objeck]]==\n<lang objeck>\nbundle Default {\n  class Arithmetic {\n     function : Main(args : String[]) ~ Nil {\n       array1 := [3, 5, 7];\n       array2 := [2, 4, 6];\n      \n       array3 := Copy(array1, array2);\n       each(i : array3) {\n         array3[i]->PrintLine();\n       };\n  }\n  \n  function : native : Copy(array1 : Int[], array2 : Int[]) ~ Int[] {\n     max := array1->Size() + array2->Size();\n     array3 := Int->New[max];\n      \n     i := 0;\n     for(i := i; i < array1->Size(); i += 1;) {\n       array3[i] := array1[i];\n     };\n      \n     j := 0;\n     for(i := i; i < max; i += 1;) {\n       array3[i] := array2[j];\n       j += 1;\n     };\n      \n      return array3;\n    }\n  }\n}\n<\/lang>\n\n==[[:Category:Objective-C|Objective-C]][[Category:Objective-C]]==\nwith immutable arrays:\n<lang objc>NSArray *arr1 = [NSArray arrayWithObjects:[NSNumber numberWithInt:1],\n                                          [NSNumber numberWithInt:2],\n                                          [NSNumber numberWithInt:3], nil];\nNSArray *arr2 = [NSArray arrayWithObjects:[NSNumber numberWithInt:4],\n                                          [NSNumber numberWithInt:5],\n                                          [NSNumber numberWithInt:6], nil];\nNSArray *arr3 = [arr1 arrayByAddingObjectsFromArray:arr2];<\/lang>\n\nor adding onto a mutable array:\n<lang objc>NSArray *arr1 = [NSArray arrayWithObjects:[NSNumber numberWithInt:1],\n                                          [NSNumber numberWithInt:2],\n                                          [NSNumber numberWithInt:3], nil];\nNSArray *arr2 = [NSArray arrayWithObjects:[NSNumber numberWithInt:4],\n                                          [NSNumber numberWithInt:5],\n                                          [NSNumber numberWithInt:6], nil];\nNSMutableArray *arr3 = [NSMutableArray arrayWithArray:arr1];\n[arr3 addObjectsFromArray:arr2];<\/lang>\n\n==[[:Category:OCaml|OCaml]][[Category:OCaml]]==\nIt is more natural in OCaml to use lists instead of arrays:\n<lang ocaml># let list1 = [1; 2; 3];;\nval list1 : int list = [1; 2; 3]\n# let list2 = [4; 5; 6];;\nval list2 : int list = [4; 5; 6]\n# let list1and2 = list1 @ list2;;\nval list1and2 : int list = [1; 2; 3; 4; 5; 6]<\/lang>\n\nIf you want to use arrays:\n<lang ocaml># let array1 = [|1; 2; 3|];;\nval array1 : int array = [|1; 2; 3|]\n# let array2 = [|4; 5; 6|];;\nval array2 : int array = [|4; 5; 6|]\n# let array1and2 = Array.append array1 array2;;\nval array1and2 : int array = [|1; 2; 3; 4; 5; 6|]<\/lang>\n\n==[[:Category:Oz|Oz]][[Category:Oz]]==\nList are concatenated with <code>List.append<\/code> (shortcut: <code>Append<\/code>). Tuples are concatened with <code>Tuple.append<\/code>. Arrays do exist in Oz, but are rarely used.\n<lang oz>%% concatenating 2 lists\n{Append [a b] [c d]} = [a b c d]\n\n%% concatenating 2 tuples\n{Tuple.append t(1 2 3) u(4 5 6)} = u(1 2 3 4 5 6)<\/lang>\n\n==[[:Category:PARI\/GP|PARI\/GP]][[Category:PARI\/GP]]==\n<lang parigp>concat(u,v)<\/lang>\n\n==[[:Category:Pascal|Pascal]][[Category:Pascal]]==\n:''See [[Array_concatenation#Delphi|Delphi]]''\n\n==[[:Category:Perl|Perl]][[Category:Perl]]==\nIn Perl, arrays placed into list context are flattened: \n<lang perl>my @arr1 = (1, 2, 3);\nmy @arr2 = (4, 5, 6);\nmy @arr3 = (@arr1, @arr2);<\/lang>\n\nThe <code>[http:\/\/perldoc.perl.org\/functions\/push.html push]<\/code> function appends elements onto an existing array:\n<lang perl>my @arr1 = (1, 2, 3);\nmy @arr2 = (4, 5, 6);\npush @arr1, @arr2;\nprint \"@arr1\\n\"; # prints \"1 2 3 4 5 6\"<\/lang>\n\n==[[:Category:Perl 6|Perl 6]][[Category:Perl 6]]==\n\n<lang perl6># the comma ',' can be used to concatenate arrays:\nsub concatenateArrays(@a, @b) { \n\t@a, @b \n}\n\nmy @a1 = (1,2,3);\nmy @a2 = (2,3,4);\nconcatenateArrays(@a1,@a2).join(\", \").say;<\/lang>\n\n==[[:Category:PHP|PHP]][[Category:PHP]]==\n\n<lang php>$arr1 = array(1, 2, 3);\n$arr2 = array(4, 5, 6);\n$arr3 = array_merge($arr1, $arr2);<\/lang>\n\n==[[:Category:PicoLisp|PicoLisp]][[Category:PicoLisp]]==\nPicoLisp has no built-in array data type. Lists are used instead.\n\nThere are destructive concatenations:\n<lang PicoLisp>: (setq  A (1 2 3)  B '(a b c))\n-> (a b c)\n: (conc A B)                        # Concatenate lists in 'A' and 'B'\n-> (1 2 3 a b c)\n: A\n-> (1 2 3 a b c)                    # Side effect: List in 'A' is modified!<\/lang>\nand non-destructive concatenations:\n<lang PicoLisp>: (setq  A (1 2 3)  B '(a b c))\n-> (a b c)\n: (append A B)                      # Append lists in 'A' and 'B'\n-> (1 2 3 a b c)\n: A           \n-> (1 2 3)\n: B\n-> (a b c)                          # Arguments are not modified<\/lang>\n\n==[[:Category:PL\/I|PL\/I]][[Category:PL\/I]]==\n<lang PL\/I>\ndeclare A(5) fixed initial (1, 2, 3, 4, 5);\ndeclare B(7) fixed initial (6, 7, 8, 9, 10, 11, 12);\ndeclare C(*) fixed controlled;\n\nallocate C(hbound(A,1)+hbound(B,1));\n\ndo i = 1 to hbound(A,1); C(i) = A(i); end;\ndo i = 1 to hbound(B,1); C(i+hbound(A,1)) = B(i); end;\n\nput (C);\n<\/lang>\n\nAn alternative, that can be used to advantage for matrices\nas well as vectors, follows.  This example illustrates\nextending a matrix diagonally.  Although fixed array bounds\nare used in the declarations, the bounds can be dynamic.\nMatrix B is extended by placing matrix C on its diagonal:\n<lang>\n   declare a(5,6) fixed;\n   declare b(3,4) fixed defined a(1sub, 2sub);\n   declare c(2,2) fixed defined a(1sub+hbound(b,1), 2sub+hbound(b,2));\n   declare (i, j, k) fixed;\n\n   a = 0;\n   put skip list ('Please type elements for a 3 x 4 matrix:');\n   get list (b);\n   put skip list ('Please type elements for a 2 x 2 matrix:');\n   get list (c);\n   put skip edit (c) ( skip, (hbound(c,2)) f(5,0) );\n\n   put skip list ('Composite matrix:');\n   put skip edit (a) ( skip, (hbound(a,2)) f(5,0) );\n<\/lang>\nOutput:\n<lang>\nPlease type elements for a 3 x 4 matrix: \n\nPlease type elements for a 2 x 2 matrix: \n\n   13   14\n   15   16\nComposite matrix: \n\n    1    2    3    4    0    0\n    5    6    7    8    0    0\n    9   10   11   12    0    0\n    0    0    0    0   13   14\n    0    0    0    0   15   16\n\n<\/lang>\n\n==[[:Category:PostScript|PostScript]][[Category:PostScript]]==\n<div class=\"examplemeta libheader\">'''Library:''' [[SMW::off]][[:Category:initlib|initlib]][[Category:initlib]][[SMW::on]]<\/div>\n<lang postscript>\n[1 2 3 4] [5 6 7 8] concat\n<\/lang>\n\n==[[:Category:PowerShell|PowerShell]][[Category:PowerShell]]==\n<lang powershell>$a = 1,2,3\n$b = 4,5,6\n\n$c = $a + $b\nWrite-Host $c<\/lang>\n\n==[[:Category:Prolog|Prolog]][[Category:Prolog]]==\n<lang prolog>\n?- append([1,2,3],[4,5,6],R).\nR = [1, 2, 3, 4, 5, 6].\n<\/lang>\n==[[:Category:PureBasic|PureBasic]][[Category:PureBasic]]==\n<lang PureBasic>Procedure displayArray(Array a(1), msg.s)\n  Protected i\n  Print(msg + \" [\")\n  For i = 0 To ArraySize(a())\n    Print(Str(a(i)))\n    If i <> ArraySize(a())\n      Print(\", \")\n    EndIf \n  Next \n  PrintN(\"]\")\nEndProcedure\n\nProcedure randomElements(Array a(1), lo, hi)\n  Protected i\n  For i = 0 To ArraySize(a())\n    a(i) = random(hi - lo) + lo\n  Next \nEndProcedure\n\nProcedure arrayConcat(Array a(1), Array b(1), Array c(1))\n  Protected i, newSize = ArraySize(a()) + ArraySize(b()) + 1\n  Dim c(newSize)\n  For i = 0 To ArraySize(a())\n    c(i) = a(i)\n  Next\n  For i = 0 To ArraySize(b())\n    c(i + ArraySize(a()) + 1) = b(i)\n  Next\nEndProcedure\n\n\nIf OpenConsole()\n  Dim a(random(3) + 1)\n  Dim b(random(3) + 1)\n  Dim c(0) ;array will be resized by arrayConcat()\n  \n  randomElements(a(), -5, 5)\n  randomElements(b(), -5, 5)\n  displayArray(a(), \"a:\")\n  displayArray(b(), \"b:\")\n  arrayConcat(a(), b(), c())\n  displayArray(c(), \"concat of a[] + b[]:\")\n  \n  Print(#CRLF$ + #CRLF$ + \"Press ENTER to exit\")\n  Input()\n  CloseConsole()\nEndIf<\/lang>\nSample output:\n<pre>a: [5, 2, -4, -1, -2]\nb: [0, -4, -1]\nconcat of a[] + b[]: [5, 2, -4, -1, -2, 0, -4, -1]<\/pre>\n\n==[[:Category:Python|Python]][[Category:Python]]==\nThe <code>[http:\/\/docs.python.org\/library\/stdtypes.html#sequence-types-str-unicode-list-tuple-buffer-xrange +]<\/code> operator concatenates two lists and returns a new list.  The <code>[http:\/\/docs.python.org\/library\/stdtypes.html#mutable-sequence-types list.extend]<\/code> method appends elements of another list to the receiver.\n<lang python>arr1 = [1, 2, 3]\narr2 = [4, 5, 6]\narr3 = [7, 8, 9]\narr4 = arr1 + arr2\nassert arr4 == [1, 2, 3, 4, 5, 6]\narr4.extend(arr3)\nassert arr4 == [1, 2, 3, 4, 5, 6, 7, 8, 9]<\/lang>\n\nNote: list.extend is normally accomplished using the += operator like this:\n<lang python>arr5 = [4, 5, 6]\narr6 = [7, 8, 9]\narr6 += arr5\nassert arr6 == [7, 8, 9, 4, 5, 6]<\/lang>\n\n==[[:Category:R|R]][[Category:R]]==\n\n<lang R>\na1 <- c(1, 2, 3)\na2 <- c(3, 4, 5)\na3 <- c(a1, a2)\n<\/lang>\n\n==[[:Category:REBOL|REBOL]][[Category:REBOL]]==\n<lang REBOL>\na1: [1 2 3]\na2: [4 5 6]\na3: [7 8 9]\n\nappend a1 a2 ; -> [1 2 3 4 5 6]\n\nappend\/only a1 a3 ; -> [1 2 3 4 5 6 [7 8 9]]\n<\/lang>\n\n==[[:Category:Retro|Retro]][[Category:Retro]]==\n<lang Retro>needs array'\n\n^array'new{ 1 2 3 }  ^array'new{ 4 5 6 }  ^array'append<\/lang>\n\n==[[:Category:REXX|REXX]][[Category:REXX]]==\nREXX doesn't have arrays as such, but it has something that looks, feels, and tastes like arrays:  stemmed variables.\n<br><br>Simply, a stemmed array is a variable with an appended dot (.) followed\nby a constant (such as an integer).  There is no way to preallocate a\nstemmed variable, REXX just assigns them as they are created.\n<br><br>\nAs such, there isn't an easy way to keep track of the number of \"elements\" in a REXX \"array\".\n<br>Consider:\n<lang rexx>a.1=10\na.2=22.7\na.7=-12<\/lang>\nwhere now we have three \"elements\", and they are disjointed.\n<br>There are ways to handle this in REXX however.\n<br><br>When assigning stemmed arrays, it is common to assign \"element\" zero to\nthe number of values, assuming that the stemmed variables are\nsequential.\n<br><br>Example:\n<lang rexx>fact.0=8\nfact.1=    1\nfact.2=    2\nfact.3=    6\nfact.4=   24\nfact.5=  120\nfact.6=  720\nfact.7= 5040\nfact.8=40320<\/lang>\nTo concat two \"arrays\" in REXX, the following assumes that the\nstemmed variables are in order, with no gaps, and none have a \"null\" value.\n<lang rexx>p.=''       \/*a short list of primes.*\/\np.1=2; p.2=3; p.3=5; p.4=7; p.5=11; p.6=13; p.7=17; p.8=19; p.9=23\np.10=27; p.11=31; p.12=37\n\nf.=''       \/*a short list of Fibonacci numbers.*\/\nf.1=1;f.2=1;f.3=2;f.4=3;f.5=5;f.6=8;f.7=13;f.8=21;f.9=34;f.10=55\n\nn=0\n\n  do j=1 while p.j\\==''\n  n=n+1\n  c.n=p.j\n  end\n\n    do k=1 while f.k\\==''\n    n=n+1\n    c.n=f.k\n    end\n\nsay 'n'=n\n\n  do m=1 for n\n  say 'c.'m\"=\"c.m\n  end<\/lang>\n'''output'''\n<pre style=\"height:30ex;overflow:scroll\">\nelements=22\nc.1=2\nc.2=3\nc.3=5\nc.4=7\nc.5=11\nc.6=13\nc.7=17\nc.8=19\nc.9=23\nc.10=27\nc.11=31\nc.12=37\nc.13=1\nc.14=1\nc.15=2\nc.16=3\nc.17=5\nc.18=8\nc.19=13\nc.20=21\nc.21=34\nc.22=55\n<\/pre>\n\n==[[:Category:RLaB|RLaB]][[Category:RLaB]]==\n\nIn RLaB the matrices can be appended (column-wise) or stacked (row-wise).\nConsider few examples:\n<lang RLaB>\n>> x = [1, 2, 3]\n>> y = [4, 5, 6]\n\/\/ appending matrix 'y' on the right from matrix 'x' is possible if the two matrices have\n\/\/ the same number of rows:\n>> z1 = [x, y]\nmatrix columns 1 thru 6\n           1             2             3             4             5             6\n\/\/ stacking matrix 'y' below the matrix 'x' is possible if the two matrices have\n\/\/ the same number of columns:\n>> z2  = [x; y]\n           1             2             3\n           4             5             6\n>>\n<\/lang>\n\n==[[:Category:Ruby|Ruby]][[Category:Ruby]]==\nThe <code>[http:\/\/www.ruby-doc.org\/core\/classes\/Array.html#M002209 Array#+]<\/code> method concatenates two arrays and returns a new array.  The <code>[http:\/\/www.ruby-doc.org\/core\/classes\/Array.html#M002166 Array#concat]<\/code> method appends elements of another array to the receiver.\n<lang ruby>arr1 = [1, 2, 3]\narr2 = [4, 5, 6]\narr3 = [7, 8, 9]\narr4 = arr1 + arr2  # => [1, 2, 3, 4, 5, 6]\narr4.concat(arr3)  # => [1, 2, 3, 4, 5, 6, 7, 8, 9]<\/lang>\n\n==[[:Category:Scala|Scala]][[Category:Scala]]==\n<lang Scala>val arr1 = Array( 1, 2, 3 )\nval arr2 = Array( 4, 5, 6 )\nval arr3 = Array( 7, 8, 9 )\n\narr1 ++ arr2 ++ arr3\n\/\/or:\nArray concat ( arr1, arr2, arr3 )\n\/\/ res0: Array[Int] = Array(1, 2, 3, 4, 5, 6, 7, 8, 9)<\/lang>\n\n==[[:Category:Scheme|Scheme]][[Category:Scheme]]==\n<lang scheme>; in r5rs, there is append for lists, but we'll need to define vector-append\n(define (vector-append . arg) (list->vector (apply append (map vector->list arg))))\n\n(vector-append #(1 2 3 4) #(5 6 7) #(8 9 10))\n; #(1 2 3 4 5 6 7 8 9 10)<\/lang>\n\n''Note : vector-append is also defined in [http:\/\/srfi.schemers.org\/srfi-43\/srfi-43.html SRFI-43].''\n\n==[[:Category:Seed7|Seed7]][[Category:Seed7]]==\n<lang seed7>$ include \"seed7_05.s7i\";\n\nvar array integer: a is [] (1, 2, 3, 4);\nvar array integer: b is [] (5, 6, 7, 8);\nvar array integer: c is [] (9, 10);\n\nconst proc: main is func\n  local\n    var integer: number is 0;\n  begin\n    c := a & b;\n    for number range c do\n      write(number <& \" \");\n    end for;\n    writeln;\n  end func;<\/lang>\n\nOutput:\n<pre>1 2 3 4 5 6 7 8<\/pre>\n\n==[[:Category:Slate|Slate]][[Category:Slate]]==\nThe binary operation of concatenation is made with the <tt>;<\/tt> (semi-colon) from the type Sequence. It is also available for appending Sequences to WriteStreams.\n\n<lang slate>\n{1. 2. 3. 4. 5} ; {6. 7. 8. 9. 10}\n<\/lang>\n\n==[[:Category:Smalltalk|Smalltalk]][[Category:Smalltalk]]==\nConcatenation (appending) is made with the method <tt>,<\/tt> (comma), present in classes SequenceableCollection, ArrayedCollection and their subclasses (e.g. Array, String, OrderedCollection ...)\n\n<lang smalltalk>|a b c|\na := #(1 2 3 4 5).\nb := #(6 7 8 9 10).\nc := a,b.\nc displayNl.<\/lang>\n\n==[[:Category:SNOBOL4|SNOBOL4]][[Category:SNOBOL4]]==\n\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Macro Spitbol]][[SMW::on]]<\/div>\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[Snobol4+]][[SMW::on]]<\/div>\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[CSnobol]][[SMW::on]]<\/div>\n\n<lang SNOBOL4>*       # Concatenate 2 arrays (vectors)\n        define('cat(a1,a2)i,j') :(cat_end)\ncat     cat = array(prototype(a1) + prototype(a2))\ncat1    i = i + 1; cat<i> = a1<i> :s(cat1)\ncat2    j = j + 1; cat<i - 1 + j> = a2<j> :s(cat2)f(return)\ncat_end\n\n*       # Fill arrays\n        str1 = '1 2 3 4 5'; arr1 = array(5)\nloop    i = i + 1; str1 len(p) span('0123456789') . arr1<i> @p :s(loop)\n        str2 = '6 7 8 9 10'; arr2 = array(5)\nloop2   j = j + 1; str2 len(q) span('0123456789') . arr2<j> @q :s(loop2)\n\n*       # Test and display\n        arr3 = cat(arr1,arr2)\nloop3   k = k + 1; str3 = str3 arr3<k> ' ' :s(loop3)\n        output = str1\n        output = str2\n        output = str3\nend<\/lang>\n\nOutput:\n<pre>1 2 3 4 5\n6 7 8 9 10\n1 2 3 4 5 6 7 8 9 10<\/pre>\n\n==[[:Category:Standard ML|Standard ML]][[Category:Standard ML]]==\n<lang Standard ML>\nval l1 = [1,2,3,4];;\nval l2 = [5,6,7,8];;\nval l3 = l1 @ l2 (* [1,2,3,4,5,6,7,8] *)\n<\/lang>\n\n==[[:Category:Tcl|Tcl]][[Category:Tcl]]==\n<lang tcl>set a {1 2 3}\nset b {4 5 6}\nset ab [concat $a $b];   # 1 2 3 4 5 6<\/lang>\nNote that in the Tcl language, \u201carrays\u201d are hash maps of strings to variables, so the notion of concatenation doesn't really apply. What other languages (usually) call arrays are \u201clists\u201d in Tcl.\n\n==[[:Category:TI-89 BASIC|TI-89 BASIC]][[Category:TI-89 BASIC]]==\n\nIf <var>a<\/var> and <var>b<\/var> are lists, <code>augment(a, b)<\/code> concatenates them in the usual fashion. If <var>a<\/var> and <var>b<\/var> are matrices, then <code>augment(a, b)<\/code> produces a matrix whose columns are the columns of <var>a<\/var> followed by the columns of <var>b<\/var>, i.e. an [[wp:augmented matrix|augmented matrix]].\n\n<pre style=\"font-family: 'TI Uni';\">\n\u25a0 augment({1,2}, {3,4})\n    {1,2,3,4}\n\u25a0 augment([[1][2]], [[3][4]])\n    [[1,3][2,4]]<\/pre>\n\nThat last example as displayed in pretty-printing mode:\n\n<math>\\operatorname{augment} \\left(\\begin{bmatrix}1 \\\\ 2\\end{bmatrix}, \\begin{bmatrix}3 \\\\ 4\\end{bmatrix}\\right)<\/math>\n\n:<math>\\begin{bmatrix}\n1 & 3 \\\\ \n2 & 4\n\\end{bmatrix}<\/math>\n\nConcatenation in the other direction may of course be done by transposition:\n\n<pre style=\"font-family: 'TI Uni';\">\n\u25a0 augment([[x][y]]\uf002, [[z][w]]\uf002)\uf002\n    [[x][y][z][w]]<\/pre>\n\n<math>\\left(\\operatorname{augment} \\left(\\begin{bmatrix}x \\\\ y\\end{bmatrix}^\\mathrm T, \\begin{bmatrix}z \\\\ w\\end{bmatrix}^\\mathrm T\\right)\\right)^\\mathrm T<\/math>\n\n:<math>\\begin{bmatrix} x \\\\ y \\\\ z \\\\ w\\end{bmatrix}<\/math>\n\n==[[:Category:Trith|Trith]][[Category:Trith]]==\n<lang trith>[1 2 3] [4 5 6] concat<\/lang>\n\n==[[:Category:UNIX Shell|UNIX Shell]][[Category:UNIX Shell]]==\n\nUsing proper built-in Bash arrays:\n\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[bash]][[SMW::on]]<\/div>\n\n<lang bash>array1=( 1 2 3 4 5 )\narray2=( 6 7 8 9 10 )\nbotharrays=( ${array1[@]} ${array2[@]} )<\/lang>\n\nWhitespace-delimited strings work in much the same way:\n\n<div class=\"examplemeta workswith\">'''Works with''': [[SMW::off]][[bash]][[SMW::on]]<\/div>\n\n<lang bash>array1='1 2 3 4 5'\narray2='6 7 8 9 10'\n\n# Concatenated to a Bash array ...\nbotharrays_a=( $array1 $array2 )\n\n# Concatenated to a string ...\nbotharrays_s=\"$array1 $array2\"<\/lang>\n\n==[[:Category:Vala|Vala]][[Category:Vala]]==\n<lang vala>int[] array_concat(int[]a,int[]b){\t\n\tint[] c = new int[a.length + b.length];\n\tMemory.copy(c, a, a.length * sizeof(int));\n\tMemory.copy(&c[a.length], b, b.length * sizeof(int));\n\treturn c;\n}\nvoid main(){\n\tint[] a = {1,2,3,4,5};\n\tint[] b = {6,7,8};\n\tint[] c = array_concat(a,b);\n\tforeach(int i in c){\n\t\tstdout.printf(\"%d\\n\",i);\n\t}\n}<\/lang>\n\n==[[:Category:VBScript|VBScript]][[Category:VBScript]]==\n<lang vb>Function ArrayConcat(arr1, arr2)\n    ReDim ret(UBound(arr1) + UBound(arr2) + 1)\n    For i = 0 To UBound(arr1)\n        ret(i) = arr1(i)\n    Next\n    offset = Ubound(arr1) + 1\n    For i = 0 To UBound(arr2)\n        ret(i + offset) = arr2(i)\n    Next\n    ArrayConcat = ret\nEnd Function\n\narr1 = array(10,20,30)\narr2 = array(40,50,60)\nWScript.Echo \"arr1 = array(\" & Join(arr1,\", \") & \")\"\nWScript.Echo \"arr2 = array(\" & Join(arr2,\", \") & \")\"\narr3 = ArrayConcat(arr1, arr2)\nWScript.Echo \"arr1 + arr2 = array(\" & Join(arr3,\", \") & \")\"<\/lang>\n\nOutput:\n\n<pre>\narr1 = array(10, 20, 30)\narr2 = array(40, 50, 60)\narr1 + arr2 = array(10, 20, 30, 40, 50, 60)\n<\/pre>\n\n==[[:Category:Visual Basic .NET|Visual Basic .NET]][[Category:Visual Basic .NET]]==\n<lang vbnet>\n    Dim iArray1() As Integer = {1, 2, 3}\n    Dim iArray2() As Integer = {4, 5, 6}\n    Dim iArray3() As Integer = Nothing\n\n    iArray3 = iArray1.Concat(iArray2).ToArray\n<\/lang>\n\n==[[:Category:Yorick|Yorick]][[Category:Yorick]]==\n<lang yorick>a = [1,2,3];\nb = [4,5,6];\nab = grow(a, b);<\/lang>\n\n==[[:Category:Zsh|Zsh]][[Category:Zsh]]==\nConcatenating arrays.\n<lang zsh>a=(1 2 3)\nb=(a b c)\n\nc=($a $b)<\/lang>\nPushing a single element into an array.\n<lang zsh>a+=4<\/lang>\nPushing another array into an array.\n<lang zsh>a+=($b)<\/lang>"}]}}}}